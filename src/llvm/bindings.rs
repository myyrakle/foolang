/* automatically generated by rust-bindgen 0.65.1 */

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage> {
    storage: Storage,
}
impl<Storage> __BindgenBitfieldUnit<Storage> {
    #[inline]
    pub const fn new(storage: Storage) -> Self {
        Self { storage }
    }
}
impl<Storage> __BindgenBitfieldUnit<Storage>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val {
            *byte |= mask;
        } else {
            *byte &= !mask;
        }
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
}
#[repr(C)]
pub struct __BindgenUnionField<T>(::std::marker::PhantomData<T>);
impl<T> __BindgenUnionField<T> {
    #[inline]
    pub const fn new() -> Self {
        __BindgenUnionField(::std::marker::PhantomData)
    }
    #[inline]
    pub unsafe fn as_ref(&self) -> &T {
        ::std::mem::transmute(self)
    }
    #[inline]
    pub unsafe fn as_mut(&mut self) -> &mut T {
        ::std::mem::transmute(self)
    }
}
impl<T> ::std::default::Default for __BindgenUnionField<T> {
    #[inline]
    fn default() -> Self {
        Self::new()
    }
}
impl<T> ::std::clone::Clone for __BindgenUnionField<T> {
    #[inline]
    fn clone(&self) -> Self {
        Self::new()
    }
}
impl<T> ::std::marker::Copy for __BindgenUnionField<T> {}
impl<T> ::std::fmt::Debug for __BindgenUnionField<T> {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.write_str("__BindgenUnionField")
    }
}
impl<T> ::std::hash::Hash for __BindgenUnionField<T> {
    fn hash<H: ::std::hash::Hasher>(&self, _state: &mut H) {}
}
impl<T> ::std::cmp::PartialEq for __BindgenUnionField<T> {
    fn eq(&self, _other: &__BindgenUnionField<T>) -> bool {
        true
    }
}
impl<T> ::std::cmp::Eq for __BindgenUnionField<T> {}
pub const LLVM_DEFAULT_TARGET_TRIPLE: &[u8; 25usize] = b"x86_64-unknown-linux-gnu\0";
pub const LLVM_ENABLE_THREADS: u32 = 1;
pub const LLVM_HAS_ATOMICS: u32 = 1;
pub const LLVM_HOST_TRIPLE: &[u8; 25usize] = b"x86_64-unknown-linux-gnu\0";
pub const LLVM_HAS_AARCH64_TARGET: u32 = 1;
pub const LLVM_HAS_AMDGPU_TARGET: u32 = 1;
pub const LLVM_HAS_ARC_TARGET: u32 = 0;
pub const LLVM_HAS_ARM_TARGET: u32 = 1;
pub const LLVM_HAS_AVR_TARGET: u32 = 1;
pub const LLVM_HAS_BPF_TARGET: u32 = 1;
pub const LLVM_HAS_CSKY_TARGET: u32 = 0;
pub const LLVM_HAS_DIRECTX_TARGET: u32 = 0;
pub const LLVM_HAS_HEXAGON_TARGET: u32 = 1;
pub const LLVM_HAS_LANAI_TARGET: u32 = 1;
pub const LLVM_HAS_LOONGARCH_TARGET: u32 = 1;
pub const LLVM_HAS_M68K_TARGET: u32 = 0;
pub const LLVM_HAS_MIPS_TARGET: u32 = 1;
pub const LLVM_HAS_MSP430_TARGET: u32 = 1;
pub const LLVM_HAS_NVPTX_TARGET: u32 = 1;
pub const LLVM_HAS_POWERPC_TARGET: u32 = 1;
pub const LLVM_HAS_RISCV_TARGET: u32 = 1;
pub const LLVM_HAS_SPARC_TARGET: u32 = 1;
pub const LLVM_HAS_SPIRV_TARGET: u32 = 0;
pub const LLVM_HAS_SYSTEMZ_TARGET: u32 = 1;
pub const LLVM_HAS_VE_TARGET: u32 = 1;
pub const LLVM_HAS_WEBASSEMBLY_TARGET: u32 = 1;
pub const LLVM_HAS_X86_TARGET: u32 = 1;
pub const LLVM_HAS_XCORE_TARGET: u32 = 1;
pub const LLVM_HAS_XTENSA_TARGET: u32 = 0;
pub const LLVM_ON_UNIX: u32 = 1;
pub const LLVM_USE_INTEL_JITEVENTS: u32 = 0;
pub const LLVM_USE_OPROFILE: u32 = 0;
pub const LLVM_USE_PERF: u32 = 0;
pub const LLVM_VERSION_MAJOR: u32 = 20;
pub const LLVM_VERSION_MINOR: u32 = 0;
pub const LLVM_VERSION_PATCH: u32 = 0;
pub const LLVM_VERSION_STRING: &[u8; 10usize] = b"20.0.0git\0";
pub const LLVM_FORCE_ENABLE_STATS: u32 = 0;
pub const LLVM_ENABLE_ZLIB: u32 = 1;
pub const LLVM_ENABLE_ZSTD: u32 = 0;
pub const HAVE_SYSEXITS_H: u32 = 1;
pub const LLVM_UNREACHABLE_OPTIMIZE: u32 = 1;
pub const LLVM_ENABLE_DIA_SDK: u32 = 0;
pub const LLVM_MEMORY_SANITIZER_BUILD: u32 = 0;
pub const LLVM_ADDRESS_SANITIZER_BUILD: u32 = 0;
pub const LLVM_HWADDRESS_SANITIZER_BUILD: u32 = 0;
pub const LLVM_THREAD_SANITIZER_BUILD: u32 = 0;
pub const _GLIBCXX_ALGORITHM: u32 = 1;
pub const _STL_ALGOBASE_H: u32 = 1;
pub const _GLIBCXX_CXX_CONFIG_H: u32 = 1;
pub const _GLIBCXX_RELEASE: u32 = 13;
pub const __GLIBCXX__: u32 = 20240412;
pub const _GLIBCXX_HAVE_ATTRIBUTE_VISIBILITY: u32 = 1;
pub const _GLIBCXX_USE_DEPRECATED: u32 = 1;
pub const _GLIBCXX_EXTERN_TEMPLATE: u32 = 1;
pub const _GLIBCXX_USE_DUAL_ABI: u32 = 1;
pub const _GLIBCXX_USE_CXX11_ABI: u32 = 1;
pub const _GLIBCXX_INLINE_VERSION: u32 = 0;
pub const _GLIBCXX_HAVE_IS_CONSTANT_EVALUATED: u32 = 1;
pub const _GLIBCXX_VERBOSE_ASSERT: u32 = 1;
pub const _GLIBCXX_USE_ALLOCATOR_NEW: u32 = 1;
pub const _GLIBCXX_OS_DEFINES: u32 = 1;
pub const __NO_CTYPE: u32 = 1;
pub const _FEATURES_H: u32 = 1;
pub const _ISOC95_SOURCE: u32 = 1;
pub const _ISOC99_SOURCE: u32 = 1;
pub const _ISOC11_SOURCE: u32 = 1;
pub const _ISOC2X_SOURCE: u32 = 1;
pub const _POSIX_SOURCE: u32 = 1;
pub const _POSIX_C_SOURCE: u32 = 200809;
pub const _XOPEN_SOURCE: u32 = 700;
pub const _XOPEN_SOURCE_EXTENDED: u32 = 1;
pub const _LARGEFILE64_SOURCE: u32 = 1;
pub const _DEFAULT_SOURCE: u32 = 1;
pub const _ATFILE_SOURCE: u32 = 1;
pub const _DYNAMIC_STACK_SIZE_SOURCE: u32 = 1;
pub const __GLIBC_USE_ISOC2X: u32 = 1;
pub const __USE_ISOC11: u32 = 1;
pub const __USE_ISOC99: u32 = 1;
pub const __USE_ISOC95: u32 = 1;
pub const __USE_ISOCXX11: u32 = 1;
pub const __USE_POSIX: u32 = 1;
pub const __USE_POSIX2: u32 = 1;
pub const __USE_POSIX199309: u32 = 1;
pub const __USE_POSIX199506: u32 = 1;
pub const __USE_XOPEN2K: u32 = 1;
pub const __USE_XOPEN2K8: u32 = 1;
pub const __USE_XOPEN: u32 = 1;
pub const __USE_XOPEN_EXTENDED: u32 = 1;
pub const __USE_UNIX98: u32 = 1;
pub const _LARGEFILE_SOURCE: u32 = 1;
pub const __USE_XOPEN2K8XSI: u32 = 1;
pub const __USE_XOPEN2KXSI: u32 = 1;
pub const __USE_LARGEFILE: u32 = 1;
pub const __USE_LARGEFILE64: u32 = 1;
pub const __WORDSIZE: u32 = 64;
pub const __WORDSIZE_TIME64_COMPAT32: u32 = 1;
pub const __SYSCALL_WORDSIZE: u32 = 64;
pub const __TIMESIZE: u32 = 64;
pub const __USE_MISC: u32 = 1;
pub const __USE_ATFILE: u32 = 1;
pub const __USE_DYNAMIC_STACK_SIZE: u32 = 1;
pub const __USE_GNU: u32 = 1;
pub const __USE_FORTIFY_LEVEL: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_GETS: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_SCANF: u32 = 0;
pub const __GLIBC_USE_C2X_STRTOL: u32 = 1;
pub const _STDC_PREDEF_H: u32 = 1;
pub const __STDC_IEC_559__: u32 = 1;
pub const __STDC_IEC_60559_BFP__: u32 = 201404;
pub const __STDC_IEC_559_COMPLEX__: u32 = 1;
pub const __STDC_IEC_60559_COMPLEX__: u32 = 201404;
pub const __STDC_ISO_10646__: u32 = 201706;
pub const __GNU_LIBRARY__: u32 = 6;
pub const __GLIBC__: u32 = 2;
pub const __GLIBC_MINOR__: u32 = 39;
pub const _SYS_CDEFS_H: u32 = 1;
pub const __glibc_c99_flexarr_available: u32 = 1;
pub const __LDOUBLE_REDIRECTS_TO_FLOAT128_ABI: u32 = 0;
pub const __HAVE_GENERIC_SELECTION: u32 = 0;
pub const _GLIBCXX_HAVE_FLOAT128_MATH: u32 = 1;
pub const _GLIBCXX_GTHREAD_USE_WEAK: u32 = 0;
pub const _GLIBCXX_CPU_DEFINES: u32 = 1;
pub const _GLIBCXX_USE_STD_SPEC_FUNCS: u32 = 1;
pub const _GLIBCXX_FAST_MATH: u32 = 0;
pub const _GLIBCXX_USE_FLOAT128: u32 = 1;
pub const _GLIBCXX_FLOAT_IS_IEEE_BINARY32: u32 = 1;
pub const _GLIBCXX_DOUBLE_IS_IEEE_BINARY64: u32 = 1;
pub const _GLIBCXX_HAVE_BUILTIN_HAS_UNIQ_OBJ_REP: u32 = 1;
pub const _GLIBCXX_HAVE_BUILTIN_IS_AGGREGATE: u32 = 1;
pub const _GLIBCXX_HAVE_BUILTIN_IS_SAME: u32 = 1;
pub const _GLIBCXX_HAVE_BUILTIN_LAUNDER: u32 = 1;
pub const _PSTL_VERSION: u32 = 12000;
pub const _PSTL_VERSION_MAJOR: u32 = 12;
pub const _PSTL_VERSION_MINOR: u32 = 0;
pub const _PSTL_VERSION_PATCH: u32 = 0;
pub const _PSTL_USAGE_WARNINGS: u32 = 0;
pub const _PSTL_UDR_PRESENT: u32 = 0;
pub const _PSTL_PRAGMA_LOCATION: &[u8; 26usize] = b" [Parallel STL message]: \0";
pub const _GLIBCXX_HAVE_ACOSF: u32 = 1;
pub const _GLIBCXX_HAVE_ACOSL: u32 = 1;
pub const _GLIBCXX_HAVE_ALIGNED_ALLOC: u32 = 1;
pub const _GLIBCXX_HAVE_ARC4RANDOM: u32 = 1;
pub const _GLIBCXX_HAVE_ARPA_INET_H: u32 = 1;
pub const _GLIBCXX_HAVE_ASINF: u32 = 1;
pub const _GLIBCXX_HAVE_ASINL: u32 = 1;
pub const _GLIBCXX_HAVE_AS_SYMVER_DIRECTIVE: u32 = 1;
pub const _GLIBCXX_HAVE_ATAN2F: u32 = 1;
pub const _GLIBCXX_HAVE_ATAN2L: u32 = 1;
pub const _GLIBCXX_HAVE_ATANF: u32 = 1;
pub const _GLIBCXX_HAVE_ATANL: u32 = 1;
pub const _GLIBCXX_HAVE_ATOMIC_LOCK_POLICY: u32 = 1;
pub const _GLIBCXX_HAVE_AT_QUICK_EXIT: u32 = 1;
pub const _GLIBCXX_HAVE_CEILF: u32 = 1;
pub const _GLIBCXX_HAVE_CEILL: u32 = 1;
pub const _GLIBCXX_HAVE_COMPLEX_H: u32 = 1;
pub const _GLIBCXX_HAVE_COSF: u32 = 1;
pub const _GLIBCXX_HAVE_COSHF: u32 = 1;
pub const _GLIBCXX_HAVE_COSHL: u32 = 1;
pub const _GLIBCXX_HAVE_COSL: u32 = 1;
pub const _GLIBCXX_HAVE_DECL_STRNLEN: u32 = 1;
pub const _GLIBCXX_HAVE_DIRENT_H: u32 = 1;
pub const _GLIBCXX_HAVE_DIRFD: u32 = 1;
pub const _GLIBCXX_HAVE_DLFCN_H: u32 = 1;
pub const _GLIBCXX_HAVE_ENDIAN_H: u32 = 1;
pub const _GLIBCXX_HAVE_EXCEPTION_PTR_SINCE_GCC46: u32 = 1;
pub const _GLIBCXX_HAVE_EXECINFO_H: u32 = 1;
pub const _GLIBCXX_HAVE_EXPF: u32 = 1;
pub const _GLIBCXX_HAVE_EXPL: u32 = 1;
pub const _GLIBCXX_HAVE_FABSF: u32 = 1;
pub const _GLIBCXX_HAVE_FABSL: u32 = 1;
pub const _GLIBCXX_HAVE_FCNTL_H: u32 = 1;
pub const _GLIBCXX_HAVE_FDOPENDIR: u32 = 1;
pub const _GLIBCXX_HAVE_FENV_H: u32 = 1;
pub const _GLIBCXX_HAVE_FINITE: u32 = 1;
pub const _GLIBCXX_HAVE_FINITEF: u32 = 1;
pub const _GLIBCXX_HAVE_FINITEL: u32 = 1;
pub const _GLIBCXX_HAVE_FLOAT_H: u32 = 1;
pub const _GLIBCXX_HAVE_FLOORF: u32 = 1;
pub const _GLIBCXX_HAVE_FLOORL: u32 = 1;
pub const _GLIBCXX_HAVE_FMODF: u32 = 1;
pub const _GLIBCXX_HAVE_FMODL: u32 = 1;
pub const _GLIBCXX_HAVE_FREXPF: u32 = 1;
pub const _GLIBCXX_HAVE_FREXPL: u32 = 1;
pub const _GLIBCXX_HAVE_GETENTROPY: u32 = 1;
pub const _GLIBCXX_HAVE_GETIPINFO: u32 = 1;
pub const _GLIBCXX_HAVE_GETS: u32 = 1;
pub const _GLIBCXX_HAVE_HYPOT: u32 = 1;
pub const _GLIBCXX_HAVE_HYPOTF: u32 = 1;
pub const _GLIBCXX_HAVE_HYPOTL: u32 = 1;
pub const _GLIBCXX_HAVE_ICONV: u32 = 1;
pub const _GLIBCXX_HAVE_INTTYPES_H: u32 = 1;
pub const _GLIBCXX_HAVE_ISINFF: u32 = 1;
pub const _GLIBCXX_HAVE_ISINFL: u32 = 1;
pub const _GLIBCXX_HAVE_ISNANF: u32 = 1;
pub const _GLIBCXX_HAVE_ISNANL: u32 = 1;
pub const _GLIBCXX_HAVE_ISWBLANK: u32 = 1;
pub const _GLIBCXX_HAVE_LC_MESSAGES: u32 = 1;
pub const _GLIBCXX_HAVE_LDEXPF: u32 = 1;
pub const _GLIBCXX_HAVE_LDEXPL: u32 = 1;
pub const _GLIBCXX_HAVE_LIBINTL_H: u32 = 1;
pub const _GLIBCXX_HAVE_LIMIT_AS: u32 = 1;
pub const _GLIBCXX_HAVE_LIMIT_DATA: u32 = 1;
pub const _GLIBCXX_HAVE_LIMIT_FSIZE: u32 = 1;
pub const _GLIBCXX_HAVE_LIMIT_RSS: u32 = 1;
pub const _GLIBCXX_HAVE_LIMIT_VMEM: u32 = 0;
pub const _GLIBCXX_HAVE_LINK: u32 = 1;
pub const _GLIBCXX_HAVE_LINK_H: u32 = 1;
pub const _GLIBCXX_HAVE_LINUX_FUTEX: u32 = 1;
pub const _GLIBCXX_HAVE_LINUX_RANDOM_H: u32 = 1;
pub const _GLIBCXX_HAVE_LINUX_TYPES_H: u32 = 1;
pub const _GLIBCXX_HAVE_LOCALE_H: u32 = 1;
pub const _GLIBCXX_HAVE_LOG10F: u32 = 1;
pub const _GLIBCXX_HAVE_LOG10L: u32 = 1;
pub const _GLIBCXX_HAVE_LOGF: u32 = 1;
pub const _GLIBCXX_HAVE_LOGL: u32 = 1;
pub const _GLIBCXX_HAVE_MBSTATE_T: u32 = 1;
pub const _GLIBCXX_HAVE_MEMALIGN: u32 = 1;
pub const _GLIBCXX_HAVE_MEMORY_H: u32 = 1;
pub const _GLIBCXX_HAVE_MODF: u32 = 1;
pub const _GLIBCXX_HAVE_MODFF: u32 = 1;
pub const _GLIBCXX_HAVE_MODFL: u32 = 1;
pub const _GLIBCXX_HAVE_NETDB_H: u32 = 1;
pub const _GLIBCXX_HAVE_NETINET_IN_H: u32 = 1;
pub const _GLIBCXX_HAVE_NETINET_TCP_H: u32 = 1;
pub const _GLIBCXX_HAVE_OPENAT: u32 = 1;
pub const _GLIBCXX_HAVE_POLL: u32 = 1;
pub const _GLIBCXX_HAVE_POLL_H: u32 = 1;
pub const _GLIBCXX_HAVE_POSIX_MEMALIGN: u32 = 1;
pub const _GLIBCXX_HAVE_POSIX_SEMAPHORE: u32 = 1;
pub const _GLIBCXX_HAVE_POWF: u32 = 1;
pub const _GLIBCXX_HAVE_POWL: u32 = 1;
pub const _GLIBCXX_HAVE_QUICK_EXIT: u32 = 1;
pub const _GLIBCXX_HAVE_READLINK: u32 = 1;
pub const _GLIBCXX_HAVE_SECURE_GETENV: u32 = 1;
pub const _GLIBCXX_HAVE_SETENV: u32 = 1;
pub const _GLIBCXX_HAVE_SINCOS: u32 = 1;
pub const _GLIBCXX_HAVE_SINCOSF: u32 = 1;
pub const _GLIBCXX_HAVE_SINCOSL: u32 = 1;
pub const _GLIBCXX_HAVE_SINF: u32 = 1;
pub const _GLIBCXX_HAVE_SINHF: u32 = 1;
pub const _GLIBCXX_HAVE_SINHL: u32 = 1;
pub const _GLIBCXX_HAVE_SINL: u32 = 1;
pub const _GLIBCXX_HAVE_SOCKATMARK: u32 = 1;
pub const _GLIBCXX_HAVE_SQRTF: u32 = 1;
pub const _GLIBCXX_HAVE_SQRTL: u32 = 1;
pub const _GLIBCXX_HAVE_STACKTRACE: u32 = 1;
pub const _GLIBCXX_HAVE_STDALIGN_H: u32 = 1;
pub const _GLIBCXX_HAVE_STDBOOL_H: u32 = 1;
pub const _GLIBCXX_HAVE_STDINT_H: u32 = 1;
pub const _GLIBCXX_HAVE_STDLIB_H: u32 = 1;
pub const _GLIBCXX_HAVE_STRERROR_L: u32 = 1;
pub const _GLIBCXX_HAVE_STRERROR_R: u32 = 1;
pub const _GLIBCXX_HAVE_STRINGS_H: u32 = 1;
pub const _GLIBCXX_HAVE_STRING_H: u32 = 1;
pub const _GLIBCXX_HAVE_STRTOF: u32 = 1;
pub const _GLIBCXX_HAVE_STRTOLD: u32 = 1;
pub const _GLIBCXX_HAVE_STRUCT_DIRENT_D_TYPE: u32 = 1;
pub const _GLIBCXX_HAVE_STRXFRM_L: u32 = 1;
pub const _GLIBCXX_HAVE_SYMLINK: u32 = 1;
pub const _GLIBCXX_HAVE_SYMVER_SYMBOL_RENAMING_RUNTIME_SUPPORT: u32 = 1;
pub const _GLIBCXX_HAVE_SYS_IOCTL_H: u32 = 1;
pub const _GLIBCXX_HAVE_SYS_IPC_H: u32 = 1;
pub const _GLIBCXX_HAVE_SYS_MMAN_H: u32 = 1;
pub const _GLIBCXX_HAVE_SYS_PARAM_H: u32 = 1;
pub const _GLIBCXX_HAVE_SYS_RESOURCE_H: u32 = 1;
pub const _GLIBCXX_HAVE_SYS_SDT_H: u32 = 1;
pub const _GLIBCXX_HAVE_SYS_SEM_H: u32 = 1;
pub const _GLIBCXX_HAVE_SYS_SOCKET_H: u32 = 1;
pub const _GLIBCXX_HAVE_SYS_STATVFS_H: u32 = 1;
pub const _GLIBCXX_HAVE_SYS_STAT_H: u32 = 1;
pub const _GLIBCXX_HAVE_SYS_SYSINFO_H: u32 = 1;
pub const _GLIBCXX_HAVE_SYS_TIME_H: u32 = 1;
pub const _GLIBCXX_HAVE_SYS_TYPES_H: u32 = 1;
pub const _GLIBCXX_HAVE_SYS_UIO_H: u32 = 1;
pub const _GLIBCXX_HAVE_S_ISREG: u32 = 1;
pub const _GLIBCXX_HAVE_TANF: u32 = 1;
pub const _GLIBCXX_HAVE_TANHF: u32 = 1;
pub const _GLIBCXX_HAVE_TANHL: u32 = 1;
pub const _GLIBCXX_HAVE_TANL: u32 = 1;
pub const _GLIBCXX_HAVE_TGMATH_H: u32 = 1;
pub const _GLIBCXX_HAVE_TIMESPEC_GET: u32 = 1;
pub const _GLIBCXX_HAVE_TLS: u32 = 1;
pub const _GLIBCXX_HAVE_TRUNCATE: u32 = 1;
pub const _GLIBCXX_HAVE_UCHAR_H: u32 = 1;
pub const _GLIBCXX_HAVE_UNISTD_H: u32 = 1;
pub const _GLIBCXX_HAVE_UNLINKAT: u32 = 1;
pub const _GLIBCXX_HAVE_USELOCALE: u32 = 1;
pub const _GLIBCXX_HAVE_UTIME_H: u32 = 1;
pub const _GLIBCXX_HAVE_VFWSCANF: u32 = 1;
pub const _GLIBCXX_HAVE_VSWSCANF: u32 = 1;
pub const _GLIBCXX_HAVE_VWSCANF: u32 = 1;
pub const _GLIBCXX_HAVE_WCHAR_H: u32 = 1;
pub const _GLIBCXX_HAVE_WCSTOF: u32 = 1;
pub const _GLIBCXX_HAVE_WCTYPE_H: u32 = 1;
pub const _GLIBCXX_HAVE_WRITEV: u32 = 1;
pub const _GLIBCXX_HAVE___CXA_THREAD_ATEXIT_IMPL: u32 = 1;
pub const _GLIBCXX_LT_OBJDIR: &[u8; 7usize] = b".libs/\0";
pub const _GLIBCXX_PACKAGE_BUGREPORT: &[u8; 1usize] = b"\0";
pub const _GLIBCXX_PACKAGE_NAME: &[u8; 15usize] = b"package-unused\0";
pub const _GLIBCXX_PACKAGE_STRING: &[u8; 30usize] = b"package-unused version-unused\0";
pub const _GLIBCXX_PACKAGE_TARNAME: &[u8; 10usize] = b"libstdc++\0";
pub const _GLIBCXX_PACKAGE_URL: &[u8; 1usize] = b"\0";
pub const _GLIBCXX_PACKAGE__GLIBCXX_VERSION: &[u8; 15usize] = b"version-unused\0";
pub const _GLIBCXX_STDC_HEADERS: u32 = 1;
pub const _GLIBCXX_DARWIN_USE_64_BIT_INODE: u32 = 1;
pub const _GLIBCXX11_USE_C99_COMPLEX: u32 = 1;
pub const _GLIBCXX11_USE_C99_MATH: u32 = 1;
pub const _GLIBCXX11_USE_C99_STDIO: u32 = 1;
pub const _GLIBCXX11_USE_C99_STDLIB: u32 = 1;
pub const _GLIBCXX11_USE_C99_WCHAR: u32 = 1;
pub const _GLIBCXX98_USE_C99_COMPLEX: u32 = 1;
pub const _GLIBCXX98_USE_C99_MATH: u32 = 1;
pub const _GLIBCXX98_USE_C99_STDIO: u32 = 1;
pub const _GLIBCXX98_USE_C99_STDLIB: u32 = 1;
pub const _GLIBCXX98_USE_C99_WCHAR: u32 = 1;
pub const _GLIBCXX_ATOMIC_BUILTINS: u32 = 1;
pub const _GLIBCXX_CAN_ALIGNAS_DESTRUCTIVE_SIZE: u32 = 1;
pub const _GLIBCXX_FULLY_DYNAMIC_STRING: u32 = 0;
pub const _GLIBCXX_HAS_GTHREADS: u32 = 1;
pub const _GLIBCXX_RES_LIMITS: u32 = 1;
pub const _GLIBCXX_STATIC_TZDATA: u32 = 1;
pub const _GLIBCXX_STDIO_EOF: i32 = -1;
pub const _GLIBCXX_STDIO_SEEK_CUR: u32 = 1;
pub const _GLIBCXX_STDIO_SEEK_END: u32 = 2;
pub const _GLIBCXX_SYMVER: u32 = 1;
pub const _GLIBCXX_SYMVER_GNU: u32 = 1;
pub const _GLIBCXX_USE_C11_UCHAR_CXX11: u32 = 1;
pub const _GLIBCXX_USE_C99: u32 = 1;
pub const _GLIBCXX_USE_C99_COMPLEX_TR1: u32 = 1;
pub const _GLIBCXX_USE_C99_CTYPE_TR1: u32 = 1;
pub const _GLIBCXX_USE_C99_FENV_TR1: u32 = 1;
pub const _GLIBCXX_USE_C99_INTTYPES_TR1: u32 = 1;
pub const _GLIBCXX_USE_C99_INTTYPES_WCHAR_T_TR1: u32 = 1;
pub const _GLIBCXX_USE_C99_MATH_TR1: u32 = 1;
pub const _GLIBCXX_USE_C99_STDINT_TR1: u32 = 1;
pub const _GLIBCXX_USE_CHDIR: u32 = 1;
pub const _GLIBCXX_USE_CHMOD: u32 = 1;
pub const _GLIBCXX_USE_CLOCK_MONOTONIC: u32 = 1;
pub const _GLIBCXX_USE_CLOCK_REALTIME: u32 = 1;
pub const _GLIBCXX_USE_DECIMAL_FLOAT: u32 = 1;
pub const _GLIBCXX_USE_DEV_RANDOM: u32 = 1;
pub const _GLIBCXX_USE_FCHMOD: u32 = 1;
pub const _GLIBCXX_USE_FCHMODAT: u32 = 1;
pub const _GLIBCXX_USE_FSEEKO_FTELLO: u32 = 1;
pub const _GLIBCXX_USE_GETCWD: u32 = 1;
pub const _GLIBCXX_USE_GETTIMEOFDAY: u32 = 1;
pub const _GLIBCXX_USE_GET_NPROCS: u32 = 1;
pub const _GLIBCXX_USE_INIT_PRIORITY_ATTRIBUTE: u32 = 1;
pub const _GLIBCXX_USE_LFS: u32 = 1;
pub const _GLIBCXX_USE_LONG_LONG: u32 = 1;
pub const _GLIBCXX_USE_LSTAT: u32 = 1;
pub const _GLIBCXX_USE_MKDIR: u32 = 1;
pub const _GLIBCXX_USE_NANOSLEEP: u32 = 1;
pub const _GLIBCXX_USE_NLS: u32 = 1;
pub const _GLIBCXX_USE_PTHREAD_COND_CLOCKWAIT: u32 = 1;
pub const _GLIBCXX_USE_PTHREAD_MUTEX_CLOCKLOCK: u32 = 1;
pub const _GLIBCXX_USE_PTHREAD_RWLOCK_CLOCKLOCK: u32 = 1;
pub const _GLIBCXX_USE_PTHREAD_RWLOCK_T: u32 = 1;
pub const _GLIBCXX_USE_RANDOM_TR1: u32 = 1;
pub const _GLIBCXX_USE_REALPATH: u32 = 1;
pub const _GLIBCXX_USE_SCHED_YIELD: u32 = 1;
pub const _GLIBCXX_USE_SC_NPROCESSORS_ONLN: u32 = 1;
pub const _GLIBCXX_USE_SENDFILE: u32 = 1;
pub const _GLIBCXX_USE_ST_MTIM: u32 = 1;
pub const _GLIBCXX_USE_TMPNAM: u32 = 1;
pub const _GLIBCXX_USE_UCHAR_C8RTOMB_MBRTOC8_CXX20: u32 = 1;
pub const _GLIBCXX_USE_UCHAR_C8RTOMB_MBRTOC8_FCHAR8_T: u32 = 1;
pub const _GLIBCXX_USE_UTIME: u32 = 1;
pub const _GLIBCXX_USE_UTIMENSAT: u32 = 1;
pub const _GLIBCXX_USE_WCHAR_T: u32 = 1;
pub const _GLIBCXX_VERBOSE: u32 = 1;
pub const _GLIBCXX_X86_RDRAND: u32 = 1;
pub const _GLIBCXX_X86_RDSEED: u32 = 1;
pub const _GLIBCXX_ZONEINFO_DIR: &[u8; 20usize] = b"/usr/share/zoneinfo\0";
pub const _GTHREAD_USE_MUTEX_TIMEDLOCK: u32 = 1;
pub const _FUNCTEXCEPT_H: u32 = 1;
pub const _EXCEPTION_DEFINES_H: u32 = 1;
pub const _CPP_TYPE_TRAITS_H: u32 = 1;
pub const _EXT_TYPE_TRAITS: u32 = 1;
pub const _EXT_NUMERIC_TRAITS: u32 = 1;
pub const _STL_PAIR_H: u32 = 1;
pub const _GLIBCXX_TYPE_TRAITS: u32 = 1;
pub const __cpp_lib_integral_constant_callable: u32 = 201304;
pub const __cpp_lib_bool_constant: u32 = 201505;
pub const __cpp_lib_logical_traits: u32 = 201510;
pub const __cpp_lib_is_null_pointer: u32 = 201309;
pub const __cpp_lib_is_final: u32 = 201402;
pub const __cpp_lib_transformation_trait_aliases: u32 = 201304;
pub const __cpp_lib_result_of_sfinae: u32 = 201210;
pub const __cpp_lib_void_t: u32 = 201411;
pub const __cpp_lib_is_swappable: u32 = 201603;
pub const __cpp_lib_is_invocable: u32 = 201703;
pub const __cpp_lib_type_trait_variable_templates: u32 = 201510;
pub const __cpp_lib_has_unique_object_representations: u32 = 201606;
pub const __cpp_lib_is_aggregate: u32 = 201703;
pub const _MOVE_H: u32 = 1;
pub const __cpp_lib_addressof_constexpr: u32 = 201603;
pub const _GLIBCXX_UTILITY_H: u32 = 1;
pub const __cpp_lib_tuple_element_t: u32 = 201402;
pub const __cpp_lib_integer_sequence: u32 = 201304;
pub const __cpp_lib_tuples_by_type: u32 = 201304;
pub const _STL_ITERATOR_BASE_TYPES_H: u32 = 1;
pub const _STL_ITERATOR_BASE_FUNCS_H: u32 = 1;
pub const _CONCEPT_CHECK_H: u32 = 1;
pub const _GLIBCXX_DEBUG_ASSERTIONS_H: u32 = 1;
pub const _STL_ITERATOR_H: u32 = 1;
pub const _PTR_TRAITS_H: u32 = 1;
pub const __cpp_lib_array_constexpr: u32 = 201803;
pub const __cpp_lib_make_reverse_iterator: u32 = 201402;
pub const _GLIBCXX_DEBUG_MACRO_SWITCH_H: u32 = 1;
pub const _GLIBCXX_PREDEFINED_OPS_H: u32 = 1;
pub const _GLIBCXX_BIT: u32 = 1;
pub const __cpp_lib_robust_nonmodifying_seq_ops: u32 = 201304;
pub const _STL_ALGO_H: u32 = 1;
pub const _GLIBCXX_ALGORITHMFWD_H: u32 = 1;
pub const _STL_HEAP_H: u32 = 1;
pub const _STL_TEMPBUF_H: u32 = 1;
pub const __EXCEPTION_H: u32 = 1;
pub const __cpp_lib_launder: u32 = 201606;
pub const _STL_CONSTRUCT_H: u32 = 1;
pub const _GLIBCXX_CSTDLIB: u32 = 1;
pub const __GLIBC_USE_LIB_EXT2: u32 = 1;
pub const __GLIBC_USE_IEC_60559_BFP_EXT: u32 = 1;
pub const __GLIBC_USE_IEC_60559_BFP_EXT_C2X: u32 = 1;
pub const __GLIBC_USE_IEC_60559_EXT: u32 = 1;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT: u32 = 1;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT_C2X: u32 = 1;
pub const __GLIBC_USE_IEC_60559_TYPES_EXT: u32 = 1;
pub const _STDLIB_H: u32 = 1;
pub const WNOHANG: u32 = 1;
pub const WUNTRACED: u32 = 2;
pub const WSTOPPED: u32 = 2;
pub const WEXITED: u32 = 4;
pub const WCONTINUED: u32 = 8;
pub const WNOWAIT: u32 = 16777216;
pub const __WNOTHREAD: u32 = 536870912;
pub const __WALL: u32 = 1073741824;
pub const __WCLONE: u32 = 2147483648;
pub const __W_CONTINUED: u32 = 65535;
pub const __WCOREFLAG: u32 = 128;
pub const __HAVE_FLOAT128: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT128: u32 = 0;
pub const __HAVE_FLOAT64X: u32 = 1;
pub const __HAVE_FLOAT64X_LONG_DOUBLE: u32 = 1;
pub const __HAVE_FLOAT16: u32 = 0;
pub const __HAVE_FLOAT32: u32 = 1;
pub const __HAVE_FLOAT64: u32 = 1;
pub const __HAVE_FLOAT32X: u32 = 1;
pub const __HAVE_FLOAT128X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT16: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT32: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT64: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT32X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT64X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT128X: u32 = 0;
pub const __HAVE_FLOATN_NOT_TYPEDEF: u32 = 0;
pub const __ldiv_t_defined: u32 = 1;
pub const __lldiv_t_defined: u32 = 1;
pub const RAND_MAX: u32 = 2147483647;
pub const EXIT_FAILURE: u32 = 1;
pub const EXIT_SUCCESS: u32 = 0;
pub const _BITS_TYPES_LOCALE_T_H: u32 = 1;
pub const _BITS_TYPES___LOCALE_T_H: u32 = 1;
pub const _SYS_TYPES_H: u32 = 1;
pub const _BITS_TYPES_H: u32 = 1;
pub const _BITS_TYPESIZES_H: u32 = 1;
pub const __OFF_T_MATCHES_OFF64_T: u32 = 1;
pub const __INO_T_MATCHES_INO64_T: u32 = 1;
pub const __RLIM_T_MATCHES_RLIM64_T: u32 = 1;
pub const __STATFS_MATCHES_STATFS64: u32 = 1;
pub const __KERNEL_OLD_TIMEVAL_MATCHES_TIMEVAL64: u32 = 1;
pub const __FD_SETSIZE: u32 = 1024;
pub const _BITS_TIME64_H: u32 = 1;
pub const __clock_t_defined: u32 = 1;
pub const __clockid_t_defined: u32 = 1;
pub const __time_t_defined: u32 = 1;
pub const __timer_t_defined: u32 = 1;
pub const _BITS_STDINT_INTN_H: u32 = 1;
pub const __BIT_TYPES_DEFINED__: u32 = 1;
pub const _ENDIAN_H: u32 = 1;
pub const _BITS_ENDIAN_H: u32 = 1;
pub const __LITTLE_ENDIAN: u32 = 1234;
pub const __BIG_ENDIAN: u32 = 4321;
pub const __PDP_ENDIAN: u32 = 3412;
pub const _BITS_ENDIANNESS_H: u32 = 1;
pub const __BYTE_ORDER: u32 = 1234;
pub const __FLOAT_WORD_ORDER: u32 = 1234;
pub const LITTLE_ENDIAN: u32 = 1234;
pub const BIG_ENDIAN: u32 = 4321;
pub const PDP_ENDIAN: u32 = 3412;
pub const BYTE_ORDER: u32 = 1234;
pub const _BITS_BYTESWAP_H: u32 = 1;
pub const _BITS_UINTN_IDENTITY_H: u32 = 1;
pub const _SYS_SELECT_H: u32 = 1;
pub const __sigset_t_defined: u32 = 1;
pub const __timeval_defined: u32 = 1;
pub const _STRUCT_TIMESPEC: u32 = 1;
pub const FD_SETSIZE: u32 = 1024;
pub const _BITS_PTHREADTYPES_COMMON_H: u32 = 1;
pub const _THREAD_SHARED_TYPES_H: u32 = 1;
pub const _BITS_PTHREADTYPES_ARCH_H: u32 = 1;
pub const __SIZEOF_PTHREAD_MUTEX_T: u32 = 40;
pub const __SIZEOF_PTHREAD_ATTR_T: u32 = 56;
pub const __SIZEOF_PTHREAD_RWLOCK_T: u32 = 56;
pub const __SIZEOF_PTHREAD_BARRIER_T: u32 = 32;
pub const __SIZEOF_PTHREAD_MUTEXATTR_T: u32 = 4;
pub const __SIZEOF_PTHREAD_COND_T: u32 = 48;
pub const __SIZEOF_PTHREAD_CONDATTR_T: u32 = 4;
pub const __SIZEOF_PTHREAD_RWLOCKATTR_T: u32 = 8;
pub const __SIZEOF_PTHREAD_BARRIERATTR_T: u32 = 4;
pub const _THREAD_MUTEX_INTERNAL_H: u32 = 1;
pub const __PTHREAD_MUTEX_HAVE_PREV: u32 = 1;
pub const __have_pthread_attr_t: u32 = 1;
pub const _ALLOCA_H: u32 = 1;
pub const __cpp_lib_clamp: u32 = 201603;
pub const __cpp_lib_sample: u32 = 201603;
pub const _PSTL_ALGORITHM_FORWARD_DECLARED: u32 = 1;
pub const __cpp_lib_parallel_algorithm: u32 = 201603;
pub const _ASSERT_H: u32 = 1;
pub const _GLIBCXX_CSTDDEF: u32 = 1;
pub const __cpp_lib_byte: u32 = 201603;
pub const _GLIBCXX_CSTDINT: u32 = 1;
pub const _STDINT_H: u32 = 1;
pub const _BITS_WCHAR_H: u32 = 1;
pub const _BITS_STDINT_UINTN_H: u32 = 1;
pub const _BITS_STDINT_LEAST_H: u32 = 1;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST16_MIN: i64 = -9223372036854775808;
pub const INT_FAST32_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST16_MAX: u64 = 9223372036854775807;
pub const INT_FAST32_MAX: u64 = 9223372036854775807;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST16_MAX: i32 = -1;
pub const UINT_FAST32_MAX: i32 = -1;
pub const INTPTR_MIN: i64 = -9223372036854775808;
pub const INTPTR_MAX: u64 = 9223372036854775807;
pub const UINTPTR_MAX: i32 = -1;
pub const PTRDIFF_MIN: i64 = -9223372036854775808;
pub const PTRDIFF_MAX: u64 = 9223372036854775807;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const SIZE_MAX: i32 = -1;
pub const WINT_MIN: u32 = 0;
pub const WINT_MAX: u32 = 4294967295;
pub const INT8_WIDTH: u32 = 8;
pub const UINT8_WIDTH: u32 = 8;
pub const INT16_WIDTH: u32 = 16;
pub const UINT16_WIDTH: u32 = 16;
pub const INT32_WIDTH: u32 = 32;
pub const UINT32_WIDTH: u32 = 32;
pub const INT64_WIDTH: u32 = 64;
pub const UINT64_WIDTH: u32 = 64;
pub const INT_LEAST8_WIDTH: u32 = 8;
pub const UINT_LEAST8_WIDTH: u32 = 8;
pub const INT_LEAST16_WIDTH: u32 = 16;
pub const UINT_LEAST16_WIDTH: u32 = 16;
pub const INT_LEAST32_WIDTH: u32 = 32;
pub const UINT_LEAST32_WIDTH: u32 = 32;
pub const INT_LEAST64_WIDTH: u32 = 64;
pub const UINT_LEAST64_WIDTH: u32 = 64;
pub const INT_FAST8_WIDTH: u32 = 8;
pub const UINT_FAST8_WIDTH: u32 = 8;
pub const INT_FAST16_WIDTH: u32 = 64;
pub const UINT_FAST16_WIDTH: u32 = 64;
pub const INT_FAST32_WIDTH: u32 = 64;
pub const UINT_FAST32_WIDTH: u32 = 64;
pub const INT_FAST64_WIDTH: u32 = 64;
pub const UINT_FAST64_WIDTH: u32 = 64;
pub const INTPTR_WIDTH: u32 = 64;
pub const UINTPTR_WIDTH: u32 = 64;
pub const INTMAX_WIDTH: u32 = 64;
pub const UINTMAX_WIDTH: u32 = 64;
pub const PTRDIFF_WIDTH: u32 = 64;
pub const SIG_ATOMIC_WIDTH: u32 = 32;
pub const SIZE_WIDTH: u32 = 64;
pub const WCHAR_WIDTH: u32 = 32;
pub const WINT_WIDTH: u32 = 32;
pub const _STRING_H: u32 = 1;
pub const _STRINGS_H: u32 = 1;
pub const _GLIBCXX_CSTRING: u32 = 1;
pub const _GLIBCXX_FUNCTIONAL: u32 = 1;
pub const _STL_FUNCTION_H: u32 = 1;
pub const __cpp_lib_transparent_operators: u32 = 201510;
pub const _BACKWARD_BINDERS_H: u32 = 1;
pub const _GLIBCXX_TUPLE: u32 = 1;
pub const _USES_ALLOCATOR_H: u32 = 1;
pub const _GLIBCXX_INVOKE_H: u32 = 1;
pub const __cpp_lib_apply: u32 = 201603;
pub const __cpp_lib_make_from_tuple: u32 = 201606;
pub const _FUNCTIONAL_HASH_H: u32 = 1;
pub const _HASH_BYTES_H: u32 = 1;
pub const _GLIBCXX_REFWRAP_H: u32 = 1;
pub const _GLIBCXX_STD_FUNCTION_H: u32 = 1;
pub const __GXX_MERGED_TYPEINFO_NAMES: u32 = 0;
pub const __GXX_TYPEINFO_EQUALITY_INLINE: u32 = 1;
pub const _GLIBCXX_UNORDERED_MAP: u32 = 1;
pub const _REQUIRES_FREESTANDING_H: u32 = 1;
pub const _HASHTABLE_H: u32 = 1;
pub const _HASHTABLE_POLICY_H: u32 = 1;
pub const _ALIGNED_BUFFER_H: u32 = 1;
pub const _EXT_ALLOC_TRAITS_H: u32 = 1;
pub const _ALLOC_TRAITS_H: u32 = 1;
pub const _MEMORYFWD_H: u32 = 1;
pub const _ALLOCATOR_H: u32 = 1;
pub const _GLIBCXX_CXX_ALLOCATOR_H: u32 = 1;
pub const _STD_NEW_ALLOCATOR_H: u32 = 1;
pub const __cpp_lib_incomplete_container_elements: u32 = 201505;
pub const __cpp_lib_allocator_traits_is_always_equal: u32 = 201411;
pub const _ENABLE_SPECIAL_MEMBERS_H: u32 = 1;
pub const _NODE_HANDLE: u32 = 1;
pub const __cpp_lib_node_extract: u32 = 201606;
pub const __cpp_lib_unordered_map_try_emplace: u32 = 201411;
pub const _GLIBCXX_RANGE_ACCESS_H: u32 = 1;
pub const __cpp_lib_nonmember_container_access: u32 = 201411;
pub const _GLIBCXX_ERASE_IF_H: u32 = 1;
pub const _GLIBCXX_MEMORY_RESOURCE_H: u32 = 1;
pub const _USES_ALLOCATOR_ARGS: u32 = 1;
pub const _GLIBCXX_VECTOR: u32 = 1;
pub const _STL_UNINITIALIZED_H: u32 = 1;
pub const __cpp_lib_raw_memory_algorithms: u32 = 201606;
pub const _STL_VECTOR_H: u32 = 1;
pub const _STL_BVECTOR_H: u32 = 1;
pub const _VECTOR_TCC: u32 = 1;
pub const _GLIBCXX_ARRAY: u32 = 1;
pub const __cpp_lib_invoke: u32 = 201411;
pub const __cpp_lib_not_fn: u32 = 201603;
pub const __cpp_lib_boyer_moore_searcher: u32 = 201603;
pub const _GLIBCXX_ITERATOR: u32 = 1;
pub const _STREAM_ITERATOR_H: u32 = 1;
pub const _GLIBCXX_IOSFWD: u32 = 1;
pub const _STRINGFWD_H: u32 = 1;
pub const _GLIBCXX_POSTYPES_H: u32 = 1;
pub const _WCHAR_H: u32 = 1;
pub const __wint_t_defined: u32 = 1;
pub const _WINT_T: u32 = 1;
pub const __mbstate_t_defined: u32 = 1;
pub const ____mbstate_t_defined: u32 = 1;
pub const ____FILE_defined: u32 = 1;
pub const __FILE_defined: u32 = 1;
pub const WEOF: u32 = 4294967295;
pub const _GLIBCXX_CWCHAR: u32 = 1;
pub const _STREAMBUF_ITERATOR_H: u32 = 1;
pub const _GLIBXX_STREAMBUF: u32 = 1;
pub const _LOCALE_FWD_H: u32 = 1;
pub const _GLIBCXX_CXX_LOCALE_H: u32 = 1;
pub const _LOCALE_H: u32 = 1;
pub const _BITS_LOCALE_H: u32 = 1;
pub const __LC_CTYPE: u32 = 0;
pub const __LC_NUMERIC: u32 = 1;
pub const __LC_TIME: u32 = 2;
pub const __LC_COLLATE: u32 = 3;
pub const __LC_MONETARY: u32 = 4;
pub const __LC_MESSAGES: u32 = 5;
pub const __LC_ALL: u32 = 6;
pub const __LC_PAPER: u32 = 7;
pub const __LC_NAME: u32 = 8;
pub const __LC_ADDRESS: u32 = 9;
pub const __LC_TELEPHONE: u32 = 10;
pub const __LC_MEASUREMENT: u32 = 11;
pub const __LC_IDENTIFICATION: u32 = 12;
pub const LC_CTYPE: u32 = 0;
pub const LC_NUMERIC: u32 = 1;
pub const LC_TIME: u32 = 2;
pub const LC_COLLATE: u32 = 3;
pub const LC_MONETARY: u32 = 4;
pub const LC_MESSAGES: u32 = 5;
pub const LC_ALL: u32 = 6;
pub const LC_PAPER: u32 = 7;
pub const LC_NAME: u32 = 8;
pub const LC_ADDRESS: u32 = 9;
pub const LC_TELEPHONE: u32 = 10;
pub const LC_MEASUREMENT: u32 = 11;
pub const LC_IDENTIFICATION: u32 = 12;
pub const LC_CTYPE_MASK: u32 = 1;
pub const LC_NUMERIC_MASK: u32 = 2;
pub const LC_TIME_MASK: u32 = 4;
pub const LC_COLLATE_MASK: u32 = 8;
pub const LC_MONETARY_MASK: u32 = 16;
pub const LC_MESSAGES_MASK: u32 = 32;
pub const LC_PAPER_MASK: u32 = 128;
pub const LC_NAME_MASK: u32 = 256;
pub const LC_ADDRESS_MASK: u32 = 512;
pub const LC_TELEPHONE_MASK: u32 = 1024;
pub const LC_MEASUREMENT_MASK: u32 = 2048;
pub const LC_IDENTIFICATION_MASK: u32 = 4096;
pub const LC_ALL_MASK: u32 = 8127;
pub const _GLIBCXX_CLOCALE: u32 = 1;
pub const _GLIBCXX_C_LOCALE_GNU: u32 = 1;
pub const _GLIBCXX_NUM_CATEGORIES: u32 = 6;
pub const _CTYPE_H: u32 = 1;
pub const _GLIBCXX_CCTYPE: u32 = 1;
pub const _IOS_BASE_H: u32 = 1;
pub const _GLIBCXX_ATOMICITY_H: u32 = 1;
pub const __GTHREADS: u32 = 1;
pub const __GTHREADS_CXX0X: u32 = 1;
pub const _PTHREAD_H: u32 = 1;
pub const _SCHED_H: u32 = 1;
pub const _BITS_SCHED_H: u32 = 1;
pub const SCHED_OTHER: u32 = 0;
pub const SCHED_FIFO: u32 = 1;
pub const SCHED_RR: u32 = 2;
pub const SCHED_BATCH: u32 = 3;
pub const SCHED_ISO: u32 = 4;
pub const SCHED_IDLE: u32 = 5;
pub const SCHED_DEADLINE: u32 = 6;
pub const SCHED_RESET_ON_FORK: u32 = 1073741824;
pub const CSIGNAL: u32 = 255;
pub const CLONE_VM: u32 = 256;
pub const CLONE_FS: u32 = 512;
pub const CLONE_FILES: u32 = 1024;
pub const CLONE_SIGHAND: u32 = 2048;
pub const CLONE_PIDFD: u32 = 4096;
pub const CLONE_PTRACE: u32 = 8192;
pub const CLONE_VFORK: u32 = 16384;
pub const CLONE_PARENT: u32 = 32768;
pub const CLONE_THREAD: u32 = 65536;
pub const CLONE_NEWNS: u32 = 131072;
pub const CLONE_SYSVSEM: u32 = 262144;
pub const CLONE_SETTLS: u32 = 524288;
pub const CLONE_PARENT_SETTID: u32 = 1048576;
pub const CLONE_CHILD_CLEARTID: u32 = 2097152;
pub const CLONE_DETACHED: u32 = 4194304;
pub const CLONE_UNTRACED: u32 = 8388608;
pub const CLONE_CHILD_SETTID: u32 = 16777216;
pub const CLONE_NEWCGROUP: u32 = 33554432;
pub const CLONE_NEWUTS: u32 = 67108864;
pub const CLONE_NEWIPC: u32 = 134217728;
pub const CLONE_NEWUSER: u32 = 268435456;
pub const CLONE_NEWPID: u32 = 536870912;
pub const CLONE_NEWNET: u32 = 1073741824;
pub const CLONE_IO: u32 = 2147483648;
pub const CLONE_NEWTIME: u32 = 128;
pub const _BITS_TYPES_STRUCT_SCHED_PARAM: u32 = 1;
pub const _BITS_CPU_SET_H: u32 = 1;
pub const __CPU_SETSIZE: u32 = 1024;
pub const CPU_SETSIZE: u32 = 1024;
pub const _TIME_H: u32 = 1;
pub const _BITS_TIME_H: u32 = 1;
pub const CLOCK_REALTIME: u32 = 0;
pub const CLOCK_MONOTONIC: u32 = 1;
pub const CLOCK_PROCESS_CPUTIME_ID: u32 = 2;
pub const CLOCK_THREAD_CPUTIME_ID: u32 = 3;
pub const CLOCK_MONOTONIC_RAW: u32 = 4;
pub const CLOCK_REALTIME_COARSE: u32 = 5;
pub const CLOCK_MONOTONIC_COARSE: u32 = 6;
pub const CLOCK_BOOTTIME: u32 = 7;
pub const CLOCK_REALTIME_ALARM: u32 = 8;
pub const CLOCK_BOOTTIME_ALARM: u32 = 9;
pub const CLOCK_TAI: u32 = 11;
pub const TIMER_ABSTIME: u32 = 1;
pub const _BITS_TIMEX_H: u32 = 1;
pub const ADJ_OFFSET: u32 = 1;
pub const ADJ_FREQUENCY: u32 = 2;
pub const ADJ_MAXERROR: u32 = 4;
pub const ADJ_ESTERROR: u32 = 8;
pub const ADJ_STATUS: u32 = 16;
pub const ADJ_TIMECONST: u32 = 32;
pub const ADJ_TAI: u32 = 128;
pub const ADJ_SETOFFSET: u32 = 256;
pub const ADJ_MICRO: u32 = 4096;
pub const ADJ_NANO: u32 = 8192;
pub const ADJ_TICK: u32 = 16384;
pub const ADJ_OFFSET_SINGLESHOT: u32 = 32769;
pub const ADJ_OFFSET_SS_READ: u32 = 40961;
pub const MOD_OFFSET: u32 = 1;
pub const MOD_FREQUENCY: u32 = 2;
pub const MOD_MAXERROR: u32 = 4;
pub const MOD_ESTERROR: u32 = 8;
pub const MOD_STATUS: u32 = 16;
pub const MOD_TIMECONST: u32 = 32;
pub const MOD_CLKB: u32 = 16384;
pub const MOD_CLKA: u32 = 32769;
pub const MOD_TAI: u32 = 128;
pub const MOD_MICRO: u32 = 4096;
pub const MOD_NANO: u32 = 8192;
pub const STA_PLL: u32 = 1;
pub const STA_PPSFREQ: u32 = 2;
pub const STA_PPSTIME: u32 = 4;
pub const STA_FLL: u32 = 8;
pub const STA_INS: u32 = 16;
pub const STA_DEL: u32 = 32;
pub const STA_UNSYNC: u32 = 64;
pub const STA_FREQHOLD: u32 = 128;
pub const STA_PPSSIGNAL: u32 = 256;
pub const STA_PPSJITTER: u32 = 512;
pub const STA_PPSWANDER: u32 = 1024;
pub const STA_PPSERROR: u32 = 2048;
pub const STA_CLOCKERR: u32 = 4096;
pub const STA_NANO: u32 = 8192;
pub const STA_MODE: u32 = 16384;
pub const STA_CLK: u32 = 32768;
pub const STA_RONLY: u32 = 65280;
pub const __struct_tm_defined: u32 = 1;
pub const __itimerspec_defined: u32 = 1;
pub const TIME_UTC: u32 = 1;
pub const _BITS_SETJMP_H: u32 = 1;
pub const __jmp_buf_tag_defined: u32 = 1;
pub const __SC_THREAD_STACK_MIN_VALUE: u32 = 75;
pub const PTHREAD_ONCE_INIT: u32 = 0;
pub const PTHREAD_BARRIER_SERIAL_THREAD: i32 = -1;
pub const PTHREAD_ATTR_NO_SIGMASK_NP: i32 = -1;
pub const __GTHREAD_HAS_COND: u32 = 1;
pub const __GTHREAD_ONCE_INIT: u32 = 0;
pub const _GLIBCXX_ATOMIC_WORD_H: u32 = 1;
pub const _LOCALE_CLASSES_H: u32 = 1;
pub const _GLIBCXX_STRING: u32 = 1;
pub const _CHAR_TRAITS_H: u32 = 1;
pub const __cpp_lib_constexpr_char_traits: u32 = 201611;
pub const _OSTREAM_INSERT_H: u32 = 1;
pub const _CXXABI_FORCED_H: u32 = 1;
pub const _BASIC_STRING_H: u32 = 1;
pub const _GLIBCXX_STRING_VIEW: u32 = 1;
pub const __cpp_lib_string_view: u32 = 201803;
pub const _GLIBCXX_STRING_VIEW_TCC: u32 = 1;
pub const __cpp_lib_constexpr_string: u32 = 201611;
pub const _STRING_CONVERSIONS_H: u32 = 1;
pub const _STDIO_H: u32 = 1;
pub const _____fpos_t_defined: u32 = 1;
pub const _____fpos64_t_defined: u32 = 1;
pub const __struct_FILE_defined: u32 = 1;
pub const _IO_EOF_SEEN: u32 = 16;
pub const _IO_ERR_SEEN: u32 = 32;
pub const _IO_USER_LOCK: u32 = 32768;
pub const __cookie_io_functions_t_defined: u32 = 1;
pub const _IOFBF: u32 = 0;
pub const _IOLBF: u32 = 1;
pub const _IONBF: u32 = 2;
pub const BUFSIZ: u32 = 8192;
pub const EOF: i32 = -1;
pub const SEEK_SET: u32 = 0;
pub const SEEK_CUR: u32 = 1;
pub const SEEK_END: u32 = 2;
pub const SEEK_DATA: u32 = 3;
pub const SEEK_HOLE: u32 = 4;
pub const P_tmpdir: &[u8; 5usize] = b"/tmp\0";
pub const L_tmpnam: u32 = 20;
pub const TMP_MAX: u32 = 238328;
pub const _BITS_STDIO_LIM_H: u32 = 1;
pub const FILENAME_MAX: u32 = 4096;
pub const L_ctermid: u32 = 9;
pub const L_cuserid: u32 = 9;
pub const FOPEN_MAX: u32 = 16;
pub const _PRINTF_NAN_LEN_MAX: u32 = 4;
pub const RENAME_NOREPLACE: u32 = 1;
pub const RENAME_EXCHANGE: u32 = 2;
pub const RENAME_WHITEOUT: u32 = 4;
pub const _GLIBCXX_CSTDIO: u32 = 1;
pub const _ERRNO_H: u32 = 1;
pub const _BITS_ERRNO_H: u32 = 1;
pub const EPERM: u32 = 1;
pub const ENOENT: u32 = 2;
pub const ESRCH: u32 = 3;
pub const EINTR: u32 = 4;
pub const EIO: u32 = 5;
pub const ENXIO: u32 = 6;
pub const E2BIG: u32 = 7;
pub const ENOEXEC: u32 = 8;
pub const EBADF: u32 = 9;
pub const ECHILD: u32 = 10;
pub const EAGAIN: u32 = 11;
pub const ENOMEM: u32 = 12;
pub const EACCES: u32 = 13;
pub const EFAULT: u32 = 14;
pub const ENOTBLK: u32 = 15;
pub const EBUSY: u32 = 16;
pub const EEXIST: u32 = 17;
pub const EXDEV: u32 = 18;
pub const ENODEV: u32 = 19;
pub const ENOTDIR: u32 = 20;
pub const EISDIR: u32 = 21;
pub const EINVAL: u32 = 22;
pub const ENFILE: u32 = 23;
pub const EMFILE: u32 = 24;
pub const ENOTTY: u32 = 25;
pub const ETXTBSY: u32 = 26;
pub const EFBIG: u32 = 27;
pub const ENOSPC: u32 = 28;
pub const ESPIPE: u32 = 29;
pub const EROFS: u32 = 30;
pub const EMLINK: u32 = 31;
pub const EPIPE: u32 = 32;
pub const EDOM: u32 = 33;
pub const ERANGE: u32 = 34;
pub const EDEADLK: u32 = 35;
pub const ENAMETOOLONG: u32 = 36;
pub const ENOLCK: u32 = 37;
pub const ENOSYS: u32 = 38;
pub const ENOTEMPTY: u32 = 39;
pub const ELOOP: u32 = 40;
pub const EWOULDBLOCK: u32 = 11;
pub const ENOMSG: u32 = 42;
pub const EIDRM: u32 = 43;
pub const ECHRNG: u32 = 44;
pub const EL2NSYNC: u32 = 45;
pub const EL3HLT: u32 = 46;
pub const EL3RST: u32 = 47;
pub const ELNRNG: u32 = 48;
pub const EUNATCH: u32 = 49;
pub const ENOCSI: u32 = 50;
pub const EL2HLT: u32 = 51;
pub const EBADE: u32 = 52;
pub const EBADR: u32 = 53;
pub const EXFULL: u32 = 54;
pub const ENOANO: u32 = 55;
pub const EBADRQC: u32 = 56;
pub const EBADSLT: u32 = 57;
pub const EDEADLOCK: u32 = 35;
pub const EBFONT: u32 = 59;
pub const ENOSTR: u32 = 60;
pub const ENODATA: u32 = 61;
pub const ETIME: u32 = 62;
pub const ENOSR: u32 = 63;
pub const ENONET: u32 = 64;
pub const ENOPKG: u32 = 65;
pub const EREMOTE: u32 = 66;
pub const ENOLINK: u32 = 67;
pub const EADV: u32 = 68;
pub const ESRMNT: u32 = 69;
pub const ECOMM: u32 = 70;
pub const EPROTO: u32 = 71;
pub const EMULTIHOP: u32 = 72;
pub const EDOTDOT: u32 = 73;
pub const EBADMSG: u32 = 74;
pub const EOVERFLOW: u32 = 75;
pub const ENOTUNIQ: u32 = 76;
pub const EBADFD: u32 = 77;
pub const EREMCHG: u32 = 78;
pub const ELIBACC: u32 = 79;
pub const ELIBBAD: u32 = 80;
pub const ELIBSCN: u32 = 81;
pub const ELIBMAX: u32 = 82;
pub const ELIBEXEC: u32 = 83;
pub const EILSEQ: u32 = 84;
pub const ERESTART: u32 = 85;
pub const ESTRPIPE: u32 = 86;
pub const EUSERS: u32 = 87;
pub const ENOTSOCK: u32 = 88;
pub const EDESTADDRREQ: u32 = 89;
pub const EMSGSIZE: u32 = 90;
pub const EPROTOTYPE: u32 = 91;
pub const ENOPROTOOPT: u32 = 92;
pub const EPROTONOSUPPORT: u32 = 93;
pub const ESOCKTNOSUPPORT: u32 = 94;
pub const EOPNOTSUPP: u32 = 95;
pub const EPFNOSUPPORT: u32 = 96;
pub const EAFNOSUPPORT: u32 = 97;
pub const EADDRINUSE: u32 = 98;
pub const EADDRNOTAVAIL: u32 = 99;
pub const ENETDOWN: u32 = 100;
pub const ENETUNREACH: u32 = 101;
pub const ENETRESET: u32 = 102;
pub const ECONNABORTED: u32 = 103;
pub const ECONNRESET: u32 = 104;
pub const ENOBUFS: u32 = 105;
pub const EISCONN: u32 = 106;
pub const ENOTCONN: u32 = 107;
pub const ESHUTDOWN: u32 = 108;
pub const ETOOMANYREFS: u32 = 109;
pub const ETIMEDOUT: u32 = 110;
pub const ECONNREFUSED: u32 = 111;
pub const EHOSTDOWN: u32 = 112;
pub const EHOSTUNREACH: u32 = 113;
pub const EALREADY: u32 = 114;
pub const EINPROGRESS: u32 = 115;
pub const ESTALE: u32 = 116;
pub const EUCLEAN: u32 = 117;
pub const ENOTNAM: u32 = 118;
pub const ENAVAIL: u32 = 119;
pub const EISNAM: u32 = 120;
pub const EREMOTEIO: u32 = 121;
pub const EDQUOT: u32 = 122;
pub const ENOMEDIUM: u32 = 123;
pub const EMEDIUMTYPE: u32 = 124;
pub const ECANCELED: u32 = 125;
pub const ENOKEY: u32 = 126;
pub const EKEYEXPIRED: u32 = 127;
pub const EKEYREVOKED: u32 = 128;
pub const EKEYREJECTED: u32 = 129;
pub const EOWNERDEAD: u32 = 130;
pub const ENOTRECOVERABLE: u32 = 131;
pub const ERFKILL: u32 = 132;
pub const EHWPOISON: u32 = 133;
pub const ENOTSUP: u32 = 95;
pub const __error_t_defined: u32 = 1;
pub const _GLIBCXX_CERRNO: u32 = 1;
pub const _GLIBCXX_CHARCONV_H: u32 = 1;
pub const __cpp_lib_string_udls: u32 = 201304;
pub const _BASIC_STRING_TCC: u32 = 1;
pub const _LOCALE_CLASSES_TCC: u32 = 1;
pub const _GLIBCXX_SYSTEM_ERROR: u32 = 1;
pub const _GLIBCXX_ERROR_CONSTANTS: u32 = 1;
pub const _GLIBCXX_STDEXCEPT: u32 = 1;
pub const __cpp_lib_uncaught_exceptions: u32 = 201411;
pub const _CXXABI_INIT_EXCEPTION_H: u32 = 1;
pub const _GLIBCXX_HAVE_CDTOR_CALLABI: u32 = 0;
pub const _GLIBCXX_NESTED_EXCEPTION_H: u32 = 1;
pub const _STREAMBUF_TCC: u32 = 1;
pub const __cpp_lib_null_iterators: u32 = 201304;
pub const _GLIBCXX_NUMERIC_LIMITS: u32 = 1;
pub const _GLIBCXX_MEMORY: u32 = 1;
pub const _STL_RAW_STORAGE_ITERATOR_H: u32 = 1;
pub const _GLIBCXX_ALIGN_H: u32 = 1;
pub const _UNIQUE_PTR_H: u32 = 1;
pub const __cpp_lib_make_unique: u32 = 201304;
pub const _SHARED_PTR_H: u32 = 1;
pub const _SHARED_PTR_BASE_H: u32 = 1;
pub const _ALLOCATED_PTR_H: u32 = 1;
pub const _CONCURRENCE_H: u32 = 1;
pub const __cpp_lib_shared_ptr_arrays: u32 = 201611;
pub const __cpp_lib_shared_ptr_weak_type: u32 = 201606;
pub const __cpp_lib_enable_shared_from_this: u32 = 201603;
pub const _SHARED_PTR_ATOMIC_H: u32 = 1;
pub const _GLIBCXX_ATOMIC_BASE_H: u32 = 1;
pub const _GLIBCXX_ATOMIC_LOCK_FREE_H: u32 = 1;
pub const _BACKWARD_AUTO_PTR_H: u32 = 1;
pub const _GLIBCXX_UTILITY: u32 = 1;
pub const _STL_RELOPS_H: u32 = 1;
pub const __cpp_lib_exchange_function: u32 = 201304;
pub const __cpp_lib_as_const: u32 = 201510;
pub const _INTTYPES_H: u32 = 1;
pub const ____gwchar_t_defined: u32 = 1;
pub const __PRI64_PREFIX: &[u8; 2usize] = b"l\0";
pub const __PRIPTR_PREFIX: &[u8; 2usize] = b"l\0";
pub const PRId8: &[u8; 2usize] = b"d\0";
pub const PRId16: &[u8; 2usize] = b"d\0";
pub const PRId32: &[u8; 2usize] = b"d\0";
pub const PRId64: &[u8; 3usize] = b"ld\0";
pub const PRIdLEAST8: &[u8; 2usize] = b"d\0";
pub const PRIdLEAST16: &[u8; 2usize] = b"d\0";
pub const PRIdLEAST32: &[u8; 2usize] = b"d\0";
pub const PRIdLEAST64: &[u8; 3usize] = b"ld\0";
pub const PRIdFAST8: &[u8; 2usize] = b"d\0";
pub const PRIdFAST16: &[u8; 3usize] = b"ld\0";
pub const PRIdFAST32: &[u8; 3usize] = b"ld\0";
pub const PRIdFAST64: &[u8; 3usize] = b"ld\0";
pub const PRIi8: &[u8; 2usize] = b"i\0";
pub const PRIi16: &[u8; 2usize] = b"i\0";
pub const PRIi32: &[u8; 2usize] = b"i\0";
pub const PRIi64: &[u8; 3usize] = b"li\0";
pub const PRIiLEAST8: &[u8; 2usize] = b"i\0";
pub const PRIiLEAST16: &[u8; 2usize] = b"i\0";
pub const PRIiLEAST32: &[u8; 2usize] = b"i\0";
pub const PRIiLEAST64: &[u8; 3usize] = b"li\0";
pub const PRIiFAST8: &[u8; 2usize] = b"i\0";
pub const PRIiFAST16: &[u8; 3usize] = b"li\0";
pub const PRIiFAST32: &[u8; 3usize] = b"li\0";
pub const PRIiFAST64: &[u8; 3usize] = b"li\0";
pub const PRIo8: &[u8; 2usize] = b"o\0";
pub const PRIo16: &[u8; 2usize] = b"o\0";
pub const PRIo32: &[u8; 2usize] = b"o\0";
pub const PRIo64: &[u8; 3usize] = b"lo\0";
pub const PRIoLEAST8: &[u8; 2usize] = b"o\0";
pub const PRIoLEAST16: &[u8; 2usize] = b"o\0";
pub const PRIoLEAST32: &[u8; 2usize] = b"o\0";
pub const PRIoLEAST64: &[u8; 3usize] = b"lo\0";
pub const PRIoFAST8: &[u8; 2usize] = b"o\0";
pub const PRIoFAST16: &[u8; 3usize] = b"lo\0";
pub const PRIoFAST32: &[u8; 3usize] = b"lo\0";
pub const PRIoFAST64: &[u8; 3usize] = b"lo\0";
pub const PRIu8: &[u8; 2usize] = b"u\0";
pub const PRIu16: &[u8; 2usize] = b"u\0";
pub const PRIu32: &[u8; 2usize] = b"u\0";
pub const PRIu64: &[u8; 3usize] = b"lu\0";
pub const PRIuLEAST8: &[u8; 2usize] = b"u\0";
pub const PRIuLEAST16: &[u8; 2usize] = b"u\0";
pub const PRIuLEAST32: &[u8; 2usize] = b"u\0";
pub const PRIuLEAST64: &[u8; 3usize] = b"lu\0";
pub const PRIuFAST8: &[u8; 2usize] = b"u\0";
pub const PRIuFAST16: &[u8; 3usize] = b"lu\0";
pub const PRIuFAST32: &[u8; 3usize] = b"lu\0";
pub const PRIuFAST64: &[u8; 3usize] = b"lu\0";
pub const PRIx8: &[u8; 2usize] = b"x\0";
pub const PRIx16: &[u8; 2usize] = b"x\0";
pub const PRIx32: &[u8; 2usize] = b"x\0";
pub const PRIx64: &[u8; 3usize] = b"lx\0";
pub const PRIxLEAST8: &[u8; 2usize] = b"x\0";
pub const PRIxLEAST16: &[u8; 2usize] = b"x\0";
pub const PRIxLEAST32: &[u8; 2usize] = b"x\0";
pub const PRIxLEAST64: &[u8; 3usize] = b"lx\0";
pub const PRIxFAST8: &[u8; 2usize] = b"x\0";
pub const PRIxFAST16: &[u8; 3usize] = b"lx\0";
pub const PRIxFAST32: &[u8; 3usize] = b"lx\0";
pub const PRIxFAST64: &[u8; 3usize] = b"lx\0";
pub const PRIX8: &[u8; 2usize] = b"X\0";
pub const PRIX16: &[u8; 2usize] = b"X\0";
pub const PRIX32: &[u8; 2usize] = b"X\0";
pub const PRIX64: &[u8; 3usize] = b"lX\0";
pub const PRIXLEAST8: &[u8; 2usize] = b"X\0";
pub const PRIXLEAST16: &[u8; 2usize] = b"X\0";
pub const PRIXLEAST32: &[u8; 2usize] = b"X\0";
pub const PRIXLEAST64: &[u8; 3usize] = b"lX\0";
pub const PRIXFAST8: &[u8; 2usize] = b"X\0";
pub const PRIXFAST16: &[u8; 3usize] = b"lX\0";
pub const PRIXFAST32: &[u8; 3usize] = b"lX\0";
pub const PRIXFAST64: &[u8; 3usize] = b"lX\0";
pub const PRIdMAX: &[u8; 3usize] = b"ld\0";
pub const PRIiMAX: &[u8; 3usize] = b"li\0";
pub const PRIoMAX: &[u8; 3usize] = b"lo\0";
pub const PRIuMAX: &[u8; 3usize] = b"lu\0";
pub const PRIxMAX: &[u8; 3usize] = b"lx\0";
pub const PRIXMAX: &[u8; 3usize] = b"lX\0";
pub const PRIdPTR: &[u8; 3usize] = b"ld\0";
pub const PRIiPTR: &[u8; 3usize] = b"li\0";
pub const PRIoPTR: &[u8; 3usize] = b"lo\0";
pub const PRIuPTR: &[u8; 3usize] = b"lu\0";
pub const PRIxPTR: &[u8; 3usize] = b"lx\0";
pub const PRIXPTR: &[u8; 3usize] = b"lX\0";
pub const PRIb8: &[u8; 2usize] = b"b\0";
pub const PRIb16: &[u8; 2usize] = b"b\0";
pub const PRIb32: &[u8; 2usize] = b"b\0";
pub const PRIb64: &[u8; 3usize] = b"lb\0";
pub const PRIbLEAST8: &[u8; 2usize] = b"b\0";
pub const PRIbLEAST16: &[u8; 2usize] = b"b\0";
pub const PRIbLEAST32: &[u8; 2usize] = b"b\0";
pub const PRIbLEAST64: &[u8; 3usize] = b"lb\0";
pub const PRIbFAST8: &[u8; 2usize] = b"b\0";
pub const PRIbFAST16: &[u8; 3usize] = b"lb\0";
pub const PRIbFAST32: &[u8; 3usize] = b"lb\0";
pub const PRIbFAST64: &[u8; 3usize] = b"lb\0";
pub const PRIbMAX: &[u8; 3usize] = b"lb\0";
pub const PRIbPTR: &[u8; 3usize] = b"lb\0";
pub const PRIB8: &[u8; 2usize] = b"B\0";
pub const PRIB16: &[u8; 2usize] = b"B\0";
pub const PRIB32: &[u8; 2usize] = b"B\0";
pub const PRIB64: &[u8; 3usize] = b"lB\0";
pub const PRIBLEAST8: &[u8; 2usize] = b"B\0";
pub const PRIBLEAST16: &[u8; 2usize] = b"B\0";
pub const PRIBLEAST32: &[u8; 2usize] = b"B\0";
pub const PRIBLEAST64: &[u8; 3usize] = b"lB\0";
pub const PRIBFAST8: &[u8; 2usize] = b"B\0";
pub const PRIBFAST16: &[u8; 3usize] = b"lB\0";
pub const PRIBFAST32: &[u8; 3usize] = b"lB\0";
pub const PRIBFAST64: &[u8; 3usize] = b"lB\0";
pub const PRIBMAX: &[u8; 3usize] = b"lB\0";
pub const PRIBPTR: &[u8; 3usize] = b"lB\0";
pub const SCNd8: &[u8; 4usize] = b"hhd\0";
pub const SCNd16: &[u8; 3usize] = b"hd\0";
pub const SCNd32: &[u8; 2usize] = b"d\0";
pub const SCNd64: &[u8; 3usize] = b"ld\0";
pub const SCNdLEAST8: &[u8; 4usize] = b"hhd\0";
pub const SCNdLEAST16: &[u8; 3usize] = b"hd\0";
pub const SCNdLEAST32: &[u8; 2usize] = b"d\0";
pub const SCNdLEAST64: &[u8; 3usize] = b"ld\0";
pub const SCNdFAST8: &[u8; 4usize] = b"hhd\0";
pub const SCNdFAST16: &[u8; 3usize] = b"ld\0";
pub const SCNdFAST32: &[u8; 3usize] = b"ld\0";
pub const SCNdFAST64: &[u8; 3usize] = b"ld\0";
pub const SCNi8: &[u8; 4usize] = b"hhi\0";
pub const SCNi16: &[u8; 3usize] = b"hi\0";
pub const SCNi32: &[u8; 2usize] = b"i\0";
pub const SCNi64: &[u8; 3usize] = b"li\0";
pub const SCNiLEAST8: &[u8; 4usize] = b"hhi\0";
pub const SCNiLEAST16: &[u8; 3usize] = b"hi\0";
pub const SCNiLEAST32: &[u8; 2usize] = b"i\0";
pub const SCNiLEAST64: &[u8; 3usize] = b"li\0";
pub const SCNiFAST8: &[u8; 4usize] = b"hhi\0";
pub const SCNiFAST16: &[u8; 3usize] = b"li\0";
pub const SCNiFAST32: &[u8; 3usize] = b"li\0";
pub const SCNiFAST64: &[u8; 3usize] = b"li\0";
pub const SCNu8: &[u8; 4usize] = b"hhu\0";
pub const SCNu16: &[u8; 3usize] = b"hu\0";
pub const SCNu32: &[u8; 2usize] = b"u\0";
pub const SCNu64: &[u8; 3usize] = b"lu\0";
pub const SCNuLEAST8: &[u8; 4usize] = b"hhu\0";
pub const SCNuLEAST16: &[u8; 3usize] = b"hu\0";
pub const SCNuLEAST32: &[u8; 2usize] = b"u\0";
pub const SCNuLEAST64: &[u8; 3usize] = b"lu\0";
pub const SCNuFAST8: &[u8; 4usize] = b"hhu\0";
pub const SCNuFAST16: &[u8; 3usize] = b"lu\0";
pub const SCNuFAST32: &[u8; 3usize] = b"lu\0";
pub const SCNuFAST64: &[u8; 3usize] = b"lu\0";
pub const SCNo8: &[u8; 4usize] = b"hho\0";
pub const SCNo16: &[u8; 3usize] = b"ho\0";
pub const SCNo32: &[u8; 2usize] = b"o\0";
pub const SCNo64: &[u8; 3usize] = b"lo\0";
pub const SCNoLEAST8: &[u8; 4usize] = b"hho\0";
pub const SCNoLEAST16: &[u8; 3usize] = b"ho\0";
pub const SCNoLEAST32: &[u8; 2usize] = b"o\0";
pub const SCNoLEAST64: &[u8; 3usize] = b"lo\0";
pub const SCNoFAST8: &[u8; 4usize] = b"hho\0";
pub const SCNoFAST16: &[u8; 3usize] = b"lo\0";
pub const SCNoFAST32: &[u8; 3usize] = b"lo\0";
pub const SCNoFAST64: &[u8; 3usize] = b"lo\0";
pub const SCNx8: &[u8; 4usize] = b"hhx\0";
pub const SCNx16: &[u8; 3usize] = b"hx\0";
pub const SCNx32: &[u8; 2usize] = b"x\0";
pub const SCNx64: &[u8; 3usize] = b"lx\0";
pub const SCNxLEAST8: &[u8; 4usize] = b"hhx\0";
pub const SCNxLEAST16: &[u8; 3usize] = b"hx\0";
pub const SCNxLEAST32: &[u8; 2usize] = b"x\0";
pub const SCNxLEAST64: &[u8; 3usize] = b"lx\0";
pub const SCNxFAST8: &[u8; 4usize] = b"hhx\0";
pub const SCNxFAST16: &[u8; 3usize] = b"lx\0";
pub const SCNxFAST32: &[u8; 3usize] = b"lx\0";
pub const SCNxFAST64: &[u8; 3usize] = b"lx\0";
pub const SCNdMAX: &[u8; 3usize] = b"ld\0";
pub const SCNiMAX: &[u8; 3usize] = b"li\0";
pub const SCNoMAX: &[u8; 3usize] = b"lo\0";
pub const SCNuMAX: &[u8; 3usize] = b"lu\0";
pub const SCNxMAX: &[u8; 3usize] = b"lx\0";
pub const SCNdPTR: &[u8; 3usize] = b"ld\0";
pub const SCNiPTR: &[u8; 3usize] = b"li\0";
pub const SCNoPTR: &[u8; 3usize] = b"lo\0";
pub const SCNuPTR: &[u8; 3usize] = b"lu\0";
pub const SCNxPTR: &[u8; 3usize] = b"lx\0";
pub const SCNb8: &[u8; 4usize] = b"hhb\0";
pub const SCNb16: &[u8; 3usize] = b"hb\0";
pub const SCNb32: &[u8; 2usize] = b"b\0";
pub const SCNb64: &[u8; 3usize] = b"lb\0";
pub const SCNbLEAST8: &[u8; 4usize] = b"hhb\0";
pub const SCNbLEAST16: &[u8; 3usize] = b"hb\0";
pub const SCNbLEAST32: &[u8; 2usize] = b"b\0";
pub const SCNbLEAST64: &[u8; 3usize] = b"lb\0";
pub const SCNbFAST8: &[u8; 4usize] = b"hhb\0";
pub const SCNbFAST16: &[u8; 3usize] = b"lb\0";
pub const SCNbFAST32: &[u8; 3usize] = b"lb\0";
pub const SCNbFAST64: &[u8; 3usize] = b"lb\0";
pub const SCNbMAX: &[u8; 3usize] = b"lb\0";
pub const SCNbPTR: &[u8; 3usize] = b"lb\0";
pub const LLVM_ENABLE_ABI_BREAKING_CHECKS: u32 = 1;
pub const LLVM_ENABLE_REVERSE_ITERATION: u32 = 0;
pub const _GLIBCXX_OPTIONAL: u32 = 1;
pub const __cpp_lib_optional: u32 = 201606;
pub const _LIBC_LIMITS_H_: u32 = 1;
pub const MB_LEN_MAX: u32 = 16;
pub const CHAR_WIDTH: u32 = 8;
pub const SCHAR_WIDTH: u32 = 8;
pub const UCHAR_WIDTH: u32 = 8;
pub const SHRT_WIDTH: u32 = 16;
pub const USHRT_WIDTH: u32 = 16;
pub const INT_WIDTH: u32 = 32;
pub const UINT_WIDTH: u32 = 32;
pub const LONG_WIDTH: u32 = 64;
pub const ULONG_WIDTH: u32 = 64;
pub const LLONG_WIDTH: u32 = 64;
pub const ULLONG_WIDTH: u32 = 64;
pub const BOOL_MAX: u32 = 1;
pub const BOOL_WIDTH: u32 = 1;
pub const _BITS_POSIX1_LIM_H: u32 = 1;
pub const _POSIX_AIO_LISTIO_MAX: u32 = 2;
pub const _POSIX_AIO_MAX: u32 = 1;
pub const _POSIX_ARG_MAX: u32 = 4096;
pub const _POSIX_CHILD_MAX: u32 = 25;
pub const _POSIX_DELAYTIMER_MAX: u32 = 32;
pub const _POSIX_HOST_NAME_MAX: u32 = 255;
pub const _POSIX_LINK_MAX: u32 = 8;
pub const _POSIX_LOGIN_NAME_MAX: u32 = 9;
pub const _POSIX_MAX_CANON: u32 = 255;
pub const _POSIX_MAX_INPUT: u32 = 255;
pub const _POSIX_MQ_OPEN_MAX: u32 = 8;
pub const _POSIX_MQ_PRIO_MAX: u32 = 32;
pub const _POSIX_NAME_MAX: u32 = 14;
pub const _POSIX_NGROUPS_MAX: u32 = 8;
pub const _POSIX_OPEN_MAX: u32 = 20;
pub const _POSIX_FD_SETSIZE: u32 = 20;
pub const _POSIX_PATH_MAX: u32 = 256;
pub const _POSIX_PIPE_BUF: u32 = 512;
pub const _POSIX_RE_DUP_MAX: u32 = 255;
pub const _POSIX_RTSIG_MAX: u32 = 8;
pub const _POSIX_SEM_NSEMS_MAX: u32 = 256;
pub const _POSIX_SEM_VALUE_MAX: u32 = 32767;
pub const _POSIX_SIGQUEUE_MAX: u32 = 32;
pub const _POSIX_SSIZE_MAX: u32 = 32767;
pub const _POSIX_STREAM_MAX: u32 = 8;
pub const _POSIX_SYMLINK_MAX: u32 = 255;
pub const _POSIX_SYMLOOP_MAX: u32 = 8;
pub const _POSIX_TIMER_MAX: u32 = 32;
pub const _POSIX_TTY_NAME_MAX: u32 = 9;
pub const _POSIX_TZNAME_MAX: u32 = 6;
pub const _POSIX_QLIMIT: u32 = 1;
pub const _POSIX_HIWAT: u32 = 512;
pub const _POSIX_UIO_MAXIOV: u32 = 16;
pub const _POSIX_CLOCKRES_MIN: u32 = 20000000;
pub const NR_OPEN: u32 = 1024;
pub const NGROUPS_MAX: u32 = 65536;
pub const ARG_MAX: u32 = 131072;
pub const LINK_MAX: u32 = 127;
pub const MAX_CANON: u32 = 255;
pub const MAX_INPUT: u32 = 255;
pub const NAME_MAX: u32 = 255;
pub const PATH_MAX: u32 = 4096;
pub const PIPE_BUF: u32 = 4096;
pub const XATTR_NAME_MAX: u32 = 255;
pub const XATTR_SIZE_MAX: u32 = 65536;
pub const XATTR_LIST_MAX: u32 = 65536;
pub const RTSIG_MAX: u32 = 32;
pub const _POSIX_THREAD_KEYS_MAX: u32 = 128;
pub const PTHREAD_KEYS_MAX: u32 = 1024;
pub const _POSIX_THREAD_DESTRUCTOR_ITERATIONS: u32 = 4;
pub const PTHREAD_DESTRUCTOR_ITERATIONS: u32 = 4;
pub const _POSIX_THREAD_THREADS_MAX: u32 = 64;
pub const AIO_PRIO_DELTA_MAX: u32 = 20;
pub const DELAYTIMER_MAX: u32 = 2147483647;
pub const TTY_NAME_MAX: u32 = 32;
pub const LOGIN_NAME_MAX: u32 = 256;
pub const HOST_NAME_MAX: u32 = 64;
pub const MQ_PRIO_MAX: u32 = 32768;
pub const SEM_VALUE_MAX: u32 = 2147483647;
pub const _BITS_POSIX2_LIM_H: u32 = 1;
pub const _POSIX2_BC_BASE_MAX: u32 = 99;
pub const _POSIX2_BC_DIM_MAX: u32 = 2048;
pub const _POSIX2_BC_SCALE_MAX: u32 = 99;
pub const _POSIX2_BC_STRING_MAX: u32 = 1000;
pub const _POSIX2_COLL_WEIGHTS_MAX: u32 = 2;
pub const _POSIX2_EXPR_NEST_MAX: u32 = 32;
pub const _POSIX2_LINE_MAX: u32 = 2048;
pub const _POSIX2_RE_DUP_MAX: u32 = 255;
pub const _POSIX2_CHARCLASS_NAME_MAX: u32 = 14;
pub const BC_BASE_MAX: u32 = 99;
pub const BC_DIM_MAX: u32 = 2048;
pub const BC_SCALE_MAX: u32 = 99;
pub const BC_STRING_MAX: u32 = 1000;
pub const COLL_WEIGHTS_MAX: u32 = 255;
pub const EXPR_NEST_MAX: u32 = 32;
pub const LINE_MAX: u32 = 2048;
pub const CHARCLASS_NAME_MAX: u32 = 2048;
pub const RE_DUP_MAX: u32 = 32767;
pub const _XOPEN_LIM_H: u32 = 1;
pub const _XOPEN_IOV_MAX: u32 = 16;
pub const _BITS_UIO_LIM_H: u32 = 1;
pub const __IOV_MAX: u32 = 1024;
pub const IOV_MAX: u32 = 1024;
pub const NL_ARGMAX: u32 = 4096;
pub const NL_LANGMAX: u32 = 2048;
pub const NZERO: u32 = 20;
pub const WORD_BIT: u32 = 32;
pub const LONG_BIT: u32 = 64;
pub const _GLIBCXX_CLIMITS: u32 = 1;
pub const LLVM_C_API: u32 = 0;
pub const LLVMErrorSuccess: u32 = 0;
pub const _GLIBCXX_CHRONO: u32 = 1;
pub const _GLIBCXX_CHRONO_H: u32 = 1;
pub const _GLIBCXX_RATIO: u32 = 1;
pub const _GLIBCXX_CTIME: u32 = 1;
pub const _GLIBCXX_PARSE_NUMBERS_H: u32 = 1;
pub const __cpp_lib_chrono: u32 = 201611;
pub const __cpp_lib_chrono_udls: u32 = 201304;
pub const LLVMDisassembler_VariantKind_None: u32 = 0;
pub const LLVMDisassembler_VariantKind_ARM_HI16: u32 = 1;
pub const LLVMDisassembler_VariantKind_ARM_LO16: u32 = 2;
pub const LLVMDisassembler_VariantKind_ARM64_PAGE: u32 = 1;
pub const LLVMDisassembler_VariantKind_ARM64_PAGEOFF: u32 = 2;
pub const LLVMDisassembler_VariantKind_ARM64_GOTPAGE: u32 = 3;
pub const LLVMDisassembler_VariantKind_ARM64_GOTPAGEOFF: u32 = 4;
pub const LLVMDisassembler_VariantKind_ARM64_TLVP: u32 = 5;
pub const LLVMDisassembler_VariantKind_ARM64_TLVOFF: u32 = 6;
pub const LLVMDisassembler_ReferenceType_InOut_None: u32 = 0;
pub const LLVMDisassembler_ReferenceType_In_Branch: u32 = 1;
pub const LLVMDisassembler_ReferenceType_In_PCrel_Load: u32 = 2;
pub const LLVMDisassembler_ReferenceType_In_ARM64_ADRP: u64 = 4294967297;
pub const LLVMDisassembler_ReferenceType_In_ARM64_ADDXri: u64 = 4294967298;
pub const LLVMDisassembler_ReferenceType_In_ARM64_LDRXui: u64 = 4294967299;
pub const LLVMDisassembler_ReferenceType_In_ARM64_LDRXl: u64 = 4294967300;
pub const LLVMDisassembler_ReferenceType_In_ARM64_ADR: u64 = 4294967301;
pub const LLVMDisassembler_ReferenceType_Out_SymbolStub: u32 = 1;
pub const LLVMDisassembler_ReferenceType_Out_LitPool_SymAddr: u32 = 2;
pub const LLVMDisassembler_ReferenceType_Out_LitPool_CstrAddr: u32 = 3;
pub const LLVMDisassembler_ReferenceType_Out_Objc_CFString_Ref: u32 = 4;
pub const LLVMDisassembler_ReferenceType_Out_Objc_Message: u32 = 5;
pub const LLVMDisassembler_ReferenceType_Out_Objc_Message_Ref: u32 = 6;
pub const LLVMDisassembler_ReferenceType_Out_Objc_Selector_Ref: u32 = 7;
pub const LLVMDisassembler_ReferenceType_Out_Objc_Class_Ref: u32 = 8;
pub const LLVMDisassembler_ReferenceType_DeMangled_Name: u32 = 9;
pub const _GLIBCXX_LIST: u32 = 1;
pub const _STL_LIST_H: u32 = 1;
pub const _LIST_TCC: u32 = 1;
pub const _GLIBCXX_ATOMIC: u32 = 1;
pub const __cpp_lib_atomic_is_always_lock_free: u32 = 201603;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct max_align_t {
    pub __clang_max_align_nonce1: ::std::os::raw::c_longlong,
    pub __bindgen_padding_0: u64,
    pub __clang_max_align_nonce2: u128,
}
#[test]
fn bindgen_test_layout_max_align_t() {
    const UNINIT: ::std::mem::MaybeUninit<max_align_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<max_align_t>(),
        32usize,
        concat!("Size of: ", stringify!(max_align_t))
    );
    assert_eq!(
        ::std::mem::align_of::<max_align_t>(),
        16usize,
        concat!("Alignment of ", stringify!(max_align_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__clang_max_align_nonce1) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(max_align_t),
            "::",
            stringify!(__clang_max_align_nonce1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__clang_max_align_nonce2) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(max_align_t),
            "::",
            stringify!(__clang_max_align_nonce2)
        )
    );
}
pub type std_nullptr_t = *const ::std::os::raw::c_void;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_basic_stringbuf {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_basic_istringstream {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_basic_ostringstream {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_basic_stringstream {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_numpunct {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_numpunct_byname {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_time_get {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_time_get_byname {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_money_get {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_money_put {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_messages {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_messages_byname {
    pub _address: u8,
}
#[repr(C)]
pub struct std_basic_string<_CharT> {
    pub _M_dataplus: std_basic_string__Alloc_hider,
    pub _M_string_length: std_basic_string_size_type,
    pub __bindgen_anon_1: std_basic_string__bindgen_ty_2<_CharT>,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_CharT>>,
}
pub type std_basic_string__Char_alloc_type = [u8; 0usize];
pub type std_basic_string__Alloc_traits = __gnu_cxx___alloc_traits;
pub type std_basic_string_traits_type<_Traits> = _Traits;
pub type std_basic_string_value_type = [u8; 0usize];
pub type std_basic_string_allocator_type = std_basic_string__Char_alloc_type;
pub type std_basic_string_size_type = [u8; 0usize];
pub type std_basic_string_difference_type = [u8; 0usize];
pub type std_basic_string_reference = [u8; 0usize];
pub type std_basic_string_const_reference = [u8; 0usize];
pub type std_basic_string_pointer = [u8; 0usize];
pub type std_basic_string_const_pointer = [u8; 0usize];
pub type std_basic_string_iterator = __gnu_cxx___normal_iterator<std_basic_string_pointer>;
pub type std_basic_string_const_iterator =
    __gnu_cxx___normal_iterator<std_basic_string_const_pointer>;
pub type std_basic_string_const_reverse_iterator =
    std_reverse_iterator<std_basic_string_const_iterator>;
pub type std_basic_string_reverse_iterator = std_reverse_iterator<std_basic_string_iterator>;
pub type std_basic_string___const_iterator = std_basic_string_const_iterator;
pub type std_basic_string___sv_type<_CharT> = std_basic_string_view<_CharT>;
pub type std_basic_string__If_sv = std_enable_if_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_basic_string___sv_wrapper<_CharT> {
    pub _M_sv: std_basic_string___sv_type<_CharT>,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_CharT>>,
}
#[repr(C)]
pub struct std_basic_string__Alloc_hider {
    pub _M_p: std_basic_string_pointer,
}
pub const std_basic_string__S_local_capacity: std_basic_string__bindgen_ty_1 = 0;
pub type std_basic_string__bindgen_ty_1 = i32;
#[repr(C)]
pub struct std_basic_string__bindgen_ty_2<_CharT> {
    pub _M_local_buf: __BindgenUnionField<*mut _CharT>,
    pub _M_allocated_capacity: __BindgenUnionField<std_basic_string_size_type>,
    pub bindgen_union_field: u64,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_CharT>>,
}
#[repr(C)]
#[derive(Debug)]
pub struct std_collate {
    pub _base: std_locale_facet,
    pub _M_c_locale_collate: std___c_locale,
}
pub type std_collate_char_type<_CharT> = _CharT;
pub type std_collate_string_type = std_basic_string<_CharT>;
#[repr(C)]
#[derive(Debug)]
pub struct std_collate_byname {
    pub _base: std_collate,
}
pub type std_collate_byname_char_type<_CharT> = _CharT;
pub type std_collate_byname_string_type = std_basic_string<_CharT>;
#[repr(C)]
pub struct std__List_base {
    pub _M_impl: std__List_base__List_impl,
}
pub type std__List_base__Tp_alloc_type = [u8; 0usize];
pub type std__List_base__Tp_alloc_traits = __gnu_cxx___alloc_traits;
pub type std__List_base__Node_alloc_type = [u8; 0usize];
pub type std__List_base__Node_alloc_traits = __gnu_cxx___alloc_traits;
#[repr(C)]
pub struct std__List_base__List_impl {
    pub _M_node: std___detail__List_node_header,
}
pub type std__List_base_allocator_type<_Alloc> = _Alloc;
#[repr(C)]
pub struct std_list {
    pub _base: std__List_base,
}
pub type std_list__Base = std__List_base;
pub type std_list__Tp_alloc_type = std_list__Base;
pub type std_list__Tp_alloc_traits = std_list__Base;
pub type std_list__Node_alloc_type = std_list__Base;
pub type std_list__Node_alloc_traits = std_list__Base;
pub type std_list_value_type<_Tp> = _Tp;
pub type std_list_pointer = std_list__Tp_alloc_traits;
pub type std_list_const_pointer = std_list__Tp_alloc_traits;
pub type std_list_reference = std_list__Tp_alloc_traits;
pub type std_list_const_reference = std_list__Tp_alloc_traits;
pub type std_list_iterator = std__List_iterator;
pub type std_list_const_iterator = std__List_const_iterator;
pub type std_list_const_reverse_iterator = std_reverse_iterator<std_list_const_iterator>;
pub type std_list_reverse_iterator = std_reverse_iterator<std_list_iterator>;
pub type std_list_size_type = usize;
pub type std_list_difference_type = isize;
pub type std_list_allocator_type<_Alloc> = _Alloc;
pub type std_list__Node = std__List_node;
pub type std_list___remove_return_type = ::std::os::raw::c_void;
#[repr(C)]
#[derive(Debug)]
pub struct std_list__Finalize_merge {
    pub _M_dest: *mut std_list,
    pub _M_src: *mut std_list,
    pub _M_next: *const std_list_iterator,
}
extern "C" {
    #[link_name = "\u{1}_ZSt21__throw_bad_exceptionv"]
    pub fn std___throw_bad_exception() -> !;
}
extern "C" {
    #[link_name = "\u{1}_ZSt17__throw_bad_allocv"]
    pub fn std___throw_bad_alloc() -> !;
}
extern "C" {
    #[link_name = "\u{1}_ZSt28__throw_bad_array_new_lengthv"]
    pub fn std___throw_bad_array_new_length() -> !;
}
extern "C" {
    #[link_name = "\u{1}_ZSt16__throw_bad_castv"]
    pub fn std___throw_bad_cast() -> !;
}
extern "C" {
    #[link_name = "\u{1}_ZSt18__throw_bad_typeidv"]
    pub fn std___throw_bad_typeid() -> !;
}
extern "C" {
    #[link_name = "\u{1}_ZSt19__throw_logic_errorPKc"]
    pub fn std___throw_logic_error(arg1: *const ::std::os::raw::c_char) -> !;
}
extern "C" {
    #[link_name = "\u{1}_ZSt20__throw_domain_errorPKc"]
    pub fn std___throw_domain_error(arg1: *const ::std::os::raw::c_char) -> !;
}
extern "C" {
    #[link_name = "\u{1}_ZSt24__throw_invalid_argumentPKc"]
    pub fn std___throw_invalid_argument(arg1: *const ::std::os::raw::c_char) -> !;
}
extern "C" {
    #[link_name = "\u{1}_ZSt20__throw_length_errorPKc"]
    pub fn std___throw_length_error(arg1: *const ::std::os::raw::c_char) -> !;
}
extern "C" {
    #[link_name = "\u{1}_ZSt20__throw_out_of_rangePKc"]
    pub fn std___throw_out_of_range(arg1: *const ::std::os::raw::c_char) -> !;
}
extern "C" {
    #[link_name = "\u{1}_ZSt24__throw_out_of_range_fmtPKcz"]
    pub fn std___throw_out_of_range_fmt(arg1: *const ::std::os::raw::c_char, ...) -> !;
}
extern "C" {
    #[link_name = "\u{1}_ZSt21__throw_runtime_errorPKc"]
    pub fn std___throw_runtime_error(arg1: *const ::std::os::raw::c_char) -> !;
}
extern "C" {
    #[link_name = "\u{1}_ZSt19__throw_range_errorPKc"]
    pub fn std___throw_range_error(arg1: *const ::std::os::raw::c_char) -> !;
}
extern "C" {
    #[link_name = "\u{1}_ZSt22__throw_overflow_errorPKc"]
    pub fn std___throw_overflow_error(arg1: *const ::std::os::raw::c_char) -> !;
}
extern "C" {
    #[link_name = "\u{1}_ZSt23__throw_underflow_errorPKc"]
    pub fn std___throw_underflow_error(arg1: *const ::std::os::raw::c_char) -> !;
}
extern "C" {
    #[link_name = "\u{1}_ZSt19__throw_ios_failurePKc"]
    pub fn std___throw_ios_failure(arg1: *const ::std::os::raw::c_char) -> !;
}
extern "C" {
    #[link_name = "\u{1}_ZSt19__throw_ios_failurePKci"]
    pub fn std___throw_ios_failure1(
        arg1: *const ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
    ) -> !;
}
extern "C" {
    #[link_name = "\u{1}_ZSt20__throw_system_errori"]
    pub fn std___throw_system_error(arg1: ::std::os::raw::c_int) -> !;
}
extern "C" {
    #[link_name = "\u{1}_ZSt20__throw_future_errori"]
    pub fn std___throw_future_error(arg1: ::std::os::raw::c_int) -> !;
}
extern "C" {
    #[link_name = "\u{1}_ZSt25__throw_bad_function_callv"]
    pub fn std___throw_bad_function_call() -> !;
}
pub type std_integral_constant_value_type<_Tp> = _Tp;
pub type std_integral_constant_type = u8;
pub type std_true_type = u8;
pub type std_false_type = u8;
pub type std___bool_constant = u8;
pub type std_bool_constant = u8;
pub type std___enable_if_t = u8;
pub type std___conditional_type<_Tp> = _Tp;
pub type std___conditional_t = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___type_identity {
    pub _address: u8,
}
pub type std___type_identity_type<_Type> = _Type;
pub type std___type_identity_t = std___type_identity;
pub type std___detail___first_t<_Tp> = _Tp;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___detail___disjunction_impl {
    pub _address: u8,
}
pub type std___detail___disjunction_impl_type<_B1> = _B1;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___detail___conjunction_impl {
    pub _address: u8,
}
pub type std___detail___conjunction_impl_type<_B1> = _B1;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___detail___variant__Never_valueless_alt {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___detail__Identity {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_std___detail__Identity() {
    assert_eq!(
        ::std::mem::size_of::<std___detail__Identity>(),
        1usize,
        concat!("Size of: ", stringify!(std___detail__Identity))
    );
    assert_eq!(
        ::std::mem::align_of::<std___detail__Identity>(),
        1usize,
        concat!("Alignment of ", stringify!(std___detail__Identity))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___detail__Select1st {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___detail__Select1st___1st_type {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_std___detail__Select1st() {
    assert_eq!(
        ::std::mem::size_of::<std___detail__Select1st>(),
        1usize,
        concat!("Size of: ", stringify!(std___detail__Select1st))
    );
    assert_eq!(
        ::std::mem::align_of::<std___detail__Select1st>(),
        1usize,
        concat!("Alignment of ", stringify!(std___detail__Select1st))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___detail__ConvertToValueType {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___detail__NodeBuilder {
    pub _address: u8,
}
#[test]
fn __bindgen_test_layout_std___detail__NodeBuilder_open0_std___detail__Select1st_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<std___detail__NodeBuilder>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___detail__NodeBuilder)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___detail__NodeBuilder>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___detail__NodeBuilder)
        )
    );
}
#[test]
fn __bindgen_test_layout_std___detail__NodeBuilder_open0_std___detail__Identity_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<std___detail__NodeBuilder>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___detail__NodeBuilder)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___detail__NodeBuilder>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___detail__NodeBuilder)
        )
    );
}
#[repr(C)]
#[derive(Debug)]
pub struct std___detail__ReuseOrAllocNode {
    pub _M_nodes: *mut std___detail__ReuseOrAllocNode___node_type,
    pub _M_h: *mut std___detail__ReuseOrAllocNode___hashtable_alloc,
}
pub type std___detail__ReuseOrAllocNode___node_alloc_type<_NodeAlloc> = _NodeAlloc;
pub type std___detail__ReuseOrAllocNode___hashtable_alloc = std___detail__Hashtable_alloc;
pub type std___detail__ReuseOrAllocNode___node_alloc_traits =
    std___detail__ReuseOrAllocNode___hashtable_alloc;
pub type std___detail__ReuseOrAllocNode___node_type =
    std___detail__ReuseOrAllocNode___hashtable_alloc;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___detail__AllocNode {
    pub _M_h: *mut std___detail__AllocNode___hashtable_alloc,
}
pub type std___detail__AllocNode___hashtable_alloc = std___detail__Hashtable_alloc;
pub type std___detail__AllocNode___node_type = std___detail__AllocNode___hashtable_alloc;
pub type std___detail__Hashtable_traits___hash_cached = std___bool_constant;
pub type std___detail__Hashtable_traits___constant_iterators = std___bool_constant;
pub type std___detail__Hashtable_traits___unique_keys = std___bool_constant;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___detail__Hashtable_hash_traits {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___detail__Hash_node_base {
    pub _M_nxt: *mut std___detail__Hash_node_base,
}
#[test]
fn bindgen_test_layout_std___detail__Hash_node_base() {
    const UNINIT: ::std::mem::MaybeUninit<std___detail__Hash_node_base> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<std___detail__Hash_node_base>(),
        8usize,
        concat!("Size of: ", stringify!(std___detail__Hash_node_base))
    );
    assert_eq!(
        ::std::mem::align_of::<std___detail__Hash_node_base>(),
        8usize,
        concat!("Alignment of ", stringify!(std___detail__Hash_node_base))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._M_nxt) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(std___detail__Hash_node_base),
            "::",
            stringify!(_M_nxt)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___detail__Hash_node_value_base {
    pub _M_storage: __gnu_cxx___aligned_buffer,
}
pub type std___detail__Hash_node_value_base_value_type<_Value> = _Value;
pub type std___detail__Node_iterator_base___node_type = u8;
pub type std___detail__Node_iterator___base_type = u8;
pub type std___detail__Node_iterator___node_type = std___detail__Node_iterator___base_type;
pub type std___detail__Node_iterator_value_type<_Value> = _Value;
pub type std___detail__Node_iterator_difference_type = isize;
pub type std___detail__Node_iterator_iterator_category = std_forward_iterator_tag;
pub type std___detail__Node_iterator_pointer = std___conditional_t;
pub type std___detail__Node_iterator_reference = std___conditional_t;
pub type std___detail__Node_const_iterator___base_type = u8;
pub type std___detail__Node_const_iterator___node_type =
    std___detail__Node_const_iterator___base_type;
pub type std___detail__Node_const_iterator_value_type<_Value> = _Value;
pub type std___detail__Node_const_iterator_difference_type = isize;
pub type std___detail__Node_const_iterator_iterator_category = std_forward_iterator_tag;
pub type std___detail__Node_const_iterator_pointer<_Value> =
    *const std___detail__Node_const_iterator_value_type<_Value>;
pub type std___detail__Node_const_iterator_reference<_Value> =
    *const std___detail__Node_const_iterator_value_type<_Value>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___detail__Mod_range_hashing {
    pub _address: u8,
}
pub type std___detail__Mod_range_hashing_first_argument_type = usize;
pub type std___detail__Mod_range_hashing_second_argument_type = usize;
pub type std___detail__Mod_range_hashing_result_type = usize;
#[test]
fn bindgen_test_layout_std___detail__Mod_range_hashing() {
    assert_eq!(
        ::std::mem::size_of::<std___detail__Mod_range_hashing>(),
        1usize,
        concat!("Size of: ", stringify!(std___detail__Mod_range_hashing))
    );
    assert_eq!(
        ::std::mem::align_of::<std___detail__Mod_range_hashing>(),
        1usize,
        concat!("Alignment of ", stringify!(std___detail__Mod_range_hashing))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___detail__Default_ranged_hash {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_std___detail__Default_ranged_hash() {
    assert_eq!(
        ::std::mem::size_of::<std___detail__Default_ranged_hash>(),
        1usize,
        concat!("Size of: ", stringify!(std___detail__Default_ranged_hash))
    );
    assert_eq!(
        ::std::mem::align_of::<std___detail__Default_ranged_hash>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(std___detail__Default_ranged_hash)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___detail__Prime_rehash_policy {
    pub _M_max_load_factor: f32,
    pub _M_next_resize: usize,
}
pub type std___detail__Prime_rehash_policy___has_load_factor = std_true_type;
pub type std___detail__Prime_rehash_policy__State = usize;
pub const std___detail__Prime_rehash_policy__S_growth_factor: usize = 2;
#[test]
fn bindgen_test_layout_std___detail__Prime_rehash_policy() {
    const UNINIT: ::std::mem::MaybeUninit<std___detail__Prime_rehash_policy> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<std___detail__Prime_rehash_policy>(),
        16usize,
        concat!("Size of: ", stringify!(std___detail__Prime_rehash_policy))
    );
    assert_eq!(
        ::std::mem::align_of::<std___detail__Prime_rehash_policy>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(std___detail__Prime_rehash_policy)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._M_max_load_factor) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(std___detail__Prime_rehash_policy),
            "::",
            stringify!(_M_max_load_factor)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._M_next_resize) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(std___detail__Prime_rehash_policy),
            "::",
            stringify!(_M_next_resize)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNKSt8__detail20_Prime_rehash_policy11_M_next_bktEm"]
    pub fn std___detail__Prime_rehash_policy__M_next_bkt(
        this: *const std___detail__Prime_rehash_policy,
        __n: usize,
    ) -> usize;
}
extern "C" {
    #[link_name = "\u{1}_ZNKSt8__detail20_Prime_rehash_policy14_M_need_rehashEmmm"]
    pub fn std___detail__Prime_rehash_policy__M_need_rehash(
        this: *const std___detail__Prime_rehash_policy,
        __n_bkt: usize,
        __n_elt: usize,
        __n_ins: usize,
    ) -> std_pair<bool, usize>;
}
impl std___detail__Prime_rehash_policy {
    #[inline]
    pub unsafe fn _M_next_bkt(&self, __n: usize) -> usize {
        std___detail__Prime_rehash_policy__M_next_bkt(self, __n)
    }
    #[inline]
    pub unsafe fn _M_need_rehash(
        &self,
        __n_bkt: usize,
        __n_elt: usize,
        __n_ins: usize,
    ) -> std_pair<bool, usize> {
        std___detail__Prime_rehash_policy__M_need_rehash(self, __n_bkt, __n_elt, __n_ins)
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___detail__Mask_range_hashing {
    pub _address: u8,
}
pub type std___detail__Mask_range_hashing_first_argument_type = usize;
pub type std___detail__Mask_range_hashing_second_argument_type = usize;
pub type std___detail__Mask_range_hashing_result_type = usize;
#[test]
fn bindgen_test_layout_std___detail__Mask_range_hashing() {
    assert_eq!(
        ::std::mem::size_of::<std___detail__Mask_range_hashing>(),
        1usize,
        concat!("Size of: ", stringify!(std___detail__Mask_range_hashing))
    );
    assert_eq!(
        ::std::mem::align_of::<std___detail__Mask_range_hashing>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(std___detail__Mask_range_hashing)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___detail__Power2_rehash_policy {
    pub _M_max_load_factor: f32,
    pub _M_next_resize: usize,
}
pub type std___detail__Power2_rehash_policy___has_load_factor = std_true_type;
pub type std___detail__Power2_rehash_policy__State = usize;
pub const std___detail__Power2_rehash_policy__S_growth_factor: usize = 2;
#[test]
fn bindgen_test_layout_std___detail__Power2_rehash_policy() {
    const UNINIT: ::std::mem::MaybeUninit<std___detail__Power2_rehash_policy> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<std___detail__Power2_rehash_policy>(),
        16usize,
        concat!("Size of: ", stringify!(std___detail__Power2_rehash_policy))
    );
    assert_eq!(
        ::std::mem::align_of::<std___detail__Power2_rehash_policy>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(std___detail__Power2_rehash_policy)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._M_max_load_factor) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(std___detail__Power2_rehash_policy),
            "::",
            stringify!(_M_max_load_factor)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._M_next_resize) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(std___detail__Power2_rehash_policy),
            "::",
            stringify!(_M_next_resize)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___detail__Insert_base {
    pub _address: u8,
}
pub type std___detail__Insert_base___hashtable_base = std___detail__Hashtable_base;
pub type std___detail__Insert_base___hashtable<_RehashPolicy> = std__Hashtable<_RehashPolicy>;
pub type std___detail__Insert_base___hash_cached = [u8; 0usize];
pub type std___detail__Insert_base___constant_iterators = [u8; 0usize];
pub type std___detail__Insert_base___hashtable_alloc = std___detail__Hashtable_alloc;
pub type std___detail__Insert_base_value_type = std___detail__Insert_base___hashtable_base;
pub type std___detail__Insert_base_size_type = std___detail__Insert_base___hashtable_base;
pub type std___detail__Insert_base___unique_keys = [u8; 0usize];
pub type std___detail__Insert_base___node_alloc_type = std___detail__Insert_base___hashtable_alloc;
pub type std___detail__Insert_base___node_gen_type = std___detail__AllocNode;
pub type std___detail__Insert_base_iterator = u8;
pub type std___detail__Insert_base_const_iterator = u8;
pub type std___detail__Insert_base___ireturn_type = std___conditional_t;
pub type std___detail___has_load_factor = [u8; 0usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___detail__Rehash_base {
    pub _address: u8,
}
pub type std___detail__Hash_code_base___ebo_hash = u8;
pub type std___detail__Hash_code_base_hasher<_Hash> = _Hash;
pub type std___detail__Hash_code_base___hash_code = usize;
pub type std___detail___hash_code_for_local_iter = u8;
pub type std___detail__Local_iterator___base_type = u8;
pub type std___detail__Local_iterator___hash_code_base = std___detail__Local_iterator___base_type;
pub type std___detail__Local_iterator_value_type<_Value> = _Value;
pub type std___detail__Local_iterator_pointer = std___conditional_t;
pub type std___detail__Local_iterator_reference = std___conditional_t;
pub type std___detail__Local_iterator_difference_type = isize;
pub type std___detail__Local_iterator_iterator_category = std_forward_iterator_tag;
pub type std___detail__Local_const_iterator___base_type = u8;
pub type std___detail__Local_const_iterator___hash_code_base =
    std___detail__Local_const_iterator___base_type;
pub type std___detail__Local_const_iterator_value_type<_Value> = _Value;
pub type std___detail__Local_const_iterator_pointer<_Value> =
    *const std___detail__Local_const_iterator_value_type<_Value>;
pub type std___detail__Local_const_iterator_reference<_Value> =
    *const std___detail__Local_const_iterator_value_type<_Value>;
pub type std___detail__Local_const_iterator_difference_type = isize;
pub type std___detail__Local_const_iterator_iterator_category = std_forward_iterator_tag;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___detail__Hashtable_base {
    pub _address: u8,
}
pub type std___detail__Hashtable_base_key_type<_Key> = _Key;
pub type std___detail__Hashtable_base_value_type<_Value> = _Value;
pub type std___detail__Hashtable_base_key_equal<_Equal> = _Equal;
pub type std___detail__Hashtable_base_size_type = usize;
pub type std___detail__Hashtable_base_difference_type = isize;
pub type std___detail__Hashtable_base___traits_type<_Traits> = _Traits;
pub type std___detail__Hashtable_base___hash_cached = [u8; 0usize];
pub type std___detail__Hashtable_base___hash_code_base = u8;
pub type std___detail__Hashtable_base___hash_code = std___detail__Hashtable_base___hash_code_base;
pub type std___detail__Hashtable_base__EqualEBO = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___detail__Hashtable_alloc {
    pub _address: u8,
}
pub type std___detail__Hashtable_alloc___ebo_node_alloc = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___detail__Hashtable_alloc___get_value_type {
    pub _address: u8,
}
pub type std___detail__Hashtable_alloc___node_type = [u8; 0usize];
pub type std___detail__Hashtable_alloc___node_alloc_type<_NodeAlloc> = _NodeAlloc;
pub type std___detail__Hashtable_alloc___node_alloc_traits = __gnu_cxx___alloc_traits;
pub type std___detail__Hashtable_alloc___value_alloc_traits = [u8; 0usize];
pub type std___detail__Hashtable_alloc___node_ptr = *mut std___detail__Hashtable_alloc___node_type;
pub type std___detail__Hashtable_alloc___node_base = std___detail__Hash_node_base;
pub type std___detail__Hashtable_alloc___node_base_ptr =
    *mut std___detail__Hashtable_alloc___node_base;
pub type std___detail__Hashtable_alloc___buckets_alloc_type = std___alloc_rebind;
pub type std___detail__Hashtable_alloc___buckets_alloc_traits = std_allocator_traits;
pub type std___detail__Hashtable_alloc___buckets_ptr =
    *mut std___detail__Hashtable_alloc___node_base_ptr;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___detail__MakeUniq {
    pub _address: u8,
}
pub type std___detail__MakeUniq___single_object = std_unique_ptr;
pub type std___detail___unique_ptr_t = std___detail__MakeUniq;
pub type std___detail___unique_ptr_array_t = std___detail__MakeUniq;
pub type std___detail___invalid_make_unique_t = std___detail__MakeUniq;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___detail__List_node_base {
    pub _M_next: *mut std___detail__List_node_base,
    pub _M_prev: *mut std___detail__List_node_base,
}
#[test]
fn bindgen_test_layout_std___detail__List_node_base() {
    const UNINIT: ::std::mem::MaybeUninit<std___detail__List_node_base> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<std___detail__List_node_base>(),
        16usize,
        concat!("Size of: ", stringify!(std___detail__List_node_base))
    );
    assert_eq!(
        ::std::mem::align_of::<std___detail__List_node_base>(),
        8usize,
        concat!("Alignment of ", stringify!(std___detail__List_node_base))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._M_next) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(std___detail__List_node_base),
            "::",
            stringify!(_M_next)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._M_prev) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(std___detail__List_node_base),
            "::",
            stringify!(_M_prev)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNSt8__detail15_List_node_base4swapERS0_S1_"]
    pub fn std___detail__List_node_base_swap(
        __x: *mut std___detail__List_node_base,
        __y: *mut std___detail__List_node_base,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNSt8__detail15_List_node_base11_M_transferEPS0_S1_"]
    pub fn std___detail__List_node_base__M_transfer(
        this: *mut std___detail__List_node_base,
        __first: *mut std___detail__List_node_base,
        __last: *mut std___detail__List_node_base,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNSt8__detail15_List_node_base10_M_reverseEv"]
    pub fn std___detail__List_node_base__M_reverse(this: *mut std___detail__List_node_base);
}
extern "C" {
    #[link_name = "\u{1}_ZNSt8__detail15_List_node_base7_M_hookEPS0_"]
    pub fn std___detail__List_node_base__M_hook(
        this: *mut std___detail__List_node_base,
        __position: *mut std___detail__List_node_base,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNSt8__detail15_List_node_base9_M_unhookEv"]
    pub fn std___detail__List_node_base__M_unhook(this: *mut std___detail__List_node_base);
}
impl std___detail__List_node_base {
    #[inline]
    pub unsafe fn swap(
        __x: *mut std___detail__List_node_base,
        __y: *mut std___detail__List_node_base,
    ) {
        std___detail__List_node_base_swap(__x, __y)
    }
    #[inline]
    pub unsafe fn _M_transfer(
        &mut self,
        __first: *mut std___detail__List_node_base,
        __last: *mut std___detail__List_node_base,
    ) {
        std___detail__List_node_base__M_transfer(self, __first, __last)
    }
    #[inline]
    pub unsafe fn _M_reverse(&mut self) {
        std___detail__List_node_base__M_reverse(self)
    }
    #[inline]
    pub unsafe fn _M_hook(&mut self, __position: *mut std___detail__List_node_base) {
        std___detail__List_node_base__M_hook(self, __position)
    }
    #[inline]
    pub unsafe fn _M_unhook(&mut self) {
        std___detail__List_node_base__M_unhook(self)
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___detail__List_node_header {
    pub _base: std___detail__List_node_base,
    pub _M_size: usize,
}
#[test]
fn bindgen_test_layout_std___detail__List_node_header() {
    const UNINIT: ::std::mem::MaybeUninit<std___detail__List_node_header> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<std___detail__List_node_header>(),
        24usize,
        concat!("Size of: ", stringify!(std___detail__List_node_header))
    );
    assert_eq!(
        ::std::mem::align_of::<std___detail__List_node_header>(),
        8usize,
        concat!("Alignment of ", stringify!(std___detail__List_node_header))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._M_size) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(std___detail__List_node_header),
            "::",
            stringify!(_M_size)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___detail__Scratch_list {
    pub _base: std___detail__List_node_base,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___detail__Scratch_list__Ptr_cmp<_Cmp> {
    pub _M_cmp: _Cmp,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Cmp>>,
}
#[test]
fn bindgen_test_layout_std___detail__Scratch_list() {
    assert_eq!(
        ::std::mem::size_of::<std___detail__Scratch_list>(),
        16usize,
        concat!("Size of: ", stringify!(std___detail__Scratch_list))
    );
    assert_eq!(
        ::std::mem::align_of::<std___detail__Scratch_list>(),
        8usize,
        concat!("Alignment of ", stringify!(std___detail__Scratch_list))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___or_ {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___and_ {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___not_ {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_conjunction {
    pub _address: u8,
}
#[test]
fn __bindgen_test_layout_std_conjunction_open0_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_conjunction>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_conjunction)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_conjunction>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_conjunction)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_disjunction {
    pub _address: u8,
}
#[test]
fn __bindgen_test_layout_std_disjunction_open0_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_disjunction>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_disjunction)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_disjunction>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_disjunction)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_negation {
    pub _address: u8,
}
pub type std___remove_cv_t = std_remove_cv;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_void {
    pub _base: std_false_type,
}
#[test]
fn __bindgen_test_layout_std_is_void_open0_void_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_is_void>(),
        1usize,
        concat!("Size of template specialization: ", stringify!(std_is_void))
    );
    assert_eq!(
        ::std::mem::align_of::<std_is_void>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_is_void)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_is_void_open0_const_void_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_is_void>(),
        1usize,
        concat!("Size of template specialization: ", stringify!(std_is_void))
    );
    assert_eq!(
        ::std::mem::align_of::<std_is_void>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_is_void)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_is_void_open0_volatile_void_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_is_void>(),
        1usize,
        concat!("Size of template specialization: ", stringify!(std_is_void))
    );
    assert_eq!(
        ::std::mem::align_of::<std_is_void>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_is_void)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_is_void_open0_const_volatile_void_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_is_void>(),
        1usize,
        concat!("Size of template specialization: ", stringify!(std_is_void))
    );
    assert_eq!(
        ::std::mem::align_of::<std_is_void>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_is_void)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_integral_helper {
    pub _base: std_false_type,
}
#[test]
fn __bindgen_test_layout_std___is_integral_helper_open0_bool__close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std___is_integral_helper>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___is_integral_helper)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___is_integral_helper>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___is_integral_helper)
        )
    );
}
#[test]
fn __bindgen_test_layout_std___is_integral_helper_open0_char_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std___is_integral_helper>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___is_integral_helper)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___is_integral_helper>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___is_integral_helper)
        )
    );
}
#[test]
fn __bindgen_test_layout_std___is_integral_helper_open0_signed_char_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std___is_integral_helper>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___is_integral_helper)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___is_integral_helper>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___is_integral_helper)
        )
    );
}
#[test]
fn __bindgen_test_layout_std___is_integral_helper_open0_unsigned_char_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std___is_integral_helper>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___is_integral_helper)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___is_integral_helper>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___is_integral_helper)
        )
    );
}
#[test]
fn __bindgen_test_layout_std___is_integral_helper_open0_wchar_t_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std___is_integral_helper>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___is_integral_helper)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___is_integral_helper>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___is_integral_helper)
        )
    );
}
#[test]
fn __bindgen_test_layout_std___is_integral_helper_open0_char16_t_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std___is_integral_helper>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___is_integral_helper)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___is_integral_helper>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___is_integral_helper)
        )
    );
}
#[test]
fn __bindgen_test_layout_std___is_integral_helper_open0_char32_t_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std___is_integral_helper>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___is_integral_helper)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___is_integral_helper>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___is_integral_helper)
        )
    );
}
#[test]
fn __bindgen_test_layout_std___is_integral_helper_open0_short_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std___is_integral_helper>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___is_integral_helper)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___is_integral_helper>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___is_integral_helper)
        )
    );
}
#[test]
fn __bindgen_test_layout_std___is_integral_helper_open0_unsigned_short_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std___is_integral_helper>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___is_integral_helper)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___is_integral_helper>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___is_integral_helper)
        )
    );
}
#[test]
fn __bindgen_test_layout_std___is_integral_helper_open0_int_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std___is_integral_helper>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___is_integral_helper)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___is_integral_helper>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___is_integral_helper)
        )
    );
}
#[test]
fn __bindgen_test_layout_std___is_integral_helper_open0_unsigned_int_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std___is_integral_helper>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___is_integral_helper)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___is_integral_helper>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___is_integral_helper)
        )
    );
}
#[test]
fn __bindgen_test_layout_std___is_integral_helper_open0_long_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std___is_integral_helper>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___is_integral_helper)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___is_integral_helper>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___is_integral_helper)
        )
    );
}
#[test]
fn __bindgen_test_layout_std___is_integral_helper_open0_unsigned_long_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std___is_integral_helper>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___is_integral_helper)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___is_integral_helper>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___is_integral_helper)
        )
    );
}
#[test]
fn __bindgen_test_layout_std___is_integral_helper_open0_long_long_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std___is_integral_helper>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___is_integral_helper)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___is_integral_helper>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___is_integral_helper)
        )
    );
}
#[test]
fn __bindgen_test_layout_std___is_integral_helper_open0_unsigned_long_long_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std___is_integral_helper>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___is_integral_helper)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___is_integral_helper>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___is_integral_helper)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_integral {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_floating_point_helper {
    pub _base: std_false_type,
}
#[test]
fn __bindgen_test_layout_std___is_floating_point_helper_open0_float_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std___is_floating_point_helper>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___is_floating_point_helper)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___is_floating_point_helper>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___is_floating_point_helper)
        )
    );
}
#[test]
fn __bindgen_test_layout_std___is_floating_point_helper_open0_double_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std___is_floating_point_helper>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___is_floating_point_helper)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___is_floating_point_helper>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___is_floating_point_helper)
        )
    );
}
#[test]
fn __bindgen_test_layout_std___is_floating_point_helper_open0_long_double_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std___is_floating_point_helper>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___is_floating_point_helper)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___is_floating_point_helper>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___is_floating_point_helper)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_floating_point {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_array {
    pub _base: std_false_type,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_pointer_helper {
    pub _base: std_false_type,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_pointer {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_lvalue_reference {
    pub _base: std_false_type,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_rvalue_reference {
    pub _base: std_false_type,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_member_object_pointer_helper {
    pub _base: std_false_type,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_member_object_pointer {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_member_function_pointer_helper {
    pub _base: std_false_type,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_member_function_pointer {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_enum {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_union {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_class {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_function {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_null_pointer {
    pub _base: std_false_type,
}
#[test]
fn __bindgen_test_layout_std_is_null_pointer_open0_nullptr_t_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_is_null_pointer>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_is_null_pointer)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_is_null_pointer>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_is_null_pointer)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_is_null_pointer_open0_const_std__nullptr_t_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_is_null_pointer>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_is_null_pointer)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_is_null_pointer>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_is_null_pointer)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_is_null_pointer_open0_volatile_std__nullptr_t_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_is_null_pointer>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_is_null_pointer)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_is_null_pointer>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_is_null_pointer)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_is_null_pointer_open0_const_volatile_std__nullptr_t_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<std_is_null_pointer>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_is_null_pointer)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_is_null_pointer>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_is_null_pointer)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_nullptr_t {
    pub _base: std_is_null_pointer,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_reference {
    pub _base: std_false_type,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_arithmetic {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_fundamental {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_object {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_scalar {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_compound {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_member_pointer_helper {
    pub _base: std_false_type,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_member_pointer {
    pub _address: u8,
}
pub type std___is_one_of = std___or_;
pub type std___is_signed_integer = std___is_one_of;
pub type std___is_unsigned_integer = std___is_one_of;
pub type std___is_standard_integer = std___or_;
pub type std___void_t = ::std::os::raw::c_void;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_const {
    pub _base: std_false_type,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_volatile {
    pub _base: std_false_type,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_trivial {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_trivially_copyable {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_standard_layout {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_pod {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_literal_type {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_empty {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_polymorphic {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_final {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_abstract {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_signed {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_unsigned {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_array_known_bounds {
    pub _base: std_false_type,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_array_unknown_bounds {
    pub _base: std_false_type,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___do_is_destructible_impl {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_std___do_is_destructible_impl() {
    assert_eq!(
        ::std::mem::size_of::<std___do_is_destructible_impl>(),
        1usize,
        concat!("Size of: ", stringify!(std___do_is_destructible_impl))
    );
    assert_eq!(
        ::std::mem::align_of::<std___do_is_destructible_impl>(),
        1usize,
        concat!("Alignment of ", stringify!(std___do_is_destructible_impl))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_destructible_impl {
    pub _address: u8,
}
pub type std___is_destructible_impl_type<_Tp> = _Tp;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_destructible {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___do_is_nt_destructible_impl {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_std___do_is_nt_destructible_impl() {
    assert_eq!(
        ::std::mem::size_of::<std___do_is_nt_destructible_impl>(),
        1usize,
        concat!("Size of: ", stringify!(std___do_is_nt_destructible_impl))
    );
    assert_eq!(
        ::std::mem::align_of::<std___do_is_nt_destructible_impl>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(std___do_is_nt_destructible_impl)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_nt_destructible_impl {
    pub _address: u8,
}
pub type std___is_nt_destructible_impl_type<_Tp> = _Tp;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_nothrow_destructible {
    pub _address: u8,
}
pub type std___is_constructible_impl = std___bool_constant;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_constructible {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_default_constructible {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___add_lvalue_reference_helper {
    pub _address: u8,
}
pub type std___add_lvalue_reference_helper_type<_Tp> = _Tp;
pub type std___add_lval_ref_t = std___add_lvalue_reference_helper;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_copy_constructible {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___add_rvalue_reference_helper {
    pub _address: u8,
}
pub type std___add_rvalue_reference_helper_type<_Tp> = _Tp;
pub type std___add_rval_ref_t = std___add_rvalue_reference_helper;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_move_constructible {
    pub _address: u8,
}
pub type std___is_nothrow_constructible_impl = std___bool_constant;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_nothrow_constructible {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_nothrow_default_constructible {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_nothrow_copy_constructible {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_nothrow_move_constructible {
    pub _address: u8,
}
pub type std___is_assignable_impl = std___bool_constant;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_assignable {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_copy_assignable {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_move_assignable {
    pub _address: u8,
}
pub type std___is_nothrow_assignable_impl = std___bool_constant;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_nothrow_assignable {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_nothrow_copy_assignable {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_nothrow_move_assignable {
    pub _address: u8,
}
pub type std___is_trivially_constructible_impl = std___bool_constant;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_trivially_constructible {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_trivially_default_constructible {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___do_is_implicitly_default_constructible_impl {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_std___do_is_implicitly_default_constructible_impl() {
    assert_eq!(
        ::std::mem::size_of::<std___do_is_implicitly_default_constructible_impl>(),
        1usize,
        concat!(
            "Size of: ",
            stringify!(std___do_is_implicitly_default_constructible_impl)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___do_is_implicitly_default_constructible_impl>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(std___do_is_implicitly_default_constructible_impl)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNSt45__do_is_implicitly_default_constructible_impl6__testEz"]
    pub fn std___do_is_implicitly_default_constructible_impl___test() -> std_false_type;
}
impl std___do_is_implicitly_default_constructible_impl {
    #[inline]
    pub unsafe fn __test() -> std_false_type {
        std___do_is_implicitly_default_constructible_impl___test()
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_implicitly_default_constructible_impl {
    pub _address: u8,
}
pub type std___is_implicitly_default_constructible_impl_type<_Tp> = _Tp;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_implicitly_default_constructible_safe {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_implicitly_default_constructible {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_trivially_copy_constructible {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_trivially_move_constructible {
    pub _address: u8,
}
pub type std___is_trivially_assignable_impl = std___bool_constant;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_trivially_assignable {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_trivially_copy_assignable {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_trivially_move_assignable {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_trivially_destructible {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_has_virtual_destructor {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_alignment_of {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_rank {
    pub _base: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_same {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_base_of {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_convertible {
    pub _address: u8,
}
pub type std___is_array_convertible = std_is_convertible;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_remove_const {
    pub _address: u8,
}
pub type std_remove_const_type<_Tp> = _Tp;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_remove_volatile {
    pub _address: u8,
}
pub type std_remove_volatile_type<_Tp> = _Tp;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_remove_cv {
    pub _address: u8,
}
pub type std_remove_cv_type<_Tp> = _Tp;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_add_const {
    pub _address: u8,
}
pub type std_add_const_type<_Tp> = _Tp;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_add_volatile {
    pub _address: u8,
}
pub type std_add_volatile_type<_Tp> = _Tp;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_add_cv {
    pub _address: u8,
}
pub type std_add_cv_type<_Tp> = _Tp;
pub type std_remove_const_t = std_remove_const;
pub type std_remove_volatile_t = std_remove_volatile;
pub type std_remove_cv_t = std_remove_cv;
pub type std_add_const_t = std_add_const;
pub type std_add_volatile_t = std_add_volatile;
pub type std_add_cv_t = std_add_cv;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_remove_reference {
    pub _address: u8,
}
pub type std_remove_reference_type<_Tp> = _Tp;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_add_lvalue_reference {
    pub _address: u8,
}
pub type std_add_lvalue_reference_type = std___add_lval_ref_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_add_rvalue_reference {
    pub _address: u8,
}
pub type std_add_rvalue_reference_type = std___add_rval_ref_t;
pub type std_remove_reference_t = std_remove_reference;
pub type std_add_lvalue_reference_t = std_add_lvalue_reference;
pub type std_add_rvalue_reference_t = std_add_rvalue_reference;
pub type std___match_cv_qualifiers___match = u8;
pub type std___match_cv_qualifiers___type = std___match_cv_qualifiers___match;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___make_unsigned {
    pub _address: u8,
}
pub type std___make_unsigned___type<_Tp> = _Tp;
#[test]
fn __bindgen_test_layout_std___make_unsigned_open0_char_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std___make_unsigned>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___make_unsigned)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___make_unsigned>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___make_unsigned)
        )
    );
}
#[test]
fn __bindgen_test_layout_std___make_unsigned_open0_signed_char_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std___make_unsigned>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___make_unsigned)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___make_unsigned>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___make_unsigned)
        )
    );
}
#[test]
fn __bindgen_test_layout_std___make_unsigned_open0_short_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std___make_unsigned>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___make_unsigned)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___make_unsigned>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___make_unsigned)
        )
    );
}
#[test]
fn __bindgen_test_layout_std___make_unsigned_open0_int_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std___make_unsigned>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___make_unsigned)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___make_unsigned>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___make_unsigned)
        )
    );
}
#[test]
fn __bindgen_test_layout_std___make_unsigned_open0_long_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std___make_unsigned>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___make_unsigned)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___make_unsigned>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___make_unsigned)
        )
    );
}
#[test]
fn __bindgen_test_layout_std___make_unsigned_open0_long_long_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std___make_unsigned>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___make_unsigned)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___make_unsigned>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___make_unsigned)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___make_unsigned_selector_base {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___make_unsigned_selector_base__List {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_std___make_unsigned_selector_base() {
    assert_eq!(
        ::std::mem::size_of::<std___make_unsigned_selector_base>(),
        1usize,
        concat!("Size of: ", stringify!(std___make_unsigned_selector_base))
    );
    assert_eq!(
        ::std::mem::align_of::<std___make_unsigned_selector_base>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(std___make_unsigned_selector_base)
        )
    );
}
#[test]
fn __bindgen_test_layout_std___make_unsigned_open0_wchar_t_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std___make_unsigned>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___make_unsigned)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___make_unsigned>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___make_unsigned)
        )
    );
}
#[test]
fn __bindgen_test_layout_std___make_unsigned_open0_char16_t_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std___make_unsigned>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___make_unsigned)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___make_unsigned>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___make_unsigned)
        )
    );
}
#[test]
fn __bindgen_test_layout_std___make_unsigned_open0_char32_t_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std___make_unsigned>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___make_unsigned)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___make_unsigned>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___make_unsigned)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_make_unsigned {
    pub _address: u8,
}
pub type std_make_unsigned_type = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___make_signed {
    pub _address: u8,
}
pub type std___make_signed___type<_Tp> = _Tp;
#[test]
fn __bindgen_test_layout_std___make_signed_open0_char_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std___make_signed>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___make_signed)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___make_signed>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___make_signed)
        )
    );
}
#[test]
fn __bindgen_test_layout_std___make_signed_open0_unsigned_char_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std___make_signed>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___make_signed)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___make_signed>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___make_signed)
        )
    );
}
#[test]
fn __bindgen_test_layout_std___make_signed_open0_unsigned_short_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std___make_signed>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___make_signed)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___make_signed>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___make_signed)
        )
    );
}
#[test]
fn __bindgen_test_layout_std___make_signed_open0_unsigned_int_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std___make_signed>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___make_signed)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___make_signed>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___make_signed)
        )
    );
}
#[test]
fn __bindgen_test_layout_std___make_signed_open0_unsigned_long_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std___make_signed>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___make_signed)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___make_signed>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___make_signed)
        )
    );
}
#[test]
fn __bindgen_test_layout_std___make_signed_open0_unsigned_long_long_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std___make_signed>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___make_signed)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___make_signed>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___make_signed)
        )
    );
}
#[test]
fn __bindgen_test_layout_std___make_signed_open0_wchar_t_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std___make_signed>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___make_signed)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___make_signed>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___make_signed)
        )
    );
}
#[test]
fn __bindgen_test_layout_std___make_signed_open0_char16_t_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std___make_signed>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___make_signed)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___make_signed>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___make_signed)
        )
    );
}
#[test]
fn __bindgen_test_layout_std___make_signed_open0_char32_t_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std___make_signed>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___make_signed)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___make_signed>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___make_signed)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_make_signed {
    pub _address: u8,
}
pub type std_make_signed_type = u8;
pub type std_make_signed_t = std_make_signed;
pub type std_make_unsigned_t = std_make_unsigned;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_remove_extent {
    pub _address: u8,
}
pub type std_remove_extent_type<_Tp> = _Tp;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_remove_all_extents {
    pub _address: u8,
}
pub type std_remove_all_extents_type<_Tp> = _Tp;
pub type std_remove_extent_t = std_remove_extent;
pub type std_remove_all_extents_t = std_remove_all_extents;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___remove_pointer_helper {
    pub _address: u8,
}
pub type std___remove_pointer_helper_type<_Tp> = _Tp;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_remove_pointer {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___add_pointer_helper {
    pub _address: u8,
}
pub type std___add_pointer_helper_type<_Tp> = _Tp;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_add_pointer {
    pub _address: u8,
}
pub type std_remove_pointer_t = std_remove_pointer;
pub type std_add_pointer_t = std_add_pointer;
#[repr(C)]
#[derive(Copy, Clone)]
pub union std___aligned_storage_msa___type {
    pub __data: *mut ::std::os::raw::c_uchar,
    pub __align: std___aligned_storage_msa___type__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___aligned_storage_msa___type__bindgen_ty_1 {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_std___aligned_storage_msa___type() {
    assert_eq!(
        ::std::mem::size_of::<std___aligned_storage_msa___type>(),
        8usize,
        concat!("Size of: ", stringify!(std___aligned_storage_msa___type))
    );
    assert_eq!(
        ::std::mem::align_of::<std___aligned_storage_msa___type>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(std___aligned_storage_msa___type)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union std_aligned_storage_type {
    pub __data: *mut ::std::os::raw::c_uchar,
    pub __align: std_aligned_storage_type__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_aligned_storage_type__bindgen_ty_1 {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_std_aligned_storage_type() {
    assert_eq!(
        ::std::mem::size_of::<std_aligned_storage_type>(),
        8usize,
        concat!("Size of: ", stringify!(std_aligned_storage_type))
    );
    assert_eq!(
        ::std::mem::align_of::<std_aligned_storage_type>(),
        8usize,
        concat!("Alignment of ", stringify!(std_aligned_storage_type))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___strictest_alignment {
    pub _address: u8,
}
pub type std_aligned_union___strictest = std___strictest_alignment;
pub type std_aligned_union_type = u8;
extern "C" {
    #[link_name = "\u{1}alignment_value"]
    pub static std_alignment_value: usize;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___decay_selector {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_decay {
    pub _address: u8,
}
pub type std_decay_type = std___decay_selector;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___strip_reference_wrapper {
    pub _address: u8,
}
pub type std___strip_reference_wrapper___type<_Tp> = _Tp;
pub type std___decay_t = std_decay;
pub type std___decay_and_strip = std___strip_reference_wrapper;
pub type std__Require = std___enable_if_t;
pub type std___remove_cvref_t = std_remove_cv;
pub type std_conditional_type<_Iftrue> = _Iftrue;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_common_type {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___success_type {
    pub _address: u8,
}
pub type std___success_type_type<_Tp> = _Tp;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___failure_type {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_std___failure_type() {
    assert_eq!(
        ::std::mem::size_of::<std___failure_type>(),
        1usize,
        concat!("Size of: ", stringify!(std___failure_type))
    );
    assert_eq!(
        ::std::mem::align_of::<std___failure_type>(),
        1usize,
        concat!("Alignment of ", stringify!(std___failure_type))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___do_common_type_impl {
    pub _address: u8,
}
pub type std___do_common_type_impl___cond_t<_Tp> = _Tp;
#[test]
fn bindgen_test_layout_std___do_common_type_impl() {
    assert_eq!(
        ::std::mem::size_of::<std___do_common_type_impl>(),
        1usize,
        concat!("Size of: ", stringify!(std___do_common_type_impl))
    );
    assert_eq!(
        ::std::mem::align_of::<std___do_common_type_impl>(),
        1usize,
        concat!("Alignment of ", stringify!(std___do_common_type_impl))
    );
}
#[test]
fn __bindgen_test_layout_std_common_type_open0_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_common_type>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_common_type)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_common_type>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_common_type)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___common_type_impl {
    pub _address: u8,
}
pub type std___common_type_impl_type = std_common_type;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___common_type_pack {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___common_type_fold {
    pub _address: u8,
}
pub type std___underlying_type_impl_type<_Tp> = _Tp;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_underlying_type {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___declval_protector {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_result_of {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___invoke_memfun_ref {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_std___invoke_memfun_ref() {
    assert_eq!(
        ::std::mem::size_of::<std___invoke_memfun_ref>(),
        1usize,
        concat!("Size of: ", stringify!(std___invoke_memfun_ref))
    );
    assert_eq!(
        ::std::mem::align_of::<std___invoke_memfun_ref>(),
        1usize,
        concat!("Alignment of ", stringify!(std___invoke_memfun_ref))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___invoke_memfun_deref {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_std___invoke_memfun_deref() {
    assert_eq!(
        ::std::mem::size_of::<std___invoke_memfun_deref>(),
        1usize,
        concat!("Size of: ", stringify!(std___invoke_memfun_deref))
    );
    assert_eq!(
        ::std::mem::align_of::<std___invoke_memfun_deref>(),
        1usize,
        concat!("Alignment of ", stringify!(std___invoke_memfun_deref))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___invoke_memobj_ref {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_std___invoke_memobj_ref() {
    assert_eq!(
        ::std::mem::size_of::<std___invoke_memobj_ref>(),
        1usize,
        concat!("Size of: ", stringify!(std___invoke_memobj_ref))
    );
    assert_eq!(
        ::std::mem::align_of::<std___invoke_memobj_ref>(),
        1usize,
        concat!("Alignment of ", stringify!(std___invoke_memobj_ref))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___invoke_memobj_deref {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_std___invoke_memobj_deref() {
    assert_eq!(
        ::std::mem::size_of::<std___invoke_memobj_deref>(),
        1usize,
        concat!("Size of: ", stringify!(std___invoke_memobj_deref))
    );
    assert_eq!(
        ::std::mem::align_of::<std___invoke_memobj_deref>(),
        1usize,
        concat!("Alignment of ", stringify!(std___invoke_memobj_deref))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___invoke_other {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_std___invoke_other() {
    assert_eq!(
        ::std::mem::size_of::<std___invoke_other>(),
        1usize,
        concat!("Size of: ", stringify!(std___invoke_other))
    );
    assert_eq!(
        ::std::mem::align_of::<std___invoke_other>(),
        1usize,
        concat!("Alignment of ", stringify!(std___invoke_other))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___result_of_success {
    pub _address: u8,
}
pub type std___result_of_success___invoke_type<_Tag> = _Tag;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___result_of_memfun_ref_impl {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_std___result_of_memfun_ref_impl() {
    assert_eq!(
        ::std::mem::size_of::<std___result_of_memfun_ref_impl>(),
        1usize,
        concat!("Size of: ", stringify!(std___result_of_memfun_ref_impl))
    );
    assert_eq!(
        ::std::mem::align_of::<std___result_of_memfun_ref_impl>(),
        1usize,
        concat!("Alignment of ", stringify!(std___result_of_memfun_ref_impl))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___result_of_memfun_ref {
    pub _address: u8,
}
pub type std___result_of_memfun_ref_type<_MemPtr> = _MemPtr;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___result_of_memfun_deref_impl {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_std___result_of_memfun_deref_impl() {
    assert_eq!(
        ::std::mem::size_of::<std___result_of_memfun_deref_impl>(),
        1usize,
        concat!("Size of: ", stringify!(std___result_of_memfun_deref_impl))
    );
    assert_eq!(
        ::std::mem::align_of::<std___result_of_memfun_deref_impl>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(std___result_of_memfun_deref_impl)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___result_of_memfun_deref {
    pub _address: u8,
}
pub type std___result_of_memfun_deref_type<_MemPtr> = _MemPtr;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___result_of_memobj_ref_impl {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_std___result_of_memobj_ref_impl() {
    assert_eq!(
        ::std::mem::size_of::<std___result_of_memobj_ref_impl>(),
        1usize,
        concat!("Size of: ", stringify!(std___result_of_memobj_ref_impl))
    );
    assert_eq!(
        ::std::mem::align_of::<std___result_of_memobj_ref_impl>(),
        1usize,
        concat!("Alignment of ", stringify!(std___result_of_memobj_ref_impl))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___result_of_memobj_ref {
    pub _address: u8,
}
pub type std___result_of_memobj_ref_type<_MemPtr> = _MemPtr;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___result_of_memobj_deref_impl {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_std___result_of_memobj_deref_impl() {
    assert_eq!(
        ::std::mem::size_of::<std___result_of_memobj_deref_impl>(),
        1usize,
        concat!("Size of: ", stringify!(std___result_of_memobj_deref_impl))
    );
    assert_eq!(
        ::std::mem::align_of::<std___result_of_memobj_deref_impl>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(std___result_of_memobj_deref_impl)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___result_of_memobj_deref {
    pub _address: u8,
}
pub type std___result_of_memobj_deref_type<_MemPtr> = _MemPtr;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___result_of_memobj {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___result_of_memfun {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___inv_unwrap {
    pub _address: u8,
}
pub type std___inv_unwrap_type<_Tp> = _Tp;
pub type std___result_of_impl_type = std___failure_type;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___result_of_other_impl {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_std___result_of_other_impl() {
    assert_eq!(
        ::std::mem::size_of::<std___result_of_other_impl>(),
        1usize,
        concat!("Size of: ", stringify!(std___result_of_other_impl))
    );
    assert_eq!(
        ::std::mem::align_of::<std___result_of_other_impl>(),
        1usize,
        concat!("Alignment of ", stringify!(std___result_of_other_impl))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___invoke_result {
    pub _address: u8,
}
pub type std_aligned_storage_t = u8;
pub type std_aligned_union_t = u8;
pub type std_decay_t = std_decay;
pub type std_enable_if_t = u8;
pub type std_conditional_t = u8;
pub type std_common_type_t = std_common_type;
pub type std_underlying_type_t = std_underlying_type;
pub type std_result_of_t = std_result_of;
pub type std_void_t = ::std::os::raw::c_void;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___detector {
    pub _address: u8,
}
pub type std___detector_type<_Default> = _Default;
pub type std___detector___is_detected = std_false_type;
pub type std___detected_or = std___detector;
pub type std___detected_or_t = std___detected_or;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_tuple_like_impl {
    pub _base: std_false_type,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_tuple_like {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___swappable_details___do_is_swappable_impl {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_std___swappable_details___do_is_swappable_impl() {
    assert_eq!(
        ::std::mem::size_of::<std___swappable_details___do_is_swappable_impl>(),
        1usize,
        concat!(
            "Size of: ",
            stringify!(std___swappable_details___do_is_swappable_impl)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___swappable_details___do_is_swappable_impl>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(std___swappable_details___do_is_swappable_impl)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___swappable_details___do_is_nothrow_swappable_impl {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_std___swappable_details___do_is_nothrow_swappable_impl() {
    assert_eq!(
        ::std::mem::size_of::<std___swappable_details___do_is_nothrow_swappable_impl>(),
        1usize,
        concat!(
            "Size of: ",
            stringify!(std___swappable_details___do_is_nothrow_swappable_impl)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___swappable_details___do_is_nothrow_swappable_impl>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(std___swappable_details___do_is_nothrow_swappable_impl)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_swappable_impl {
    pub _address: u8,
}
pub type std___is_swappable_impl_type<_Tp> = _Tp;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_nothrow_swappable_impl {
    pub _address: u8,
}
pub type std___is_nothrow_swappable_impl_type<_Tp> = _Tp;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_swappable {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_nothrow_swappable {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_swappable {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_nothrow_swappable {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___swappable_with_details___do_is_swappable_with_impl {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_std___swappable_with_details___do_is_swappable_with_impl() {
    assert_eq!(
        ::std::mem::size_of::<std___swappable_with_details___do_is_swappable_with_impl>(),
        1usize,
        concat!(
            "Size of: ",
            stringify!(std___swappable_with_details___do_is_swappable_with_impl)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___swappable_with_details___do_is_swappable_with_impl>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(std___swappable_with_details___do_is_swappable_with_impl)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___swappable_with_details___do_is_nothrow_swappable_with_impl {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_std___swappable_with_details___do_is_nothrow_swappable_with_impl() {
    assert_eq!(
        ::std::mem::size_of::<std___swappable_with_details___do_is_nothrow_swappable_with_impl>(),
        1usize,
        concat!(
            "Size of: ",
            stringify!(std___swappable_with_details___do_is_nothrow_swappable_with_impl)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___swappable_with_details___do_is_nothrow_swappable_with_impl>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(std___swappable_with_details___do_is_nothrow_swappable_with_impl)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_swappable_with_impl {
    pub _address: u8,
}
pub type std___is_swappable_with_impl_type<_Tp> = _Tp;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_nothrow_swappable_with_impl {
    pub _address: u8,
}
pub type std___is_nothrow_swappable_with_impl_type<_Tp> = _Tp;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_swappable_with {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_nothrow_swappable_with {
    pub _address: u8,
}
pub type std___is_invocable_impl___nothrow_conv = std_false_type;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_invocable {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___call_is_nothrow {
    pub _address: u8,
}
pub type std___call_is_nothrow_ = std___call_is_nothrow;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_nothrow_invocable {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___nonesuchbase {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_std___nonesuchbase() {
    assert_eq!(
        ::std::mem::size_of::<std___nonesuchbase>(),
        1usize,
        concat!("Size of: ", stringify!(std___nonesuchbase))
    );
    assert_eq!(
        ::std::mem::align_of::<std___nonesuchbase>(),
        1usize,
        concat!("Alignment of ", stringify!(std___nonesuchbase))
    );
}
#[repr(C)]
#[derive(Debug)]
pub struct std___nonesuch {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_std___nonesuch() {
    assert_eq!(
        ::std::mem::size_of::<std___nonesuch>(),
        1usize,
        concat!("Size of: ", stringify!(std___nonesuch))
    );
    assert_eq!(
        ::std::mem::align_of::<std___nonesuch>(),
        1usize,
        concat!("Alignment of ", stringify!(std___nonesuch))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_invoke_result {
    pub _address: u8,
}
pub type std_invoke_result_t = std_invoke_result;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_invocable {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_invocable_r {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_nothrow_invocable {
    pub _address: u8,
}
pub type std___is_nt_invocable_impl = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_nothrow_invocable_r {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_has_unique_object_representations {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_aggregate {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___move_if_noexcept_cond {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_tuple_size {
    pub _address: u8,
}
pub type std___enable_if_has_tuple_size<_Tp> = _Tp;
pub type std___tuple_element_t = u8;
pub type std_tuple_element_t = u8;
pub type std__Build_index_tuple__IdxTuple = u8;
pub type std__Build_index_tuple___type = u8;
pub type std_integer_sequence_value_type<_Tp> = _Tp;
pub type std_make_integer_sequence = u8;
pub type std_index_sequence = u8;
pub type std_make_index_sequence = std_make_integer_sequence;
pub type std_index_sequence_for = std_make_index_sequence;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_in_place_t {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_std_in_place_t() {
    assert_eq!(
        ::std::mem::size_of::<std_in_place_t>(),
        1usize,
        concat!("Size of: ", stringify!(std_in_place_t))
    );
    assert_eq!(
        ::std::mem::align_of::<std_in_place_t>(),
        1usize,
        concat!("Alignment of ", stringify!(std_in_place_t))
    );
}
extern "C" {
    #[link_name = "\u{1}_ZSt8in_place"]
    pub static std_in_place: std_in_place_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_in_place_type_t {
    pub _address: u8,
}
pub type std___is_in_place_type = std_bool_constant;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_piecewise_construct_t {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_std_piecewise_construct_t() {
    assert_eq!(
        ::std::mem::size_of::<std_piecewise_construct_t>(),
        1usize,
        concat!("Size of: ", stringify!(std_piecewise_construct_t))
    );
    assert_eq!(
        ::std::mem::align_of::<std_piecewise_construct_t>(),
        1usize,
        concat!("Alignment of ", stringify!(std_piecewise_construct_t))
    );
}
extern "C" {
    #[link_name = "\u{1}_ZSt19piecewise_construct"]
    pub static std_piecewise_construct: std_piecewise_construct_t;
}
#[repr(C)]
#[derive(Debug)]
pub struct std___pair_base {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug)]
pub struct std_pair<_T1, _T2> {
    pub first: _T1,
    pub second: _T2,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_T1>>,
    pub _phantom_1: ::std::marker::PhantomData<::std::cell::UnsafeCell<_T2>>,
}
pub type std_pair_first_type<_T1> = _T1;
pub type std_pair_second_type<_T2> = _T2;
pub type std_pair__PCCP = u8;
pub type std_pair__PCCFP = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_pair___zero_as_null_pointer_constant {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_input_iterator_tag {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_std_input_iterator_tag() {
    assert_eq!(
        ::std::mem::size_of::<std_input_iterator_tag>(),
        1usize,
        concat!("Size of: ", stringify!(std_input_iterator_tag))
    );
    assert_eq!(
        ::std::mem::align_of::<std_input_iterator_tag>(),
        1usize,
        concat!("Alignment of ", stringify!(std_input_iterator_tag))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_output_iterator_tag {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_std_output_iterator_tag() {
    assert_eq!(
        ::std::mem::size_of::<std_output_iterator_tag>(),
        1usize,
        concat!("Size of: ", stringify!(std_output_iterator_tag))
    );
    assert_eq!(
        ::std::mem::align_of::<std_output_iterator_tag>(),
        1usize,
        concat!("Alignment of ", stringify!(std_output_iterator_tag))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_forward_iterator_tag {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_std_forward_iterator_tag() {
    assert_eq!(
        ::std::mem::size_of::<std_forward_iterator_tag>(),
        1usize,
        concat!("Size of: ", stringify!(std_forward_iterator_tag))
    );
    assert_eq!(
        ::std::mem::align_of::<std_forward_iterator_tag>(),
        1usize,
        concat!("Alignment of ", stringify!(std_forward_iterator_tag))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_bidirectional_iterator_tag {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_std_bidirectional_iterator_tag() {
    assert_eq!(
        ::std::mem::size_of::<std_bidirectional_iterator_tag>(),
        1usize,
        concat!("Size of: ", stringify!(std_bidirectional_iterator_tag))
    );
    assert_eq!(
        ::std::mem::align_of::<std_bidirectional_iterator_tag>(),
        1usize,
        concat!("Alignment of ", stringify!(std_bidirectional_iterator_tag))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_random_access_iterator_tag {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_std_random_access_iterator_tag() {
    assert_eq!(
        ::std::mem::size_of::<std_random_access_iterator_tag>(),
        1usize,
        concat!("Size of: ", stringify!(std_random_access_iterator_tag))
    );
    assert_eq!(
        ::std::mem::align_of::<std_random_access_iterator_tag>(),
        1usize,
        concat!("Alignment of ", stringify!(std_random_access_iterator_tag))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_iterator {
    pub _address: u8,
}
pub type std_iterator_iterator_category<_Category> = _Category;
pub type std_iterator_value_type<_Tp> = _Tp;
pub type std_iterator_difference_type<_Distance> = _Distance;
pub type std_iterator_pointer<_Pointer> = _Pointer;
pub type std_iterator_reference<_Reference> = _Reference;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___iterator_traits {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_iterator_traits {
    pub _address: u8,
}
pub type std___iter_category_t = std_iterator_traits;
pub type std__RequireInputIter = std___enable_if_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_random_access_iter {
    pub _address: u8,
}
pub type std___is_random_access_iter__Base = std_is_base_of;
pub const std___is_random_access_iter___value: std___is_random_access_iter__bindgen_ty_1 = 0;
pub type std___is_random_access_iter__bindgen_ty_1 = i32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___undefined {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___get_first_arg {
    pub _address: u8,
}
pub type std___get_first_arg_type = std___undefined;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___replace_first_arg {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___ptr_traits_elem {
    pub _address: u8,
}
pub type std___ptr_traits_elem_t = std___ptr_traits_elem;
pub type std___ptr_traits_ptr_to_pointer<_Ptr> = _Ptr;
pub type std___ptr_traits_ptr_to_element_type<_Elt> = _Elt;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___ptr_traits_impl {
    pub _address: u8,
}
pub type std___ptr_traits_impl___diff_t = [u8; 0usize];
pub type std___ptr_traits_impl___rebind = std___type_identity;
pub type std___ptr_traits_impl_pointer<_Ptr> = _Ptr;
pub type std___ptr_traits_impl_element_type<_Elt> = _Elt;
pub type std___ptr_traits_impl_difference_type = std___detected_or_t;
pub type std___ptr_traits_impl_rebind = std___detected_or_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_pointer_traits {
    pub _address: u8,
}
pub type std___ptr_rebind = std_pointer_traits;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_reverse_iterator<_Iterator> {
    pub current: _Iterator,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Iterator>>,
}
pub type std_reverse_iterator___traits_type = std_iterator_traits;
pub type std_reverse_iterator_iterator_type<_Iterator> = _Iterator;
pub type std_reverse_iterator_pointer = std_reverse_iterator___traits_type;
pub type std_reverse_iterator_difference_type = std_reverse_iterator___traits_type;
pub type std_reverse_iterator_reference = std_reverse_iterator___traits_type;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_back_insert_iterator<_Container> {
    pub container: *mut _Container,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Container>>,
}
pub type std_back_insert_iterator_container_type<_Container> = _Container;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_front_insert_iterator<_Container> {
    pub container: *mut _Container,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Container>>,
}
pub type std_front_insert_iterator_container_type<_Container> = _Container;
#[repr(C)]
pub struct std_insert_iterator<_Container> {
    pub container: *mut _Container,
    pub iter: std_insert_iterator__Iter,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Container>>,
}
pub type std_insert_iterator__Iter = [u8; 0usize];
pub type std_insert_iterator_container_type<_Container> = _Container;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_move_iterator<_Iterator> {
    pub _M_current: _Iterator,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Iterator>>,
}
pub type std_move_iterator___traits_type = std_iterator_traits;
pub type std_move_iterator___base_ref = std_move_iterator___traits_type;
pub type std_move_iterator_iterator_type<_Iterator> = _Iterator;
pub type std_move_iterator_iterator_category = std_move_iterator___traits_type;
pub type std_move_iterator_value_type = std_move_iterator___traits_type;
pub type std_move_iterator_difference_type = std_move_iterator___traits_type;
pub type std_move_iterator_pointer<_Iterator> = _Iterator;
pub type std_move_iterator_reference = std___conditional_t;
pub type std___iter_key_t = std_remove_const_t;
pub type std___iter_val_t = std_iterator_traits;
pub type std___iter_to_alloc_t = std_pair<std___iter_key_t, std___iter_val_t>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std__Deque_iterator {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___lc_rai {
    pub _address: u8,
}
#[test]
fn __bindgen_test_layout_std___lc_rai_open0_std_random_access_iterator_tag_std_random_access_iterator_tag_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<std___lc_rai>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___lc_rai)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___lc_rai>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___lc_rai)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_initializer_list<_E> {
    pub _M_array: std_initializer_list_iterator<_E>,
    pub _M_len: std_initializer_list_size_type,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_E>>,
}
pub type std_initializer_list_value_type<_E> = _E;
pub type std_initializer_list_reference<_E> = *const _E;
pub type std_initializer_list_const_reference<_E> = *const _E;
pub type std_initializer_list_size_type = usize;
pub type std_initializer_list_iterator<_E> = *const _E;
pub type std_initializer_list_const_iterator<_E> = *const _E;
#[repr(C)]
pub struct std__V2_error_category__bindgen_vtable(::std::os::raw::c_void);
#[repr(C)]
#[derive(Debug)]
pub struct std__V2_error_category {
    pub vtable_: *const std__V2_error_category__bindgen_vtable,
}
#[test]
fn bindgen_test_layout_std__V2_error_category() {
    assert_eq!(
        ::std::mem::size_of::<std__V2_error_category>(),
        8usize,
        concat!("Size of: ", stringify!(std__V2_error_category))
    );
    assert_eq!(
        ::std::mem::align_of::<std__V2_error_category>(),
        8usize,
        concat!("Alignment of ", stringify!(std__V2_error_category))
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNSt3_V214error_categoryD1Ev"]
    pub fn std__V2_error_category_error_category_destructor(this: *mut std__V2_error_category);
}
extern "C" {
    #[link_name = "\u{1}_ZNKSt3_V214error_category23default_error_conditionEi"]
    pub fn std__V2_error_category_default_error_condition(
        this: *mut ::std::os::raw::c_void,
        __i: ::std::os::raw::c_int,
    ) -> std_error_condition;
}
extern "C" {
    #[link_name = "\u{1}_ZNKSt3_V214error_category10equivalentEiRKSt15error_condition"]
    pub fn std__V2_error_category_equivalent(
        this: *mut ::std::os::raw::c_void,
        __i: ::std::os::raw::c_int,
        __cond: *const std_error_condition,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZNKSt3_V214error_category10equivalentERKSt10error_codei"]
    pub fn std__V2_error_category_equivalent1(
        this: *mut ::std::os::raw::c_void,
        __code: *const std_error_code,
        __i: ::std::os::raw::c_int,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZNSt3_V216generic_categoryEv"]
    pub fn std__V2_generic_category() -> *const std__V2_error_category;
}
extern "C" {
    #[link_name = "\u{1}_ZNSt3_V215system_categoryEv"]
    pub fn std__V2_system_category() -> *const std__V2_error_category;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_uniform_int_distribution<_IntType> {
    pub _M_param: std_uniform_int_distribution_param_type<_IntType>,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_IntType>>,
}
pub type std_uniform_int_distribution_result_type<_IntType> = _IntType;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_uniform_int_distribution_param_type<_IntType> {
    pub _M_a: _IntType,
    pub _M_b: _IntType,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_IntType>>,
}
pub type std_uniform_int_distribution_param_type_distribution_type<_IntType> =
    std_uniform_int_distribution<_IntType>;
#[repr(C)]
#[derive(Debug)]
pub struct std__Temporary_buffer<_Tp> {
    pub _M_original_len: std__Temporary_buffer_size_type,
    pub _M_len: std__Temporary_buffer_size_type,
    pub _M_buffer: std__Temporary_buffer_pointer<_Tp>,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Tp>>,
}
pub type std__Temporary_buffer_value_type<_Tp> = _Tp;
pub type std__Temporary_buffer_pointer<_Tp> = *mut std__Temporary_buffer_value_type<_Tp>;
pub type std__Temporary_buffer_iterator<_Tp> = std__Temporary_buffer_pointer<_Tp>;
pub type std__Temporary_buffer_size_type = isize;
pub const _S_threshold: std__bindgen_ty_1 = 16;
pub type std__bindgen_ty_1 = ::std::os::raw::c_uint;
pub const _S_chunk_size: std__bindgen_ty_2 = 7;
pub type std__bindgen_ty_2 = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_unary_function {
    pub _address: u8,
}
pub type std_unary_function_argument_type<_Arg> = _Arg;
pub type std_unary_function_result_type<_Result> = _Result;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_binary_function {
    pub _address: u8,
}
pub type std_binary_function_first_argument_type<_Arg1> = _Arg1;
pub type std_binary_function_second_argument_type<_Arg2> = _Arg2;
pub type std_binary_function_result_type<_Result> = _Result;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_transparent {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_plus {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_minus {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_multiplies {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_divides {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_modulus {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_negate {
    pub _address: u8,
}
#[test]
fn __bindgen_test_layout_std_plus_open0_void_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_plus>(),
        1usize,
        concat!("Size of template specialization: ", stringify!(std_plus))
    );
    assert_eq!(
        ::std::mem::align_of::<std_plus>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_plus)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_minus_open0_void_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_minus>(),
        1usize,
        concat!("Size of template specialization: ", stringify!(std_minus))
    );
    assert_eq!(
        ::std::mem::align_of::<std_minus>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_minus)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_multiplies_open0_void_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_multiplies>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_multiplies)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_multiplies>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_multiplies)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_divides_open0_void_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_divides>(),
        1usize,
        concat!("Size of template specialization: ", stringify!(std_divides))
    );
    assert_eq!(
        ::std::mem::align_of::<std_divides>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_divides)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_modulus_open0_void_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_modulus>(),
        1usize,
        concat!("Size of template specialization: ", stringify!(std_modulus))
    );
    assert_eq!(
        ::std::mem::align_of::<std_modulus>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_modulus)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_negate_open0_void_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_negate>(),
        1usize,
        concat!("Size of template specialization: ", stringify!(std_negate))
    );
    assert_eq!(
        ::std::mem::align_of::<std_negate>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_negate)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_equal_to {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_not_equal_to {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_greater {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_less {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_greater_equal {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_less_equal {
    pub _address: u8,
}
#[test]
fn __bindgen_test_layout_std_equal_to_open0_void_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_equal_to>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_equal_to)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_equal_to>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_equal_to)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_not_equal_to_open0_void_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_not_equal_to>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_not_equal_to)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_not_equal_to>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_not_equal_to)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_greater_open0_void_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_greater>(),
        1usize,
        concat!("Size of template specialization: ", stringify!(std_greater))
    );
    assert_eq!(
        ::std::mem::align_of::<std_greater>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_greater)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_less_open0_void_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_less>(),
        1usize,
        concat!("Size of template specialization: ", stringify!(std_less))
    );
    assert_eq!(
        ::std::mem::align_of::<std_less>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_less)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_greater_equal_open0_void_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_greater_equal>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_greater_equal)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_greater_equal>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_greater_equal)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_less_equal_open0_void_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_less_equal>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_less_equal)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_less_equal>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_less_equal)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_logical_and {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_logical_or {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_logical_not {
    pub _address: u8,
}
#[test]
fn __bindgen_test_layout_std_logical_and_open0_void_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_logical_and>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_logical_and)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_logical_and>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_logical_and)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_logical_or_open0_void_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_logical_or>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_logical_or)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_logical_or>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_logical_or)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_logical_not_open0_void_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_logical_not>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_logical_not)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_logical_not>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_logical_not)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_bit_and {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_bit_or {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_bit_xor {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_bit_not {
    pub _address: u8,
}
#[test]
fn __bindgen_test_layout_std_bit_and_open0_void_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_bit_and>(),
        1usize,
        concat!("Size of template specialization: ", stringify!(std_bit_and))
    );
    assert_eq!(
        ::std::mem::align_of::<std_bit_and>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_bit_and)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_bit_or_open0_void_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_bit_or>(),
        1usize,
        concat!("Size of template specialization: ", stringify!(std_bit_or))
    );
    assert_eq!(
        ::std::mem::align_of::<std_bit_or>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_bit_or)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_bit_xor_open0_void_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_bit_xor>(),
        1usize,
        concat!("Size of template specialization: ", stringify!(std_bit_xor))
    );
    assert_eq!(
        ::std::mem::align_of::<std_bit_xor>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_bit_xor)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_bit_not_open0_void_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_bit_not>(),
        1usize,
        concat!("Size of template specialization: ", stringify!(std_bit_not))
    );
    assert_eq!(
        ::std::mem::align_of::<std_bit_not>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_bit_not)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_unary_negate<_Predicate> {
    pub _M_pred: _Predicate,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Predicate>>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_binary_negate<_Predicate> {
    pub _M_pred: _Predicate,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Predicate>>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_pointer_to_unary_function<_Arg, _Result> {
    pub _M_ptr: ::std::option::Option<unsafe extern "C" fn(arg1: _Arg) -> _Result>,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Arg>>,
    pub _phantom_1: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Result>>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_pointer_to_binary_function<_Arg1, _Arg2, _Result> {
    pub _M_ptr: ::std::option::Option<unsafe extern "C" fn(arg1: _Arg1, arg2: _Arg2) -> _Result>,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Arg1>>,
    pub _phantom_1: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Arg2>>,
    pub _phantom_2: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Result>>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std__Identity {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std__Select1st {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std__Select2nd {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_mem_fun_t<_Ret> {
    pub _M_f: ::std::option::Option<unsafe extern "C" fn() -> _Ret>,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Ret>>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_const_mem_fun_t<_Ret> {
    pub _M_f: ::std::option::Option<unsafe extern "C" fn() -> _Ret>,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Ret>>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_mem_fun_ref_t<_Ret> {
    pub _M_f: ::std::option::Option<unsafe extern "C" fn() -> _Ret>,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Ret>>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_const_mem_fun_ref_t<_Ret> {
    pub _M_f: ::std::option::Option<unsafe extern "C" fn() -> _Ret>,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Ret>>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_mem_fun1_t<_Ret, _Arg> {
    pub _M_f: ::std::option::Option<unsafe extern "C" fn(arg1: _Arg) -> _Ret>,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Ret>>,
    pub _phantom_1: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Arg>>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_const_mem_fun1_t<_Ret, _Arg> {
    pub _M_f: ::std::option::Option<unsafe extern "C" fn(arg1: _Arg) -> _Ret>,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Ret>>,
    pub _phantom_1: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Arg>>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_mem_fun1_ref_t<_Ret, _Arg> {
    pub _M_f: ::std::option::Option<unsafe extern "C" fn(arg1: _Arg) -> _Ret>,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Ret>>,
    pub _phantom_1: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Arg>>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_const_mem_fun1_ref_t<_Ret, _Arg> {
    pub _M_f: ::std::option::Option<unsafe extern "C" fn(arg1: _Arg) -> _Ret>,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Ret>>,
    pub _phantom_1: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Arg>>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___has_is_transparent {
    pub _address: u8,
}
pub type std___has_is_transparent_t = std___has_is_transparent;
#[repr(C)]
pub struct std_binder1st<_Operation> {
    pub op: _Operation,
    pub value: [u8; 0usize],
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Operation>>,
}
#[repr(C)]
pub struct std_binder2nd<_Operation> {
    pub op: _Operation,
    pub value: [u8; 0usize],
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Operation>>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___erased_type {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_std___erased_type() {
    assert_eq!(
        ::std::mem::size_of::<std___erased_type>(),
        1usize,
        concat!("Size of: ", stringify!(std___erased_type))
    );
    assert_eq!(
        ::std::mem::align_of::<std___erased_type>(),
        1usize,
        concat!("Alignment of ", stringify!(std___erased_type))
    );
}
pub type std___is_erased_or_convertible = std___or_;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_allocator_arg_t {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_std_allocator_arg_t() {
    assert_eq!(
        ::std::mem::size_of::<std_allocator_arg_t>(),
        1usize,
        concat!("Size of: ", stringify!(std_allocator_arg_t))
    );
    assert_eq!(
        ::std::mem::align_of::<std_allocator_arg_t>(),
        1usize,
        concat!("Alignment of ", stringify!(std_allocator_arg_t))
    );
}
extern "C" {
    #[link_name = "\u{1}_ZSt13allocator_arg"]
    pub static std_allocator_arg: std_allocator_arg_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___uses_allocator_helper {
    pub _base: std_false_type,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_uses_allocator {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___uses_alloc_base {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_std___uses_alloc_base() {
    assert_eq!(
        ::std::mem::size_of::<std___uses_alloc_base>(),
        1usize,
        concat!("Size of: ", stringify!(std___uses_alloc_base))
    );
    assert_eq!(
        ::std::mem::align_of::<std___uses_alloc_base>(),
        1usize,
        concat!("Alignment of ", stringify!(std___uses_alloc_base))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___uses_alloc0 {
    pub _M_a: std___uses_alloc0__Sink,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___uses_alloc0__Sink {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_std___uses_alloc0__Sink() {
    assert_eq!(
        ::std::mem::size_of::<std___uses_alloc0__Sink>(),
        1usize,
        concat!("Size of: ", stringify!(std___uses_alloc0__Sink))
    );
    assert_eq!(
        ::std::mem::align_of::<std___uses_alloc0__Sink>(),
        1usize,
        concat!("Alignment of ", stringify!(std___uses_alloc0__Sink))
    );
}
#[test]
fn bindgen_test_layout_std___uses_alloc0() {
    const UNINIT: ::std::mem::MaybeUninit<std___uses_alloc0> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<std___uses_alloc0>(),
        1usize,
        concat!("Size of: ", stringify!(std___uses_alloc0))
    );
    assert_eq!(
        ::std::mem::align_of::<std___uses_alloc0>(),
        1usize,
        concat!("Alignment of ", stringify!(std___uses_alloc0))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._M_a) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(std___uses_alloc0),
            "::",
            stringify!(_M_a)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___uses_alloc1<_Alloc> {
    pub _M_a: *const _Alloc,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Alloc>>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___uses_alloc2<_Alloc> {
    pub _M_a: *const _Alloc,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Alloc>>,
}
pub type std___uses_alloc_t = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_uses_allocator_predicate {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_uses_allocator_constructible {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_nothrow_uses_allocator_constructible {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_empty_non_tuple {
    pub _address: u8,
}
pub type std___empty_not_final = std___conditional_t;
pub type std__TupleConstraints___constructible = std___and_;
pub type std__TupleConstraints___convertible = std___and_;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_tuple {
    pub _address: u8,
}
pub type std_tuple__Inherited = u8;
pub type std_tuple__TCC = u8;
pub type std_tuple__ImplicitDefaultCtor = std___enable_if_t;
pub type std_tuple__ExplicitDefaultCtor = std___enable_if_t;
pub type std_tuple__ImplicitCtor = std___enable_if_t;
pub type std_tuple__ExplicitCtor = std___enable_if_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_tuple__UseOtherCtor {
    pub _base: std_false_type,
}
#[test]
fn __bindgen_test_layout_std_tuple_open0_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_tuple>(),
        1usize,
        concat!("Size of template specialization: ", stringify!(std_tuple))
    );
    assert_eq!(
        ::std::mem::align_of::<std_tuple>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_tuple)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___do_make_tuple {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___make_tuple {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___combine_tuples {
    pub _address: u8,
}
#[test]
fn __bindgen_test_layout_std___combine_tuples_open0_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std___combine_tuples>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___combine_tuples)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___combine_tuples>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___combine_tuples)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___tuple_cat_result {
    pub _address: u8,
}
pub type std___tuple_cat_result___type = std___combine_tuples;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___make_1st_indices {
    pub _address: u8,
}
#[test]
fn __bindgen_test_layout_std___make_1st_indices_open0_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std___make_1st_indices>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___make_1st_indices)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___make_1st_indices>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___make_1st_indices)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___tuple_concater {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std__Swallow_assign {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_std__Swallow_assign() {
    assert_eq!(
        ::std::mem::size_of::<std__Swallow_assign>(),
        1usize,
        concat!("Size of: ", stringify!(std__Swallow_assign))
    );
    assert_eq!(
        ::std::mem::align_of::<std__Swallow_assign>(),
        1usize,
        concat!("Alignment of ", stringify!(std__Swallow_assign))
    );
}
extern "C" {
    #[link_name = "\u{1}_ZSt6ignore"]
    pub static std_ignore: std__Swallow_assign;
}
extern "C" {
    #[link_name = "\u{1}_ZSt11_Hash_bytesPKvmm"]
    pub fn std__Hash_bytes(
        __ptr: *const ::std::os::raw::c_void,
        __len: usize,
        __seed: usize,
    ) -> usize;
}
extern "C" {
    #[link_name = "\u{1}_ZSt15_Fnv_hash_bytesPKvmm"]
    pub fn std__Fnv_hash_bytes(
        __ptr: *const ::std::os::raw::c_void,
        __len: usize,
        __seed: usize,
    ) -> usize;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___hash_base {
    pub _address: u8,
}
pub type std___hash_base_result_type<_Result> = _Result;
pub type std___hash_base_argument_type<_Arg> = _Arg;
#[repr(C)]
#[derive(Debug)]
pub struct std___poison_hash {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug)]
pub struct std_hash {
    pub _address: u8,
}
#[test]
fn __bindgen_test_layout_std_hash_open0_bool__close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_hash>(),
        1usize,
        concat!("Size of template specialization: ", stringify!(std_hash))
    );
    assert_eq!(
        ::std::mem::align_of::<std_hash>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_hash)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_hash_open0_char_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_hash>(),
        1usize,
        concat!("Size of template specialization: ", stringify!(std_hash))
    );
    assert_eq!(
        ::std::mem::align_of::<std_hash>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_hash)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_hash_open0_signed_char_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_hash>(),
        1usize,
        concat!("Size of template specialization: ", stringify!(std_hash))
    );
    assert_eq!(
        ::std::mem::align_of::<std_hash>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_hash)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_hash_open0_unsigned_char_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_hash>(),
        1usize,
        concat!("Size of template specialization: ", stringify!(std_hash))
    );
    assert_eq!(
        ::std::mem::align_of::<std_hash>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_hash)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_hash_open0_wchar_t_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_hash>(),
        1usize,
        concat!("Size of template specialization: ", stringify!(std_hash))
    );
    assert_eq!(
        ::std::mem::align_of::<std_hash>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_hash)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_hash_open0_char16_t_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_hash>(),
        1usize,
        concat!("Size of template specialization: ", stringify!(std_hash))
    );
    assert_eq!(
        ::std::mem::align_of::<std_hash>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_hash)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_hash_open0_char32_t_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_hash>(),
        1usize,
        concat!("Size of template specialization: ", stringify!(std_hash))
    );
    assert_eq!(
        ::std::mem::align_of::<std_hash>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_hash)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_hash_open0_short_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_hash>(),
        1usize,
        concat!("Size of template specialization: ", stringify!(std_hash))
    );
    assert_eq!(
        ::std::mem::align_of::<std_hash>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_hash)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_hash_open0_int_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_hash>(),
        1usize,
        concat!("Size of template specialization: ", stringify!(std_hash))
    );
    assert_eq!(
        ::std::mem::align_of::<std_hash>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_hash)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_hash_open0_long_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_hash>(),
        1usize,
        concat!("Size of template specialization: ", stringify!(std_hash))
    );
    assert_eq!(
        ::std::mem::align_of::<std_hash>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_hash)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_hash_open0_long_long_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_hash>(),
        1usize,
        concat!("Size of template specialization: ", stringify!(std_hash))
    );
    assert_eq!(
        ::std::mem::align_of::<std_hash>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_hash)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_hash_open0_unsigned_short_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_hash>(),
        1usize,
        concat!("Size of template specialization: ", stringify!(std_hash))
    );
    assert_eq!(
        ::std::mem::align_of::<std_hash>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_hash)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_hash_open0_unsigned_int_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_hash>(),
        1usize,
        concat!("Size of template specialization: ", stringify!(std_hash))
    );
    assert_eq!(
        ::std::mem::align_of::<std_hash>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_hash)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_hash_open0_unsigned_long_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_hash>(),
        1usize,
        concat!("Size of template specialization: ", stringify!(std_hash))
    );
    assert_eq!(
        ::std::mem::align_of::<std_hash>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_hash)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_hash_open0_unsigned_long_long_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_hash>(),
        1usize,
        concat!("Size of template specialization: ", stringify!(std_hash))
    );
    assert_eq!(
        ::std::mem::align_of::<std_hash>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_hash)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std__Hash_impl {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_std__Hash_impl() {
    assert_eq!(
        ::std::mem::size_of::<std__Hash_impl>(),
        1usize,
        concat!("Size of: ", stringify!(std__Hash_impl))
    );
    assert_eq!(
        ::std::mem::align_of::<std__Hash_impl>(),
        1usize,
        concat!("Alignment of ", stringify!(std__Hash_impl))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std__Fnv_hash_impl {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_std__Fnv_hash_impl() {
    assert_eq!(
        ::std::mem::size_of::<std__Fnv_hash_impl>(),
        1usize,
        concat!("Size of: ", stringify!(std__Fnv_hash_impl))
    );
    assert_eq!(
        ::std::mem::align_of::<std__Fnv_hash_impl>(),
        1usize,
        concat!("Alignment of ", stringify!(std__Fnv_hash_impl))
    );
}
#[test]
fn __bindgen_test_layout_std_hash_open0_float_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_hash>(),
        1usize,
        concat!("Size of template specialization: ", stringify!(std_hash))
    );
    assert_eq!(
        ::std::mem::align_of::<std_hash>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_hash)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_hash_open0_double_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_hash>(),
        1usize,
        concat!("Size of template specialization: ", stringify!(std_hash))
    );
    assert_eq!(
        ::std::mem::align_of::<std_hash>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_hash)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_hash_open0_long_double_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_hash>(),
        1usize,
        concat!("Size of template specialization: ", stringify!(std_hash))
    );
    assert_eq!(
        ::std::mem::align_of::<std_hash>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_hash)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_hash_open0_nullptr_t_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_hash>(),
        1usize,
        concat!("Size of template specialization: ", stringify!(std_hash))
    );
    assert_eq!(
        ::std::mem::align_of::<std_hash>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_hash)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_fast_hash {
    pub _base: std_true_type,
}
#[test]
fn __bindgen_test_layout_std___is_fast_hash_open0_std_hash_open1_long_double_close1_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<std___is_fast_hash>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___is_fast_hash)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___is_fast_hash>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___is_fast_hash)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std__Maybe_unary_or_binary_function {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std__Mem_fn_traits {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std__Mem_fn_traits_base {
    pub _address: u8,
}
pub type std__Mem_fn_traits_base___result_type<_Res> = _Res;
pub type std__Mem_fn_traits_base___maybe_type = std__Maybe_unary_or_binary_function;
pub type std__Mem_fn_traits_base___arity = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std__Maybe_get_result_type {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std__Weak_result_type_impl {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std__Weak_result_type {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std__Refwrap_base_arg1 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std__Refwrap_base_arg2 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std__Reference_wrapper_base {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_reference_wrapper<_Tp> {
    pub _M_data: *mut _Tp,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Tp>>,
}
pub type std_reference_wrapper___not_same = u8;
pub type std_reference_wrapper_type<_Tp> = _Tp;
#[repr(C)]
#[derive(Debug)]
pub struct std_bad_function_call {
    pub _base: exception,
}
#[test]
fn bindgen_test_layout_std_bad_function_call() {
    assert_eq!(
        ::std::mem::size_of::<std_bad_function_call>(),
        8usize,
        concat!("Size of: ", stringify!(std_bad_function_call))
    );
    assert_eq!(
        ::std::mem::align_of::<std_bad_function_call>(),
        8usize,
        concat!("Alignment of ", stringify!(std_bad_function_call))
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNSt17bad_function_callD1Ev"]
    pub fn std_bad_function_call_bad_function_call_destructor(this: *mut std_bad_function_call);
}
extern "C" {
    #[link_name = "\u{1}_ZNKSt17bad_function_call4whatEv"]
    pub fn std_bad_function_call_what(
        this: *mut ::std::os::raw::c_void,
    ) -> *const ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_location_invariant {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std__Undefined_class {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union std__Nocopy_types {
    pub _M_object: *mut ::std::os::raw::c_void,
    pub _M_const_object: *const ::std::os::raw::c_void,
    pub _M_function_pointer: ::std::option::Option<unsafe extern "C" fn()>,
    pub _M_member_pointer: ::std::option::Option<unsafe extern "C" fn()>,
}
#[test]
fn bindgen_test_layout_std__Nocopy_types() {
    const UNINIT: ::std::mem::MaybeUninit<std__Nocopy_types> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<std__Nocopy_types>(),
        16usize,
        concat!("Size of: ", stringify!(std__Nocopy_types))
    );
    assert_eq!(
        ::std::mem::align_of::<std__Nocopy_types>(),
        8usize,
        concat!("Alignment of ", stringify!(std__Nocopy_types))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._M_object) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(std__Nocopy_types),
            "::",
            stringify!(_M_object)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._M_const_object) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(std__Nocopy_types),
            "::",
            stringify!(_M_const_object)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._M_function_pointer) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(std__Nocopy_types),
            "::",
            stringify!(_M_function_pointer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._M_member_pointer) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(std__Nocopy_types),
            "::",
            stringify!(_M_member_pointer)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union std__Any_data {
    pub _M_unused: std__Nocopy_types,
    pub _M_pod_data: [::std::os::raw::c_char; 16usize],
}
#[test]
fn bindgen_test_layout_std__Any_data() {
    const UNINIT: ::std::mem::MaybeUninit<std__Any_data> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<std__Any_data>(),
        16usize,
        concat!("Size of: ", stringify!(std__Any_data))
    );
    assert_eq!(
        ::std::mem::align_of::<std__Any_data>(),
        8usize,
        concat!("Alignment of ", stringify!(std__Any_data))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._M_unused) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(std__Any_data),
            "::",
            stringify!(_M_unused)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._M_pod_data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(std__Any_data),
            "::",
            stringify!(_M_pod_data)
        )
    );
}
pub const std__Manager_operation___get_type_info: std__Manager_operation = 0;
pub const std__Manager_operation___get_functor_ptr: std__Manager_operation = 1;
pub const std__Manager_operation___clone_functor: std__Manager_operation = 2;
pub const std__Manager_operation___destroy_functor: std__Manager_operation = 3;
pub type std__Manager_operation = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_function {
    pub _address: u8,
}
#[repr(C)]
pub struct std__Function_base {
    pub _M_functor: std__Any_data,
    pub _M_manager: std__Function_base__Manager_type,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std__Function_base__Base_manager {
    pub _address: u8,
}
pub type std__Function_base__Base_manager__Local_storage = u8;
pub type std__Function_base__Manager_type = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut std__Any_data,
        arg2: *const std__Any_data,
        arg3: std__Manager_operation,
    ) -> bool,
>;
pub const std__Function_base__M_max_size: usize = 16;
pub const std__Function_base__M_max_align: usize = 8;
#[test]
fn bindgen_test_layout_std__Function_base() {
    const UNINIT: ::std::mem::MaybeUninit<std__Function_base> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<std__Function_base>(),
        24usize,
        concat!("Size of: ", stringify!(std__Function_base))
    );
    assert_eq!(
        ::std::mem::align_of::<std__Function_base>(),
        8usize,
        concat!("Alignment of ", stringify!(std__Function_base))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._M_functor) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(std__Function_base),
            "::",
            stringify!(_M_functor)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._M_manager) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(std__Function_base),
            "::",
            stringify!(_M_manager)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std__Function_handler {
    pub _address: u8,
}
#[test]
fn __bindgen_test_layout_std__Function_handler_open0_void_void_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std__Function_handler>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std__Function_handler)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std__Function_handler>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std__Function_handler)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___function_guide_helper {
    pub _address: u8,
}
pub type std___function_guide_t = std___function_guide_helper;
#[repr(C)]
#[derive(Debug)]
pub struct std___new_allocator {
    pub _address: u8,
}
pub type std___new_allocator_value_type<_Tp> = _Tp;
pub type std___new_allocator_size_type = usize;
pub type std___new_allocator_difference_type = isize;
pub type std___new_allocator_pointer<_Tp> = *mut _Tp;
pub type std___new_allocator_const_pointer<_Tp> = *const _Tp;
pub type std___new_allocator_reference<_Tp> = *mut _Tp;
pub type std___new_allocator_const_reference<_Tp> = *const _Tp;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___new_allocator_rebind {
    pub _address: u8,
}
pub type std___new_allocator_propagate_on_container_move_assignment = std_true_type;
pub type std___allocator_base = std___new_allocator;
#[test]
fn __bindgen_test_layout_std_allocator_open0_void_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_allocator>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_allocator)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_allocator>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_allocator)
        )
    );
}
#[repr(C)]
#[derive(Debug)]
pub struct std_allocator {
    pub _address: u8,
}
pub type std_allocator_value_type<_Tp> = _Tp;
pub type std_allocator_size_type = usize;
pub type std_allocator_difference_type = isize;
pub type std_allocator_pointer<_Tp> = *mut _Tp;
pub type std_allocator_const_pointer<_Tp> = *const _Tp;
pub type std_allocator_reference<_Tp> = *mut _Tp;
pub type std_allocator_const_reference<_Tp> = *const _Tp;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_allocator_rebind {
    pub _address: u8,
}
pub type std_allocator_rebind_other = std_allocator;
pub type std_allocator_propagate_on_container_move_assignment = std_true_type;
pub type std_allocator_is_always_equal = std_true_type;
#[test]
fn __bindgen_test_layout_std_allocator_open0_char_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_allocator>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_allocator)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_allocator>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_allocator)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_allocator_open0_wchar_t_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_allocator>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_allocator)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_allocator>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_allocator)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___allocator_traits_base {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___allocator_traits_base___rebind {
    pub _address: u8,
}
pub type std___allocator_traits_base___pointer = [u8; 0usize];
pub type std___allocator_traits_base___c_pointer = [u8; 0usize];
pub type std___allocator_traits_base___v_pointer = [u8; 0usize];
pub type std___allocator_traits_base___cv_pointer = [u8; 0usize];
pub type std___allocator_traits_base___pocca = [u8; 0usize];
pub type std___allocator_traits_base___pocma = [u8; 0usize];
pub type std___allocator_traits_base___pocs = [u8; 0usize];
pub type std___allocator_traits_base___equal = std___type_identity;
#[test]
fn bindgen_test_layout_std___allocator_traits_base() {
    assert_eq!(
        ::std::mem::size_of::<std___allocator_traits_base>(),
        1usize,
        concat!("Size of: ", stringify!(std___allocator_traits_base))
    );
    assert_eq!(
        ::std::mem::align_of::<std___allocator_traits_base>(),
        1usize,
        concat!("Alignment of ", stringify!(std___allocator_traits_base))
    );
}
pub type std___alloc_rebind = std___allocator_traits_base;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_allocator_traits {
    pub _address: u8,
}
pub type std_allocator_traits_allocator_type<_Alloc> = _Alloc;
pub type std_allocator_traits_value_type = [u8; 0usize];
pub type std_allocator_traits_pointer = std___detected_or_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_allocator_traits__Ptr {
    pub _address: u8,
}
pub type std_allocator_traits__Ptr_type = [u8; 0usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_allocator_traits__Diff {
    pub _address: u8,
}
pub type std_allocator_traits__Diff_type = std_pointer_traits;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_allocator_traits__Size {
    pub _address: u8,
}
pub type std_allocator_traits_const_pointer = [u8; 0usize];
pub type std_allocator_traits_void_pointer = std_allocator_traits__Ptr;
pub type std_allocator_traits_const_void_pointer = std_allocator_traits__Ptr;
pub type std_allocator_traits_difference_type = [u8; 0usize];
pub type std_allocator_traits_size_type = [u8; 0usize];
pub type std_allocator_traits_propagate_on_container_copy_assignment = std___detected_or_t;
pub type std_allocator_traits_propagate_on_container_move_assignment = std___detected_or_t;
pub type std_allocator_traits_propagate_on_container_swap = std___detected_or_t;
pub type std_allocator_traits_is_always_equal = std___detected_or_t;
pub type std_allocator_traits_rebind_alloc = std___alloc_rebind;
pub type std_allocator_traits_rebind_traits = std_allocator_traits;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_allocator_traits___construct_helper {
    pub _address: u8,
}
pub type std_allocator_traits___construct_helper_type<_Alloc> = _Alloc;
pub type std_allocator_traits___has_construct = std_allocator_traits___construct_helper;
#[test]
fn __bindgen_test_layout_std_allocator_traits_open0_std_allocator_open1_void_close1_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<std_allocator_traits>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_allocator_traits)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_allocator_traits>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_allocator_traits)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_alloc_insertable_impl {
    pub _base: std_false_type,
}
#[repr(C)]
pub struct std___is_copy_insertable {
    pub _address: u8,
}
#[repr(C)]
pub struct std___is_move_insertable {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_allocator {
    pub _base: std_false_type,
}
pub type std__RequireAllocator = u8;
pub type std__RequireNotAllocator = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std__Enable_default_constructor_tag {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_std__Enable_default_constructor_tag() {
    assert_eq!(
        ::std::mem::size_of::<std__Enable_default_constructor_tag>(),
        1usize,
        concat!("Size of: ", stringify!(std__Enable_default_constructor_tag))
    );
    assert_eq!(
        ::std::mem::align_of::<std__Enable_default_constructor_tag>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(std__Enable_default_constructor_tag)
        )
    );
}
#[repr(C)]
pub struct std__Node_handle_common<_NodeAlloc> {
    pub _M_ptr: std__Node_handle_common__AllocTraits,
    pub _M_alloc: std__Node_handle_common__Optional_alloc<_NodeAlloc>,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_NodeAlloc>>,
}
pub type std__Node_handle_common__AllocTraits = std_allocator_traits;
pub type std__Node_handle_common_allocator_type = std___alloc_rebind;
#[repr(C)]
#[repr(align(1))]
pub struct std__Node_handle_common__Optional_alloc<_NodeAlloc> {
    pub _M_alloc: __BindgenUnionField<_NodeAlloc>,
    pub bindgen_union_field: [u8; 0usize],
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_NodeAlloc>>,
}
#[repr(C)]
pub struct std__Node_handle<_NodeAlloc> {
    pub _base: std__Node_handle_common<_NodeAlloc>,
    pub _M_pkey: std__Node_handle___pointer,
    pub _M_pmapped: std__Node_handle___pointer,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_NodeAlloc>>,
}
pub type std__Node_handle_key_type<_Key> = _Key;
pub type std__Node_handle_mapped_type = [u8; 0usize];
pub type std__Node_handle__AllocTraits = std_allocator_traits;
pub type std__Node_handle___pointer = std___ptr_rebind;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std__Node_insert_return<_Iterator, _NodeHandle> {
    pub position: _Iterator,
    pub inserted: bool,
    pub node: _NodeHandle,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Iterator>>,
    pub _phantom_1: ::std::marker::PhantomData<::std::cell::UnsafeCell<_NodeHandle>>,
}
pub type std___cache_default = std___not_;
pub type std__Hashtable_enable_default_ctor = u8;
#[repr(C)]
#[derive(Debug)]
pub struct std__Hashtable<_RehashPolicy> {
    pub _M_buckets: std__Hashtable___buckets_ptr,
    pub _M_bucket_count: std__Hashtable_size_type,
    pub _M_before_begin: std__Hashtable___node_base,
    pub _M_element_count: std__Hashtable_size_type,
    pub _M_rehash_policy: _RehashPolicy,
    pub _M_single_bucket: std__Hashtable___node_base_ptr,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_RehashPolicy>>,
}
pub type std__Hashtable___traits_type<_Traits> = _Traits;
pub type std__Hashtable___hash_cached = [u8; 0usize];
pub type std__Hashtable___constant_iterators = [u8; 0usize];
pub type std__Hashtable___node_type = u8;
pub type std__Hashtable___node_alloc_type = std___alloc_rebind;
pub type std__Hashtable___hashtable_alloc = std___detail__Hashtable_alloc;
pub type std__Hashtable___node_value_type = u8;
pub type std__Hashtable___node_ptr = std__Hashtable___hashtable_alloc;
pub type std__Hashtable___value_alloc_traits = std__Hashtable___hashtable_alloc;
pub type std__Hashtable___node_alloc_traits = std__Hashtable___hashtable_alloc;
pub type std__Hashtable___node_base = std__Hashtable___hashtable_alloc;
pub type std__Hashtable___node_base_ptr = std__Hashtable___hashtable_alloc;
pub type std__Hashtable___buckets_ptr = std__Hashtable___hashtable_alloc;
pub type std__Hashtable___insert_base = u8;
pub type std__Hashtable___enable_default_ctor = std__Hashtable_enable_default_ctor;
pub type std__Hashtable_key_type<_Key> = _Key;
pub type std__Hashtable_value_type<_Value> = _Value;
pub type std__Hashtable_allocator_type<_Alloc> = _Alloc;
pub type std__Hashtable_key_equal<_Equal> = _Equal;
pub type std__Hashtable_pointer = std__Hashtable___value_alloc_traits;
pub type std__Hashtable_const_pointer = std__Hashtable___value_alloc_traits;
pub type std__Hashtable_reference<_Value> = *mut std__Hashtable_value_type<_Value>;
pub type std__Hashtable_const_reference<_Value> = *const std__Hashtable_value_type<_Value>;
pub type std__Hashtable_iterator = std__Hashtable___insert_base;
pub type std__Hashtable_const_iterator = std__Hashtable___insert_base;
pub type std__Hashtable_local_iterator = u8;
pub type std__Hashtable_const_local_iterator = u8;
pub type std__Hashtable___rehash_type<_RehashPolicy> = _RehashPolicy;
pub type std__Hashtable___rehash_state = [u8; 0usize];
pub type std__Hashtable___unique_keys = [u8; 0usize];
pub type std__Hashtable___hashtable_base = std___detail__Hashtable_base;
pub type std__Hashtable___hash_code_base = std__Hashtable___hashtable_base;
pub type std__Hashtable___hash_code = std__Hashtable___hashtable_base;
pub type std__Hashtable___ireturn_type = std__Hashtable___insert_base;
pub type std__Hashtable___map_base = u8;
pub type std__Hashtable___rehash_base = std___detail__Rehash_base;
pub type std__Hashtable___eq_base = u8;
pub type std__Hashtable___reuse_or_alloc_node_gen_t = std___detail__ReuseOrAllocNode;
pub type std__Hashtable___alloc_node_gen_t = std___detail__AllocNode;
pub type std__Hashtable___node_builder_t = std___detail__NodeBuilder;
#[repr(C)]
#[derive(Debug)]
pub struct std__Hashtable__Scoped_node {
    pub _M_h: *mut std__Hashtable___hashtable_alloc,
    pub _M_node: std__Hashtable___node_ptr,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std__Hashtable___hash_code_base_access {
    pub _address: u8,
}
pub type std__Hashtable_size_type = std__Hashtable___hashtable_base;
pub type std__Hashtable_difference_type = std__Hashtable___hashtable_base;
pub type std__Hashtable_node_type = std__Node_handle<std__Hashtable___node_alloc_type>;
pub type std__Hashtable_insert_return_type =
    std__Node_insert_return<std__Hashtable_iterator, std__Hashtable_node_type>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std__Hash_merge_helper {
    pub _address: u8,
}
pub type std__RequireNotAllocatorOrIntegral = std___enable_if_t;
pub type std___umap_traits = u8;
pub type std___umap_hashtable = std__Hashtable<_RehashPolicy>;
pub type std___ummap_traits = u8;
pub type std___ummap_hashtable = std__Hashtable<_RehashPolicy>;
#[repr(C)]
#[derive(Debug)]
pub struct std_unordered_map {
    pub _M_h: std_unordered_map__Hashtable,
}
pub type std_unordered_map__Hashtable = std___umap_hashtable;
pub type std_unordered_map_key_type = std_unordered_map__Hashtable;
pub type std_unordered_map_value_type = std_unordered_map__Hashtable;
pub type std_unordered_map_mapped_type = std_unordered_map__Hashtable;
pub type std_unordered_map_hasher = std_unordered_map__Hashtable;
pub type std_unordered_map_key_equal = std_unordered_map__Hashtable;
pub type std_unordered_map_allocator_type = std_unordered_map__Hashtable;
pub type std_unordered_map_pointer = std_unordered_map__Hashtable;
pub type std_unordered_map_const_pointer = std_unordered_map__Hashtable;
pub type std_unordered_map_reference = std_unordered_map__Hashtable;
pub type std_unordered_map_const_reference = std_unordered_map__Hashtable;
pub type std_unordered_map_iterator = std_unordered_map__Hashtable;
pub type std_unordered_map_const_iterator = std_unordered_map__Hashtable;
pub type std_unordered_map_local_iterator = std_unordered_map__Hashtable;
pub type std_unordered_map_const_local_iterator = std_unordered_map__Hashtable;
pub type std_unordered_map_size_type = std_unordered_map__Hashtable;
pub type std_unordered_map_difference_type = std_unordered_map__Hashtable;
pub type std_unordered_map_node_type = std_unordered_map__Hashtable;
pub type std_unordered_map_insert_return_type = std_unordered_map__Hashtable;
#[repr(C)]
#[derive(Debug)]
pub struct std_unordered_multimap {
    pub _M_h: std_unordered_multimap__Hashtable,
}
pub type std_unordered_multimap__Hashtable = std___ummap_hashtable;
pub type std_unordered_multimap_key_type = std_unordered_multimap__Hashtable;
pub type std_unordered_multimap_value_type = std_unordered_multimap__Hashtable;
pub type std_unordered_multimap_mapped_type = std_unordered_multimap__Hashtable;
pub type std_unordered_multimap_hasher = std_unordered_multimap__Hashtable;
pub type std_unordered_multimap_key_equal = std_unordered_multimap__Hashtable;
pub type std_unordered_multimap_allocator_type = std_unordered_multimap__Hashtable;
pub type std_unordered_multimap_pointer = std_unordered_multimap__Hashtable;
pub type std_unordered_multimap_const_pointer = std_unordered_multimap__Hashtable;
pub type std_unordered_multimap_reference = std_unordered_multimap__Hashtable;
pub type std_unordered_multimap_const_reference = std_unordered_multimap__Hashtable;
pub type std_unordered_multimap_iterator = std_unordered_multimap__Hashtable;
pub type std_unordered_multimap_const_iterator = std_unordered_multimap__Hashtable;
pub type std_unordered_multimap_local_iterator = std_unordered_multimap__Hashtable;
pub type std_unordered_multimap_const_local_iterator = std_unordered_multimap__Hashtable;
pub type std_unordered_multimap_size_type = std_unordered_multimap__Hashtable;
pub type std_unordered_multimap_difference_type = std_unordered_multimap__Hashtable;
pub type std_unordered_multimap_node_type = std_unordered_multimap__Hashtable;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_valarray {
    pub _address: u8,
}
#[repr(C)]
pub struct std_pmr_memory_resource__bindgen_vtable(::std::os::raw::c_void);
#[repr(C)]
#[derive(Debug)]
pub struct std_pmr_memory_resource {
    pub vtable_: *const std_pmr_memory_resource__bindgen_vtable,
}
pub const std_pmr_memory_resource__S_max_align: usize = 16;
#[test]
fn bindgen_test_layout_std_pmr_memory_resource() {
    assert_eq!(
        ::std::mem::size_of::<std_pmr_memory_resource>(),
        8usize,
        concat!("Size of: ", stringify!(std_pmr_memory_resource))
    );
    assert_eq!(
        ::std::mem::align_of::<std_pmr_memory_resource>(),
        8usize,
        concat!("Alignment of ", stringify!(std_pmr_memory_resource))
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNSt3pmr15memory_resourceD1Ev"]
    pub fn std_pmr_memory_resource_memory_resource_destructor(this: *mut std_pmr_memory_resource);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_pmr_polymorphic_allocator {
    pub _M_resource: *mut std_pmr_memory_resource,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_pmr_polymorphic_allocator___not_pair {
    pub _address: u8,
}
pub type std_pmr_polymorphic_allocator___not_pair_type = ::std::os::raw::c_void;
pub type std_pmr_polymorphic_allocator_value_type<_Tp> = _Tp;
pub type std_pmr_polymorphic_allocator___uses_alloc1_ =
    std___uses_alloc1<std_pmr_polymorphic_allocator>;
pub type std_pmr_polymorphic_allocator___uses_alloc2_ =
    std___uses_alloc2<std_pmr_polymorphic_allocator>;
pub type std_pmr_unordered_map = std_unordered_map;
pub type std_pmr_unordered_multimap = std_unordered_multimap;
pub type std_pmr_vector = std_vector;
pub type std_pmr_basic_string<_CharT> = std_basic_string<_CharT>;
pub type std_pmr_string = std_basic_string<::std::os::raw::c_char>;
pub type std_pmr_u16string = std_basic_string<u16>;
pub type std_pmr_u32string = std_basic_string<u32>;
pub type std_pmr_wstring = std_basic_string<u32>;
pub type std_pmr_list = std_list;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_bitwise_relocatable {
    pub _address: u8,
}
#[repr(C)]
pub struct std__Vector_base {
    pub _M_impl: std__Vector_base__Vector_impl,
}
pub type std__Vector_base__Tp_alloc_type = [u8; 0usize];
pub type std__Vector_base_pointer = [u8; 0usize];
#[repr(C)]
pub struct std__Vector_base__Vector_impl_data {
    pub _M_start: std__Vector_base_pointer,
    pub _M_finish: std__Vector_base_pointer,
    pub _M_end_of_storage: std__Vector_base_pointer,
}
#[repr(C)]
pub struct std__Vector_base__Vector_impl {
    pub _base_1: std__Vector_base__Vector_impl_data,
}
pub type std__Vector_base_allocator_type<_Alloc> = _Alloc;
#[repr(C)]
pub struct std_vector {
    pub _base: std__Vector_base,
}
pub type std_vector__Base = std__Vector_base;
pub type std_vector__Tp_alloc_type = std_vector__Base;
pub type std_vector__Alloc_traits = __gnu_cxx___alloc_traits;
pub type std_vector_value_type<_Tp> = _Tp;
pub type std_vector_pointer = std_vector__Base;
pub type std_vector_const_pointer = std_vector__Alloc_traits;
pub type std_vector_reference = std_vector__Alloc_traits;
pub type std_vector_const_reference = std_vector__Alloc_traits;
pub type std_vector_iterator = __gnu_cxx___normal_iterator<std_vector_pointer>;
pub type std_vector_const_iterator = __gnu_cxx___normal_iterator<std_vector_const_pointer>;
pub type std_vector_const_reverse_iterator = std_reverse_iterator<std_vector_const_iterator>;
pub type std_vector_reverse_iterator = std_reverse_iterator<std_vector_iterator>;
pub type std_vector_size_type = usize;
pub type std_vector_difference_type = isize;
pub type std_vector_allocator_type<_Alloc> = _Alloc;
#[repr(C)]
pub struct std_vector__Temporary_value<_Tp> {
    pub _M_this: *mut std_vector,
    pub _M_storage: std_vector__Temporary_value__Storage<_Tp>,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Tp>>,
}
#[repr(C)]
pub union std_vector__Temporary_value__Storage<_Tp> {
    pub _M_byte: ::std::os::raw::c_uchar,
    pub _M_val: _Tp,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Tp>>,
}
pub type std__Bit_type = ::std::os::raw::c_ulong;
pub const _S_word_bit: std__bindgen_ty_3 = 64;
pub type std__bindgen_ty_3 = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std__Bit_reference {
    pub _M_p: *mut std__Bit_type,
    pub _M_mask: std__Bit_type,
}
#[test]
fn bindgen_test_layout_std__Bit_reference() {
    const UNINIT: ::std::mem::MaybeUninit<std__Bit_reference> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<std__Bit_reference>(),
        16usize,
        concat!("Size of: ", stringify!(std__Bit_reference))
    );
    assert_eq!(
        ::std::mem::align_of::<std__Bit_reference>(),
        8usize,
        concat!("Alignment of ", stringify!(std__Bit_reference))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._M_p) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(std__Bit_reference),
            "::",
            stringify!(_M_p)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._M_mask) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(std__Bit_reference),
            "::",
            stringify!(_M_mask)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std__Bit_iterator_base {
    pub _M_p: *mut std__Bit_type,
    pub _M_offset: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_std__Bit_iterator_base() {
    const UNINIT: ::std::mem::MaybeUninit<std__Bit_iterator_base> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<std__Bit_iterator_base>(),
        16usize,
        concat!("Size of: ", stringify!(std__Bit_iterator_base))
    );
    assert_eq!(
        ::std::mem::align_of::<std__Bit_iterator_base>(),
        8usize,
        concat!("Alignment of ", stringify!(std__Bit_iterator_base))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._M_p) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(std__Bit_iterator_base),
            "::",
            stringify!(_M_p)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._M_offset) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(std__Bit_iterator_base),
            "::",
            stringify!(_M_offset)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std__Bit_iterator {
    pub _base: std__Bit_iterator_base,
}
pub type std__Bit_iterator_reference = std__Bit_reference;
pub type std__Bit_iterator_pointer = *mut std__Bit_reference;
#[test]
fn bindgen_test_layout_std__Bit_iterator() {
    assert_eq!(
        ::std::mem::size_of::<std__Bit_iterator>(),
        16usize,
        concat!("Size of: ", stringify!(std__Bit_iterator))
    );
    assert_eq!(
        ::std::mem::align_of::<std__Bit_iterator>(),
        8usize,
        concat!("Alignment of ", stringify!(std__Bit_iterator))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std__Bit_const_iterator {
    pub _base: std__Bit_iterator_base,
}
pub type std__Bit_const_iterator_reference = bool;
pub type std__Bit_const_iterator_const_reference = bool;
pub type std__Bit_const_iterator_pointer = *const bool;
#[test]
fn bindgen_test_layout_std__Bit_const_iterator() {
    assert_eq!(
        ::std::mem::size_of::<std__Bit_const_iterator>(),
        16usize,
        concat!("Size of: ", stringify!(std__Bit_const_iterator))
    );
    assert_eq!(
        ::std::mem::align_of::<std__Bit_const_iterator>(),
        8usize,
        concat!("Alignment of ", stringify!(std__Bit_const_iterator))
    );
}
#[repr(C)]
pub struct std__Bvector_base {
    pub _M_impl: std__Bvector_base__Bvector_impl,
}
pub type std__Bvector_base__Bit_alloc_type = [u8; 0usize];
pub type std__Bvector_base__Bit_alloc_traits = __gnu_cxx___alloc_traits;
pub type std__Bvector_base__Bit_pointer = [u8; 0usize];
#[repr(C)]
pub struct std__Bvector_base__Bvector_impl_data {
    pub _M_start: std__Bit_iterator,
    pub _M_finish: std__Bit_iterator,
    pub _M_end_of_storage: std__Bvector_base__Bit_pointer,
}
#[repr(C)]
pub struct std__Bvector_base__Bvector_impl {
    pub _base_1: std__Bvector_base__Bvector_impl_data,
}
pub type std__Bvector_base_allocator_type<_Alloc> = _Alloc;
pub type std___array_traits__Type<_Tp> = *mut _Tp;
pub type std___array_traits__Is_swappable = std___is_swappable;
pub type std___array_traits__Is_nothrow_swappable = std___is_nothrow_swappable;
pub type std_array_value_type<_Tp> = _Tp;
pub type std_array_pointer<_Tp> = *mut std_array_value_type<_Tp>;
pub type std_array_const_pointer<_Tp> = *const std_array_value_type<_Tp>;
pub type std_array_reference<_Tp> = *mut std_array_value_type<_Tp>;
pub type std_array_const_reference<_Tp> = *const std_array_value_type<_Tp>;
pub type std_array_iterator<_Tp> = *mut std_array_value_type<_Tp>;
pub type std_array_const_iterator<_Tp> = *const std_array_value_type<_Tp>;
pub type std_array_size_type = usize;
pub type std_array_difference_type = isize;
pub type std_array_reverse_iterator<_Tp> = std_reverse_iterator<std_array_iterator<_Tp>>;
pub type std_array_const_reverse_iterator<_Tp> =
    std_reverse_iterator<std_array_const_iterator<_Tp>>;
pub type std__Mem_fn_base__Traits = std__Mem_fn_traits;
pub type std__Mem_fn_base__Arity = std__Mem_fn_base__Traits;
pub type std__Mem_fn_base__Varargs = std__Mem_fn_base__Traits;
pub type std__Mem_fn_base_result_type = std__Mem_fn_base__Traits;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std__Mem_fn {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_bind_expression {
    pub _base: std_false_type,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_placeholder {
    pub _base: u8,
}
extern "C" {
    #[link_name = "\u{1}_ZNSt12placeholders2_1E"]
    pub static std_placeholders__1: u8;
}
extern "C" {
    #[link_name = "\u{1}_ZNSt12placeholders2_2E"]
    pub static std_placeholders__2: u8;
}
extern "C" {
    #[link_name = "\u{1}_ZNSt12placeholders2_3E"]
    pub static std_placeholders__3: u8;
}
extern "C" {
    #[link_name = "\u{1}_ZNSt12placeholders2_4E"]
    pub static std_placeholders__4: u8;
}
extern "C" {
    #[link_name = "\u{1}_ZNSt12placeholders2_5E"]
    pub static std_placeholders__5: u8;
}
extern "C" {
    #[link_name = "\u{1}_ZNSt12placeholders2_6E"]
    pub static std_placeholders__6: u8;
}
extern "C" {
    #[link_name = "\u{1}_ZNSt12placeholders2_7E"]
    pub static std_placeholders__7: u8;
}
extern "C" {
    #[link_name = "\u{1}_ZNSt12placeholders2_8E"]
    pub static std_placeholders__8: u8;
}
extern "C" {
    #[link_name = "\u{1}_ZNSt12placeholders2_9E"]
    pub static std_placeholders__9: u8;
}
extern "C" {
    #[link_name = "\u{1}_ZNSt12placeholders3_10E"]
    pub static std_placeholders__10: u8;
}
extern "C" {
    #[link_name = "\u{1}_ZNSt12placeholders3_11E"]
    pub static std_placeholders__11: u8;
}
extern "C" {
    #[link_name = "\u{1}_ZNSt12placeholders3_12E"]
    pub static std_placeholders__12: u8;
}
extern "C" {
    #[link_name = "\u{1}_ZNSt12placeholders3_13E"]
    pub static std_placeholders__13: u8;
}
extern "C" {
    #[link_name = "\u{1}_ZNSt12placeholders3_14E"]
    pub static std_placeholders__14: u8;
}
extern "C" {
    #[link_name = "\u{1}_ZNSt12placeholders3_15E"]
    pub static std_placeholders__15: u8;
}
extern "C" {
    #[link_name = "\u{1}_ZNSt12placeholders3_16E"]
    pub static std_placeholders__16: u8;
}
extern "C" {
    #[link_name = "\u{1}_ZNSt12placeholders3_17E"]
    pub static std_placeholders__17: u8;
}
extern "C" {
    #[link_name = "\u{1}_ZNSt12placeholders3_18E"]
    pub static std_placeholders__18: u8;
}
extern "C" {
    #[link_name = "\u{1}_ZNSt12placeholders3_19E"]
    pub static std_placeholders__19: u8;
}
extern "C" {
    #[link_name = "\u{1}_ZNSt12placeholders3_20E"]
    pub static std_placeholders__20: u8;
}
extern "C" {
    #[link_name = "\u{1}_ZNSt12placeholders3_21E"]
    pub static std_placeholders__21: u8;
}
extern "C" {
    #[link_name = "\u{1}_ZNSt12placeholders3_22E"]
    pub static std_placeholders__22: u8;
}
extern "C" {
    #[link_name = "\u{1}_ZNSt12placeholders3_23E"]
    pub static std_placeholders__23: u8;
}
extern "C" {
    #[link_name = "\u{1}_ZNSt12placeholders3_24E"]
    pub static std_placeholders__24: u8;
}
extern "C" {
    #[link_name = "\u{1}_ZNSt12placeholders3_25E"]
    pub static std_placeholders__25: u8;
}
extern "C" {
    #[link_name = "\u{1}_ZNSt12placeholders3_26E"]
    pub static std_placeholders__26: u8;
}
extern "C" {
    #[link_name = "\u{1}_ZNSt12placeholders3_27E"]
    pub static std_placeholders__27: u8;
}
extern "C" {
    #[link_name = "\u{1}_ZNSt12placeholders3_28E"]
    pub static std_placeholders__28: u8;
}
extern "C" {
    #[link_name = "\u{1}_ZNSt12placeholders3_29E"]
    pub static std_placeholders__29: u8;
}
pub type std__Safe_tuple_element_t = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std__Bind {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std__Bind_result {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std__Bind_check_arity {
    pub _address: u8,
}
pub type std___is_socketlike = std___or_;
pub type std__Bind_helper___func_type = std_decay;
pub type std__Bind_helper_type = std__Bind;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std__Bindres_helper {
    pub _address: u8,
}
pub type std__Bindres_helper___functor_type = std_decay;
pub type std__Bindres_helper_type = std__Bind_result;
#[repr(C)]
#[derive(Debug)]
pub struct std__Not_fn<_Fn> {
    pub _M_fn: _Fn,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Fn>>,
}
pub type std__Not_fn___inv_res_t = std___invoke_result;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_byte_like {
    pub _base: std_false_type,
}
#[test]
fn __bindgen_test_layout_std___is_byte_like_open0_std_byte_std_equal_to_open1_std_byte_close1_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<std___is_byte_like>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___is_byte_like)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___is_byte_like>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___is_byte_like)
        )
    );
}
#[test]
fn __bindgen_test_layout_std___is_byte_like_open0_std_byte_std_equal_to_open1_void_close1_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<std___is_byte_like>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___is_byte_like)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___is_byte_like>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___is_byte_like)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_default_searcher {
    pub _M_m: std_tuple,
}
#[repr(C)]
#[derive(Debug)]
pub struct std___boyer_moore_map_base {
    pub _M_bad_char: std_unordered_map,
}
pub type std___boyer_moore_map_base___diff_type<_Tp> = _Tp;
pub type std___boyer_moore_array_base___diff_type<_Tp> = _Tp;
pub type std___boyer_moore_base_t = std___conditional_t;
#[repr(C)]
pub struct std_boyer_moore_searcher<_RAIter> {
    pub _M_pat: _RAIter,
    pub _M_pat_end: _RAIter,
    pub _M_good_suffix: std_vector,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_RAIter>>,
}
pub type std_boyer_moore_searcher__Base = std___boyer_moore_base_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_boyer_moore_horspool_searcher<_RAIter> {
    pub _M_pat: _RAIter,
    pub _M_pat_end: _RAIter,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_RAIter>>,
}
pub type std_boyer_moore_horspool_searcher__Base = std___boyer_moore_base_t;
pub type std_string = std_basic_string<::std::os::raw::c_char>;
pub type std_wstring = std_basic_string<u32>;
pub type std_u16string = std_basic_string<u16>;
pub type std_u32string = std_basic_string<u32>;
pub type std_streamoff = ::std::os::raw::c_long;
pub type std_streamsize = isize;
#[repr(C)]
#[derive(Debug)]
pub struct std_fpos<_StateT> {
    pub _M_off: std_streamoff,
    pub _M_state: _StateT,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_StateT>>,
}
pub type std_streampos = std_fpos<__mbstate_t>;
pub type std_wstreampos = std_fpos<__mbstate_t>;
pub type std_u16streampos = std_fpos<__mbstate_t>;
pub type std_u32streampos = std_fpos<__mbstate_t>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_basic_ios {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_basic_istream {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_basic_ostream {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_basic_iostream {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_basic_filebuf {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_basic_ifstream {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_basic_ofstream {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_basic_fstream {
    pub _address: u8,
}
pub type std_ios = std_basic_ios;
pub type std_streambuf = std_basic_streambuf<::std::os::raw::c_char>;
pub type std_istream = std_basic_istream;
pub type std_ostream = std_basic_ostream;
pub type std_iostream = std_basic_iostream;
pub type std_stringbuf = std_basic_stringbuf;
pub type std_istringstream = std_basic_istringstream;
pub type std_ostringstream = std_basic_ostringstream;
pub type std_stringstream = std_basic_stringstream;
pub type std_filebuf = std_basic_filebuf;
pub type std_ifstream = std_basic_ifstream;
pub type std_ofstream = std_basic_ofstream;
pub type std_fstream = std_basic_fstream;
pub type std_wios = std_basic_ios;
pub type std_wstreambuf = std_basic_streambuf<u32>;
pub type std_wistream = std_basic_istream;
pub type std_wostream = std_basic_ostream;
pub type std_wiostream = std_basic_iostream;
pub type std_wstringbuf = std_basic_stringbuf;
pub type std_wistringstream = std_basic_istringstream;
pub type std_wostringstream = std_basic_ostringstream;
pub type std_wstringstream = std_basic_stringstream;
pub type std_wfilebuf = std_basic_filebuf;
pub type std_wifstream = std_basic_ifstream;
pub type std_wofstream = std_basic_ofstream;
pub type std_wfstream = std_basic_fstream;
#[repr(C)]
#[derive(Debug)]
pub struct std_istream_iterator<_Tp> {
    pub _M_stream: *mut std_istream_iterator_istream_type,
    pub _M_value: _Tp,
    pub _M_ok: bool,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Tp>>,
}
pub type std_istream_iterator_char_type<_CharT> = _CharT;
pub type std_istream_iterator_traits_type<_Traits> = _Traits;
pub type std_istream_iterator_istream_type = std_basic_istream;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_ostream_iterator<_CharT> {
    pub _M_stream: *mut std_ostream_iterator_ostream_type,
    pub _M_string: *const _CharT,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_CharT>>,
}
pub type std_ostream_iterator_char_type<_CharT> = _CharT;
pub type std_ostream_iterator_traits_type<_Traits> = _Traits;
pub type std_ostream_iterator_ostream_type = std_basic_ostream;
pub type std___c_locale = __locale_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_ctype_base {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_ctype {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_ctype_byname {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_codecvt_base {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_codecvt {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_codecvt_byname {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_num_get {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_num_put {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_time_base {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_time_put {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_time_put_byname {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_money_base {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_messages_base {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_char_traits {
    pub _address: u8,
}
#[test]
fn __bindgen_test_layout_std_char_traits_open0_char_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_char_traits>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_char_traits)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_char_traits>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_char_traits)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_char_traits_open0_wchar_t_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_char_traits>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_char_traits)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_char_traits>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_char_traits)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_char_traits_open0_char16_t_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_char_traits>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_char_traits)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_char_traits>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_char_traits)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_char_traits_open0_char32_t_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_char_traits>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_char_traits)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_char_traits>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_char_traits)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_basic_string_view<_CharT> {
    pub _M_len: usize,
    pub _M_str: *const _CharT,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_CharT>>,
}
pub type std_basic_string_view_traits_type<_Traits> = _Traits;
pub type std_basic_string_view_value_type<_CharT> = _CharT;
pub type std_basic_string_view_pointer<_CharT> = *mut std_basic_string_view_value_type<_CharT>;
pub type std_basic_string_view_const_pointer<_CharT> =
    *const std_basic_string_view_value_type<_CharT>;
pub type std_basic_string_view_reference<_CharT> = *mut std_basic_string_view_value_type<_CharT>;
pub type std_basic_string_view_const_reference<_CharT> =
    *const std_basic_string_view_value_type<_CharT>;
pub type std_basic_string_view_const_iterator<_CharT> =
    *const std_basic_string_view_value_type<_CharT>;
pub type std_basic_string_view_iterator<_CharT> = std_basic_string_view_const_iterator<_CharT>;
pub type std_basic_string_view_const_reverse_iterator<_CharT> =
    std_reverse_iterator<std_basic_string_view_const_iterator<_CharT>>;
pub type std_basic_string_view_reverse_iterator<_CharT> =
    std_basic_string_view_const_reverse_iterator<_CharT>;
pub type std_basic_string_view_size_type = usize;
pub type std_basic_string_view_difference_type = isize;
pub type std_string_view = std_basic_string_view<::std::os::raw::c_char>;
pub type std_wstring_view = std_basic_string_view<u32>;
pub type std_u16string_view = std_basic_string_view<u16>;
pub type std_u32string_view = std_basic_string_view<u32>;
#[test]
fn __bindgen_test_layout_std_hash_open0_std_basic_string_view_open1_char_std_char_traits_open2_char_close2_close1_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<std_hash>(),
        1usize,
        concat!("Size of template specialization: ", stringify!(std_hash))
    );
    assert_eq!(
        ::std::mem::align_of::<std_hash>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_hash)
        )
    );
}
#[test]
fn __bindgen_test_layout_std___is_fast_hash_open0_std_hash_open1_std_basic_string_view_open2_char_std_char_traits_open3_char_close3_close2_close1_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<std___is_fast_hash>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___is_fast_hash)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___is_fast_hash>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___is_fast_hash)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_hash_open0_std_basic_string_view_open1_wchar_t_std_char_traits_open2_wchar_t_close2_close1_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<std_hash>(),
        1usize,
        concat!("Size of template specialization: ", stringify!(std_hash))
    );
    assert_eq!(
        ::std::mem::align_of::<std_hash>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_hash)
        )
    );
}
#[test]
fn __bindgen_test_layout_std___is_fast_hash_open0_std_hash_open1_std_basic_string_view_open2_wchar_t_std_char_traits_open3_wchar_t_close3_close2_close1_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<std___is_fast_hash>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___is_fast_hash)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___is_fast_hash>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___is_fast_hash)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_hash_open0_std_basic_string_view_open1_char16_t_std_char_traits_open2_char16_t_close2_close1_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<std_hash>(),
        1usize,
        concat!("Size of template specialization: ", stringify!(std_hash))
    );
    assert_eq!(
        ::std::mem::align_of::<std_hash>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_hash)
        )
    );
}
#[test]
fn __bindgen_test_layout_std___is_fast_hash_open0_std_hash_open1_std_basic_string_view_open2_char16_t_std_char_traits_open3_char16_t_close3_close2_close1_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<std___is_fast_hash>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___is_fast_hash)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___is_fast_hash>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___is_fast_hash)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_hash_open0_std_basic_string_view_open1_char32_t_std_char_traits_open2_char32_t_close2_close1_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<std_hash>(),
        1usize,
        concat!("Size of template specialization: ", stringify!(std_hash))
    );
    assert_eq!(
        ::std::mem::align_of::<std_hash>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_hash)
        )
    );
}
#[test]
fn __bindgen_test_layout_std___is_fast_hash_open0_std_hash_open1_std_basic_string_view_open2_char32_t_std_char_traits_open3_char32_t_close3_close2_close1_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<std___is_fast_hash>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___is_fast_hash)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___is_fast_hash>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___is_fast_hash)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZSt7getlineIcSt11char_traitsIcESaIcEERSt13basic_istreamIT_T0_ES7_RNSt7__cxx1112basic_stringIS4_S5_T1_EES4_"]
    pub fn std_getline(
        __in: *mut std_basic_istream,
        __str: *mut std_basic_string<::std::os::raw::c_char>,
        __delim: ::std::os::raw::c_char,
    ) -> *mut std_basic_istream;
}
extern "C" {
    #[link_name = "\u{1}_ZSt7getlineIwSt11char_traitsIwESaIwEERSt13basic_istreamIT_T0_ES7_RNSt7__cxx1112basic_stringIS4_S5_T1_EES4_"]
    pub fn std_getline1(
        __in: *mut std_basic_istream,
        __str: *mut std_basic_string<u32>,
        __delim: u32,
    ) -> *mut std_basic_istream;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___str_hash_base {
    pub _address: u8,
}
#[test]
fn __bindgen_test_layout_std___is_fast_hash_open0_std_hash_open1_std_basic_string_open2_char_std_char_traits_open3_char_close3_std_allocator_open3_char_close3_close2_close1_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<std___is_fast_hash>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___is_fast_hash)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___is_fast_hash>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___is_fast_hash)
        )
    );
}
#[test]
fn __bindgen_test_layout_std___is_fast_hash_open0_std_hash_open1_std_basic_string_open2_wchar_t_std_char_traits_open3_wchar_t_close3_std_allocator_open3_wchar_t_close3_close2_close1_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<std___is_fast_hash>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___is_fast_hash)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___is_fast_hash>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___is_fast_hash)
        )
    );
}
#[test]
fn __bindgen_test_layout_std___is_fast_hash_open0_std_hash_open1_std_basic_string_open2_char16_t_std_char_traits_open3_char16_t_close3_std_allocator_open3_char16_t_close3_close2_close1_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<std___is_fast_hash>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___is_fast_hash)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___is_fast_hash>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___is_fast_hash)
        )
    );
}
#[test]
fn __bindgen_test_layout_std___is_fast_hash_open0_std_hash_open1_std_basic_string_open2_char32_t_std_char_traits_open3_char32_t_close3_std_allocator_open3_char32_t_close3_close2_close1_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<std___is_fast_hash>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___is_fast_hash)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___is_fast_hash>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___is_fast_hash)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}npos"]
    pub static std_npos: std_basic_string_size_type;
}
#[test]
fn __bindgen_test_layout_std_basic_string_open0_char_std_char_traits_open1_char_close1_std_allocator_open1_char_close1_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<std_basic_string<::std::os::raw::c_char>>(),
        32usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_basic_string<::std::os::raw::c_char>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_basic_string<::std::os::raw::c_char>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_basic_string<::std::os::raw::c_char>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_basic_string_open0_wchar_t_std_char_traits_open1_wchar_t_close1_std_allocator_open1_wchar_t_close1_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<std_basic_string<u32>>(),
        32usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_basic_string<u32>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_basic_string<u32>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_basic_string<u32>)
        )
    );
}
#[repr(C)]
#[derive(Debug)]
pub struct std_locale {
    pub _M_impl: *mut std_locale__Impl,
}
pub type std_locale_category = ::std::os::raw::c_int;
pub const std_locale__S_categories_size: std_locale__bindgen_ty_1 = 12;
pub type std_locale__bindgen_ty_1 = ::std::os::raw::c_uint;
pub const std_locale_none: std_locale_category = 0;
pub const std_locale_ctype: std_locale_category = 1;
pub const std_locale_numeric: std_locale_category = 2;
pub const std_locale_collate: std_locale_category = 4;
pub const std_locale_time: std_locale_category = 8;
pub const std_locale_monetary: std_locale_category = 16;
pub const std_locale_messages: std_locale_category = 32;
pub const std_locale_all: std_locale_category = 63;
extern "C" {
    #[link_name = "\u{1}_ZNSt6locale10_S_classicE"]
    pub static mut std_locale__S_classic: *mut std_locale__Impl;
}
extern "C" {
    #[link_name = "\u{1}_ZNSt6locale9_S_globalE"]
    pub static mut std_locale__S_global: *mut std_locale__Impl;
}
extern "C" {
    #[link_name = "\u{1}_ZNSt6locale13_S_categoriesE"]
    pub static std_locale__S_categories: *const *const ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_ZNSt6locale7_S_onceE"]
    pub static mut std_locale__S_once: __gthread_once_t;
}
extern "C" {
    #[link_name = "\u{1}_ZNSt6locale17_S_twinned_facetsE"]
    pub static std_locale__S_twinned_facets: [*const std_locale_id; 0usize];
}
#[test]
fn bindgen_test_layout_std_locale() {
    const UNINIT: ::std::mem::MaybeUninit<std_locale> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<std_locale>(),
        8usize,
        concat!("Size of: ", stringify!(std_locale))
    );
    assert_eq!(
        ::std::mem::align_of::<std_locale>(),
        8usize,
        concat!("Alignment of ", stringify!(std_locale))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._M_impl) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(std_locale),
            "::",
            stringify!(_M_impl)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNKSt6locale4nameB5cxx11Ev"]
    pub fn std_locale_name(this: *const std_locale) -> std_string;
}
extern "C" {
    #[link_name = "\u{1}_ZNSt6locale6globalERKS_"]
    pub fn std_locale_global(__loc: *const std_locale) -> std_locale;
}
extern "C" {
    #[link_name = "\u{1}_ZNSt6locale7classicEv"]
    pub fn std_locale_classic() -> *const std_locale;
}
extern "C" {
    #[link_name = "\u{1}_ZNSt6localeC1Ev"]
    pub fn std_locale_locale(this: *mut std_locale);
}
extern "C" {
    #[link_name = "\u{1}_ZNSt6localeC1ERKS_"]
    pub fn std_locale_locale1(this: *mut std_locale, __other: *const std_locale);
}
extern "C" {
    #[link_name = "\u{1}_ZNSt6localeC1EPKc"]
    pub fn std_locale_locale2(this: *mut std_locale, __s: *const ::std::os::raw::c_char);
}
extern "C" {
    #[link_name = "\u{1}_ZNSt6localeC1ERKS_PKci"]
    pub fn std_locale_locale3(
        this: *mut std_locale,
        __base: *const std_locale,
        __s: *const ::std::os::raw::c_char,
        __cat: std_locale_category,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNSt6localeC1ERKS_S1_i"]
    pub fn std_locale_locale4(
        this: *mut std_locale,
        __base: *const std_locale,
        __add: *const std_locale,
        __cat: std_locale_category,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNSt6localeD1Ev"]
    pub fn std_locale_locale_destructor(this: *mut std_locale);
}
impl std_locale {
    #[inline]
    pub unsafe fn name(&self) -> std_string {
        std_locale_name(self)
    }
    #[inline]
    pub unsafe fn global(__loc: *const std_locale) -> std_locale {
        std_locale_global(__loc)
    }
    #[inline]
    pub unsafe fn classic() -> *const std_locale {
        std_locale_classic()
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        std_locale_locale(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(__other: *const std_locale) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        std_locale_locale1(__bindgen_tmp.as_mut_ptr(), __other);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new2(__s: *const ::std::os::raw::c_char) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        std_locale_locale2(__bindgen_tmp.as_mut_ptr(), __s);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new3(
        __base: *const std_locale,
        __s: *const ::std::os::raw::c_char,
        __cat: std_locale_category,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        std_locale_locale3(__bindgen_tmp.as_mut_ptr(), __base, __s, __cat);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new4(
        __base: *const std_locale,
        __add: *const std_locale,
        __cat: std_locale_category,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        std_locale_locale4(__bindgen_tmp.as_mut_ptr(), __base, __add, __cat);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn destruct(&mut self) {
        std_locale_locale_destructor(self)
    }
}
#[repr(C)]
pub struct std_locale_facet__bindgen_vtable(::std::os::raw::c_void);
#[repr(C)]
#[derive(Debug)]
pub struct std_locale_facet {
    pub vtable_: *const std_locale_facet__bindgen_vtable,
    pub _M_refcount: _Atomic_word,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_locale_facet___shim {
    _unused: [u8; 0],
}
extern "C" {
    #[link_name = "\u{1}_ZNSt6locale5facet11_S_c_localeE"]
    pub static mut std_locale_facet__S_c_locale: std___c_locale;
}
extern "C" {
    #[link_name = "\u{1}_ZNSt6locale5facet9_S_c_nameE"]
    pub static std_locale_facet__S_c_name: [::std::os::raw::c_char; 2usize];
}
extern "C" {
    #[link_name = "\u{1}_ZNSt6locale5facet7_S_onceE"]
    pub static mut std_locale_facet__S_once: __gthread_once_t;
}
#[test]
fn bindgen_test_layout_std_locale_facet() {
    const UNINIT: ::std::mem::MaybeUninit<std_locale_facet> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<std_locale_facet>(),
        16usize,
        concat!("Size of: ", stringify!(std_locale_facet))
    );
    assert_eq!(
        ::std::mem::align_of::<std_locale_facet>(),
        8usize,
        concat!("Alignment of ", stringify!(std_locale_facet))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._M_refcount) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(std_locale_facet),
            "::",
            stringify!(_M_refcount)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNSt6locale5facet18_S_create_c_localeERP15__locale_structPKcS2_"]
    pub fn std_locale_facet__S_create_c_locale(
        __cloc: *mut std___c_locale,
        __s: *const ::std::os::raw::c_char,
        __old: std___c_locale,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNSt6locale5facet17_S_clone_c_localeERP15__locale_struct"]
    pub fn std_locale_facet__S_clone_c_locale(__cloc: *mut std___c_locale) -> std___c_locale;
}
extern "C" {
    #[link_name = "\u{1}_ZNSt6locale5facet19_S_destroy_c_localeERP15__locale_struct"]
    pub fn std_locale_facet__S_destroy_c_locale(__cloc: *mut std___c_locale);
}
extern "C" {
    #[link_name = "\u{1}_ZNSt6locale5facet20_S_lc_ctype_c_localeEP15__locale_structPKc"]
    pub fn std_locale_facet__S_lc_ctype_c_locale(
        __cloc: std___c_locale,
        __s: *const ::std::os::raw::c_char,
    ) -> std___c_locale;
}
extern "C" {
    #[link_name = "\u{1}_ZNSt6locale5facet15_S_get_c_localeEv"]
    pub fn std_locale_facet__S_get_c_locale() -> std___c_locale;
}
extern "C" {
    #[link_name = "\u{1}_ZNSt6locale5facet13_S_get_c_nameEv"]
    pub fn std_locale_facet__S_get_c_name() -> *const ::std::os::raw::c_char;
}
impl std_locale_facet {
    #[inline]
    pub unsafe fn _S_create_c_locale(
        __cloc: *mut std___c_locale,
        __s: *const ::std::os::raw::c_char,
        __old: std___c_locale,
    ) {
        std_locale_facet__S_create_c_locale(__cloc, __s, __old)
    }
    #[inline]
    pub unsafe fn _S_clone_c_locale(__cloc: *mut std___c_locale) -> std___c_locale {
        std_locale_facet__S_clone_c_locale(__cloc)
    }
    #[inline]
    pub unsafe fn _S_destroy_c_locale(__cloc: *mut std___c_locale) {
        std_locale_facet__S_destroy_c_locale(__cloc)
    }
    #[inline]
    pub unsafe fn _S_lc_ctype_c_locale(
        __cloc: std___c_locale,
        __s: *const ::std::os::raw::c_char,
    ) -> std___c_locale {
        std_locale_facet__S_lc_ctype_c_locale(__cloc, __s)
    }
    #[inline]
    pub unsafe fn _S_get_c_locale() -> std___c_locale {
        std_locale_facet__S_get_c_locale()
    }
    #[inline]
    pub unsafe fn _S_get_c_name() -> *const ::std::os::raw::c_char {
        std_locale_facet__S_get_c_name()
    }
}
extern "C" {
    #[link_name = "\u{1}_ZNSt6locale5facetD1Ev"]
    pub fn std_locale_facet_facet_destructor(this: *mut std_locale_facet);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_locale_id {
    pub _M_index: usize,
}
extern "C" {
    #[link_name = "\u{1}_ZNSt6locale2id11_S_refcountE"]
    pub static mut std_locale_id__S_refcount: _Atomic_word;
}
#[test]
fn bindgen_test_layout_std_locale_id() {
    const UNINIT: ::std::mem::MaybeUninit<std_locale_id> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<std_locale_id>(),
        8usize,
        concat!("Size of: ", stringify!(std_locale_id))
    );
    assert_eq!(
        ::std::mem::align_of::<std_locale_id>(),
        8usize,
        concat!("Alignment of ", stringify!(std_locale_id))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._M_index) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(std_locale_id),
            "::",
            stringify!(_M_index)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNKSt6locale2id5_M_idEv"]
    pub fn std_locale_id__M_id(this: *const std_locale_id) -> usize;
}
impl std_locale_id {
    #[inline]
    pub unsafe fn _M_id(&self) -> usize {
        std_locale_id__M_id(self)
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct std_locale__Impl {
    pub _M_refcount: _Atomic_word,
    pub _M_facets: *mut *const std_locale_facet,
    pub _M_facets_size: usize,
    pub _M_caches: *mut *const std_locale_facet,
    pub _M_names: *mut *mut ::std::os::raw::c_char,
}
extern "C" {
    #[link_name = "\u{1}_ZNSt6locale5_Impl11_S_id_ctypeE"]
    pub static std_locale__Impl__S_id_ctype: [*const std_locale_id; 0usize];
}
extern "C" {
    #[link_name = "\u{1}_ZNSt6locale5_Impl13_S_id_numericE"]
    pub static std_locale__Impl__S_id_numeric: [*const std_locale_id; 0usize];
}
extern "C" {
    #[link_name = "\u{1}_ZNSt6locale5_Impl13_S_id_collateE"]
    pub static std_locale__Impl__S_id_collate: [*const std_locale_id; 0usize];
}
extern "C" {
    #[link_name = "\u{1}_ZNSt6locale5_Impl10_S_id_timeE"]
    pub static std_locale__Impl__S_id_time: [*const std_locale_id; 0usize];
}
extern "C" {
    #[link_name = "\u{1}_ZNSt6locale5_Impl14_S_id_monetaryE"]
    pub static std_locale__Impl__S_id_monetary: [*const std_locale_id; 0usize];
}
extern "C" {
    #[link_name = "\u{1}_ZNSt6locale5_Impl14_S_id_messagesE"]
    pub static std_locale__Impl__S_id_messages: [*const std_locale_id; 0usize];
}
extern "C" {
    #[link_name = "\u{1}_ZNSt6locale5_Impl19_S_facet_categoriesE"]
    pub static std_locale__Impl__S_facet_categories: [*const *const std_locale_id; 0usize];
}
#[test]
fn bindgen_test_layout_std_locale__Impl() {
    const UNINIT: ::std::mem::MaybeUninit<std_locale__Impl> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<std_locale__Impl>(),
        40usize,
        concat!("Size of: ", stringify!(std_locale__Impl))
    );
    assert_eq!(
        ::std::mem::align_of::<std_locale__Impl>(),
        8usize,
        concat!("Alignment of ", stringify!(std_locale__Impl))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._M_refcount) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(std_locale__Impl),
            "::",
            stringify!(_M_refcount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._M_facets) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(std_locale__Impl),
            "::",
            stringify!(_M_facets)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._M_facets_size) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(std_locale__Impl),
            "::",
            stringify!(_M_facets_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._M_caches) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(std_locale__Impl),
            "::",
            stringify!(_M_caches)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._M_names) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(std_locale__Impl),
            "::",
            stringify!(_M_names)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}id"]
    pub static mut std_id: std_locale_id;
}
#[test]
fn __bindgen_test_layout_std_collate_open0_char_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_collate>(),
        24usize,
        concat!("Size of template specialization: ", stringify!(std_collate))
    );
    assert_eq!(
        ::std::mem::align_of::<std_collate>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_collate)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_collate_byname_open0_char_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_collate_byname>(),
        24usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_collate_byname)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_collate_byname>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_collate_byname)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_collate_open0_wchar_t_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_collate>(),
        24usize,
        concat!("Size of template specialization: ", stringify!(std_collate))
    );
    assert_eq!(
        ::std::mem::align_of::<std_collate>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_collate)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_collate_byname_open0_wchar_t_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_collate_byname>(),
        24usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_collate_byname)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_collate_byname>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_collate_byname)
        )
    );
}
pub const std_errc_address_family_not_supported: std_errc = 97;
pub const std_errc_address_in_use: std_errc = 98;
pub const std_errc_address_not_available: std_errc = 99;
pub const std_errc_already_connected: std_errc = 106;
pub const std_errc_argument_list_too_long: std_errc = 7;
pub const std_errc_argument_out_of_domain: std_errc = 33;
pub const std_errc_bad_address: std_errc = 14;
pub const std_errc_bad_file_descriptor: std_errc = 9;
pub const std_errc_bad_message: std_errc = 74;
pub const std_errc_broken_pipe: std_errc = 32;
pub const std_errc_connection_aborted: std_errc = 103;
pub const std_errc_connection_already_in_progress: std_errc = 114;
pub const std_errc_connection_refused: std_errc = 111;
pub const std_errc_connection_reset: std_errc = 104;
pub const std_errc_cross_device_link: std_errc = 18;
pub const std_errc_destination_address_required: std_errc = 89;
pub const std_errc_device_or_resource_busy: std_errc = 16;
pub const std_errc_directory_not_empty: std_errc = 39;
pub const std_errc_executable_format_error: std_errc = 8;
pub const std_errc_file_exists: std_errc = 17;
pub const std_errc_file_too_large: std_errc = 27;
pub const std_errc_filename_too_long: std_errc = 36;
pub const std_errc_function_not_supported: std_errc = 38;
pub const std_errc_host_unreachable: std_errc = 113;
pub const std_errc_identifier_removed: std_errc = 43;
pub const std_errc_illegal_byte_sequence: std_errc = 84;
pub const std_errc_inappropriate_io_control_operation: std_errc = 25;
pub const std_errc_interrupted: std_errc = 4;
pub const std_errc_invalid_argument: std_errc = 22;
pub const std_errc_invalid_seek: std_errc = 29;
pub const std_errc_io_error: std_errc = 5;
pub const std_errc_is_a_directory: std_errc = 21;
pub const std_errc_message_size: std_errc = 90;
pub const std_errc_network_down: std_errc = 100;
pub const std_errc_network_reset: std_errc = 102;
pub const std_errc_network_unreachable: std_errc = 101;
pub const std_errc_no_buffer_space: std_errc = 105;
pub const std_errc_no_child_process: std_errc = 10;
pub const std_errc_no_link: std_errc = 67;
pub const std_errc_no_lock_available: std_errc = 37;
pub const std_errc_no_message_available: std_errc = 61;
pub const std_errc_no_message: std_errc = 42;
pub const std_errc_no_protocol_option: std_errc = 92;
pub const std_errc_no_space_on_device: std_errc = 28;
pub const std_errc_no_stream_resources: std_errc = 63;
pub const std_errc_no_such_device_or_address: std_errc = 6;
pub const std_errc_no_such_device: std_errc = 19;
pub const std_errc_no_such_file_or_directory: std_errc = 2;
pub const std_errc_no_such_process: std_errc = 3;
pub const std_errc_not_a_directory: std_errc = 20;
pub const std_errc_not_a_socket: std_errc = 88;
pub const std_errc_not_a_stream: std_errc = 60;
pub const std_errc_not_connected: std_errc = 107;
pub const std_errc_not_enough_memory: std_errc = 12;
pub const std_errc_not_supported: std_errc = 95;
pub const std_errc_operation_canceled: std_errc = 125;
pub const std_errc_operation_in_progress: std_errc = 115;
pub const std_errc_operation_not_permitted: std_errc = 1;
pub const std_errc_operation_not_supported: std_errc = 95;
pub const std_errc_operation_would_block: std_errc = 11;
pub const std_errc_owner_dead: std_errc = 130;
pub const std_errc_permission_denied: std_errc = 13;
pub const std_errc_protocol_error: std_errc = 71;
pub const std_errc_protocol_not_supported: std_errc = 93;
pub const std_errc_read_only_file_system: std_errc = 30;
pub const std_errc_resource_deadlock_would_occur: std_errc = 35;
pub const std_errc_resource_unavailable_try_again: std_errc = 11;
pub const std_errc_result_out_of_range: std_errc = 34;
pub const std_errc_state_not_recoverable: std_errc = 131;
pub const std_errc_stream_timeout: std_errc = 62;
pub const std_errc_text_file_busy: std_errc = 26;
pub const std_errc_timed_out: std_errc = 110;
pub const std_errc_too_many_files_open_in_system: std_errc = 23;
pub const std_errc_too_many_files_open: std_errc = 24;
pub const std_errc_too_many_links: std_errc = 31;
pub const std_errc_too_many_symbolic_link_levels: std_errc = 40;
pub const std_errc_value_too_large: std_errc = 75;
pub const std_errc_wrong_protocol_type: std_errc = 91;
pub type std_errc = ::std::os::raw::c_int;
#[repr(C)]
pub struct std___cow_string {
    pub __bindgen_anon_1: std___cow_string__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union std___cow_string__bindgen_ty_1 {
    pub _M_p: *const ::std::os::raw::c_char,
    pub _M_bytes: [::std::os::raw::c_char; 8usize],
}
#[test]
fn bindgen_test_layout_std___cow_string__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<std___cow_string__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<std___cow_string__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(std___cow_string__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<std___cow_string__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(std___cow_string__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._M_p) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(std___cow_string__bindgen_ty_1),
            "::",
            stringify!(_M_p)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._M_bytes) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(std___cow_string__bindgen_ty_1),
            "::",
            stringify!(_M_bytes)
        )
    );
}
#[test]
fn bindgen_test_layout_std___cow_string() {
    assert_eq!(
        ::std::mem::size_of::<std___cow_string>(),
        8usize,
        concat!("Size of: ", stringify!(std___cow_string))
    );
    assert_eq!(
        ::std::mem::align_of::<std___cow_string>(),
        8usize,
        concat!("Alignment of ", stringify!(std___cow_string))
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNSt12__cow_stringC1Ev"]
    pub fn std___cow_string___cow_string(this: *mut std___cow_string);
}
extern "C" {
    #[link_name = "\u{1}_ZNSt12__cow_stringC1ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE"]
    pub fn std___cow_string___cow_string1(this: *mut std___cow_string, arg1: *const std_string);
}
extern "C" {
    #[link_name = "\u{1}_ZNSt12__cow_stringC1EPKcm"]
    pub fn std___cow_string___cow_string2(
        this: *mut std___cow_string,
        arg1: *const ::std::os::raw::c_char,
        arg2: usize,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNSt12__cow_stringC1ERKS_"]
    pub fn std___cow_string___cow_string3(
        this: *mut std___cow_string,
        arg1: *const std___cow_string,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNSt12__cow_stringC1EOS_"]
    pub fn std___cow_string___cow_string4(this: *mut std___cow_string, arg1: *mut std___cow_string);
}
extern "C" {
    #[link_name = "\u{1}_ZNSt12__cow_stringD1Ev"]
    pub fn std___cow_string___cow_string_destructor(this: *mut std___cow_string);
}
impl std___cow_string {
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        std___cow_string___cow_string(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(arg1: *const std_string) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        std___cow_string___cow_string1(__bindgen_tmp.as_mut_ptr(), arg1);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new2(arg1: *const ::std::os::raw::c_char, arg2: usize) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        std___cow_string___cow_string2(__bindgen_tmp.as_mut_ptr(), arg1, arg2);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new3(arg1: *const std___cow_string) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        std___cow_string___cow_string3(__bindgen_tmp.as_mut_ptr(), arg1);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new4(arg1: *mut std___cow_string) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        std___cow_string___cow_string4(__bindgen_tmp.as_mut_ptr(), arg1);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn destruct(&mut self) {
        std___cow_string___cow_string_destructor(self)
    }
}
pub type std___sso_string = std_basic_string<::std::os::raw::c_char>;
#[repr(C)]
pub struct std_logic_error {
    pub _base: exception,
    pub _M_msg: std___cow_string,
}
#[test]
fn bindgen_test_layout_std_logic_error() {
    const UNINIT: ::std::mem::MaybeUninit<std_logic_error> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<std_logic_error>(),
        16usize,
        concat!("Size of: ", stringify!(std_logic_error))
    );
    assert_eq!(
        ::std::mem::align_of::<std_logic_error>(),
        8usize,
        concat!("Alignment of ", stringify!(std_logic_error))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._M_msg) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(std_logic_error),
            "::",
            stringify!(_M_msg)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNSt11logic_errorC1ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE"]
    pub fn std_logic_error_logic_error(this: *mut std_logic_error, __arg: *const std_string);
}
extern "C" {
    #[link_name = "\u{1}_ZNSt11logic_errorC1EPKc"]
    pub fn std_logic_error_logic_error1(
        this: *mut std_logic_error,
        arg1: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNSt11logic_errorC1EOS_"]
    pub fn std_logic_error_logic_error2(this: *mut std_logic_error, arg1: *mut std_logic_error);
}
extern "C" {
    #[link_name = "\u{1}_ZNSt11logic_errorC1ERKS_"]
    pub fn std_logic_error_logic_error3(this: *mut std_logic_error, arg1: *const std_logic_error);
}
impl std_logic_error {
    #[inline]
    pub unsafe fn new(__arg: *const std_string) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        std_logic_error_logic_error(__bindgen_tmp.as_mut_ptr(), __arg);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(arg1: *const ::std::os::raw::c_char) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        std_logic_error_logic_error1(__bindgen_tmp.as_mut_ptr(), arg1);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new2(arg1: *mut std_logic_error) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        std_logic_error_logic_error2(__bindgen_tmp.as_mut_ptr(), arg1);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new3(arg1: *const std_logic_error) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        std_logic_error_logic_error3(__bindgen_tmp.as_mut_ptr(), arg1);
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[link_name = "\u{1}_ZNSt11logic_errorD1Ev"]
    pub fn std_logic_error_logic_error_destructor(this: *mut std_logic_error);
}
extern "C" {
    #[link_name = "\u{1}_ZNKSt11logic_error4whatEv"]
    pub fn std_logic_error_what(this: *mut ::std::os::raw::c_void)
        -> *const ::std::os::raw::c_char;
}
#[repr(C)]
pub struct std_domain_error {
    pub _base: std_logic_error,
}
#[test]
fn bindgen_test_layout_std_domain_error() {
    assert_eq!(
        ::std::mem::size_of::<std_domain_error>(),
        16usize,
        concat!("Size of: ", stringify!(std_domain_error))
    );
    assert_eq!(
        ::std::mem::align_of::<std_domain_error>(),
        8usize,
        concat!("Alignment of ", stringify!(std_domain_error))
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNSt12domain_errorC1ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE"]
    pub fn std_domain_error_domain_error(this: *mut std_domain_error, __arg: *const std_string);
}
extern "C" {
    #[link_name = "\u{1}_ZNSt12domain_errorC1EPKc"]
    pub fn std_domain_error_domain_error1(
        this: *mut std_domain_error,
        arg1: *const ::std::os::raw::c_char,
    );
}
impl std_domain_error {
    #[inline]
    pub unsafe fn new(__arg: *const std_string) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        std_domain_error_domain_error(__bindgen_tmp.as_mut_ptr(), __arg);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(arg1: *const ::std::os::raw::c_char) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        std_domain_error_domain_error1(__bindgen_tmp.as_mut_ptr(), arg1);
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[link_name = "\u{1}_ZNSt12domain_errorD1Ev"]
    pub fn std_domain_error_domain_error_destructor(this: *mut std_domain_error);
}
#[repr(C)]
pub struct std_invalid_argument {
    pub _base: std_logic_error,
}
#[test]
fn bindgen_test_layout_std_invalid_argument() {
    assert_eq!(
        ::std::mem::size_of::<std_invalid_argument>(),
        16usize,
        concat!("Size of: ", stringify!(std_invalid_argument))
    );
    assert_eq!(
        ::std::mem::align_of::<std_invalid_argument>(),
        8usize,
        concat!("Alignment of ", stringify!(std_invalid_argument))
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNSt16invalid_argumentC1ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE"]
    pub fn std_invalid_argument_invalid_argument(
        this: *mut std_invalid_argument,
        __arg: *const std_string,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNSt16invalid_argumentC1EPKc"]
    pub fn std_invalid_argument_invalid_argument1(
        this: *mut std_invalid_argument,
        arg1: *const ::std::os::raw::c_char,
    );
}
impl std_invalid_argument {
    #[inline]
    pub unsafe fn new(__arg: *const std_string) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        std_invalid_argument_invalid_argument(__bindgen_tmp.as_mut_ptr(), __arg);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(arg1: *const ::std::os::raw::c_char) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        std_invalid_argument_invalid_argument1(__bindgen_tmp.as_mut_ptr(), arg1);
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[link_name = "\u{1}_ZNSt16invalid_argumentD1Ev"]
    pub fn std_invalid_argument_invalid_argument_destructor(this: *mut std_invalid_argument);
}
#[repr(C)]
pub struct std_length_error {
    pub _base: std_logic_error,
}
#[test]
fn bindgen_test_layout_std_length_error() {
    assert_eq!(
        ::std::mem::size_of::<std_length_error>(),
        16usize,
        concat!("Size of: ", stringify!(std_length_error))
    );
    assert_eq!(
        ::std::mem::align_of::<std_length_error>(),
        8usize,
        concat!("Alignment of ", stringify!(std_length_error))
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNSt12length_errorC1ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE"]
    pub fn std_length_error_length_error(this: *mut std_length_error, __arg: *const std_string);
}
extern "C" {
    #[link_name = "\u{1}_ZNSt12length_errorC1EPKc"]
    pub fn std_length_error_length_error1(
        this: *mut std_length_error,
        arg1: *const ::std::os::raw::c_char,
    );
}
impl std_length_error {
    #[inline]
    pub unsafe fn new(__arg: *const std_string) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        std_length_error_length_error(__bindgen_tmp.as_mut_ptr(), __arg);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(arg1: *const ::std::os::raw::c_char) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        std_length_error_length_error1(__bindgen_tmp.as_mut_ptr(), arg1);
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[link_name = "\u{1}_ZNSt12length_errorD1Ev"]
    pub fn std_length_error_length_error_destructor(this: *mut std_length_error);
}
#[repr(C)]
pub struct std_out_of_range {
    pub _base: std_logic_error,
}
#[test]
fn bindgen_test_layout_std_out_of_range() {
    assert_eq!(
        ::std::mem::size_of::<std_out_of_range>(),
        16usize,
        concat!("Size of: ", stringify!(std_out_of_range))
    );
    assert_eq!(
        ::std::mem::align_of::<std_out_of_range>(),
        8usize,
        concat!("Alignment of ", stringify!(std_out_of_range))
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNSt12out_of_rangeC1ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE"]
    pub fn std_out_of_range_out_of_range(this: *mut std_out_of_range, __arg: *const std_string);
}
extern "C" {
    #[link_name = "\u{1}_ZNSt12out_of_rangeC1EPKc"]
    pub fn std_out_of_range_out_of_range1(
        this: *mut std_out_of_range,
        arg1: *const ::std::os::raw::c_char,
    );
}
impl std_out_of_range {
    #[inline]
    pub unsafe fn new(__arg: *const std_string) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        std_out_of_range_out_of_range(__bindgen_tmp.as_mut_ptr(), __arg);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(arg1: *const ::std::os::raw::c_char) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        std_out_of_range_out_of_range1(__bindgen_tmp.as_mut_ptr(), arg1);
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[link_name = "\u{1}_ZNSt12out_of_rangeD1Ev"]
    pub fn std_out_of_range_out_of_range_destructor(this: *mut std_out_of_range);
}
#[repr(C)]
pub struct std_runtime_error {
    pub _base: exception,
    pub _M_msg: std___cow_string,
}
#[test]
fn bindgen_test_layout_std_runtime_error() {
    const UNINIT: ::std::mem::MaybeUninit<std_runtime_error> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<std_runtime_error>(),
        16usize,
        concat!("Size of: ", stringify!(std_runtime_error))
    );
    assert_eq!(
        ::std::mem::align_of::<std_runtime_error>(),
        8usize,
        concat!("Alignment of ", stringify!(std_runtime_error))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._M_msg) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(std_runtime_error),
            "::",
            stringify!(_M_msg)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNSt13runtime_errorC1ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE"]
    pub fn std_runtime_error_runtime_error(this: *mut std_runtime_error, __arg: *const std_string);
}
extern "C" {
    #[link_name = "\u{1}_ZNSt13runtime_errorC1EPKc"]
    pub fn std_runtime_error_runtime_error1(
        this: *mut std_runtime_error,
        arg1: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNSt13runtime_errorC1EOS_"]
    pub fn std_runtime_error_runtime_error2(
        this: *mut std_runtime_error,
        arg1: *mut std_runtime_error,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNSt13runtime_errorC1ERKS_"]
    pub fn std_runtime_error_runtime_error3(
        this: *mut std_runtime_error,
        arg1: *const std_runtime_error,
    );
}
impl std_runtime_error {
    #[inline]
    pub unsafe fn new(__arg: *const std_string) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        std_runtime_error_runtime_error(__bindgen_tmp.as_mut_ptr(), __arg);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(arg1: *const ::std::os::raw::c_char) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        std_runtime_error_runtime_error1(__bindgen_tmp.as_mut_ptr(), arg1);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new2(arg1: *mut std_runtime_error) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        std_runtime_error_runtime_error2(__bindgen_tmp.as_mut_ptr(), arg1);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new3(arg1: *const std_runtime_error) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        std_runtime_error_runtime_error3(__bindgen_tmp.as_mut_ptr(), arg1);
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[link_name = "\u{1}_ZNSt13runtime_errorD1Ev"]
    pub fn std_runtime_error_runtime_error_destructor(this: *mut std_runtime_error);
}
extern "C" {
    #[link_name = "\u{1}_ZNKSt13runtime_error4whatEv"]
    pub fn std_runtime_error_what(
        this: *mut ::std::os::raw::c_void,
    ) -> *const ::std::os::raw::c_char;
}
#[repr(C)]
pub struct std_range_error {
    pub _base: std_runtime_error,
}
#[test]
fn bindgen_test_layout_std_range_error() {
    assert_eq!(
        ::std::mem::size_of::<std_range_error>(),
        16usize,
        concat!("Size of: ", stringify!(std_range_error))
    );
    assert_eq!(
        ::std::mem::align_of::<std_range_error>(),
        8usize,
        concat!("Alignment of ", stringify!(std_range_error))
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNSt11range_errorC1ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE"]
    pub fn std_range_error_range_error(this: *mut std_range_error, __arg: *const std_string);
}
extern "C" {
    #[link_name = "\u{1}_ZNSt11range_errorC1EPKc"]
    pub fn std_range_error_range_error1(
        this: *mut std_range_error,
        arg1: *const ::std::os::raw::c_char,
    );
}
impl std_range_error {
    #[inline]
    pub unsafe fn new(__arg: *const std_string) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        std_range_error_range_error(__bindgen_tmp.as_mut_ptr(), __arg);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(arg1: *const ::std::os::raw::c_char) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        std_range_error_range_error1(__bindgen_tmp.as_mut_ptr(), arg1);
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[link_name = "\u{1}_ZNSt11range_errorD1Ev"]
    pub fn std_range_error_range_error_destructor(this: *mut std_range_error);
}
#[repr(C)]
pub struct std_overflow_error {
    pub _base: std_runtime_error,
}
#[test]
fn bindgen_test_layout_std_overflow_error() {
    assert_eq!(
        ::std::mem::size_of::<std_overflow_error>(),
        16usize,
        concat!("Size of: ", stringify!(std_overflow_error))
    );
    assert_eq!(
        ::std::mem::align_of::<std_overflow_error>(),
        8usize,
        concat!("Alignment of ", stringify!(std_overflow_error))
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNSt14overflow_errorC1ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE"]
    pub fn std_overflow_error_overflow_error(
        this: *mut std_overflow_error,
        __arg: *const std_string,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNSt14overflow_errorC1EPKc"]
    pub fn std_overflow_error_overflow_error1(
        this: *mut std_overflow_error,
        arg1: *const ::std::os::raw::c_char,
    );
}
impl std_overflow_error {
    #[inline]
    pub unsafe fn new(__arg: *const std_string) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        std_overflow_error_overflow_error(__bindgen_tmp.as_mut_ptr(), __arg);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(arg1: *const ::std::os::raw::c_char) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        std_overflow_error_overflow_error1(__bindgen_tmp.as_mut_ptr(), arg1);
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[link_name = "\u{1}_ZNSt14overflow_errorD1Ev"]
    pub fn std_overflow_error_overflow_error_destructor(this: *mut std_overflow_error);
}
#[repr(C)]
pub struct std_underflow_error {
    pub _base: std_runtime_error,
}
#[test]
fn bindgen_test_layout_std_underflow_error() {
    assert_eq!(
        ::std::mem::size_of::<std_underflow_error>(),
        16usize,
        concat!("Size of: ", stringify!(std_underflow_error))
    );
    assert_eq!(
        ::std::mem::align_of::<std_underflow_error>(),
        8usize,
        concat!("Alignment of ", stringify!(std_underflow_error))
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNSt15underflow_errorC1ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE"]
    pub fn std_underflow_error_underflow_error(
        this: *mut std_underflow_error,
        __arg: *const std_string,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNSt15underflow_errorC1EPKc"]
    pub fn std_underflow_error_underflow_error1(
        this: *mut std_underflow_error,
        arg1: *const ::std::os::raw::c_char,
    );
}
impl std_underflow_error {
    #[inline]
    pub unsafe fn new(__arg: *const std_string) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        std_underflow_error_underflow_error(__bindgen_tmp.as_mut_ptr(), __arg);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(arg1: *const ::std::os::raw::c_char) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        std_underflow_error_underflow_error1(__bindgen_tmp.as_mut_ptr(), arg1);
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[link_name = "\u{1}_ZNSt15underflow_errorD1Ev"]
    pub fn std_underflow_error_underflow_error_destructor(this: *mut std_underflow_error);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_error_code_enum {
    pub _base: std_false_type,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_error_condition_enum {
    pub _base: std_false_type,
}
#[test]
fn __bindgen_test_layout_std_is_error_condition_enum_open0_std_errc_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_is_error_condition_enum>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_is_error_condition_enum)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_is_error_condition_enum>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_is_error_condition_enum)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_error_code {
    pub _M_value: ::std::os::raw::c_int,
    pub _M_cat: *const std__V2_error_category,
}
pub type std_error_code__Check = std___enable_if_t;
#[test]
fn bindgen_test_layout_std_error_code() {
    const UNINIT: ::std::mem::MaybeUninit<std_error_code> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<std_error_code>(),
        16usize,
        concat!("Size of: ", stringify!(std_error_code))
    );
    assert_eq!(
        ::std::mem::align_of::<std_error_code>(),
        8usize,
        concat!("Alignment of ", stringify!(std_error_code))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._M_value) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(std_error_code),
            "::",
            stringify!(_M_value)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._M_cat) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(std_error_code),
            "::",
            stringify!(_M_cat)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNKSt10error_code23default_error_conditionEv"]
    pub fn std_error_code_default_error_condition(
        this: *const std_error_code,
    ) -> std_error_condition;
}
impl std_error_code {
    #[inline]
    pub unsafe fn default_error_condition(&self) -> std_error_condition {
        std_error_code_default_error_condition(self)
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_error_condition {
    pub _M_value: ::std::os::raw::c_int,
    pub _M_cat: *const std__V2_error_category,
}
pub type std_error_condition__Check = std___enable_if_t;
#[test]
fn bindgen_test_layout_std_error_condition() {
    const UNINIT: ::std::mem::MaybeUninit<std_error_condition> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<std_error_condition>(),
        16usize,
        concat!("Size of: ", stringify!(std_error_condition))
    );
    assert_eq!(
        ::std::mem::align_of::<std_error_condition>(),
        8usize,
        concat!("Alignment of ", stringify!(std_error_condition))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._M_value) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(std_error_condition),
            "::",
            stringify!(_M_value)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._M_cat) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(std_error_condition),
            "::",
            stringify!(_M_cat)
        )
    );
}
#[repr(C)]
pub struct std_system_error {
    pub _base: std_runtime_error,
    pub _M_code: std_error_code,
}
#[test]
fn bindgen_test_layout_std_system_error() {
    const UNINIT: ::std::mem::MaybeUninit<std_system_error> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<std_system_error>(),
        32usize,
        concat!("Size of: ", stringify!(std_system_error))
    );
    assert_eq!(
        ::std::mem::align_of::<std_system_error>(),
        8usize,
        concat!("Alignment of ", stringify!(std_system_error))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._M_code) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(std_system_error),
            "::",
            stringify!(_M_code)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNSt12system_errorD1Ev"]
    pub fn std_system_error_system_error_destructor(this: *mut std_system_error);
}
#[test]
fn __bindgen_test_layout_std_hash_open0_std_error_code_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_hash>(),
        1usize,
        concat!("Size of template specialization: ", stringify!(std_hash))
    );
    assert_eq!(
        ::std::mem::align_of::<std_hash>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_hash)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_hash_open0_std_error_condition_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_hash>(),
        1usize,
        concat!("Size of template specialization: ", stringify!(std_hash))
    );
    assert_eq!(
        ::std::mem::align_of::<std_hash>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_hash)
        )
    );
}
pub const std__Ios_Fmtflags__S_boolalpha: std__Ios_Fmtflags = 1;
pub const std__Ios_Fmtflags__S_dec: std__Ios_Fmtflags = 2;
pub const std__Ios_Fmtflags__S_fixed: std__Ios_Fmtflags = 4;
pub const std__Ios_Fmtflags__S_hex: std__Ios_Fmtflags = 8;
pub const std__Ios_Fmtflags__S_internal: std__Ios_Fmtflags = 16;
pub const std__Ios_Fmtflags__S_left: std__Ios_Fmtflags = 32;
pub const std__Ios_Fmtflags__S_oct: std__Ios_Fmtflags = 64;
pub const std__Ios_Fmtflags__S_right: std__Ios_Fmtflags = 128;
pub const std__Ios_Fmtflags__S_scientific: std__Ios_Fmtflags = 256;
pub const std__Ios_Fmtflags__S_showbase: std__Ios_Fmtflags = 512;
pub const std__Ios_Fmtflags__S_showpoint: std__Ios_Fmtflags = 1024;
pub const std__Ios_Fmtflags__S_showpos: std__Ios_Fmtflags = 2048;
pub const std__Ios_Fmtflags__S_skipws: std__Ios_Fmtflags = 4096;
pub const std__Ios_Fmtflags__S_unitbuf: std__Ios_Fmtflags = 8192;
pub const std__Ios_Fmtflags__S_uppercase: std__Ios_Fmtflags = 16384;
pub const std__Ios_Fmtflags__S_adjustfield: std__Ios_Fmtflags = 176;
pub const std__Ios_Fmtflags__S_basefield: std__Ios_Fmtflags = 74;
pub const std__Ios_Fmtflags__S_floatfield: std__Ios_Fmtflags = 260;
pub const std__Ios_Fmtflags__S_ios_fmtflags_end: std__Ios_Fmtflags = 65536;
pub const std__Ios_Fmtflags__S_ios_fmtflags_max: std__Ios_Fmtflags = 2147483647;
pub const std__Ios_Fmtflags__S_ios_fmtflags_min: std__Ios_Fmtflags = -2147483648;
pub type std__Ios_Fmtflags = ::std::os::raw::c_int;
pub const std__Ios_Openmode__S_app: std__Ios_Openmode = 1;
pub const std__Ios_Openmode__S_ate: std__Ios_Openmode = 2;
pub const std__Ios_Openmode__S_bin: std__Ios_Openmode = 4;
pub const std__Ios_Openmode__S_in: std__Ios_Openmode = 8;
pub const std__Ios_Openmode__S_out: std__Ios_Openmode = 16;
pub const std__Ios_Openmode__S_trunc: std__Ios_Openmode = 32;
pub const std__Ios_Openmode__S_noreplace: std__Ios_Openmode = 64;
pub const std__Ios_Openmode__S_ios_openmode_end: std__Ios_Openmode = 65536;
pub const std__Ios_Openmode__S_ios_openmode_max: std__Ios_Openmode = 2147483647;
pub const std__Ios_Openmode__S_ios_openmode_min: std__Ios_Openmode = -2147483648;
pub type std__Ios_Openmode = ::std::os::raw::c_int;
pub const std__Ios_Iostate__S_goodbit: std__Ios_Iostate = 0;
pub const std__Ios_Iostate__S_badbit: std__Ios_Iostate = 1;
pub const std__Ios_Iostate__S_eofbit: std__Ios_Iostate = 2;
pub const std__Ios_Iostate__S_failbit: std__Ios_Iostate = 4;
pub const std__Ios_Iostate__S_ios_iostate_end: std__Ios_Iostate = 65536;
pub const std__Ios_Iostate__S_ios_iostate_max: std__Ios_Iostate = 2147483647;
pub const std__Ios_Iostate__S_ios_iostate_min: std__Ios_Iostate = -2147483648;
pub type std__Ios_Iostate = ::std::os::raw::c_int;
pub const std__Ios_Seekdir__S_beg: std__Ios_Seekdir = 0;
pub const std__Ios_Seekdir__S_cur: std__Ios_Seekdir = 1;
pub const std__Ios_Seekdir__S_end: std__Ios_Seekdir = 2;
pub const std__Ios_Seekdir__S_ios_seekdir_end: std__Ios_Seekdir = 65536;
pub type std__Ios_Seekdir = ::std::os::raw::c_uint;
pub const std_io_errc_stream: std_io_errc = 1;
pub type std_io_errc = ::std::os::raw::c_int;
#[test]
fn __bindgen_test_layout_std_is_error_code_enum_open0_std_io_errc_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_is_error_code_enum>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_is_error_code_enum)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_is_error_code_enum>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_is_error_code_enum)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZSt17iostream_categoryv"]
    pub fn std_iostream_category() -> *const std__V2_error_category;
}
#[repr(C)]
pub struct std_ios_base__bindgen_vtable(::std::os::raw::c_void);
#[repr(C)]
#[derive(Debug)]
pub struct std_ios_base {
    pub vtable_: *const std_ios_base__bindgen_vtable,
    pub _M_precision: std_streamsize,
    pub _M_width: std_streamsize,
    pub _M_flags: std_ios_base_fmtflags,
    pub _M_exception: std_ios_base_iostate,
    pub _M_streambuf_state: std_ios_base_iostate,
    pub _M_callbacks: *mut std_ios_base__Callback_list,
    pub _M_word_zero: std_ios_base__Words,
    pub _M_local_word: [std_ios_base__Words; 8usize],
    pub _M_word_size: ::std::os::raw::c_int,
    pub _M_word: *mut std_ios_base__Words,
    pub _M_ios_locale: std_locale,
}
#[repr(C)]
pub struct std_ios_base_failure {
    pub _base: std_system_error,
}
#[test]
fn bindgen_test_layout_std_ios_base_failure() {
    assert_eq!(
        ::std::mem::size_of::<std_ios_base_failure>(),
        32usize,
        concat!("Size of: ", stringify!(std_ios_base_failure))
    );
    assert_eq!(
        ::std::mem::align_of::<std_ios_base_failure>(),
        8usize,
        concat!("Alignment of ", stringify!(std_ios_base_failure))
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNSt8ios_base7failureB5cxx11C1ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE"]
    pub fn std_ios_base_failure_failure(this: *mut std_ios_base_failure, __str: *const std_string);
}
extern "C" {
    #[link_name = "\u{1}_ZNSt8ios_base7failureB5cxx11C1ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEERKSt10error_code"]
    pub fn std_ios_base_failure_failure1(
        this: *mut std_ios_base_failure,
        arg1: *const std_string,
        arg2: *const std_error_code,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNSt8ios_base7failureB5cxx11C1EPKcRKSt10error_code"]
    pub fn std_ios_base_failure_failure2(
        this: *mut std_ios_base_failure,
        arg1: *const ::std::os::raw::c_char,
        arg2: *const std_error_code,
    );
}
impl std_ios_base_failure {
    #[inline]
    pub unsafe fn new(__str: *const std_string) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        std_ios_base_failure_failure(__bindgen_tmp.as_mut_ptr(), __str);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(arg1: *const std_string, arg2: *const std_error_code) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        std_ios_base_failure_failure1(__bindgen_tmp.as_mut_ptr(), arg1, arg2);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new2(arg1: *const ::std::os::raw::c_char, arg2: *const std_error_code) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        std_ios_base_failure_failure2(__bindgen_tmp.as_mut_ptr(), arg1, arg2);
        __bindgen_tmp.assume_init()
    }
}
pub use self::std__Ios_Fmtflags as std_ios_base_fmtflags;
pub use self::std__Ios_Iostate as std_ios_base_iostate;
pub use self::std__Ios_Openmode as std_ios_base_openmode;
pub use self::std__Ios_Seekdir as std_ios_base_seekdir;
pub const std_ios_base_event_erase_event: std_ios_base_event = 0;
pub const std_ios_base_event_imbue_event: std_ios_base_event = 1;
pub const std_ios_base_event_copyfmt_event: std_ios_base_event = 2;
pub type std_ios_base_event = ::std::os::raw::c_uint;
pub type std_ios_base_event_callback = ::std::option::Option<
    unsafe extern "C" fn(
        __e: std_ios_base_event,
        __b: *mut std_ios_base,
        __i: ::std::os::raw::c_int,
    ),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_ios_base__Callback_list {
    pub _M_next: *mut std_ios_base__Callback_list,
    pub _M_fn: std_ios_base_event_callback,
    pub _M_index: ::std::os::raw::c_int,
    pub _M_refcount: _Atomic_word,
}
#[test]
fn bindgen_test_layout_std_ios_base__Callback_list() {
    const UNINIT: ::std::mem::MaybeUninit<std_ios_base__Callback_list> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<std_ios_base__Callback_list>(),
        24usize,
        concat!("Size of: ", stringify!(std_ios_base__Callback_list))
    );
    assert_eq!(
        ::std::mem::align_of::<std_ios_base__Callback_list>(),
        8usize,
        concat!("Alignment of ", stringify!(std_ios_base__Callback_list))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._M_next) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(std_ios_base__Callback_list),
            "::",
            stringify!(_M_next)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._M_fn) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(std_ios_base__Callback_list),
            "::",
            stringify!(_M_fn)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._M_index) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(std_ios_base__Callback_list),
            "::",
            stringify!(_M_index)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._M_refcount) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(std_ios_base__Callback_list),
            "::",
            stringify!(_M_refcount)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_ios_base__Words {
    pub _M_pword: *mut ::std::os::raw::c_void,
    pub _M_iword: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_std_ios_base__Words() {
    const UNINIT: ::std::mem::MaybeUninit<std_ios_base__Words> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<std_ios_base__Words>(),
        16usize,
        concat!("Size of: ", stringify!(std_ios_base__Words))
    );
    assert_eq!(
        ::std::mem::align_of::<std_ios_base__Words>(),
        8usize,
        concat!("Alignment of ", stringify!(std_ios_base__Words))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._M_pword) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(std_ios_base__Words),
            "::",
            stringify!(_M_pword)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._M_iword) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(std_ios_base__Words),
            "::",
            stringify!(_M_iword)
        )
    );
}
pub const std_ios_base__S_local_word_size: std_ios_base__bindgen_ty_1 = 8;
pub type std_ios_base__bindgen_ty_1 = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug)]
pub struct std_ios_base_Init {
    pub _address: u8,
}
extern "C" {
    #[link_name = "\u{1}_ZNSt8ios_base4Init11_S_refcountE"]
    pub static mut std_ios_base_Init__S_refcount: _Atomic_word;
}
extern "C" {
    #[link_name = "\u{1}_ZNSt8ios_base4Init20_S_synced_with_stdioE"]
    pub static mut std_ios_base_Init__S_synced_with_stdio: bool;
}
#[test]
fn bindgen_test_layout_std_ios_base_Init() {
    assert_eq!(
        ::std::mem::size_of::<std_ios_base_Init>(),
        1usize,
        concat!("Size of: ", stringify!(std_ios_base_Init))
    );
    assert_eq!(
        ::std::mem::align_of::<std_ios_base_Init>(),
        1usize,
        concat!("Alignment of ", stringify!(std_ios_base_Init))
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNSt8ios_base4InitC1Ev"]
    pub fn std_ios_base_Init_Init(this: *mut std_ios_base_Init);
}
extern "C" {
    #[link_name = "\u{1}_ZNSt8ios_base4InitD1Ev"]
    pub fn std_ios_base_Init_Init_destructor(this: *mut std_ios_base_Init);
}
impl std_ios_base_Init {
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        std_ios_base_Init_Init(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn destruct(&mut self) {
        std_ios_base_Init_Init_destructor(self)
    }
}
extern "C" {
    #[link_name = "\u{1}_ZNSt8ios_base9boolalphaE"]
    pub static std_ios_base_boolalpha: std_ios_base_fmtflags;
}
extern "C" {
    #[link_name = "\u{1}_ZNSt8ios_base3decE"]
    pub static std_ios_base_dec: std_ios_base_fmtflags;
}
extern "C" {
    #[link_name = "\u{1}_ZNSt8ios_base5fixedE"]
    pub static std_ios_base_fixed: std_ios_base_fmtflags;
}
extern "C" {
    #[link_name = "\u{1}_ZNSt8ios_base3hexE"]
    pub static std_ios_base_hex: std_ios_base_fmtflags;
}
extern "C" {
    #[link_name = "\u{1}_ZNSt8ios_base8internalE"]
    pub static std_ios_base_internal: std_ios_base_fmtflags;
}
extern "C" {
    #[link_name = "\u{1}_ZNSt8ios_base4leftE"]
    pub static std_ios_base_left: std_ios_base_fmtflags;
}
extern "C" {
    #[link_name = "\u{1}_ZNSt8ios_base3octE"]
    pub static std_ios_base_oct: std_ios_base_fmtflags;
}
extern "C" {
    #[link_name = "\u{1}_ZNSt8ios_base5rightE"]
    pub static std_ios_base_right: std_ios_base_fmtflags;
}
extern "C" {
    #[link_name = "\u{1}_ZNSt8ios_base10scientificE"]
    pub static std_ios_base_scientific: std_ios_base_fmtflags;
}
extern "C" {
    #[link_name = "\u{1}_ZNSt8ios_base8showbaseE"]
    pub static std_ios_base_showbase: std_ios_base_fmtflags;
}
extern "C" {
    #[link_name = "\u{1}_ZNSt8ios_base9showpointE"]
    pub static std_ios_base_showpoint: std_ios_base_fmtflags;
}
extern "C" {
    #[link_name = "\u{1}_ZNSt8ios_base7showposE"]
    pub static std_ios_base_showpos: std_ios_base_fmtflags;
}
extern "C" {
    #[link_name = "\u{1}_ZNSt8ios_base6skipwsE"]
    pub static std_ios_base_skipws: std_ios_base_fmtflags;
}
extern "C" {
    #[link_name = "\u{1}_ZNSt8ios_base7unitbufE"]
    pub static std_ios_base_unitbuf: std_ios_base_fmtflags;
}
extern "C" {
    #[link_name = "\u{1}_ZNSt8ios_base9uppercaseE"]
    pub static std_ios_base_uppercase: std_ios_base_fmtflags;
}
extern "C" {
    #[link_name = "\u{1}_ZNSt8ios_base11adjustfieldE"]
    pub static std_ios_base_adjustfield: std_ios_base_fmtflags;
}
extern "C" {
    #[link_name = "\u{1}_ZNSt8ios_base9basefieldE"]
    pub static std_ios_base_basefield: std_ios_base_fmtflags;
}
extern "C" {
    #[link_name = "\u{1}_ZNSt8ios_base10floatfieldE"]
    pub static std_ios_base_floatfield: std_ios_base_fmtflags;
}
extern "C" {
    #[link_name = "\u{1}_ZNSt8ios_base6badbitE"]
    pub static std_ios_base_badbit: std_ios_base_iostate;
}
extern "C" {
    #[link_name = "\u{1}_ZNSt8ios_base6eofbitE"]
    pub static std_ios_base_eofbit: std_ios_base_iostate;
}
extern "C" {
    #[link_name = "\u{1}_ZNSt8ios_base7failbitE"]
    pub static std_ios_base_failbit: std_ios_base_iostate;
}
extern "C" {
    #[link_name = "\u{1}_ZNSt8ios_base7goodbitE"]
    pub static std_ios_base_goodbit: std_ios_base_iostate;
}
extern "C" {
    #[link_name = "\u{1}_ZNSt8ios_base3appE"]
    pub static std_ios_base_app: std_ios_base_openmode;
}
extern "C" {
    #[link_name = "\u{1}_ZNSt8ios_base3ateE"]
    pub static std_ios_base_ate: std_ios_base_openmode;
}
extern "C" {
    #[link_name = "\u{1}_ZNSt8ios_base6binaryE"]
    pub static std_ios_base_binary: std_ios_base_openmode;
}
extern "C" {
    #[link_name = "\u{1}_ZNSt8ios_base2inE"]
    pub static std_ios_base_in: std_ios_base_openmode;
}
extern "C" {
    #[link_name = "\u{1}_ZNSt8ios_base3outE"]
    pub static std_ios_base_out: std_ios_base_openmode;
}
extern "C" {
    #[link_name = "\u{1}_ZNSt8ios_base5truncE"]
    pub static std_ios_base_trunc: std_ios_base_openmode;
}
extern "C" {
    #[link_name = "\u{1}_ZNSt8ios_base11__noreplaceE"]
    pub static std_ios_base___noreplace: std_ios_base_openmode;
}
extern "C" {
    #[link_name = "\u{1}_ZNSt8ios_base3begE"]
    pub static std_ios_base_beg: std_ios_base_seekdir;
}
extern "C" {
    #[link_name = "\u{1}_ZNSt8ios_base3curE"]
    pub static std_ios_base_cur: std_ios_base_seekdir;
}
extern "C" {
    #[link_name = "\u{1}_ZNSt8ios_base3endE"]
    pub static std_ios_base_end: std_ios_base_seekdir;
}
#[test]
fn bindgen_test_layout_std_ios_base() {
    const UNINIT: ::std::mem::MaybeUninit<std_ios_base> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<std_ios_base>(),
        216usize,
        concat!("Size of: ", stringify!(std_ios_base))
    );
    assert_eq!(
        ::std::mem::align_of::<std_ios_base>(),
        8usize,
        concat!("Alignment of ", stringify!(std_ios_base))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._M_precision) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(std_ios_base),
            "::",
            stringify!(_M_precision)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._M_width) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(std_ios_base),
            "::",
            stringify!(_M_width)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._M_flags) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(std_ios_base),
            "::",
            stringify!(_M_flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._M_exception) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(std_ios_base),
            "::",
            stringify!(_M_exception)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._M_streambuf_state) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(std_ios_base),
            "::",
            stringify!(_M_streambuf_state)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._M_callbacks) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(std_ios_base),
            "::",
            stringify!(_M_callbacks)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._M_word_zero) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(std_ios_base),
            "::",
            stringify!(_M_word_zero)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._M_local_word) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(std_ios_base),
            "::",
            stringify!(_M_local_word)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._M_word_size) as usize - ptr as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(std_ios_base),
            "::",
            stringify!(_M_word_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._M_word) as usize - ptr as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(std_ios_base),
            "::",
            stringify!(_M_word)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._M_ios_locale) as usize - ptr as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(std_ios_base),
            "::",
            stringify!(_M_ios_locale)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNSt8ios_base17register_callbackEPFvNS_5eventERS_iEi"]
    pub fn std_ios_base_register_callback(
        this: *mut std_ios_base,
        __fn: std_ios_base_event_callback,
        __index: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNSt8ios_base17_M_call_callbacksENS_5eventE"]
    pub fn std_ios_base__M_call_callbacks(this: *mut std_ios_base, __ev: std_ios_base_event);
}
extern "C" {
    #[link_name = "\u{1}_ZNSt8ios_base20_M_dispose_callbacksEv"]
    pub fn std_ios_base__M_dispose_callbacks(this: *mut std_ios_base);
}
extern "C" {
    #[link_name = "\u{1}_ZNSt8ios_base13_M_grow_wordsEib"]
    pub fn std_ios_base__M_grow_words(
        this: *mut std_ios_base,
        __index: ::std::os::raw::c_int,
        __iword: bool,
    ) -> *mut std_ios_base__Words;
}
extern "C" {
    #[link_name = "\u{1}_ZNSt8ios_base7_M_initEv"]
    pub fn std_ios_base__M_init(this: *mut std_ios_base);
}
extern "C" {
    #[link_name = "\u{1}_ZNSt8ios_base15sync_with_stdioEb"]
    pub fn std_ios_base_sync_with_stdio(__sync: bool) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZNSt8ios_base5imbueERKSt6locale"]
    pub fn std_ios_base_imbue(this: *mut std_ios_base, __loc: *const std_locale) -> std_locale;
}
extern "C" {
    #[link_name = "\u{1}_ZNSt8ios_base6xallocEv"]
    pub fn std_ios_base_xalloc() -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZNSt8ios_base7_M_moveERS_"]
    pub fn std_ios_base__M_move(this: *mut std_ios_base, arg1: *mut std_ios_base);
}
extern "C" {
    #[link_name = "\u{1}_ZNSt8ios_base7_M_swapERS_"]
    pub fn std_ios_base__M_swap(this: *mut std_ios_base, __rhs: *mut std_ios_base);
}
extern "C" {
    #[link_name = "\u{1}_ZNSt8ios_baseC1Ev"]
    pub fn std_ios_base_ios_base(this: *mut std_ios_base);
}
impl std_ios_base {
    #[inline]
    pub unsafe fn register_callback(
        &mut self,
        __fn: std_ios_base_event_callback,
        __index: ::std::os::raw::c_int,
    ) {
        std_ios_base_register_callback(self, __fn, __index)
    }
    #[inline]
    pub unsafe fn _M_call_callbacks(&mut self, __ev: std_ios_base_event) {
        std_ios_base__M_call_callbacks(self, __ev)
    }
    #[inline]
    pub unsafe fn _M_dispose_callbacks(&mut self) {
        std_ios_base__M_dispose_callbacks(self)
    }
    #[inline]
    pub unsafe fn _M_grow_words(
        &mut self,
        __index: ::std::os::raw::c_int,
        __iword: bool,
    ) -> *mut std_ios_base__Words {
        std_ios_base__M_grow_words(self, __index, __iword)
    }
    #[inline]
    pub unsafe fn _M_init(&mut self) {
        std_ios_base__M_init(self)
    }
    #[inline]
    pub unsafe fn sync_with_stdio(__sync: bool) -> bool {
        std_ios_base_sync_with_stdio(__sync)
    }
    #[inline]
    pub unsafe fn imbue(&mut self, __loc: *const std_locale) -> std_locale {
        std_ios_base_imbue(self, __loc)
    }
    #[inline]
    pub unsafe fn xalloc() -> ::std::os::raw::c_int {
        std_ios_base_xalloc()
    }
    #[inline]
    pub unsafe fn _M_move(&mut self, arg1: *mut std_ios_base) {
        std_ios_base__M_move(self, arg1)
    }
    #[inline]
    pub unsafe fn _M_swap(&mut self, __rhs: *mut std_ios_base) {
        std_ios_base__M_swap(self, __rhs)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        std_ios_base_ios_base(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[link_name = "\u{1}_ZNSt8ios_base7failureB5cxx11D1Ev"]
    pub fn std_ios_base_failure_failure_destructor(this: *mut std_ios_base_failure);
}
extern "C" {
    #[link_name = "\u{1}_ZNKSt8ios_base7failureB5cxx114whatEv"]
    pub fn std_ios_base_failure_what(
        this: *mut ::std::os::raw::c_void,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_ZNSt8ios_baseD1Ev"]
    pub fn std_ios_base_ios_base_destructor(this: *mut std_ios_base);
}
#[repr(C)]
pub struct std_basic_streambuf__bindgen_vtable(::std::os::raw::c_void);
#[repr(C)]
#[derive(Debug)]
pub struct std_basic_streambuf<_CharT> {
    pub vtable_: *const std_basic_streambuf__bindgen_vtable,
    pub _M_in_beg: *mut std_basic_streambuf_char_type<_CharT>,
    pub _M_in_cur: *mut std_basic_streambuf_char_type<_CharT>,
    pub _M_in_end: *mut std_basic_streambuf_char_type<_CharT>,
    pub _M_out_beg: *mut std_basic_streambuf_char_type<_CharT>,
    pub _M_out_cur: *mut std_basic_streambuf_char_type<_CharT>,
    pub _M_out_end: *mut std_basic_streambuf_char_type<_CharT>,
    pub _M_buf_locale: std_locale,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_CharT>>,
}
pub type std_basic_streambuf_char_type<_CharT> = _CharT;
pub type std_basic_streambuf_traits_type<_Traits> = _Traits;
pub type std_basic_streambuf_int_type = [u8; 0usize];
pub type std_basic_streambuf_pos_type = [u8; 0usize];
pub type std_basic_streambuf_off_type = [u8; 0usize];
pub type std_basic_streambuf___streambuf_type<_CharT> =
    std_basic_streambuf<std_basic_streambuf_char_type<_CharT>>;
extern "C" {
    #[link_name = "\u{1}_ZSt21__copy_streambufs_eofIcSt11char_traitsIcEElPSt15basic_streambufIT_T0_ES6_Rb"]
    pub fn std___copy_streambufs_eof(
        __sbin: *mut std_basic_streambuf<::std::os::raw::c_char>,
        __sbout: *mut std_basic_streambuf<::std::os::raw::c_char>,
        __ineof: *mut bool,
    ) -> std_streamsize;
}
extern "C" {
    #[link_name = "\u{1}_ZSt21__copy_streambufs_eofIwSt11char_traitsIwEElPSt15basic_streambufIT_T0_ES6_Rb"]
    pub fn std___copy_streambufs_eof1(
        __sbin: *mut std_basic_streambuf<u32>,
        __sbout: *mut std_basic_streambuf<u32>,
        __ineof: *mut bool,
    ) -> std_streamsize;
}
#[test]
fn __bindgen_test_layout_std_basic_streambuf_open0_char_std_char_traits_open1_char_close1_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<std_basic_streambuf<::std::os::raw::c_char>>(),
        64usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_basic_streambuf<::std::os::raw::c_char>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_basic_streambuf<::std::os::raw::c_char>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_basic_streambuf<::std::os::raw::c_char>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_basic_streambuf_open0_wchar_t_std_char_traits_open1_wchar_t_close1_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<std_basic_streambuf<u32>>(),
        64usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_basic_streambuf<u32>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_basic_streambuf<u32>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_basic_streambuf<u32>)
        )
    );
}
#[repr(C)]
pub struct std_istreambuf_iterator<_CharT> {
    pub _M_sbuf: *mut std_istreambuf_iterator_streambuf_type<_CharT>,
    pub _M_c: std_istreambuf_iterator_int_type,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_CharT>>,
}
pub type std_istreambuf_iterator_char_type<_CharT> = _CharT;
pub type std_istreambuf_iterator_traits_type<_Traits> = _Traits;
pub type std_istreambuf_iterator_int_type = [u8; 0usize];
pub type std_istreambuf_iterator_streambuf_type<_CharT> = std_basic_streambuf<_CharT>;
pub type std_istreambuf_iterator_istream_type = std_basic_istream;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_ostreambuf_iterator<_CharT> {
    pub _M_sbuf: *mut std_ostreambuf_iterator_streambuf_type<_CharT>,
    pub _M_failed: bool,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_CharT>>,
}
pub type std_ostreambuf_iterator_char_type<_CharT> = _CharT;
pub type std_ostreambuf_iterator_traits_type<_Traits> = _Traits;
pub type std_ostreambuf_iterator_streambuf_type<_CharT> = std_basic_streambuf<_CharT>;
pub type std_ostreambuf_iterator_ostream_type = std_basic_ostream;
pub const std_float_round_style_round_indeterminate: std_float_round_style = -1;
pub const std_float_round_style_round_toward_zero: std_float_round_style = 0;
pub const std_float_round_style_round_to_nearest: std_float_round_style = 1;
pub const std_float_round_style_round_toward_infinity: std_float_round_style = 2;
pub const std_float_round_style_round_toward_neg_infinity: std_float_round_style = 3;
pub type std_float_round_style = ::std::os::raw::c_int;
pub const std_float_denorm_style_denorm_indeterminate: std_float_denorm_style = -1;
pub const std_float_denorm_style_denorm_absent: std_float_denorm_style = 0;
pub const std_float_denorm_style_denorm_present: std_float_denorm_style = 1;
pub type std_float_denorm_style = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___numeric_limits_base {
    pub _address: u8,
}
pub const std___numeric_limits_base_is_specialized: bool = false;
pub const std___numeric_limits_base_digits: ::std::os::raw::c_int = 0;
pub const std___numeric_limits_base_digits10: ::std::os::raw::c_int = 0;
pub const std___numeric_limits_base_max_digits10: ::std::os::raw::c_int = 0;
pub const std___numeric_limits_base_is_signed: bool = false;
pub const std___numeric_limits_base_is_integer: bool = false;
pub const std___numeric_limits_base_is_exact: bool = false;
pub const std___numeric_limits_base_radix: ::std::os::raw::c_int = 0;
pub const std___numeric_limits_base_min_exponent: ::std::os::raw::c_int = 0;
pub const std___numeric_limits_base_min_exponent10: ::std::os::raw::c_int = 0;
pub const std___numeric_limits_base_max_exponent: ::std::os::raw::c_int = 0;
pub const std___numeric_limits_base_max_exponent10: ::std::os::raw::c_int = 0;
pub const std___numeric_limits_base_has_infinity: bool = false;
pub const std___numeric_limits_base_has_quiet_NaN: bool = false;
pub const std___numeric_limits_base_has_signaling_NaN: bool = false;
extern "C" {
    #[link_name = "\u{1}_ZNSt21__numeric_limits_base10has_denormE"]
    pub static std___numeric_limits_base_has_denorm: std_float_denorm_style;
}
pub const std___numeric_limits_base_has_denorm_loss: bool = false;
pub const std___numeric_limits_base_is_iec559: bool = false;
pub const std___numeric_limits_base_is_bounded: bool = false;
pub const std___numeric_limits_base_is_modulo: bool = false;
pub const std___numeric_limits_base_traps: bool = false;
pub const std___numeric_limits_base_tinyness_before: bool = false;
extern "C" {
    #[link_name = "\u{1}_ZNSt21__numeric_limits_base11round_styleE"]
    pub static std___numeric_limits_base_round_style: std_float_round_style;
}
#[test]
fn bindgen_test_layout_std___numeric_limits_base() {
    assert_eq!(
        ::std::mem::size_of::<std___numeric_limits_base>(),
        1usize,
        concat!("Size of: ", stringify!(std___numeric_limits_base))
    );
    assert_eq!(
        ::std::mem::align_of::<std___numeric_limits_base>(),
        1usize,
        concat!("Alignment of ", stringify!(std___numeric_limits_base))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_numeric_limits {
    pub _address: u8,
}
#[test]
fn __bindgen_test_layout_std_numeric_limits_open0_bool__close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_numeric_limits>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_numeric_limits)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_numeric_limits>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_numeric_limits)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_numeric_limits_open0_char_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_numeric_limits>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_numeric_limits)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_numeric_limits>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_numeric_limits)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_numeric_limits_open0_signed_char_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_numeric_limits>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_numeric_limits)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_numeric_limits>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_numeric_limits)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_numeric_limits_open0_unsigned_char_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_numeric_limits>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_numeric_limits)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_numeric_limits>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_numeric_limits)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_numeric_limits_open0_wchar_t_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_numeric_limits>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_numeric_limits)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_numeric_limits>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_numeric_limits)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_numeric_limits_open0_char16_t_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_numeric_limits>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_numeric_limits)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_numeric_limits>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_numeric_limits)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_numeric_limits_open0_char32_t_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_numeric_limits>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_numeric_limits)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_numeric_limits>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_numeric_limits)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_numeric_limits_open0_short_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_numeric_limits>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_numeric_limits)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_numeric_limits>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_numeric_limits)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_numeric_limits_open0_unsigned_short_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_numeric_limits>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_numeric_limits)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_numeric_limits>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_numeric_limits)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_numeric_limits_open0_int_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_numeric_limits>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_numeric_limits)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_numeric_limits>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_numeric_limits)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_numeric_limits_open0_unsigned_int_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_numeric_limits>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_numeric_limits)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_numeric_limits>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_numeric_limits)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_numeric_limits_open0_long_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_numeric_limits>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_numeric_limits)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_numeric_limits>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_numeric_limits)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_numeric_limits_open0_unsigned_long_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_numeric_limits>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_numeric_limits)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_numeric_limits>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_numeric_limits)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_numeric_limits_open0_long_long_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_numeric_limits>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_numeric_limits)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_numeric_limits>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_numeric_limits)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_numeric_limits_open0_unsigned_long_long_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_numeric_limits>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_numeric_limits)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_numeric_limits>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_numeric_limits)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_numeric_limits_open0___int128_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_numeric_limits>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_numeric_limits)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_numeric_limits>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_numeric_limits)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_numeric_limits_open0_unsigned___int128_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_numeric_limits>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_numeric_limits)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_numeric_limits>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_numeric_limits)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_numeric_limits_open0_float_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_numeric_limits>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_numeric_limits)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_numeric_limits>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_numeric_limits)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_numeric_limits_open0_double_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_numeric_limits>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_numeric_limits)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_numeric_limits>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_numeric_limits)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_numeric_limits_open0_long_double_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_numeric_limits>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_numeric_limits)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_numeric_limits>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_numeric_limits)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_raw_storage_iterator<_OutputIterator> {
    pub _M_iter: _OutputIterator,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_OutputIterator>>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_default_delete {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___uniq_ptr_impl {
    pub _M_t: std_tuple,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___uniq_ptr_impl__Ptr {
    pub _address: u8,
}
pub type std___uniq_ptr_impl__Ptr_type<_Up> = *mut _Up;
pub type std___uniq_ptr_impl__DeleterConstraint = u8;
pub type std___uniq_ptr_impl_pointer = std___uniq_ptr_impl__Ptr;
#[repr(C)]
#[derive(Debug)]
pub struct std_unique_ptr {
    pub _M_t: u8,
}
pub type std_unique_ptr__DeleterConstraint = std___uniq_ptr_impl;
pub type std_unique_ptr_pointer = std___uniq_ptr_impl;
pub type std_unique_ptr_element_type<_Tp> = _Tp;
pub type std_unique_ptr_deleter_type<_Dp> = _Dp;
pub type std_unique_ptr___safe_conversion_up = std___and_;
#[repr(C)]
#[derive(Debug)]
pub struct std___allocated_ptr<_Alloc> {
    pub _M_alloc: *mut _Alloc,
    pub _M_ptr: std___allocated_ptr_pointer,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Alloc>>,
}
pub type std___allocated_ptr_pointer = std_allocator_traits;
pub type std___allocated_ptr_value_type = std_allocator_traits;
#[repr(C)]
#[derive(Debug)]
pub struct std_bad_weak_ptr {
    pub _base: exception,
}
#[test]
fn bindgen_test_layout_std_bad_weak_ptr() {
    assert_eq!(
        ::std::mem::size_of::<std_bad_weak_ptr>(),
        8usize,
        concat!("Size of: ", stringify!(std_bad_weak_ptr))
    );
    assert_eq!(
        ::std::mem::align_of::<std_bad_weak_ptr>(),
        8usize,
        concat!("Alignment of ", stringify!(std_bad_weak_ptr))
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNKSt12bad_weak_ptr4whatEv"]
    pub fn std_bad_weak_ptr_what(
        this: *mut ::std::os::raw::c_void,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_ZNSt12bad_weak_ptrD1Ev"]
    pub fn std_bad_weak_ptr_bad_weak_ptr_destructor(this: *mut std_bad_weak_ptr);
}
pub const std__Mutex_base__S_need_barriers: std__Mutex_base__bindgen_ty_1 = 0;
pub type std__Mutex_base__bindgen_ty_1 = i32;
extern "C" {
    #[link_name = "\u{1}_M_add_ref_lock_nothrow"]
    pub fn std__Sp_counted_base__M_add_ref_lock_nothrow(this: *mut u8) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_M_release"]
    pub fn std__Sp_counted_base__M_release(this: *mut u8);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_owner_less {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std__Sp_counted_deleter__Impl<_Ptr> {
    pub _M_ptr: _Ptr,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Ptr>>,
}
pub type std__Sp_counted_deleter__Impl__Del_base = u8;
pub type std__Sp_counted_deleter__Impl__Alloc_base = u8;
pub type std__Sp_counted_deleter___allocator_type = std___alloc_rebind;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std__Sp_make_shared_tag {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_std__Sp_make_shared_tag() {
    assert_eq!(
        ::std::mem::size_of::<std__Sp_make_shared_tag>(),
        1usize,
        concat!("Size of: ", stringify!(std__Sp_make_shared_tag))
    );
    assert_eq!(
        ::std::mem::align_of::<std__Sp_make_shared_tag>(),
        1usize,
        concat!("Alignment of ", stringify!(std__Sp_make_shared_tag))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std__Sp_alloc_shared_tag<_Alloc> {
    pub _M_a: *const _Alloc,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Alloc>>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std__Sp_counted_ptr_inplace__Impl {
    pub _M_storage: __gnu_cxx___aligned_buffer,
}
pub type std__Sp_counted_ptr_inplace__Impl__A_base = u8;
pub type std__Sp_counted_ptr_inplace___allocator_type = std___alloc_rebind;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___sp_array_delete {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_std___sp_array_delete() {
    assert_eq!(
        ::std::mem::size_of::<std___sp_array_delete>(),
        1usize,
        concat!("Size of: ", stringify!(std___sp_array_delete))
    );
    assert_eq!(
        ::std::mem::align_of::<std___sp_array_delete>(),
        1usize,
        concat!("Alignment of ", stringify!(std___sp_array_delete))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___shared_count___not_alloc_shared_tag {
    pub _address: u8,
}
pub type std___shared_count___not_alloc_shared_tag_type = ::std::os::raw::c_void;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___sp_compatible_with {
    pub _base: std_false_type,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___sp_is_constructible_arr {
    pub _base: std_false_type,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___sp_is_constructible {
    pub _address: u8,
}
pub type std___shared_ptr_access_element_type<_Tp> = _Tp;
pub type std___shared_ptr_element_type = std_remove_extent;
pub type std___shared_ptr__SafeConv = u8;
pub type std___shared_ptr__Compatible = u8;
pub type std___shared_ptr__Assignable = std___shared_ptr__Compatible;
pub type std___shared_ptr__UniqCompatible = std___enable_if_t;
pub type std___shared_ptr__UniqAssignable = std___shared_ptr__UniqCompatible;
pub type std___shared_ptr_weak_type = u8;
pub type std___shared_ptr___esft_base_t = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___shared_ptr___has_esft_base {
    pub _base: std_false_type,
}
pub type std___weak_ptr__Compatible = u8;
pub type std___weak_ptr__Assignable = std___weak_ptr__Compatible;
pub type std___weak_ptr_element_type = std_remove_extent;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std__Sp_owner_less {
    pub _address: u8,
}
#[test]
fn __bindgen_test_layout_std__Sp_owner_less_open0_void_void_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std__Sp_owner_less>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std__Sp_owner_less)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std__Sp_owner_less>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std__Sp_owner_less)
        )
    );
}
pub type std__NonArray = std___enable_if_t;
#[repr(C)]
#[derive(Debug)]
pub struct std_shared_ptr {
    pub _address: u8,
}
pub type std_shared_ptr__Constructible = u8;
pub type std_shared_ptr__Assignable = u8;
pub type std_shared_ptr_element_type = u8;
pub type std_shared_ptr_weak_type = std_weak_ptr;
#[repr(C)]
#[derive(Debug)]
pub struct std_weak_ptr {
    pub _address: u8,
}
pub type std_weak_ptr__Constructible = u8;
pub type std_weak_ptr__Assignable = u8;
#[test]
fn __bindgen_test_layout_std_owner_less_open0_void_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_owner_less>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_owner_less)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_owner_less>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_owner_less)
        )
    );
}
#[repr(C)]
#[derive(Debug)]
pub struct std_enable_shared_from_this {
    pub _M_weak_this: std_weak_ptr,
}
pub const std_memory_order_memory_order_relaxed: std_memory_order = 0;
pub const std_memory_order_memory_order_consume: std_memory_order = 1;
pub const std_memory_order_memory_order_acquire: std_memory_order = 2;
pub const std_memory_order_memory_order_release: std_memory_order = 3;
pub const std_memory_order_memory_order_acq_rel: std_memory_order = 4;
pub const std_memory_order_memory_order_seq_cst: std_memory_order = 5;
pub type std_memory_order = ::std::os::raw::c_uint;
pub const std___memory_order_modifier___memory_order_mask: std___memory_order_modifier = 65535;
pub const std___memory_order_modifier___memory_order_modifier_mask: std___memory_order_modifier =
    4294901760;
pub const std___memory_order_modifier___memory_order_hle_acquire: std___memory_order_modifier =
    65536;
pub const std___memory_order_modifier___memory_order_hle_release: std___memory_order_modifier =
    131072;
pub type std___memory_order_modifier = ::std::os::raw::c_uint;
pub type std___atomic_flag_data_type = bool;
#[repr(C)]
#[derive(Debug)]
pub struct std_atomic_flag {
    pub _base: __atomic_flag_base,
}
#[test]
fn bindgen_test_layout_std_atomic_flag() {
    assert_eq!(
        ::std::mem::size_of::<std_atomic_flag>(),
        1usize,
        concat!("Size of: ", stringify!(std_atomic_flag))
    );
    assert_eq!(
        ::std::mem::align_of::<std_atomic_flag>(),
        1usize,
        concat!("Alignment of ", stringify!(std_atomic_flag))
    );
}
#[repr(C)]
#[derive(Debug)]
pub struct std___atomic_base<_ITp> {
    pub _M_i: std___atomic_base___int_type<_ITp>,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_ITp>>,
}
pub type std___atomic_base_value_type<_ITp> = _ITp;
pub type std___atomic_base_difference_type<_ITp> = std___atomic_base_value_type<_ITp>;
pub type std___atomic_base___int_type<_ITp> = _ITp;
pub type std___atomic_impl__Val = std_remove_volatile;
#[repr(C)]
#[derive(Debug)]
pub struct std__Sp_locker {
    pub _M_key1: ::std::os::raw::c_uchar,
    pub _M_key2: ::std::os::raw::c_uchar,
}
#[test]
fn bindgen_test_layout_std__Sp_locker() {
    const UNINIT: ::std::mem::MaybeUninit<std__Sp_locker> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<std__Sp_locker>(),
        2usize,
        concat!("Size of: ", stringify!(std__Sp_locker))
    );
    assert_eq!(
        ::std::mem::align_of::<std__Sp_locker>(),
        1usize,
        concat!("Alignment of ", stringify!(std__Sp_locker))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._M_key1) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(std__Sp_locker),
            "::",
            stringify!(_M_key1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._M_key2) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(std__Sp_locker),
            "::",
            stringify!(_M_key2)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNSt10_Sp_lockerC1EPKv"]
    pub fn std__Sp_locker__Sp_locker(
        this: *mut std__Sp_locker,
        arg1: *const ::std::os::raw::c_void,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNSt10_Sp_lockerC1EPKvS1_"]
    pub fn std__Sp_locker__Sp_locker1(
        this: *mut std__Sp_locker,
        arg1: *const ::std::os::raw::c_void,
        arg2: *const ::std::os::raw::c_void,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNSt10_Sp_lockerD1Ev"]
    pub fn std__Sp_locker__Sp_locker_destructor(this: *mut std__Sp_locker);
}
impl std__Sp_locker {
    #[inline]
    pub unsafe fn new(arg1: *const ::std::os::raw::c_void) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        std__Sp_locker__Sp_locker(__bindgen_tmp.as_mut_ptr(), arg1);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(
        arg1: *const ::std::os::raw::c_void,
        arg2: *const ::std::os::raw::c_void,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        std__Sp_locker__Sp_locker1(__bindgen_tmp.as_mut_ptr(), arg1, arg2);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn destruct(&mut self) {
        std__Sp_locker__Sp_locker_destructor(self)
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_auto_ptr_ref<_Tp1> {
    pub _M_ptr: *mut _Tp1,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Tp1>>,
}
#[repr(C)]
#[derive(Debug)]
pub struct std_auto_ptr<_Tp> {
    pub _M_ptr: *mut _Tp,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Tp>>,
}
pub type std_auto_ptr_element_type<_Tp> = _Tp;
#[test]
fn __bindgen_test_layout_std_auto_ptr_open0_void_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_auto_ptr<::std::os::raw::c_void>>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_auto_ptr<::std::os::raw::c_void>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_auto_ptr<::std::os::raw::c_void>>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_auto_ptr<::std::os::raw::c_void>)
        )
    );
}
pub const std_pointer_safety_relaxed: std_pointer_safety = 0;
pub const std_pointer_safety_preferred: std_pointer_safety = 1;
pub const std_pointer_safety_strict: std_pointer_safety = 2;
pub type std_pointer_safety = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_nullopt_t {
    pub _address: u8,
}
pub const std_nullopt_t__Construct__Token: std_nullopt_t__Construct = 0;
pub type std_nullopt_t__Construct = ::std::os::raw::c_int;
#[test]
fn bindgen_test_layout_std_nullopt_t() {
    assert_eq!(
        ::std::mem::size_of::<std_nullopt_t>(),
        1usize,
        concat!("Size of: ", stringify!(std_nullopt_t))
    );
    assert_eq!(
        ::std::mem::align_of::<std_nullopt_t>(),
        1usize,
        concat!("Alignment of ", stringify!(std_nullopt_t))
    );
}
extern "C" {
    #[link_name = "\u{1}_ZSt7nullopt"]
    pub static std_nullopt: std_nullopt_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std__Optional_func<_Fn> {
    pub _M_f: *mut _Fn,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Fn>>,
}
#[repr(C)]
#[derive(Debug)]
pub struct std_bad_optional_access {
    pub _base: exception,
}
#[test]
fn bindgen_test_layout_std_bad_optional_access() {
    assert_eq!(
        ::std::mem::size_of::<std_bad_optional_access>(),
        8usize,
        concat!("Size of: ", stringify!(std_bad_optional_access))
    );
    assert_eq!(
        ::std::mem::align_of::<std_bad_optional_access>(),
        8usize,
        concat!("Alignment of ", stringify!(std_bad_optional_access))
    );
}
#[repr(C)]
#[derive(Debug)]
pub struct std__Optional_payload_base {
    pub _M_payload: u8,
    pub _M_engaged: bool,
}
pub type std__Optional_payload_base__Stored_type = std_remove_const_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std__Optional_payload_base__Empty_byte {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std__Optional_base_impl {
    pub _address: u8,
}
pub type std__Optional_base_impl__Stored_type = std_remove_const_t;
pub type std___converts_from_optional = std___or_;
pub type std___assigns_from_optional = std___or_;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_optional {
    pub _address: u8,
}
pub type std_optional__Base = u8;
pub type std_optional___not_self = std___not_;
pub type std_optional___not_tag = std___not_;
pub type std_optional__Requires = std_enable_if_t;
pub type std_optional_value_type<_Tp> = _Tp;
pub type std___optional_relop_t = std_enable_if_t;
pub type std___optional_eq_t = std___optional_relop_t;
pub type std___optional_ne_t = std___optional_relop_t;
pub type std___optional_lt_t = std___optional_relop_t;
pub type std___optional_gt_t = std___optional_relop_t;
pub type std___optional_le_t = std___optional_relop_t;
pub type std___optional_ge_t = std___optional_relop_t;
#[test]
fn __bindgen_test_layout_std_hash_open0_llvm_hash_code_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_hash>(),
        1usize,
        concat!("Size of template specialization: ", stringify!(std_hash))
    );
    assert_eq!(
        ::std::mem::align_of::<std_hash>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_hash)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_is_error_code_enum_open0_llvm_BitcodeError_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_is_error_code_enum>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_is_error_code_enum)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_is_error_code_enum>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_is_error_code_enum)
        )
    );
}
pub const std___safe_multiply___c: ::std::os::raw::c_ulong = 4294967296;
extern "C" {
    #[link_name = "\u{1}__a0"]
    pub static std___safe_multiply___a0: ::std::os::raw::c_ulong;
}
extern "C" {
    #[link_name = "\u{1}__a1"]
    pub static std___safe_multiply___a1: ::std::os::raw::c_ulong;
}
extern "C" {
    #[link_name = "\u{1}__b0"]
    pub static std___safe_multiply___b0: ::std::os::raw::c_ulong;
}
extern "C" {
    #[link_name = "\u{1}__b1"]
    pub static std___safe_multiply___b1: ::std::os::raw::c_ulong;
}
extern "C" {
    #[link_name = "\u{1}value"]
    pub static std___safe_multiply_value: ::std::os::raw::c_long;
}
extern "C" {
    #[link_name = "\u{1}__lo"]
    pub static std___big_add___lo: ::std::os::raw::c_ulong;
}
extern "C" {
    #[link_name = "\u{1}__hi"]
    pub static std___big_add___hi: ::std::os::raw::c_ulong;
}
extern "C" {
    #[link_name = "\u{1}__lo"]
    pub static std___big_sub___lo: ::std::os::raw::c_ulong;
}
extern "C" {
    #[link_name = "\u{1}__hi"]
    pub static std___big_sub___hi: ::std::os::raw::c_ulong;
}
pub const std___big_mul___c: ::std::os::raw::c_ulong = 4294967296;
extern "C" {
    #[link_name = "\u{1}__x0"]
    pub static std___big_mul___x0: ::std::os::raw::c_ulong;
}
extern "C" {
    #[link_name = "\u{1}__x1"]
    pub static std___big_mul___x1: ::std::os::raw::c_ulong;
}
extern "C" {
    #[link_name = "\u{1}__y0"]
    pub static std___big_mul___y0: ::std::os::raw::c_ulong;
}
extern "C" {
    #[link_name = "\u{1}__y1"]
    pub static std___big_mul___y1: ::std::os::raw::c_ulong;
}
extern "C" {
    #[link_name = "\u{1}__x0y0"]
    pub static std___big_mul___x0y0: ::std::os::raw::c_ulong;
}
extern "C" {
    #[link_name = "\u{1}__x0y1"]
    pub static std___big_mul___x0y1: ::std::os::raw::c_ulong;
}
extern "C" {
    #[link_name = "\u{1}__x1y0"]
    pub static std___big_mul___x1y0: ::std::os::raw::c_ulong;
}
extern "C" {
    #[link_name = "\u{1}__x1y1"]
    pub static std___big_mul___x1y1: ::std::os::raw::c_ulong;
}
extern "C" {
    #[link_name = "\u{1}__mix"]
    pub static std___big_mul___mix: ::std::os::raw::c_ulong;
}
extern "C" {
    #[link_name = "\u{1}__mix_lo"]
    pub static std___big_mul___mix_lo: ::std::os::raw::c_ulong;
}
extern "C" {
    #[link_name = "\u{1}__mix_hi"]
    pub static std___big_mul___mix_hi: ::std::os::raw::c_ulong;
}
pub type std___big_mul__Res = u8;
extern "C" {
    #[link_name = "\u{1}__hi"]
    pub static std___big_mul___hi: ::std::os::raw::c_ulong;
}
extern "C" {
    #[link_name = "\u{1}__lo"]
    pub static std___big_mul___lo: ::std::os::raw::c_ulong;
}
pub const std___big_div_impl___c: ::std::os::raw::c_ulong = 4294967296;
extern "C" {
    #[link_name = "\u{1}__d1"]
    pub static std___big_div_impl___d1: ::std::os::raw::c_ulong;
}
extern "C" {
    #[link_name = "\u{1}__d0"]
    pub static std___big_div_impl___d0: ::std::os::raw::c_ulong;
}
extern "C" {
    #[link_name = "\u{1}__q1x"]
    pub static std___big_div_impl___q1x: ::std::os::raw::c_ulong;
}
extern "C" {
    #[link_name = "\u{1}__r1x"]
    pub static std___big_div_impl___r1x: ::std::os::raw::c_ulong;
}
extern "C" {
    #[link_name = "\u{1}__m"]
    pub static std___big_div_impl___m: ::std::os::raw::c_ulong;
}
extern "C" {
    #[link_name = "\u{1}__r1y"]
    pub static std___big_div_impl___r1y: ::std::os::raw::c_ulong;
}
extern "C" {
    #[link_name = "\u{1}__r1z"]
    pub static std___big_div_impl___r1z: ::std::os::raw::c_ulong;
}
extern "C" {
    #[link_name = "\u{1}__r1"]
    pub static std___big_div_impl___r1: ::std::os::raw::c_ulong;
}
extern "C" {
    #[link_name = "\u{1}__q1"]
    pub static std___big_div_impl___q1: ::std::os::raw::c_ulong;
}
extern "C" {
    #[link_name = "\u{1}__q0x"]
    pub static std___big_div_impl___q0x: ::std::os::raw::c_ulong;
}
extern "C" {
    #[link_name = "\u{1}__r0x"]
    pub static std___big_div_impl___r0x: ::std::os::raw::c_ulong;
}
extern "C" {
    #[link_name = "\u{1}__n"]
    pub static std___big_div_impl___n: ::std::os::raw::c_ulong;
}
extern "C" {
    #[link_name = "\u{1}__r0y"]
    pub static std___big_div_impl___r0y: ::std::os::raw::c_ulong;
}
extern "C" {
    #[link_name = "\u{1}__r0z"]
    pub static std___big_div_impl___r0z: ::std::os::raw::c_ulong;
}
extern "C" {
    #[link_name = "\u{1}__r0"]
    pub static std___big_div_impl___r0: ::std::os::raw::c_ulong;
}
extern "C" {
    #[link_name = "\u{1}__q0"]
    pub static std___big_div_impl___q0: ::std::os::raw::c_ulong;
}
extern "C" {
    #[link_name = "\u{1}__quot"]
    pub static std___big_div_impl___quot: ::std::os::raw::c_ulong;
}
extern "C" {
    #[link_name = "\u{1}__rem"]
    pub static std___big_div_impl___rem: ::std::os::raw::c_ulong;
}
pub type std___big_div_impl__Prod = u8;
pub type std___big_div_impl__Sum = u8;
extern "C" {
    #[link_name = "\u{1}__shift"]
    pub static std___big_div___shift: ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__coshift_"]
    pub static std___big_div___coshift_: ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__coshift"]
    pub static std___big_div___coshift: ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__c1"]
    pub static std___big_div___c1: ::std::os::raw::c_ulong;
}
extern "C" {
    #[link_name = "\u{1}__c2"]
    pub static std___big_div___c2: ::std::os::raw::c_ulong;
}
extern "C" {
    #[link_name = "\u{1}__new_d"]
    pub static std___big_div___new_d: ::std::os::raw::c_ulong;
}
extern "C" {
    #[link_name = "\u{1}__new_n0"]
    pub static std___big_div___new_n0: ::std::os::raw::c_ulong;
}
extern "C" {
    #[link_name = "\u{1}__n1_shifted"]
    pub static std___big_div___n1_shifted: ::std::os::raw::c_ulong;
}
extern "C" {
    #[link_name = "\u{1}__n0_top"]
    pub static std___big_div___n0_top: ::std::os::raw::c_ulong;
}
extern "C" {
    #[link_name = "\u{1}__new_n1"]
    pub static std___big_div___new_n1: ::std::os::raw::c_ulong;
}
pub type std___big_div__Res = u8;
extern "C" {
    #[link_name = "\u{1}__quot_hi"]
    pub static std___big_div___quot_hi: ::std::os::raw::c_ulong;
}
extern "C" {
    #[link_name = "\u{1}__quot_lo"]
    pub static std___big_div___quot_lo: ::std::os::raw::c_ulong;
}
extern "C" {
    #[link_name = "\u{1}__rem"]
    pub static std___big_div___rem: ::std::os::raw::c_ulong;
}
pub type std___big_div__P0 = u8;
pub type std___big_div__P1 = u8;
pub type std___big_div__Sum = u8;
extern "C" {
    #[link_name = "\u{1}num"]
    pub static std_ratio_num: ::std::os::raw::c_long;
}
extern "C" {
    #[link_name = "\u{1}den"]
    pub static std_ratio_den: ::std::os::raw::c_long;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_ratio {
    pub _base: std_false_type,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___ratio_multiply {
    pub _address: u8,
}
pub type std___ratio_multiply_type = u8;
pub type std_ratio_multiply = std___ratio_multiply;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___ratio_divide {
    pub _address: u8,
}
pub type std___ratio_divide_type = std___ratio_multiply;
pub type std_ratio_divide = std___ratio_divide;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_ratio_equal {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_ratio_not_equal {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___ratio_less_impl_1 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_ratio_less {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_ratio_less_equal {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_ratio_greater {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_ratio_greater_equal {
    pub _address: u8,
}
pub type std___ratio_add_impl___t = u8;
pub type std___ratio_add_impl_type = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___ratio_add {
    pub _address: u8,
}
pub type std___ratio_add_type = u8;
pub type std_ratio_add = std___ratio_add;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___ratio_subtract {
    pub _address: u8,
}
pub type std___ratio_subtract_type = std___ratio_add;
pub type std_ratio_subtract = std___ratio_subtract;
pub type std_atto = u8;
pub type std_femto = u8;
pub type std_pico = u8;
pub type std_nano = u8;
pub type std_micro = u8;
pub type std_milli = u8;
pub type std_centi = u8;
pub type std_deci = u8;
pub type std_deca = u8;
pub type std_hecto = u8;
pub type std_kilo = u8;
pub type std_mega = u8;
pub type std_giga = u8;
pub type std_tera = u8;
pub type std_peta = u8;
pub type std_exa = u8;
pub type std___parse_int__Digit_impl___valid = std_true_type;
pub type std___parse_int___ull_constant = u8;
pub type std___parse_int__Power_help___next = u8;
pub type std___parse_int__Power_help___valid_digit = u8;
pub type std___parse_int__Power_help_type = std___parse_int___ull_constant;
pub type std___parse_int__Number_help___digit = u8;
pub type std___parse_int__Number_help___valid_digit = std___parse_int__Number_help___digit;
pub type std___parse_int__Number_help_type = std___parse_int___ull_constant;
pub type std___select_int__Select_int = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_filesystem___file_clock {
    pub _address: u8,
}
pub type std_filesystem___file_clock_duration = std_chrono_nanoseconds;
pub type std_filesystem___file_clock_rep = rep;
pub type std_filesystem___file_clock_period = u8;
pub type std_filesystem___file_clock_time_point =
    std_chrono_time_point<std_chrono_duration<::std::os::raw::c_long>>;
pub type std_filesystem___file_clock___sys_clock = std_chrono__V2_system_clock;
pub const std_filesystem___file_clock_is_steady: bool = false;
extern "C" {
    #[link_name = "\u{1}_ZNSt10filesystem12__file_clock13_S_epoch_diffE"]
    pub static std_filesystem___file_clock__S_epoch_diff: std_chrono_seconds;
}
#[test]
fn bindgen_test_layout_std_filesystem___file_clock() {
    assert_eq!(
        ::std::mem::size_of::<std_filesystem___file_clock>(),
        1usize,
        concat!("Size of: ", stringify!(std_filesystem___file_clock))
    );
    assert_eq!(
        ::std::mem::align_of::<std_filesystem___file_clock>(),
        1usize,
        concat!("Alignment of ", stringify!(std_filesystem___file_clock))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_chrono___is_duration {
    pub _base: std_false_type,
}
pub type std_chrono___enable_if_is_duration = u8;
pub type std_chrono___disable_if_is_duration = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_chrono_treat_as_floating_point {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_chrono_duration_values {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug)]
pub struct std_chrono_duration<_Rep> {
    pub __r: std_chrono_duration_rep<_Rep>,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Rep>>,
}
pub type std_chrono_duration___is_float = std_chrono_treat_as_floating_point;
pub type std_chrono_duration___divide = u8;
pub type std_chrono_duration___is_harmonic = std___bool_constant;
pub type std_chrono_duration_rep<_Rep> = _Rep;
pub type std_chrono_duration_period = [u8; 0usize];
pub type std_chrono___common_rep_t = u8;
pub type std_chrono_nanoseconds = std_chrono_duration<::std::os::raw::c_long>;
pub type std_chrono_microseconds = std_chrono_duration<::std::os::raw::c_long>;
pub type std_chrono_milliseconds = std_chrono_duration<::std::os::raw::c_long>;
pub type std_chrono_seconds = std_chrono_duration<::std::os::raw::c_long>;
pub type std_chrono_minutes = std_chrono_duration<::std::os::raw::c_long>;
pub type std_chrono_hours = std_chrono_duration<::std::os::raw::c_long>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_chrono_time_point<_Dur> {
    pub __d: std_chrono_time_point_duration<_Dur>,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Dur>>,
}
pub type std_chrono_time_point_clock<_Clock> = _Clock;
pub type std_chrono_time_point_duration<_Dur> = _Dur;
pub type std_chrono_time_point_rep = [u8; 0usize];
pub type std_chrono_time_point_period = [u8; 0usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_chrono__V2_system_clock {
    pub _address: u8,
}
pub type std_chrono__V2_system_clock_duration = std_chrono_nanoseconds;
pub type std_chrono__V2_system_clock_rep = rep;
pub type std_chrono__V2_system_clock_period = u8;
pub type std_chrono__V2_system_clock_time_point =
    std_chrono_time_point<std_chrono__V2_system_clock_duration>;
pub const std_chrono__V2_system_clock_is_steady: bool = false;
#[test]
fn bindgen_test_layout_std_chrono__V2_system_clock() {
    assert_eq!(
        ::std::mem::size_of::<std_chrono__V2_system_clock>(),
        1usize,
        concat!("Size of: ", stringify!(std_chrono__V2_system_clock))
    );
    assert_eq!(
        ::std::mem::align_of::<std_chrono__V2_system_clock>(),
        1usize,
        concat!("Alignment of ", stringify!(std_chrono__V2_system_clock))
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNSt6chrono3_V212system_clock3nowEv"]
    pub fn std_chrono__V2_system_clock_now() -> std_chrono__V2_system_clock_time_point;
}
impl std_chrono__V2_system_clock {
    #[inline]
    pub unsafe fn now() -> std_chrono__V2_system_clock_time_point {
        std_chrono__V2_system_clock_now()
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_chrono__V2_steady_clock {
    pub _address: u8,
}
pub type std_chrono__V2_steady_clock_duration = std_chrono_nanoseconds;
pub type std_chrono__V2_steady_clock_rep = rep;
pub type std_chrono__V2_steady_clock_period = u8;
pub type std_chrono__V2_steady_clock_time_point =
    std_chrono_time_point<std_chrono__V2_steady_clock_duration>;
pub const std_chrono__V2_steady_clock_is_steady: bool = true;
#[test]
fn bindgen_test_layout_std_chrono__V2_steady_clock() {
    assert_eq!(
        ::std::mem::size_of::<std_chrono__V2_steady_clock>(),
        1usize,
        concat!("Size of: ", stringify!(std_chrono__V2_steady_clock))
    );
    assert_eq!(
        ::std::mem::align_of::<std_chrono__V2_steady_clock>(),
        1usize,
        concat!("Alignment of ", stringify!(std_chrono__V2_steady_clock))
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNSt6chrono3_V212steady_clock3nowEv"]
    pub fn std_chrono__V2_steady_clock_now() -> std_chrono__V2_steady_clock_time_point;
}
impl std_chrono__V2_steady_clock {
    #[inline]
    pub unsafe fn now() -> std_chrono__V2_steady_clock_time_point {
        std_chrono__V2_steady_clock_now()
    }
}
pub type std_chrono__V2_high_resolution_clock = std_chrono__V2_system_clock;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___duration_common_type {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___timepoint_common_type {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std__List_node {
    pub _base: std___detail__List_node_base,
    pub _M_storage: __gnu_cxx___aligned_membuf,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std__List_iterator {
    pub _M_node: *mut std___detail__List_node_base,
}
pub type std__List_iterator__Self = std__List_iterator;
pub type std__List_iterator__Node = std__List_node;
pub type std__List_iterator_difference_type = isize;
pub type std__List_iterator_iterator_category = std_bidirectional_iterator_tag;
pub type std__List_iterator_value_type<_Tp> = _Tp;
pub type std__List_iterator_pointer<_Tp> = *mut _Tp;
pub type std__List_iterator_reference<_Tp> = *mut _Tp;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std__List_const_iterator {
    pub _M_node: *const std___detail__List_node_base,
}
pub type std__List_const_iterator__Self = std__List_const_iterator;
pub type std__List_const_iterator__Node = std__List_node;
pub type std__List_const_iterator_iterator = std__List_iterator;
pub type std__List_const_iterator_difference_type = isize;
pub type std__List_const_iterator_iterator_category = std_bidirectional_iterator_tag;
pub type std__List_const_iterator_value_type<_Tp> = _Tp;
pub type std__List_const_iterator_pointer<_Tp> = *const _Tp;
pub type std__List_const_iterator_reference<_Tp> = *const _Tp;
#[test]
fn __bindgen_test_layout_std_atomic_open0_bool__close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_atomic<bool>>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_atomic<bool>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_atomic<bool>>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_atomic<bool>)
        )
    );
}
#[repr(C)]
#[derive(Debug)]
pub struct std_atomic<_Tp> {
    pub _M_i: _Tp,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Tp>>,
}
pub type std_atomic_value_type<_Tp> = _Tp;
#[test]
fn __bindgen_test_layout_std_atomic_open0_char_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_atomic<::std::os::raw::c_char>>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_atomic<::std::os::raw::c_char>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_atomic<::std::os::raw::c_char>>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_atomic<::std::os::raw::c_char>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_atomic_open0_signed_char_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_atomic<::std::os::raw::c_schar>>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_atomic<::std::os::raw::c_schar>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_atomic<::std::os::raw::c_schar>>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_atomic<::std::os::raw::c_schar>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_atomic_open0_unsigned_char_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_atomic<::std::os::raw::c_uchar>>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_atomic<::std::os::raw::c_uchar>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_atomic<::std::os::raw::c_uchar>>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_atomic<::std::os::raw::c_uchar>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_atomic_open0_short_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_atomic<::std::os::raw::c_short>>(),
        2usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_atomic<::std::os::raw::c_short>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_atomic<::std::os::raw::c_short>>(),
        2usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_atomic<::std::os::raw::c_short>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_atomic_open0_unsigned_short_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_atomic<::std::os::raw::c_ushort>>(),
        2usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_atomic<::std::os::raw::c_ushort>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_atomic<::std::os::raw::c_ushort>>(),
        2usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_atomic<::std::os::raw::c_ushort>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_atomic_open0_int_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_atomic<::std::os::raw::c_int>>(),
        4usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_atomic<::std::os::raw::c_int>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_atomic<::std::os::raw::c_int>>(),
        4usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_atomic<::std::os::raw::c_int>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_atomic_open0_unsigned_int_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_atomic<::std::os::raw::c_uint>>(),
        4usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_atomic<::std::os::raw::c_uint>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_atomic<::std::os::raw::c_uint>>(),
        4usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_atomic<::std::os::raw::c_uint>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_atomic_open0_long_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_atomic<::std::os::raw::c_long>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_atomic<::std::os::raw::c_long>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_atomic<::std::os::raw::c_long>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_atomic<::std::os::raw::c_long>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_atomic_open0_unsigned_long_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_atomic<::std::os::raw::c_ulong>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_atomic<::std::os::raw::c_ulong>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_atomic<::std::os::raw::c_ulong>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_atomic<::std::os::raw::c_ulong>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_atomic_open0_long_long_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_atomic<::std::os::raw::c_longlong>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_atomic<::std::os::raw::c_longlong>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_atomic<::std::os::raw::c_longlong>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_atomic<::std::os::raw::c_longlong>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_atomic_open0_unsigned_long_long_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_atomic<::std::os::raw::c_ulonglong>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_atomic<::std::os::raw::c_ulonglong>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_atomic<::std::os::raw::c_ulonglong>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_atomic<::std::os::raw::c_ulonglong>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_atomic_open0_wchar_t_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_atomic<u32>>(),
        4usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_atomic<u32>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_atomic<u32>>(),
        4usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_atomic<u32>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_atomic_open0_char16_t_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_atomic<u16>>(),
        2usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_atomic<u16>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_atomic<u16>>(),
        2usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_atomic<u16>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_atomic_open0_char32_t_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_atomic<u32>>(),
        4usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_atomic<u32>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_atomic<u32>>(),
        4usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_atomic<u32>)
        )
    );
}
pub type std_atomic_bool = std_atomic<bool>;
pub type std_atomic_char = std_atomic<::std::os::raw::c_char>;
pub type std_atomic_schar = std_atomic<::std::os::raw::c_schar>;
pub type std_atomic_uchar = std_atomic<::std::os::raw::c_uchar>;
pub type std_atomic_short = std_atomic<::std::os::raw::c_short>;
pub type std_atomic_ushort = std_atomic<::std::os::raw::c_ushort>;
pub type std_atomic_int = std_atomic<::std::os::raw::c_int>;
pub type std_atomic_uint = std_atomic<::std::os::raw::c_uint>;
pub type std_atomic_long = std_atomic<::std::os::raw::c_long>;
pub type std_atomic_ulong = std_atomic<::std::os::raw::c_ulong>;
pub type std_atomic_llong = std_atomic<::std::os::raw::c_longlong>;
pub type std_atomic_ullong = std_atomic<::std::os::raw::c_ulonglong>;
pub type std_atomic_wchar_t = std_atomic<u32>;
pub type std_atomic_char16_t = std_atomic<u16>;
pub type std_atomic_char32_t = std_atomic<u32>;
pub type std_atomic_int8_t = std_atomic<::std::os::raw::c_schar>;
pub type std_atomic_uint8_t = std_atomic<::std::os::raw::c_uchar>;
pub type std_atomic_int16_t = std_atomic<::std::os::raw::c_short>;
pub type std_atomic_uint16_t = std_atomic<::std::os::raw::c_ushort>;
pub type std_atomic_int32_t = std_atomic<::std::os::raw::c_int>;
pub type std_atomic_uint32_t = std_atomic<::std::os::raw::c_uint>;
pub type std_atomic_int64_t = std_atomic<::std::os::raw::c_long>;
pub type std_atomic_uint64_t = std_atomic<::std::os::raw::c_ulong>;
pub type std_atomic_int_least8_t = std_atomic<::std::os::raw::c_schar>;
pub type std_atomic_uint_least8_t = std_atomic<::std::os::raw::c_uchar>;
pub type std_atomic_int_least16_t = std_atomic<::std::os::raw::c_short>;
pub type std_atomic_uint_least16_t = std_atomic<::std::os::raw::c_ushort>;
pub type std_atomic_int_least32_t = std_atomic<::std::os::raw::c_int>;
pub type std_atomic_uint_least32_t = std_atomic<::std::os::raw::c_uint>;
pub type std_atomic_int_least64_t = std_atomic<::std::os::raw::c_long>;
pub type std_atomic_uint_least64_t = std_atomic<::std::os::raw::c_ulong>;
pub type std_atomic_int_fast8_t = std_atomic<::std::os::raw::c_schar>;
pub type std_atomic_uint_fast8_t = std_atomic<::std::os::raw::c_uchar>;
pub type std_atomic_int_fast16_t = std_atomic<::std::os::raw::c_long>;
pub type std_atomic_uint_fast16_t = std_atomic<::std::os::raw::c_ulong>;
pub type std_atomic_int_fast32_t = std_atomic<::std::os::raw::c_long>;
pub type std_atomic_uint_fast32_t = std_atomic<::std::os::raw::c_ulong>;
pub type std_atomic_int_fast64_t = std_atomic<::std::os::raw::c_long>;
pub type std_atomic_uint_fast64_t = std_atomic<::std::os::raw::c_ulong>;
pub type std_atomic_intptr_t = std_atomic<::std::os::raw::c_long>;
pub type std_atomic_uintptr_t = std_atomic<::std::os::raw::c_ulong>;
pub type std_atomic_size_t = std_atomic<usize>;
pub type std_atomic_ptrdiff_t = std_atomic<isize>;
pub type std_atomic_intmax_t = std_atomic<::std::os::raw::c_long>;
pub type std_atomic_uintmax_t = std_atomic<::std::os::raw::c_ulong>;
pub type std___atomic_val_t = std___type_identity_t;
pub type std___atomic_diff_t = std_atomic<_Tp>;
#[test]
fn __bindgen_test_layout_std_allocator_open0_void_close0_instantiation_1() {
    assert_eq!(
        ::std::mem::size_of::<std_allocator>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_allocator)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_allocator>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_allocator)
        )
    );
}
pub type std_byte = ::std::os::raw::c_uchar;
#[test]
fn __bindgen_test_layout_std_char_traits_open0_char_close0_instantiation_1() {
    assert_eq!(
        ::std::mem::size_of::<std_char_traits>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_char_traits)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_char_traits>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_char_traits)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_char_traits_open0_wchar_t_close0_instantiation_1() {
    assert_eq!(
        ::std::mem::size_of::<std_char_traits>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_char_traits)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_char_traits>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_char_traits)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_char_traits_open0_char16_t_close0_instantiation_1() {
    assert_eq!(
        ::std::mem::size_of::<std_char_traits>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_char_traits)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_char_traits>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_char_traits)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_char_traits_open0_char32_t_close0_instantiation_1() {
    assert_eq!(
        ::std::mem::size_of::<std_char_traits>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_char_traits)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_char_traits>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_char_traits)
        )
    );
}
#[repr(C)]
pub struct std_type_info__bindgen_vtable(::std::os::raw::c_void);
#[repr(C)]
#[derive(Debug)]
pub struct std_type_info {
    pub vtable_: *const std_type_info__bindgen_vtable,
    pub __name: *const ::std::os::raw::c_char,
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __gnu_cxx___is_integer_nonstrict {
    pub _address: u8,
}
pub const __gnu_cxx___is_integer_nonstrict___width: __gnu_cxx___is_integer_nonstrict__bindgen_ty_1 =
    0;
pub type __gnu_cxx___is_integer_nonstrict__bindgen_ty_1 = i32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __gnu_cxx___numeric_traits_integer {
    pub _address: u8,
}
extern "C" {
    #[link_name = "\u{1}__min"]
    pub static __gnu_cxx___min: _Value;
}
extern "C" {
    #[link_name = "\u{1}__max"]
    pub static __gnu_cxx___max: _Value;
}
extern "C" {
    #[link_name = "\u{1}__is_signed"]
    pub static __gnu_cxx___is_signed: bool;
}
extern "C" {
    #[link_name = "\u{1}__digits"]
    pub static __gnu_cxx___digits: ::std::os::raw::c_int;
}
#[test]
fn __bindgen_test_layout___gnu_cxx___is_integer_nonstrict_open0___int128_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<__gnu_cxx___is_integer_nonstrict>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(__gnu_cxx___is_integer_nonstrict)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<__gnu_cxx___is_integer_nonstrict>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(__gnu_cxx___is_integer_nonstrict)
        )
    );
}
#[test]
fn __bindgen_test_layout___gnu_cxx___is_integer_nonstrict_open0_unsigned___int128_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<__gnu_cxx___is_integer_nonstrict>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(__gnu_cxx___is_integer_nonstrict)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<__gnu_cxx___is_integer_nonstrict>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(__gnu_cxx___is_integer_nonstrict)
        )
    );
}
pub type __gnu_cxx___int_traits = __gnu_cxx___numeric_traits_integer;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __gnu_cxx___numeric_traits_floating {
    pub _address: u8,
}
extern "C" {
    #[link_name = "\u{1}__max_digits10"]
    pub static __gnu_cxx___max_digits10: ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__digits10"]
    pub static __gnu_cxx___digits10: ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__max_exponent10"]
    pub static __gnu_cxx___max_exponent10: ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __gnu_cxx___numeric_traits {
    pub _address: u8,
}
#[test]
fn __bindgen_test_layout___gnu_cxx___numeric_traits_open0_float_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<__gnu_cxx___numeric_traits>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(__gnu_cxx___numeric_traits)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<__gnu_cxx___numeric_traits>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(__gnu_cxx___numeric_traits)
        )
    );
}
#[test]
fn __bindgen_test_layout___gnu_cxx___numeric_traits_open0_double_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<__gnu_cxx___numeric_traits>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(__gnu_cxx___numeric_traits)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<__gnu_cxx___numeric_traits>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(__gnu_cxx___numeric_traits)
        )
    );
}
#[test]
fn __bindgen_test_layout___gnu_cxx___numeric_traits_open0_long_double_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<__gnu_cxx___numeric_traits>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(__gnu_cxx___numeric_traits)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<__gnu_cxx___numeric_traits>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(__gnu_cxx___numeric_traits)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __gnu_cxx___normal_iterator<_Iterator> {
    pub _M_current: _Iterator,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Iterator>>,
}
pub type __gnu_cxx___normal_iterator___traits_type = std_iterator_traits;
pub type __gnu_cxx___normal_iterator___convertible_from = std___enable_if_t;
pub type __gnu_cxx___normal_iterator_iterator_type<_Iterator> = _Iterator;
pub type __gnu_cxx___normal_iterator_iterator_category = __gnu_cxx___normal_iterator___traits_type;
pub type __gnu_cxx___normal_iterator_value_type = __gnu_cxx___normal_iterator___traits_type;
pub type __gnu_cxx___normal_iterator_difference_type = __gnu_cxx___normal_iterator___traits_type;
pub type __gnu_cxx___normal_iterator_reference = __gnu_cxx___normal_iterator___traits_type;
pub type __gnu_cxx___normal_iterator_pointer = __gnu_cxx___normal_iterator___traits_type;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __gnu_cxx___ops__Iter_less_iter {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout___gnu_cxx___ops__Iter_less_iter() {
    assert_eq!(
        ::std::mem::size_of::<__gnu_cxx___ops__Iter_less_iter>(),
        1usize,
        concat!("Size of: ", stringify!(__gnu_cxx___ops__Iter_less_iter))
    );
    assert_eq!(
        ::std::mem::align_of::<__gnu_cxx___ops__Iter_less_iter>(),
        1usize,
        concat!("Alignment of ", stringify!(__gnu_cxx___ops__Iter_less_iter))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __gnu_cxx___ops__Iter_less_val {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout___gnu_cxx___ops__Iter_less_val() {
    assert_eq!(
        ::std::mem::size_of::<__gnu_cxx___ops__Iter_less_val>(),
        1usize,
        concat!("Size of: ", stringify!(__gnu_cxx___ops__Iter_less_val))
    );
    assert_eq!(
        ::std::mem::align_of::<__gnu_cxx___ops__Iter_less_val>(),
        1usize,
        concat!("Alignment of ", stringify!(__gnu_cxx___ops__Iter_less_val))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __gnu_cxx___ops__Val_less_iter {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout___gnu_cxx___ops__Val_less_iter() {
    assert_eq!(
        ::std::mem::size_of::<__gnu_cxx___ops__Val_less_iter>(),
        1usize,
        concat!("Size of: ", stringify!(__gnu_cxx___ops__Val_less_iter))
    );
    assert_eq!(
        ::std::mem::align_of::<__gnu_cxx___ops__Val_less_iter>(),
        1usize,
        concat!("Alignment of ", stringify!(__gnu_cxx___ops__Val_less_iter))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __gnu_cxx___ops__Iter_equal_to_iter {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout___gnu_cxx___ops__Iter_equal_to_iter() {
    assert_eq!(
        ::std::mem::size_of::<__gnu_cxx___ops__Iter_equal_to_iter>(),
        1usize,
        concat!("Size of: ", stringify!(__gnu_cxx___ops__Iter_equal_to_iter))
    );
    assert_eq!(
        ::std::mem::align_of::<__gnu_cxx___ops__Iter_equal_to_iter>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(__gnu_cxx___ops__Iter_equal_to_iter)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __gnu_cxx___ops__Iter_equal_to_val {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout___gnu_cxx___ops__Iter_equal_to_val() {
    assert_eq!(
        ::std::mem::size_of::<__gnu_cxx___ops__Iter_equal_to_val>(),
        1usize,
        concat!("Size of: ", stringify!(__gnu_cxx___ops__Iter_equal_to_val))
    );
    assert_eq!(
        ::std::mem::align_of::<__gnu_cxx___ops__Iter_equal_to_val>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(__gnu_cxx___ops__Iter_equal_to_val)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __gnu_cxx___ops__Iter_comp_iter<_Compare> {
    pub _M_comp: _Compare,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Compare>>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __gnu_cxx___ops__Iter_comp_val<_Compare> {
    pub _M_comp: _Compare,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Compare>>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __gnu_cxx___ops__Val_comp_iter<_Compare> {
    pub _M_comp: _Compare,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Compare>>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __gnu_cxx___ops__Iter_equals_val<_Value> {
    pub _M_value: *mut _Value,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Value>>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __gnu_cxx___ops__Iter_equals_iter<_Iterator1> {
    pub _M_it1: _Iterator1,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Iterator1>>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __gnu_cxx___ops__Iter_pred<_Predicate> {
    pub _M_pred: _Predicate,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Predicate>>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __gnu_cxx___ops__Iter_comp_to_val<_Compare, _Value> {
    pub _M_comp: _Compare,
    pub _M_value: *mut _Value,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Compare>>,
    pub _phantom_1: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Value>>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __gnu_cxx___ops__Iter_comp_to_iter<_Compare, _Iterator1> {
    pub _M_comp: _Compare,
    pub _M_it1: _Iterator1,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Compare>>,
    pub _phantom_1: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Iterator1>>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __gnu_cxx___ops__Iter_negate<_Predicate> {
    pub _M_pred: _Predicate,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Predicate>>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __gnu_cxx___aligned_membuf {
    pub _M_storage: *mut ::std::os::raw::c_uchar,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __gnu_cxx___aligned_membuf__Tp2<_Tp> {
    pub _M_t: _Tp,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Tp>>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __gnu_cxx___aligned_buffer {
    pub _M_storage: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __gnu_cxx___alloc_traits {
    pub _address: u8,
}
pub type __gnu_cxx___alloc_traits_allocator_type<_Alloc> = _Alloc;
pub type __gnu_cxx___alloc_traits__Base_type = std_allocator_traits;
pub type __gnu_cxx___alloc_traits_value_type = __gnu_cxx___alloc_traits__Base_type;
pub type __gnu_cxx___alloc_traits_pointer = __gnu_cxx___alloc_traits__Base_type;
pub type __gnu_cxx___alloc_traits_const_pointer = __gnu_cxx___alloc_traits__Base_type;
pub type __gnu_cxx___alloc_traits_size_type = __gnu_cxx___alloc_traits__Base_type;
pub type __gnu_cxx___alloc_traits_difference_type = __gnu_cxx___alloc_traits__Base_type;
pub type __gnu_cxx___alloc_traits_reference = *mut __gnu_cxx___alloc_traits_value_type;
pub type __gnu_cxx___alloc_traits_const_reference = *const __gnu_cxx___alloc_traits_value_type;
pub type __gnu_cxx___alloc_traits___is_custom_pointer = std___and_;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __gnu_cxx___alloc_traits_rebind {
    pub _address: u8,
}
pub type __gnu_cxx___alloc_traits_rebind_other = __gnu_cxx___alloc_traits__Base_type;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __gnu_cxx__Char_types {
    pub _address: u8,
}
pub type __gnu_cxx__Char_types_int_type = ::std::os::raw::c_ulong;
pub type __gnu_cxx__Char_types_pos_type = std_streampos;
pub type __gnu_cxx__Char_types_off_type = std_streamoff;
pub type __gnu_cxx__Char_types_state_type = __mbstate_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __gnu_cxx_char_traits {
    pub _address: u8,
}
pub type __gnu_cxx_char_traits_char_type<_CharT> = _CharT;
pub type __gnu_cxx_char_traits_int_type = __gnu_cxx__Char_types;
pub type __gnu_cxx_char_traits_pos_type = __gnu_cxx__Char_types;
pub type __gnu_cxx_char_traits_off_type = __gnu_cxx__Char_types;
pub type __gnu_cxx_char_traits_state_type = __gnu_cxx__Char_types;
pub const __gnu_cxx__Lock_policy__S_single: __gnu_cxx__Lock_policy = 0;
pub const __gnu_cxx__Lock_policy__S_mutex: __gnu_cxx__Lock_policy = 1;
pub const __gnu_cxx__Lock_policy__S_atomic: __gnu_cxx__Lock_policy = 2;
pub type __gnu_cxx__Lock_policy = ::std::os::raw::c_uint;
extern "C" {
    #[link_name = "\u{1}_ZN9__gnu_cxx21__default_lock_policyE"]
    pub static __gnu_cxx___default_lock_policy: __gnu_cxx__Lock_policy;
}
#[repr(C)]
#[derive(Debug)]
pub struct __gnu_cxx___concurrence_lock_error {
    pub _base: exception,
}
#[test]
fn bindgen_test_layout___gnu_cxx___concurrence_lock_error() {
    assert_eq!(
        ::std::mem::size_of::<__gnu_cxx___concurrence_lock_error>(),
        8usize,
        concat!("Size of: ", stringify!(__gnu_cxx___concurrence_lock_error))
    );
    assert_eq!(
        ::std::mem::align_of::<__gnu_cxx___concurrence_lock_error>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(__gnu_cxx___concurrence_lock_error)
        )
    );
}
#[repr(C)]
#[derive(Debug)]
pub struct __gnu_cxx___concurrence_unlock_error {
    pub _base: exception,
}
#[test]
fn bindgen_test_layout___gnu_cxx___concurrence_unlock_error() {
    assert_eq!(
        ::std::mem::size_of::<__gnu_cxx___concurrence_unlock_error>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(__gnu_cxx___concurrence_unlock_error)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<__gnu_cxx___concurrence_unlock_error>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(__gnu_cxx___concurrence_unlock_error)
        )
    );
}
#[repr(C)]
#[derive(Debug)]
pub struct __gnu_cxx___concurrence_broadcast_error {
    pub _base: exception,
}
#[test]
fn bindgen_test_layout___gnu_cxx___concurrence_broadcast_error() {
    assert_eq!(
        ::std::mem::size_of::<__gnu_cxx___concurrence_broadcast_error>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(__gnu_cxx___concurrence_broadcast_error)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<__gnu_cxx___concurrence_broadcast_error>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(__gnu_cxx___concurrence_broadcast_error)
        )
    );
}
#[repr(C)]
#[derive(Debug)]
pub struct __gnu_cxx___concurrence_wait_error {
    pub _base: exception,
}
#[test]
fn bindgen_test_layout___gnu_cxx___concurrence_wait_error() {
    assert_eq!(
        ::std::mem::size_of::<__gnu_cxx___concurrence_wait_error>(),
        8usize,
        concat!("Size of: ", stringify!(__gnu_cxx___concurrence_wait_error))
    );
    assert_eq!(
        ::std::mem::align_of::<__gnu_cxx___concurrence_wait_error>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(__gnu_cxx___concurrence_wait_error)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __gnu_cxx___mutex {
    pub _M_mutex: __gthread_mutex_t,
}
#[test]
fn bindgen_test_layout___gnu_cxx___mutex() {
    const UNINIT: ::std::mem::MaybeUninit<__gnu_cxx___mutex> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__gnu_cxx___mutex>(),
        40usize,
        concat!("Size of: ", stringify!(__gnu_cxx___mutex))
    );
    assert_eq!(
        ::std::mem::align_of::<__gnu_cxx___mutex>(),
        8usize,
        concat!("Alignment of ", stringify!(__gnu_cxx___mutex))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._M_mutex) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__gnu_cxx___mutex),
            "::",
            stringify!(_M_mutex)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __gnu_cxx___recursive_mutex {
    pub _M_mutex: __gthread_recursive_mutex_t,
}
#[test]
fn bindgen_test_layout___gnu_cxx___recursive_mutex() {
    const UNINIT: ::std::mem::MaybeUninit<__gnu_cxx___recursive_mutex> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__gnu_cxx___recursive_mutex>(),
        40usize,
        concat!("Size of: ", stringify!(__gnu_cxx___recursive_mutex))
    );
    assert_eq!(
        ::std::mem::align_of::<__gnu_cxx___recursive_mutex>(),
        8usize,
        concat!("Alignment of ", stringify!(__gnu_cxx___recursive_mutex))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._M_mutex) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__gnu_cxx___recursive_mutex),
            "::",
            stringify!(_M_mutex)
        )
    );
}
#[repr(C)]
#[derive(Debug)]
pub struct __gnu_cxx___scoped_lock {
    pub _M_device: *mut __gnu_cxx___scoped_lock___mutex_type,
}
pub type __gnu_cxx___scoped_lock___mutex_type = __gnu_cxx___mutex;
#[test]
fn bindgen_test_layout___gnu_cxx___scoped_lock() {
    const UNINIT: ::std::mem::MaybeUninit<__gnu_cxx___scoped_lock> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__gnu_cxx___scoped_lock>(),
        8usize,
        concat!("Size of: ", stringify!(__gnu_cxx___scoped_lock))
    );
    assert_eq!(
        ::std::mem::align_of::<__gnu_cxx___scoped_lock>(),
        8usize,
        concat!("Alignment of ", stringify!(__gnu_cxx___scoped_lock))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._M_device) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__gnu_cxx___scoped_lock),
            "::",
            stringify!(_M_device)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __gnu_cxx___cond {
    pub _M_cond: __gthread_cond_t,
}
#[test]
fn bindgen_test_layout___gnu_cxx___cond() {
    const UNINIT: ::std::mem::MaybeUninit<__gnu_cxx___cond> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__gnu_cxx___cond>(),
        48usize,
        concat!("Size of: ", stringify!(__gnu_cxx___cond))
    );
    assert_eq!(
        ::std::mem::align_of::<__gnu_cxx___cond>(),
        8usize,
        concat!("Alignment of ", stringify!(__gnu_cxx___cond))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._M_cond) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__gnu_cxx___cond),
            "::",
            stringify!(_M_cond)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __gnu_debug__Safe_iterator {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pstl_execution_sequenced_policy {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout___pstl_execution_sequenced_policy() {
    assert_eq!(
        ::std::mem::size_of::<__pstl_execution_sequenced_policy>(),
        1usize,
        concat!("Size of: ", stringify!(__pstl_execution_sequenced_policy))
    );
    assert_eq!(
        ::std::mem::align_of::<__pstl_execution_sequenced_policy>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(__pstl_execution_sequenced_policy)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pstl_execution_parallel_policy {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout___pstl_execution_parallel_policy() {
    assert_eq!(
        ::std::mem::size_of::<__pstl_execution_parallel_policy>(),
        1usize,
        concat!("Size of: ", stringify!(__pstl_execution_parallel_policy))
    );
    assert_eq!(
        ::std::mem::align_of::<__pstl_execution_parallel_policy>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(__pstl_execution_parallel_policy)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pstl_execution_parallel_unsequenced_policy {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout___pstl_execution_parallel_unsequenced_policy() {
    assert_eq!(
        ::std::mem::size_of::<__pstl_execution_parallel_unsequenced_policy>(),
        1usize,
        concat!(
            "Size of: ",
            stringify!(__pstl_execution_parallel_unsequenced_policy)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<__pstl_execution_parallel_unsequenced_policy>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(__pstl_execution_parallel_unsequenced_policy)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pstl_execution_unsequenced_policy {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout___pstl_execution_unsequenced_policy() {
    assert_eq!(
        ::std::mem::size_of::<__pstl_execution_unsequenced_policy>(),
        1usize,
        concat!("Size of: ", stringify!(__pstl_execution_unsequenced_policy))
    );
    assert_eq!(
        ::std::mem::align_of::<__pstl_execution_unsequenced_policy>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(__pstl_execution_unsequenced_policy)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN6__pstl9execution2v13seqE"]
    pub static __pstl_execution_seq: __pstl_execution_sequenced_policy;
}
extern "C" {
    #[link_name = "\u{1}_ZN6__pstl9execution2v13parE"]
    pub static __pstl_execution_par: __pstl_execution_parallel_policy;
}
extern "C" {
    #[link_name = "\u{1}_ZN6__pstl9execution2v19par_unseqE"]
    pub static __pstl_execution_par_unseq: __pstl_execution_parallel_unsequenced_policy;
}
extern "C" {
    #[link_name = "\u{1}_ZN6__pstl9execution2v15unseqE"]
    pub static __pstl_execution_unseq: __pstl_execution_unsequenced_policy;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pstl_execution_is_execution_policy {
    pub _base: std_false_type,
}
#[test]
fn __bindgen_test_layout___pstl_execution_is_execution_policy_open0___pstl_execution_sequenced_policy_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<__pstl_execution_is_execution_policy>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(__pstl_execution_is_execution_policy)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<__pstl_execution_is_execution_policy>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(__pstl_execution_is_execution_policy)
        )
    );
}
#[test]
fn __bindgen_test_layout___pstl_execution_is_execution_policy_open0___pstl_execution_parallel_policy_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<__pstl_execution_is_execution_policy>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(__pstl_execution_is_execution_policy)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<__pstl_execution_is_execution_policy>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(__pstl_execution_is_execution_policy)
        )
    );
}
#[test]
fn __bindgen_test_layout___pstl_execution_is_execution_policy_open0___pstl_execution_parallel_unsequenced_policy_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<__pstl_execution_is_execution_policy>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(__pstl_execution_is_execution_policy)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<__pstl_execution_is_execution_policy>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(__pstl_execution_is_execution_policy)
        )
    );
}
#[test]
fn __bindgen_test_layout___pstl_execution_is_execution_policy_open0___pstl_execution_unsequenced_policy_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<__pstl_execution_is_execution_policy>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(__pstl_execution_is_execution_policy)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<__pstl_execution_is_execution_policy>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(__pstl_execution_is_execution_policy)
        )
    );
}
pub type __pstl___internal___enable_if_execution_policy = u8;
pub type int_least8_t = __int_least8_t;
pub type int_least16_t = __int_least16_t;
pub type int_least32_t = __int_least32_t;
pub type int_least64_t = __int_least64_t;
pub type uint_least8_t = __uint_least8_t;
pub type uint_least16_t = __uint_least16_t;
pub type uint_least32_t = __uint_least32_t;
pub type uint_least64_t = __uint_least64_t;
pub type int_fast8_t = ::std::os::raw::c_schar;
pub type int_fast16_t = ::std::os::raw::c_long;
pub type int_fast32_t = ::std::os::raw::c_long;
pub type int_fast64_t = ::std::os::raw::c_long;
pub type uint_fast8_t = ::std::os::raw::c_uchar;
pub type uint_fast16_t = ::std::os::raw::c_ulong;
pub type uint_fast32_t = ::std::os::raw::c_ulong;
pub type uint_fast64_t = ::std::os::raw::c_ulong;
pub type intmax_t = __intmax_t;
pub type uintmax_t = __uintmax_t;
pub type __gnuc_va_list = __builtin_va_list;
pub type va_list = __gnuc_va_list;
pub type wint_t = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __mbstate_t {
    pub __count: ::std::os::raw::c_int,
    pub __value: __mbstate_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union __mbstate_t__bindgen_ty_1 {
    pub __wch: ::std::os::raw::c_uint,
    pub __wchb: [::std::os::raw::c_char; 4usize],
}
#[test]
fn bindgen_test_layout___mbstate_t__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<__mbstate_t__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__mbstate_t__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(__mbstate_t__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<__mbstate_t__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(__mbstate_t__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__wch) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t__bindgen_ty_1),
            "::",
            stringify!(__wch)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__wchb) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t__bindgen_ty_1),
            "::",
            stringify!(__wchb)
        )
    );
}
#[test]
fn bindgen_test_layout___mbstate_t() {
    const UNINIT: ::std::mem::MaybeUninit<__mbstate_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__mbstate_t>(),
        8usize,
        concat!("Size of: ", stringify!(__mbstate_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__mbstate_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__mbstate_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__count) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t),
            "::",
            stringify!(__count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__value) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t),
            "::",
            stringify!(__value)
        )
    );
}
pub type mbstate_t = __mbstate_t;
pub type __FILE = _IO_FILE;
pub type FILE = _IO_FILE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sched_param {
    pub sched_priority: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_sched_param() {
    const UNINIT: ::std::mem::MaybeUninit<sched_param> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<sched_param>(),
        4usize,
        concat!("Size of: ", stringify!(sched_param))
    );
    assert_eq!(
        ::std::mem::align_of::<sched_param>(),
        4usize,
        concat!("Alignment of ", stringify!(sched_param))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sched_priority) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_param),
            "::",
            stringify!(sched_priority)
        )
    );
}
pub type __cpu_mask = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cpu_set_t {
    pub __bits: [__cpu_mask; 16usize],
}
#[test]
fn bindgen_test_layout_cpu_set_t() {
    const UNINIT: ::std::mem::MaybeUninit<cpu_set_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cpu_set_t>(),
        128usize,
        concat!("Size of: ", stringify!(cpu_set_t))
    );
    assert_eq!(
        ::std::mem::align_of::<cpu_set_t>(),
        8usize,
        concat!("Alignment of ", stringify!(cpu_set_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__bits) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cpu_set_t),
            "::",
            stringify!(__bits)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timex {
    pub modes: ::std::os::raw::c_uint,
    pub offset: timex___syscall_slong_t,
    pub freq: timex___syscall_slong_t,
    pub maxerror: timex___syscall_slong_t,
    pub esterror: timex___syscall_slong_t,
    pub status: ::std::os::raw::c_int,
    pub constant: timex___syscall_slong_t,
    pub precision: timex___syscall_slong_t,
    pub tolerance: timex___syscall_slong_t,
    pub time: timex_timeval,
    pub tick: timex___syscall_slong_t,
    pub ppsfreq: timex___syscall_slong_t,
    pub jitter: timex___syscall_slong_t,
    pub shift: ::std::os::raw::c_int,
    pub stabil: timex___syscall_slong_t,
    pub jitcnt: timex___syscall_slong_t,
    pub calcnt: timex___syscall_slong_t,
    pub errcnt: timex___syscall_slong_t,
    pub stbcnt: timex___syscall_slong_t,
    pub tai: ::std::os::raw::c_int,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 44usize]>,
}
#[test]
fn bindgen_test_layout_timex() {
    const UNINIT: ::std::mem::MaybeUninit<timex> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<timex>(),
        208usize,
        concat!("Size of: ", stringify!(timex))
    );
    assert_eq!(
        ::std::mem::align_of::<timex>(),
        8usize,
        concat!("Alignment of ", stringify!(timex))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).modes) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timex),
            "::",
            stringify!(modes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).offset) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(timex),
            "::",
            stringify!(offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).freq) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(timex),
            "::",
            stringify!(freq)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).maxerror) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(timex),
            "::",
            stringify!(maxerror)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).esterror) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(timex),
            "::",
            stringify!(esterror)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).status) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(timex),
            "::",
            stringify!(status)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).constant) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(timex),
            "::",
            stringify!(constant)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).precision) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(timex),
            "::",
            stringify!(precision)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tolerance) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(timex),
            "::",
            stringify!(tolerance)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).time) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(timex),
            "::",
            stringify!(time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tick) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(timex),
            "::",
            stringify!(tick)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ppsfreq) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(timex),
            "::",
            stringify!(ppsfreq)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).jitter) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(timex),
            "::",
            stringify!(jitter)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).shift) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(timex),
            "::",
            stringify!(shift)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).stabil) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(timex),
            "::",
            stringify!(stabil)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).jitcnt) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(timex),
            "::",
            stringify!(jitcnt)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).calcnt) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(timex),
            "::",
            stringify!(calcnt)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).errcnt) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(timex),
            "::",
            stringify!(errcnt)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).stbcnt) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(timex),
            "::",
            stringify!(stbcnt)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tai) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(timex),
            "::",
            stringify!(tai)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tm {
    pub tm_sec: ::std::os::raw::c_int,
    pub tm_min: ::std::os::raw::c_int,
    pub tm_hour: ::std::os::raw::c_int,
    pub tm_mday: ::std::os::raw::c_int,
    pub tm_mon: ::std::os::raw::c_int,
    pub tm_year: ::std::os::raw::c_int,
    pub tm_wday: ::std::os::raw::c_int,
    pub tm_yday: ::std::os::raw::c_int,
    pub tm_isdst: ::std::os::raw::c_int,
    pub tm_gmtoff: ::std::os::raw::c_long,
    pub tm_zone: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_tm() {
    const UNINIT: ::std::mem::MaybeUninit<tm> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<tm>(),
        56usize,
        concat!("Size of: ", stringify!(tm))
    );
    assert_eq!(
        ::std::mem::align_of::<tm>(),
        8usize,
        concat!("Alignment of ", stringify!(tm))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_sec) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_sec)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_min) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_min)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_hour) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_hour)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_mday) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_mday)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_mon) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_mon)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_year) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_year)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_wday) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_wday)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_yday) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_yday)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_isdst) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_isdst)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_gmtoff) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_gmtoff)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_zone) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_zone)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct itimerspec {
    pub it_interval: itimerspec_timespec,
    pub it_value: itimerspec_timespec,
}
#[test]
fn bindgen_test_layout_itimerspec() {
    const UNINIT: ::std::mem::MaybeUninit<itimerspec> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<itimerspec>(),
        32usize,
        concat!("Size of: ", stringify!(itimerspec))
    );
    assert_eq!(
        ::std::mem::align_of::<itimerspec>(),
        8usize,
        concat!("Alignment of ", stringify!(itimerspec))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).it_interval) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(itimerspec),
            "::",
            stringify!(it_interval)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).it_value) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(itimerspec),
            "::",
            stringify!(it_value)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sigevent {
    _unused: [u8; 0],
}
pub type __jmp_buf = [::std::os::raw::c_long; 8usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __jmp_buf_tag {
    pub __jmpbuf: __jmp_buf,
    pub __mask_was_saved: ::std::os::raw::c_int,
    pub __saved_mask: [u64; 16usize],
}
#[test]
fn bindgen_test_layout___jmp_buf_tag() {
    const UNINIT: ::std::mem::MaybeUninit<__jmp_buf_tag> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__jmp_buf_tag>(),
        200usize,
        concat!("Size of: ", stringify!(__jmp_buf_tag))
    );
    assert_eq!(
        ::std::mem::align_of::<__jmp_buf_tag>(),
        8usize,
        concat!("Alignment of ", stringify!(__jmp_buf_tag))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__jmpbuf) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__jmp_buf_tag),
            "::",
            stringify!(__jmpbuf)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__mask_was_saved) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(__jmp_buf_tag),
            "::",
            stringify!(__mask_was_saved)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__saved_mask) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(__jmp_buf_tag),
            "::",
            stringify!(__saved_mask)
        )
    );
}
pub const PTHREAD_CREATE_JOINABLE: _bindgen_ty_42 = 0;
pub const PTHREAD_CREATE_DETACHED: _bindgen_ty_42 = 1;
pub type _bindgen_ty_42 = ::std::os::raw::c_uint;
pub const PTHREAD_MUTEX_TIMED_NP: _bindgen_ty_43 = 0;
pub const PTHREAD_MUTEX_RECURSIVE_NP: _bindgen_ty_43 = 1;
pub const PTHREAD_MUTEX_ERRORCHECK_NP: _bindgen_ty_43 = 2;
pub const PTHREAD_MUTEX_ADAPTIVE_NP: _bindgen_ty_43 = 3;
pub const PTHREAD_MUTEX_NORMAL: _bindgen_ty_43 = 0;
pub const PTHREAD_MUTEX_RECURSIVE: _bindgen_ty_43 = 1;
pub const PTHREAD_MUTEX_ERRORCHECK: _bindgen_ty_43 = 2;
pub const PTHREAD_MUTEX_DEFAULT: _bindgen_ty_43 = 0;
pub const PTHREAD_MUTEX_FAST_NP: _bindgen_ty_43 = 0;
pub type _bindgen_ty_43 = ::std::os::raw::c_uint;
pub const PTHREAD_MUTEX_STALLED: _bindgen_ty_44 = 0;
pub const PTHREAD_MUTEX_STALLED_NP: _bindgen_ty_44 = 0;
pub const PTHREAD_MUTEX_ROBUST: _bindgen_ty_44 = 1;
pub const PTHREAD_MUTEX_ROBUST_NP: _bindgen_ty_44 = 1;
pub type _bindgen_ty_44 = ::std::os::raw::c_uint;
pub const PTHREAD_PRIO_NONE: _bindgen_ty_45 = 0;
pub const PTHREAD_PRIO_INHERIT: _bindgen_ty_45 = 1;
pub const PTHREAD_PRIO_PROTECT: _bindgen_ty_45 = 2;
pub type _bindgen_ty_45 = ::std::os::raw::c_uint;
pub const PTHREAD_RWLOCK_PREFER_READER_NP: _bindgen_ty_46 = 0;
pub const PTHREAD_RWLOCK_PREFER_WRITER_NP: _bindgen_ty_46 = 1;
pub const PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP: _bindgen_ty_46 = 2;
pub const PTHREAD_RWLOCK_DEFAULT_NP: _bindgen_ty_46 = 0;
pub type _bindgen_ty_46 = ::std::os::raw::c_uint;
pub const PTHREAD_INHERIT_SCHED: _bindgen_ty_47 = 0;
pub const PTHREAD_EXPLICIT_SCHED: _bindgen_ty_47 = 1;
pub type _bindgen_ty_47 = ::std::os::raw::c_uint;
pub const PTHREAD_SCOPE_SYSTEM: _bindgen_ty_48 = 0;
pub const PTHREAD_SCOPE_PROCESS: _bindgen_ty_48 = 1;
pub type _bindgen_ty_48 = ::std::os::raw::c_uint;
pub const PTHREAD_PROCESS_PRIVATE: _bindgen_ty_49 = 0;
pub const PTHREAD_PROCESS_SHARED: _bindgen_ty_49 = 1;
pub type _bindgen_ty_49 = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _pthread_cleanup_buffer {
    pub __routine: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
    pub __arg: *mut ::std::os::raw::c_void,
    pub __canceltype: ::std::os::raw::c_int,
    pub __prev: *mut _pthread_cleanup_buffer,
}
#[test]
fn bindgen_test_layout__pthread_cleanup_buffer() {
    const UNINIT: ::std::mem::MaybeUninit<_pthread_cleanup_buffer> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_pthread_cleanup_buffer>(),
        32usize,
        concat!("Size of: ", stringify!(_pthread_cleanup_buffer))
    );
    assert_eq!(
        ::std::mem::align_of::<_pthread_cleanup_buffer>(),
        8usize,
        concat!("Alignment of ", stringify!(_pthread_cleanup_buffer))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__routine) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_pthread_cleanup_buffer),
            "::",
            stringify!(__routine)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__arg) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_pthread_cleanup_buffer),
            "::",
            stringify!(__arg)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__canceltype) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_pthread_cleanup_buffer),
            "::",
            stringify!(__canceltype)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__prev) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_pthread_cleanup_buffer),
            "::",
            stringify!(__prev)
        )
    );
}
pub const PTHREAD_CANCEL_ENABLE: _bindgen_ty_50 = 0;
pub const PTHREAD_CANCEL_DISABLE: _bindgen_ty_50 = 1;
pub type _bindgen_ty_50 = ::std::os::raw::c_uint;
pub const PTHREAD_CANCEL_DEFERRED: _bindgen_ty_51 = 0;
pub const PTHREAD_CANCEL_ASYNCHRONOUS: _bindgen_ty_51 = 1;
pub type _bindgen_ty_51 = ::std::os::raw::c_uint;
pub type __gthread_t = pthread_t;
pub type __gthread_key_t = pthread_key_t;
pub type __gthread_once_t = pthread_once_t;
pub type __gthread_mutex_t = [u64; 5usize];
pub type __gthread_recursive_mutex_t = [u64; 5usize];
pub type __gthread_cond_t = [u64; 6usize];
pub type __gthread_time_t = itimerspec_timespec;
pub type _Atomic_word = ::std::os::raw::c_int;
#[repr(C)]
pub struct __cxxabiv1___forced_unwind__bindgen_vtable(::std::os::raw::c_void);
#[repr(C)]
#[derive(Debug)]
pub struct __cxxabiv1___forced_unwind {
    pub vtable_: *const __cxxabiv1___forced_unwind__bindgen_vtable,
}
#[test]
fn bindgen_test_layout___cxxabiv1___forced_unwind() {
    assert_eq!(
        ::std::mem::size_of::<__cxxabiv1___forced_unwind>(),
        8usize,
        concat!("Size of: ", stringify!(__cxxabiv1___forced_unwind))
    );
    assert_eq!(
        ::std::mem::align_of::<__cxxabiv1___forced_unwind>(),
        8usize,
        concat!("Alignment of ", stringify!(__cxxabiv1___forced_unwind))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __cxxabiv1___cxa_refcounted_exception {
    _unused: [u8; 0],
}
pub type llvm_EnableIfConvertibleToInputIterator = std_enable_if_t;
#[doc = " This is all the stuff common to all SmallVectors.\n\n The template parameter specifies the type which should be used to hold the\n Size and Capacity of the SmallVector, so it can be adjusted.\n Using 32 bit size is desirable to shrink the size of the SmallVector.\n Using 64 bit size is desirable for cases like SmallVector<char>, where a\n 32 bit size would limit the vector to ~4GB. SmallVectors are used for\n buffering bitcode output - which can exceed 4GB."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_SmallVectorBase<Size_T> {
    pub BeginX: *mut ::std::os::raw::c_void,
    pub Size: Size_T,
    pub Capacity: Size_T,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<Size_T>>,
}
pub type llvm_SmallVectorSizeType = std_conditional_t;
#[doc = " Figure out the offset of the first element."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_SmallVectorAlignmentAndSize {
    pub Base: *mut ::std::os::raw::c_char,
    pub FirstEl: *mut ::std::os::raw::c_char,
}
#[doc = " This is the part of SmallVectorTemplateBase which does not depend on whether\n the type T is a POD. The extra dummy template argument is used by ArrayRef\n to avoid unnecessarily requiring T to be complete."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_SmallVectorTemplateCommon {
    pub _base: llvm_SmallVectorBase<llvm_SmallVectorSizeType>,
}
#[doc = " This is all the stuff common to all SmallVectors.\n\n The template parameter specifies the type which should be used to hold the\n Size and Capacity of the SmallVector, so it can be adjusted.\n Using 32 bit size is desirable to shrink the size of the SmallVector.\n Using 64 bit size is desirable for cases like SmallVector<char>, where a\n 32 bit size would limit the vector to ~4GB. SmallVectors are used for\n buffering bitcode output - which can exceed 4GB."]
pub type llvm_SmallVectorTemplateCommon_Base = llvm_SmallVectorBase<llvm_SmallVectorSizeType>;
pub type llvm_SmallVectorTemplateCommon_size_type = usize;
pub type llvm_SmallVectorTemplateCommon_difference_type = isize;
pub type llvm_SmallVectorTemplateCommon_value_type<T> = T;
pub type llvm_SmallVectorTemplateCommon_iterator<T> = *mut T;
pub type llvm_SmallVectorTemplateCommon_const_iterator<T> = *const T;
pub type llvm_SmallVectorTemplateCommon_const_reverse_iterator<T> =
    std_reverse_iterator<llvm_SmallVectorTemplateCommon_const_iterator<T>>;
pub type llvm_SmallVectorTemplateCommon_reverse_iterator<T> =
    std_reverse_iterator<llvm_SmallVectorTemplateCommon_iterator<T>>;
pub type llvm_SmallVectorTemplateCommon_reference<T> = *mut T;
pub type llvm_SmallVectorTemplateCommon_const_reference<T> = *const T;
pub type llvm_SmallVectorTemplateCommon_pointer<T> = *mut T;
pub type llvm_SmallVectorTemplateCommon_const_pointer<T> = *const T;
pub type llvm_SmallVectorTemplateBase_ValueParamT<T> = *const T;
#[doc = " This class consists of common code factored out of the SmallVector class to\n reduce code duplication based on the SmallVector 'N' template parameter."]
#[repr(C)]
#[derive(Debug)]
pub struct llvm_SmallVectorImpl {
    pub _address: u8,
}
#[doc = " SmallVectorTemplateBase<TriviallyCopyable = false> - This is where we put\n method implementations that are designed to work with non-trivial T's.\n\n We approximate is_trivially_copyable with trivial move/copy construction and\n trivial destruction. While the standard doesn't specify that you're allowed\n copy these types with memcpy, there is no way for the type to observe this.\n This catches the important case of std::pair<POD, POD>, which is not\n trivially assignable."]
pub type llvm_SmallVectorImpl_SuperClass = u8;
pub type llvm_SmallVectorImpl_iterator = llvm_SmallVectorImpl_SuperClass;
pub type llvm_SmallVectorImpl_const_iterator = llvm_SmallVectorImpl_SuperClass;
pub type llvm_SmallVectorImpl_reference = llvm_SmallVectorImpl_SuperClass;
pub type llvm_SmallVectorImpl_size_type = llvm_SmallVectorImpl_SuperClass;
pub type llvm_SmallVectorImpl_ValueParamT = llvm_SmallVectorImpl_SuperClass;
#[doc = " Helper class for calculating the default number of inline elements for\n `SmallVector<T>`.\n\n This should be migrated to a constexpr function when our minimum\n compiler support is enough for multi-statement constexpr functions."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_CalculateSmallVectorDefaultInlinedElements {
    pub _address: u8,
}
pub type llvm_ValueTypeFromRangeType = std_remove_const_t;
#[test]
fn __bindgen_test_layout_llvm_SmallVectorBase_open0_unsigned_int_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<llvm_SmallVectorBase<::std::os::raw::c_uint>>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_SmallVectorBase<::std::os::raw::c_uint>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_SmallVectorBase<::std::os::raw::c_uint>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_SmallVectorBase<::std::os::raw::c_uint>)
        )
    );
}
#[test]
fn __bindgen_test_layout_llvm_SmallVectorBase_open0_unsigned_long_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<llvm_SmallVectorBase<::std::os::raw::c_ulong>>(),
        24usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_SmallVectorBase<::std::os::raw::c_ulong>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_SmallVectorBase<::std::os::raw::c_ulong>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_SmallVectorBase<::std::os::raw::c_ulong>)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm23EnableABIBreakingChecksE"]
    pub static mut llvm_EnableABIBreakingChecks: ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm29VerifyEnableABIBreakingChecksE"]
    pub static mut llvm_VerifyEnableABIBreakingChecks: *mut ::std::os::raw::c_int;
}
#[doc = " An error handler callback."]
pub type llvm_fatal_error_handler_t = ::std::option::Option<
    unsafe extern "C" fn(
        user_data: *mut ::std::os::raw::c_void,
        reason: *const ::std::os::raw::c_char,
        gen_crash_diag: bool,
    ),
>;
extern "C" {
    #[doc = " install_fatal_error_handler - Installs a new error handler to be used\n whenever a serious (non-recoverable) error is encountered by LLVM.\n\n If no error handler is installed the default is to print the error message\n to stderr, and call exit(1).  If an error handler is installed then it is\n the handler's responsibility to log the message, it will no longer be\n printed to stderr.  If the error handler returns, then exit(1) will be\n called.\n\n It is dangerous to naively use an error handler which throws an exception.\n Even though some applications desire to gracefully recover from arbitrary\n faults, blindly throwing exceptions through unfamiliar code isn't a way to\n achieve this.\n\n \\param user_data - An argument which will be passed to the install error\n handler."]
    #[link_name = "\u{1}_ZN4llvm27install_fatal_error_handlerEPFvPvPKcbES0_"]
    pub fn llvm_install_fatal_error_handler(
        handler: llvm_fatal_error_handler_t,
        user_data: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = " Restores default error handling behaviour."]
    #[link_name = "\u{1}_ZN4llvm26remove_fatal_error_handlerEv"]
    pub fn llvm_remove_fatal_error_handler();
}
#[doc = " ScopedFatalErrorHandler - This is a simple helper class which just\n calls install_fatal_error_handler in its constructor and\n remove_fatal_error_handler in its destructor."]
#[repr(C)]
#[derive(Debug)]
pub struct llvm_ScopedFatalErrorHandler {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_llvm_ScopedFatalErrorHandler() {
    assert_eq!(
        ::std::mem::size_of::<llvm_ScopedFatalErrorHandler>(),
        1usize,
        concat!("Size of: ", stringify!(llvm_ScopedFatalErrorHandler))
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_ScopedFatalErrorHandler>(),
        1usize,
        concat!("Alignment of ", stringify!(llvm_ScopedFatalErrorHandler))
    );
}
extern "C" {
    #[doc = " Reports a serious error, calling any installed error handler. These\n functions are intended to be used for error conditions which are outside\n the control of the compiler (I/O errors, invalid user input, etc.)\n\n If no error handler is installed the default is to print the message to\n standard error, followed by a newline.\n After the error handler is called this function will call abort(), it\n does not return.\n NOTE: The std::string variant was removed to avoid a <string> dependency."]
    #[link_name = "\u{1}_ZN4llvm18report_fatal_errorEPKcb"]
    pub fn llvm_report_fatal_error(reason: *const ::std::os::raw::c_char, gen_crash_diag: bool);
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm18report_fatal_errorENS_9StringRefEb"]
    pub fn llvm_report_fatal_error1(reason: llvm_StringRef, gen_crash_diag: bool);
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm18report_fatal_errorERKNS_5TwineEb"]
    pub fn llvm_report_fatal_error2(reason: *const llvm_Twine, gen_crash_diag: bool);
}
extern "C" {
    #[doc = " Installs a new bad alloc error handler that should be used whenever a\n bad alloc error, e.g. failing malloc/calloc, is encountered by LLVM.\n\n The user can install a bad alloc handler, in order to define the behavior\n in case of failing allocations, e.g. throwing an exception. Note that this\n handler must not trigger any additional allocations itself.\n\n If no error handler is installed the default is to print the error message\n to stderr, and call exit(1).  If an error handler is installed then it is\n the handler's responsibility to log the message, it will no longer be\n printed to stderr.  If the error handler returns, then exit(1) will be\n called.\n\n\n \\param user_data - An argument which will be passed to the installed error\n handler."]
    #[link_name = "\u{1}_ZN4llvm31install_bad_alloc_error_handlerEPFvPvPKcbES0_"]
    pub fn llvm_install_bad_alloc_error_handler(
        handler: llvm_fatal_error_handler_t,
        user_data: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = " Restores default bad alloc error handling behavior."]
    #[link_name = "\u{1}_ZN4llvm30remove_bad_alloc_error_handlerEv"]
    pub fn llvm_remove_bad_alloc_error_handler();
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm33install_out_of_memory_new_handlerEv"]
    pub fn llvm_install_out_of_memory_new_handler();
}
extern "C" {
    #[doc = " Reports a bad alloc error, calling any user defined bad alloc\n error handler. In contrast to the generic 'report_fatal_error'\n functions, this function might not terminate, e.g. the user\n defined error handler throws an exception, but it won't return.\n\n Note: When throwing an exception in the bad alloc handler, make sure that\n the following unwind succeeds, e.g. do not trigger additional allocations\n in the unwind chain.\n\n If no error handler is installed (default), throws a bad_alloc exception\n if LLVM is compiled with exception support. Otherwise prints the error\n to standard error and calls abort()."]
    #[link_name = "\u{1}_ZN4llvm22report_bad_alloc_errorEPKcb"]
    pub fn llvm_report_bad_alloc_error(Reason: *const ::std::os::raw::c_char, GenCrashDiag: bool);
}
extern "C" {
    #[doc = " This function calls abort(), and prints the optional message to stderr.\n Use the llvm_unreachable macro (that adds location info), instead of\n calling this function directly."]
    #[link_name = "\u{1}_ZN4llvm25llvm_unreachable_internalEPKcS1_j"]
    pub fn llvm_llvm_unreachable_internal(
        msg: *const ::std::os::raw::c_char,
        file: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_uint,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_remove_cvref {
    pub _address: u8,
}
pub type llvm_remove_cvref_type = std_remove_cv_t;
pub type llvm_remove_cvref_t = llvm_remove_cvref;
pub const llvm_endianness_big: llvm_endianness = 0;
pub const llvm_endianness_little: llvm_endianness = 1;
pub const llvm_endianness_native: llvm_endianness = 1;
pub type llvm_endianness = ::std::os::raw::c_int;
#[repr(C)]
#[repr(align(1))]
pub struct llvm_detail_trivial_helper<T> {
    pub t: __BindgenUnionField<T>,
    pub bindgen_union_field: [u8; 0usize],
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<T>>,
}
pub type llvm_detail_IterOfRange<RangeT> = RangeT;
pub type llvm_detail_ValueOfRange = std_remove_reference_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_detail_detector {
    pub _address: u8,
}
pub type llvm_detail_detector_value_t = std_false_type;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_detail_TypesAreDistinct {
    pub _address: u8,
}
pub type llvm_detail_check_has_free_function_rbegin<Range> = Range;
pub type llvm_detail_fwd_or_bidi_tag_impl_type = std_forward_iterator_tag;
#[doc = " Helper which sets its type member to forward_iterator_tag if the category\n of \\p IterT does not derive from bidirectional_iterator_tag, and to\n bidirectional_iterator_tag otherwise."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_detail_fwd_or_bidi_tag {
    pub _address: u8,
}
pub type llvm_detail_fwd_or_bidi_tag_type = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_detail_ZipTupleType {
    pub _address: u8,
}
pub type llvm_detail_ZipTupleType_type = std_tuple;
pub type llvm_detail_zip_traits = llvm_iterator_facade_base;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_detail_zip_common {
    pub iterators: std_tuple,
}
#[doc = " CRTP base class which implements the entire standard iterator facade\n in terms of a minimal subset of the interface.\n\n Use this when it is reasonable to implement most of the iterator\n functionality in terms of a core subset. If you need special behavior or\n there are performance implications for this, you may want to override the\n relevant members instead.\n\n Note, one abstraction that this does *not* provide is implementing\n subtraction in terms of addition by negating the difference. Negation isn't\n always information preserving, and I can see very reasonable iterator\n designs where this doesn't work well. It doesn't really force much added\n boilerplate anyways.\n\n Another abstraction that this doesn't provide is implementing increment in\n terms of addition of one. These aren't equivalent for all iterator\n categories, and respecting that adds a lot of complexity for little gain.\n\n Iterators are expected to have const rules analogous to pointers, with a\n single, const-qualified operator*() that returns ReferenceT. This matches\n the second and third pointers in the following example:\n \\code\n   int Value;\n   { int *I = &Value; }             // ReferenceT 'int&'\n   { int *const I = &Value; }       // ReferenceT 'int&'; const\n   { const int *I = &Value; }       // ReferenceT 'const int&'\n   { const int *const I = &Value; } // ReferenceT 'const int&'; const\n \\endcode\n If an iterator facade returns a handle to its own state, then T (and\n PointerT and ReferenceT) should usually be const-qualified. Otherwise, if\n clients are expected to modify the handle itself, the field can be declared\n mutable or use const_cast.\n\n Classes wishing to use `iterator_facade_base` should implement the following\n methods:\n\n Forward Iterators:\n   (All of the following methods)\n   - DerivedT &operator=(const DerivedT &R);\n   - bool operator==(const DerivedT &R) const;\n   - T &operator*() const;\n   - DerivedT &operator++();\n\n Bidirectional Iterators:\n   (All methods of forward iterators, plus the following)\n   - DerivedT &operator--();\n\n Random-access Iterators:\n   (All methods of bidirectional iterators excluding the following)\n   - DerivedT &operator++();\n   - DerivedT &operator--();\n   (and plus the following)\n   - bool operator<(const DerivedT &RHS) const;\n   - DifferenceTypeT operator-(const DerivedT &R) const;\n   - DerivedT &operator+=(DifferenceTypeT N);\n   - DerivedT &operator-=(DifferenceTypeT N);\n"]
pub type llvm_detail_zip_common_Base = llvm_detail_zip_traits;
pub type llvm_detail_zip_common_IndexSequence = std_index_sequence_for;
pub type llvm_detail_zip_common_value_type = llvm_detail_zip_common_Base;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_detail_zip_first {
    pub _base: llvm_detail_zip_common,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_detail_zip_shortest {
    pub _base: llvm_detail_zip_common,
}
#[doc = " Helper to obtain the iterator types for the tuple storage within `zippy`."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_detail_ZippyIteratorTuple {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_detail_zippy {
    pub storage: std_tuple,
}
pub type llvm_detail_zippy_IndexSequence = std_index_sequence_for;
pub type llvm_detail_zippy_iterator = llvm_detail_ZippyIteratorTuple;
pub type llvm_detail_zippy_const_iterator = llvm_detail_ZippyIteratorTuple;
pub type llvm_detail_zippy_iterator_category = llvm_detail_zippy_iterator;
pub type llvm_detail_zippy_value_type = llvm_detail_zippy_iterator;
pub type llvm_detail_zippy_difference_type = llvm_detail_zippy_iterator;
pub type llvm_detail_zippy_pointer = llvm_detail_zippy_iterator;
pub type llvm_detail_zippy_reference = llvm_detail_zippy_iterator;
pub type llvm_detail_zippy_const_reference = llvm_detail_zippy_const_iterator;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_detail_ZipLongestItemType {
    pub _address: u8,
}
pub type llvm_detail_ZipLongestItemType_type = std_optional;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_detail_ZipLongestTupleType {
    pub _address: u8,
}
pub type llvm_detail_ZipLongestTupleType_type = std_tuple;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_detail_zip_longest_iterator {
    pub iterators: std_tuple,
    pub end_iterators: std_tuple,
}
pub type llvm_detail_zip_longest_iterator_value_type = llvm_detail_ZipLongestTupleType;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_detail_zip_longest_range {
    pub ts: std_tuple,
}
pub type llvm_detail_zip_longest_range_iterator = llvm_detail_zip_longest_iterator;
pub type llvm_detail_zip_longest_range_iterator_category = llvm_detail_zip_longest_range_iterator;
pub type llvm_detail_zip_longest_range_value_type = llvm_detail_zip_longest_range_iterator;
pub type llvm_detail_zip_longest_range_difference_type = llvm_detail_zip_longest_range_iterator;
pub type llvm_detail_zip_longest_range_pointer = llvm_detail_zip_longest_range_iterator;
pub type llvm_detail_zip_longest_range_reference = llvm_detail_zip_longest_range_iterator;
#[doc = " Helper to store a sequence of ranges being concatenated and access them.\n\n This is designed to facilitate providing actual storage when temporaries\n are passed into the constructor such that we can use it as part of range\n based for loops."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_detail_concat_range {
    pub Ranges: std_tuple,
}
#[doc = " Iterator wrapper that concatenates sequences together.\n\n This can concatenate different iterators, even with different types, into\n a single iterator provided the value types of all the concatenated\n iterators expose `reference` and `pointer` types that can be converted to\n `ValueT &` and `ValueT *` respectively. It doesn't support more\n interesting/customized pointer or reference types.\n\n Currently this only supports forward or higher iterator categories as\n inputs and always exposes a forward iterator interface."]
pub type llvm_detail_concat_range_iterator = llvm_concat_iterator;
#[doc = " The class represents the base of a range of indexed_accessor_iterators. It\n provides support for many different range functionalities, e.g.\n drop_front/slice/etc.. Derived range classes must implement the following\n static methods:\n   * ReferenceT dereference_iterator(const BaseT &base, ptrdiff_t index)\n     - Dereference an iterator pointing to the base object at the given\n       index.\n   * BaseT offset_base(const BaseT &base, ptrdiff_t index)\n     - Return a new base that is offset from the provide base by 'index'\n       elements."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_detail_indexed_accessor_range_base<BaseT> {
    #[doc = " The base that owns the provided range of values."]
    pub base: BaseT,
    #[doc = " The size from the owning range."]
    pub count: isize,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<BaseT>>,
}
#[doc = " The class represents the base of a range of indexed_accessor_iterators. It\n provides support for many different range functionalities, e.g.\n drop_front/slice/etc.. Derived range classes must implement the following\n static methods:\n   * ReferenceT dereference_iterator(const BaseT &base, ptrdiff_t index)\n     - Dereference an iterator pointing to the base object at the given\n       index.\n   * BaseT offset_base(const BaseT &base, ptrdiff_t index)\n     - Return a new base that is offset from the provide base by 'index'\n       elements."]
pub type llvm_detail_indexed_accessor_range_base_RangeBaseT<BaseT> =
    llvm_detail_indexed_accessor_range_base<BaseT>;
#[doc = " An iterator element of this range."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_detail_indexed_accessor_range_base_iterator<BaseT> {
    pub _base: llvm_indexed_accessor_iterator<BaseT>,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<BaseT>>,
}
#[doc = " Return a reference to the first or second member of a reference. Otherwise,\n return a copy of the member of a temporary.\n\n When passing a range whose iterators return values instead of references,\n the reference must be dropped from `decltype((elt.first))`, which will\n always be a reference, to avoid returning a reference to a temporary."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_detail_first_or_second_type {
    pub _address: u8,
}
pub type llvm_detail_first_or_second_type_type = std_conditional_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_detail_Visitor {
    pub _address: u8,
}
pub type llvm_detail_sort_trivially_copyable = std_conjunction;
pub type llvm_detail_check_has_free_function_size<Range> = Range;
pub type llvm_detail_check_has_member_contains_t<Range> = Range;
pub type llvm_detail_check_has_member_find_t<Range> = Range;
#[doc = " Tuple-like type for `zip_enumerator` dereference."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_detail_enumerator_result {
    pub _address: u8,
}
pub type llvm_detail_EnumeratorTupleType = llvm_detail_enumerator_result;
#[doc = " Zippy iterator that uses the second iterator for comparisons. For the\n increment to be safe, the second range has to be the shortest.\n Returns `enumerator_result` on dereference to provide `.index()` and\n `.value()` member functions.\n Note: Because the dereference operator returns `enumerator_result` as a\n value instead of a reference and does not strictly conform to the C++17's\n definition of forward iterator. However, it satisfies all the\n forward_iterator requirements that the `zip_common` and `zippy` depend on\n and fully conforms to the C++20 definition of forward iterator.\n This is similar to `std::vector<bool>::iterator` that returns bit reference\n wrappers on dereference."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_detail_zip_enumerator {
    pub _base: llvm_detail_zip_common,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_detail_index_iterator {
    pub Index: usize,
}
#[test]
fn bindgen_test_layout_llvm_detail_index_iterator() {
    const UNINIT: ::std::mem::MaybeUninit<llvm_detail_index_iterator> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<llvm_detail_index_iterator>(),
        8usize,
        concat!("Size of: ", stringify!(llvm_detail_index_iterator))
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_detail_index_iterator>(),
        8usize,
        concat!("Alignment of ", stringify!(llvm_detail_index_iterator))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Index) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_detail_index_iterator),
            "::",
            stringify!(Index)
        )
    );
}
#[doc = " Infinite stream of increasing 0-based `size_t` indices."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_detail_index_stream {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_llvm_detail_index_stream() {
    assert_eq!(
        ::std::mem::size_of::<llvm_detail_index_stream>(),
        1usize,
        concat!("Size of: ", stringify!(llvm_detail_index_stream))
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_detail_index_stream>(),
        1usize,
        concat!("Alignment of ", stringify!(llvm_detail_index_stream))
    );
}
pub type llvm_detail_has_sizeof<T> = T;
#[doc = " A helper to derive the type to use with `Self` for cast traits, when the\n provided CRTP derived type is allowed to be void."]
pub type llvm_detail_SelfType = std_conditional_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_detail_IsaCheckPredicate {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_detail_IsaAndPresentCheckPredicate {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_detail_AllocatorHolder<Alloc> {
    pub _base: Alloc,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<Alloc>>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_detail_HasPointerLikeTypeTraits {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_detail_IsPointerLike {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_detail_CheckedInt {
    pub Value: intmax_t,
}
#[test]
fn bindgen_test_layout_llvm_detail_CheckedInt() {
    const UNINIT: ::std::mem::MaybeUninit<llvm_detail_CheckedInt> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<llvm_detail_CheckedInt>(),
        8usize,
        concat!("Size of: ", stringify!(llvm_detail_CheckedInt))
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_detail_CheckedInt>(),
        8usize,
        concat!("Alignment of ", stringify!(llvm_detail_CheckedInt))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Value) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_detail_CheckedInt),
            "::",
            stringify!(Value)
        )
    );
}
pub type llvm_detail_SafeIntIterator_iterator_category = std_random_access_iterator_tag;
pub type llvm_detail_SafeIntIterator_value_type<T> = T;
pub type llvm_detail_SafeIntIterator_difference_type = intmax_t;
pub type llvm_detail_SafeIntIterator_pointer<T> = *mut T;
pub type llvm_detail_SafeIntIterator_reference<T> = llvm_detail_SafeIntIterator_value_type<T>;
#[repr(C)]
#[derive(Debug)]
pub struct llvm_detail_DenseMapPair<KeyT, ValueT> {
    pub _base: std_pair<KeyT, ValueT>,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<KeyT>>,
    pub _phantom_1: ::std::marker::PhantomData<::std::cell::UnsafeCell<ValueT>>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_detail_DenseSetEmpty {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_llvm_detail_DenseSetEmpty() {
    assert_eq!(
        ::std::mem::size_of::<llvm_detail_DenseSetEmpty>(),
        1usize,
        concat!("Size of: ", stringify!(llvm_detail_DenseSetEmpty))
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_detail_DenseSetEmpty>(),
        1usize,
        concat!("Alignment of ", stringify!(llvm_detail_DenseSetEmpty))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_detail_DenseSetPair<KeyT> {
    pub key: KeyT,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<KeyT>>,
}
#[doc = " Base class for DenseSet and DenseSmallSet.\n\n MapTy should be either\n\n   DenseMap<ValueT, detail::DenseSetEmpty, ValueInfoT,\n            detail::DenseSetPair<ValueT>>\n\n or the equivalent SmallDenseMap type.  ValueInfoT must implement the\n DenseMapInfo \"concept\"."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_detail_DenseSetImpl<MapTy> {
    pub TheMap: MapTy,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<MapTy>>,
}
pub type llvm_detail_DenseSetImpl_const_arg_type_t = llvm_const_pointer_or_const_ref;
pub type llvm_detail_DenseSetImpl_key_type<ValueT> = ValueT;
pub type llvm_detail_DenseSetImpl_value_type<ValueT> = ValueT;
pub type llvm_detail_DenseSetImpl_size_type = ::std::os::raw::c_uint;
#[repr(C)]
pub struct llvm_detail_DenseSetImpl_Iterator {
    pub I: [u8; 0usize],
}
pub type llvm_detail_DenseSetImpl_Iterator_difference_type = [u8; 0usize];
pub type llvm_detail_DenseSetImpl_Iterator_value_type<ValueT> = ValueT;
pub type llvm_detail_DenseSetImpl_Iterator_pointer<ValueT> =
    *mut llvm_detail_DenseSetImpl_Iterator_value_type<ValueT>;
pub type llvm_detail_DenseSetImpl_Iterator_reference<ValueT> =
    *mut llvm_detail_DenseSetImpl_Iterator_value_type<ValueT>;
pub type llvm_detail_DenseSetImpl_Iterator_iterator_category = std_forward_iterator_tag;
#[repr(C)]
pub struct llvm_detail_DenseSetImpl_ConstIterator {
    pub I: [u8; 0usize],
}
pub type llvm_detail_DenseSetImpl_ConstIterator_difference_type = [u8; 0usize];
pub type llvm_detail_DenseSetImpl_ConstIterator_value_type<ValueT> = ValueT;
pub type llvm_detail_DenseSetImpl_ConstIterator_pointer<ValueT> =
    *const llvm_detail_DenseSetImpl_ConstIterator_value_type<ValueT>;
pub type llvm_detail_DenseSetImpl_ConstIterator_reference<ValueT> =
    *const llvm_detail_DenseSetImpl_ConstIterator_value_type<ValueT>;
pub type llvm_detail_DenseSetImpl_ConstIterator_iterator_category = std_forward_iterator_tag;
pub type llvm_detail_DenseSetImpl_iterator = llvm_detail_DenseSetImpl_Iterator;
pub type llvm_detail_DenseSetImpl_const_iterator = llvm_detail_DenseSetImpl_ConstIterator;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_detail_PunnedPointer {
    pub Data: *mut ::std::os::raw::c_uchar,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_detail_unit {
    pub _address: u8,
}
extern "C" {
    #[link_name = "\u{1}value"]
    pub static llvm_detail_value: [::std::os::raw::c_char; 1usize];
}
#[test]
fn __bindgen_test_layout_llvm_detail_unit_open0_std_ratio_open1_close1_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<llvm_detail_unit>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_detail_unit)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_detail_unit>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_detail_unit)
        )
    );
}
#[test]
fn __bindgen_test_layout_llvm_detail_unit_open0_std_ratio_open1_close1_close0_instantiation_1() {
    assert_eq!(
        ::std::mem::size_of::<llvm_detail_unit>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_detail_unit)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_detail_unit>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_detail_unit)
        )
    );
}
#[test]
fn __bindgen_test_layout_llvm_detail_unit_open0_std_ratio_open1_close1_close0_instantiation_2() {
    assert_eq!(
        ::std::mem::size_of::<llvm_detail_unit>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_detail_unit)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_detail_unit>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_detail_unit)
        )
    );
}
#[test]
fn __bindgen_test_layout_llvm_detail_unit_open0_std_ratio_open1_close1_close0_instantiation_3() {
    assert_eq!(
        ::std::mem::size_of::<llvm_detail_unit>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_detail_unit)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_detail_unit>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_detail_unit)
        )
    );
}
#[test]
fn __bindgen_test_layout_llvm_detail_unit_open0_std_ratio_open1_close1_close0_instantiation_4() {
    assert_eq!(
        ::std::mem::size_of::<llvm_detail_unit>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_detail_unit)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_detail_unit>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_detail_unit)
        )
    );
}
#[test]
fn __bindgen_test_layout_llvm_detail_unit_open0_std_ratio_open1_close1_close0_instantiation_5() {
    assert_eq!(
        ::std::mem::size_of::<llvm_detail_unit>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_detail_unit)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_detail_unit>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_detail_unit)
        )
    );
}
#[repr(C)]
pub struct llvm_detail_PassConcept__bindgen_vtable(::std::os::raw::c_void);
#[doc = " Template for the abstract base class used to dispatch\n polymorphically over pass objects."]
#[repr(C)]
#[derive(Debug)]
pub struct llvm_detail_PassConcept {
    pub vtable_: *const llvm_detail_PassConcept__bindgen_vtable,
}
#[doc = " A template wrapper used to implement the polymorphic API.\n\n Can be instantiated for any object which provides a \\c run method accepting\n an \\c IRUnitT& and an \\c AnalysisManager<IRUnit>&. It requires the pass to\n be a copyable object."]
#[repr(C)]
#[derive(Debug)]
pub struct llvm_detail_PassModel<PassT> {
    pub _base: llvm_detail_PassConcept,
    pub Pass: PassT,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<PassT>>,
}
pub type llvm_detail_PassModel_has_required_t<T> = T;
#[repr(C)]
pub struct llvm_detail_AnalysisResultConcept__bindgen_vtable(::std::os::raw::c_void);
#[doc = " Abstract concept of an analysis result.\n\n This concept is parameterized over the IR unit that this result pertains\n to."]
#[repr(C)]
#[derive(Debug)]
pub struct llvm_detail_AnalysisResultConcept {
    pub vtable_: *const llvm_detail_AnalysisResultConcept__bindgen_vtable,
}
#[doc = " SFINAE metafunction for computing whether \\c ResultT provides an\n \\c invalidate member function."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_detail_ResultHasInvalidateMethod {
    pub _address: u8,
}
pub type llvm_detail_ResultHasInvalidateMethod_EnabledType = ::std::os::raw::c_char;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_detail_ResultHasInvalidateMethod_DisabledType {
    pub a: ::std::os::raw::c_char,
    pub b: ::std::os::raw::c_char,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_detail_ResultHasInvalidateMethod_Nonce {
    pub _address: u8,
}
pub type llvm_detail_ResultHasInvalidateMethod_Nonce_Type =
    llvm_detail_ResultHasInvalidateMethod_EnabledType;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_detail_ResultHasInvalidateMethod_CheckerBase {
    pub invalidate: ::std::os::raw::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_detail_ResultHasInvalidateMethod_Checker<T> {
    pub _base: llvm_detail_ResultHasInvalidateMethod_CheckerBase,
    pub _base_1: T,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<T>>,
}
pub const llvm_detail_ResultHasInvalidateMethod_Value:
    llvm_detail_ResultHasInvalidateMethod__bindgen_ty_1 = 0;
pub type llvm_detail_ResultHasInvalidateMethod__bindgen_ty_1 = i32;
#[repr(C)]
pub struct llvm_detail_AnalysisPassConcept__bindgen_vtable(::std::os::raw::c_void);
#[doc = " Abstract concept of an analysis pass.\n\n This concept is parameterized over the IR unit that it can run over and\n produce an analysis result."]
#[repr(C)]
#[derive(Debug)]
pub struct llvm_detail_AnalysisPassConcept {
    pub vtable_: *const llvm_detail_AnalysisPassConcept__bindgen_vtable,
}
#[doc = " Wrapper to model the analysis pass concept.\n\n Can wrap any type which implements a suitable \\c run method. The method\n must accept an \\c IRUnitT& and an \\c AnalysisManager<IRUnitT>& as arguments\n and produce an object which can be wrapped in a \\c AnalysisResultModel."]
#[repr(C)]
#[derive(Debug)]
pub struct llvm_detail_AnalysisPassModel<PassT> {
    pub _base: llvm_detail_AnalysisPassConcept,
    pub Pass: PassT,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<PassT>>,
}
pub type llvm_detail_AnalysisPassModel_ResultModelT = u8;
extern "C" {
    #[link_name = "\u{1}_ZN4llvm6detail26printBumpPtrAllocatorStatsEjmm"]
    pub fn llvm_detail_printBumpPtrAllocatorStats(
        NumSlabs: ::std::os::raw::c_uint,
        BytesAllocated: usize,
        TotalMemory: usize,
    );
}
pub const llvm_sys_IsBigEndianHost: bool = false;
pub const llvm_sys_IsLittleEndianHost: bool = true;
pub type llvm_sys_fs_file_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_sys_fs_UniqueID {
    pub Device: u64,
    pub File: u64,
}
#[test]
fn bindgen_test_layout_llvm_sys_fs_UniqueID() {
    const UNINIT: ::std::mem::MaybeUninit<llvm_sys_fs_UniqueID> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<llvm_sys_fs_UniqueID>(),
        16usize,
        concat!("Size of: ", stringify!(llvm_sys_fs_UniqueID))
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_sys_fs_UniqueID>(),
        8usize,
        concat!("Alignment of ", stringify!(llvm_sys_fs_UniqueID))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Device) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_sys_fs_UniqueID),
            "::",
            stringify!(Device)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).File) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_sys_fs_UniqueID),
            "::",
            stringify!(File)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm3sys2fs12kInvalidFileE"]
    pub static llvm_sys_fs_kInvalidFile: llvm_sys_fs_file_t;
}
pub const llvm_sys_fs_file_type_status_error: llvm_sys_fs_file_type = 0;
pub const llvm_sys_fs_file_type_file_not_found: llvm_sys_fs_file_type = 1;
pub const llvm_sys_fs_file_type_regular_file: llvm_sys_fs_file_type = 2;
pub const llvm_sys_fs_file_type_directory_file: llvm_sys_fs_file_type = 3;
pub const llvm_sys_fs_file_type_symlink_file: llvm_sys_fs_file_type = 4;
pub const llvm_sys_fs_file_type_block_file: llvm_sys_fs_file_type = 5;
pub const llvm_sys_fs_file_type_character_file: llvm_sys_fs_file_type = 6;
pub const llvm_sys_fs_file_type_fifo_file: llvm_sys_fs_file_type = 7;
pub const llvm_sys_fs_file_type_socket_file: llvm_sys_fs_file_type = 8;
pub const llvm_sys_fs_file_type_type_unknown: llvm_sys_fs_file_type = 9;
#[doc = " An enumeration for the file system's view of the type."]
pub type llvm_sys_fs_file_type = ::std::os::raw::c_int;
#[doc = " space_info - Self explanatory."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_sys_fs_space_info {
    pub capacity: u64,
    pub free: u64,
    pub available: u64,
}
#[test]
fn bindgen_test_layout_llvm_sys_fs_space_info() {
    const UNINIT: ::std::mem::MaybeUninit<llvm_sys_fs_space_info> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<llvm_sys_fs_space_info>(),
        24usize,
        concat!("Size of: ", stringify!(llvm_sys_fs_space_info))
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_sys_fs_space_info>(),
        8usize,
        concat!("Alignment of ", stringify!(llvm_sys_fs_space_info))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).capacity) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_sys_fs_space_info),
            "::",
            stringify!(capacity)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).free) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_sys_fs_space_info),
            "::",
            stringify!(free)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).available) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_sys_fs_space_info),
            "::",
            stringify!(available)
        )
    );
}
pub const llvm_sys_fs_perms_no_perms: llvm_sys_fs_perms = 0;
pub const llvm_sys_fs_perms_owner_read: llvm_sys_fs_perms = 256;
pub const llvm_sys_fs_perms_owner_write: llvm_sys_fs_perms = 128;
pub const llvm_sys_fs_perms_owner_exe: llvm_sys_fs_perms = 64;
pub const llvm_sys_fs_perms_owner_all: llvm_sys_fs_perms = 448;
pub const llvm_sys_fs_perms_group_read: llvm_sys_fs_perms = 32;
pub const llvm_sys_fs_perms_group_write: llvm_sys_fs_perms = 16;
pub const llvm_sys_fs_perms_group_exe: llvm_sys_fs_perms = 8;
pub const llvm_sys_fs_perms_group_all: llvm_sys_fs_perms = 56;
pub const llvm_sys_fs_perms_others_read: llvm_sys_fs_perms = 4;
pub const llvm_sys_fs_perms_others_write: llvm_sys_fs_perms = 2;
pub const llvm_sys_fs_perms_others_exe: llvm_sys_fs_perms = 1;
pub const llvm_sys_fs_perms_others_all: llvm_sys_fs_perms = 7;
pub const llvm_sys_fs_perms_all_read: llvm_sys_fs_perms = 292;
pub const llvm_sys_fs_perms_all_write: llvm_sys_fs_perms = 146;
pub const llvm_sys_fs_perms_all_exe: llvm_sys_fs_perms = 73;
pub const llvm_sys_fs_perms_all_all: llvm_sys_fs_perms = 511;
pub const llvm_sys_fs_perms_set_uid_on_exe: llvm_sys_fs_perms = 2048;
pub const llvm_sys_fs_perms_set_gid_on_exe: llvm_sys_fs_perms = 1024;
pub const llvm_sys_fs_perms_sticky_bit: llvm_sys_fs_perms = 512;
pub const llvm_sys_fs_perms_all_perms: llvm_sys_fs_perms = 4095;
pub const llvm_sys_fs_perms_perms_not_known: llvm_sys_fs_perms = 65535;
pub type llvm_sys_fs_perms = ::std::os::raw::c_uint;
#[doc = " Represents the result of a call to directory_iterator::status(). This is a\n subset of the information returned by a regular sys::fs::status() call, and\n represents the information provided by Windows FileFirstFile/FindNextFile."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_sys_fs_basic_file_status {
    pub fs_st_atime: llvm_sys_fs_basic_file_status_time_t,
    pub fs_st_mtime: llvm_sys_fs_basic_file_status_time_t,
    pub fs_st_atime_nsec: u32,
    pub fs_st_mtime_nsec: u32,
    pub fs_st_uid: llvm_sys_fs_basic_file_status_uid_t,
    pub fs_st_gid: llvm_sys_fs_basic_file_status_gid_t,
    pub fs_st_size: llvm_sys_fs_basic_file_status_off_t,
    pub Type: llvm_sys_fs_file_type,
    pub Perms: llvm_sys_fs_perms,
}
#[test]
fn bindgen_test_layout_llvm_sys_fs_basic_file_status() {
    const UNINIT: ::std::mem::MaybeUninit<llvm_sys_fs_basic_file_status> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<llvm_sys_fs_basic_file_status>(),
        48usize,
        concat!("Size of: ", stringify!(llvm_sys_fs_basic_file_status))
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_sys_fs_basic_file_status>(),
        8usize,
        concat!("Alignment of ", stringify!(llvm_sys_fs_basic_file_status))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fs_st_atime) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_sys_fs_basic_file_status),
            "::",
            stringify!(fs_st_atime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fs_st_mtime) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_sys_fs_basic_file_status),
            "::",
            stringify!(fs_st_mtime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fs_st_atime_nsec) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_sys_fs_basic_file_status),
            "::",
            stringify!(fs_st_atime_nsec)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fs_st_mtime_nsec) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_sys_fs_basic_file_status),
            "::",
            stringify!(fs_st_mtime_nsec)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fs_st_uid) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_sys_fs_basic_file_status),
            "::",
            stringify!(fs_st_uid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fs_st_gid) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_sys_fs_basic_file_status),
            "::",
            stringify!(fs_st_gid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fs_st_size) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_sys_fs_basic_file_status),
            "::",
            stringify!(fs_st_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Type) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_sys_fs_basic_file_status),
            "::",
            stringify!(Type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Perms) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_sys_fs_basic_file_status),
            "::",
            stringify!(Perms)
        )
    );
}
extern "C" {
    #[doc = " The file access time as reported from the underlying file system.\n\n Also see comments on \\c getLastModificationTime() related to the precision\n of the returned value."]
    #[link_name = "\u{1}_ZNK4llvm3sys2fs17basic_file_status19getLastAccessedTimeEv"]
    pub fn llvm_sys_fs_basic_file_status_getLastAccessedTime(
        this: *const llvm_sys_fs_basic_file_status,
    ) -> std_chrono_time_point<std_chrono_duration<::std::os::raw::c_long>>;
}
extern "C" {
    #[doc = " The file modification time as reported from the underlying file system.\n\n The returned value allows for nanosecond precision but the actual\n resolution is an implementation detail of the underlying file system.\n There is no guarantee for what kind of resolution you can expect, the\n resolution can differ across platforms and even across mountpoints on the\n same machine."]
    #[link_name = "\u{1}_ZNK4llvm3sys2fs17basic_file_status23getLastModificationTimeEv"]
    pub fn llvm_sys_fs_basic_file_status_getLastModificationTime(
        this: *const llvm_sys_fs_basic_file_status,
    ) -> std_chrono_time_point<std_chrono_duration<::std::os::raw::c_long>>;
}
impl llvm_sys_fs_basic_file_status {
    #[inline]
    pub unsafe fn getLastAccessedTime(
        &self,
    ) -> std_chrono_time_point<std_chrono_duration<::std::os::raw::c_long>> {
        llvm_sys_fs_basic_file_status_getLastAccessedTime(self)
    }
    #[inline]
    pub unsafe fn getLastModificationTime(
        &self,
    ) -> std_chrono_time_point<std_chrono_duration<::std::os::raw::c_long>> {
        llvm_sys_fs_basic_file_status_getLastModificationTime(self)
    }
}
#[doc = " Represents the result of a call to sys::fs::status()."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_sys_fs_file_status {
    pub _base: llvm_sys_fs_basic_file_status,
    pub fs_st_dev: llvm_sys_fs_file_status_dev_t,
    pub fs_st_nlinks: llvm_sys_fs_file_status_nlink_t,
    pub fs_st_ino: llvm_sys_fs_file_status_ino_t,
}
#[test]
fn bindgen_test_layout_llvm_sys_fs_file_status() {
    const UNINIT: ::std::mem::MaybeUninit<llvm_sys_fs_file_status> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<llvm_sys_fs_file_status>(),
        72usize,
        concat!("Size of: ", stringify!(llvm_sys_fs_file_status))
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_sys_fs_file_status>(),
        8usize,
        concat!("Alignment of ", stringify!(llvm_sys_fs_file_status))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fs_st_dev) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_sys_fs_file_status),
            "::",
            stringify!(fs_st_dev)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fs_st_nlinks) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_sys_fs_file_status),
            "::",
            stringify!(fs_st_nlinks)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fs_st_ino) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_sys_fs_file_status),
            "::",
            stringify!(fs_st_ino)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK4llvm3sys2fs11file_status11getUniqueIDEv"]
    pub fn llvm_sys_fs_file_status_getUniqueID(
        this: *const llvm_sys_fs_file_status,
    ) -> llvm_sys_fs_UniqueID;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4llvm3sys2fs11file_status12getLinkCountEv"]
    pub fn llvm_sys_fs_file_status_getLinkCount(this: *const llvm_sys_fs_file_status) -> u32;
}
impl llvm_sys_fs_file_status {
    #[inline]
    pub unsafe fn getUniqueID(&self) -> llvm_sys_fs_UniqueID {
        llvm_sys_fs_file_status_getUniqueID(self)
    }
    #[inline]
    pub unsafe fn getLinkCount(&self) -> u32 {
        llvm_sys_fs_file_status_getLinkCount(self)
    }
}
extern "C" {
    #[doc = " Make \\a path an absolute path.\n\n Makes \\a path absolute using the \\a current_directory if it is not already.\n An empty \\a path will result in the \\a current_directory.\n\n /absolute/path   => /absolute/path\n relative/../path => <current-directory>/relative/../path\n\n @param path A path that is modified to be an absolute path."]
    #[link_name = "\u{1}_ZN4llvm3sys2fs13make_absoluteERKNS_5TwineERNS_15SmallVectorImplIcEE"]
    pub fn llvm_sys_fs_make_absolute(
        current_directory: *const llvm_Twine,
        path: *mut llvm_SmallVectorImpl,
    );
}
extern "C" {
    #[doc = " Make \\a path an absolute path.\n\n Makes \\a path absolute using the current directory if it is not already. An\n empty \\a path will result in the current directory.\n\n /absolute/path   => /absolute/path\n relative/../path => <current-directory>/relative/../path\n\n @param path A path that is modified to be an absolute path.\n @returns errc::success if \\a path has been made absolute, otherwise a\n          platform-specific error_code."]
    #[link_name = "\u{1}_ZN4llvm3sys2fs13make_absoluteERNS_15SmallVectorImplIcEE"]
    pub fn llvm_sys_fs_make_absolute1(path: *mut llvm_SmallVectorImpl) -> std_error_code;
}
extern "C" {
    #[doc = " Create all the non-existent directories in path.\n\n @param path Directories to create.\n @returns errc::success if is_directory(path), otherwise a platform\n          specific error_code. If IgnoreExisting is false, also returns\n          error if the directory already existed."]
    #[link_name = "\u{1}_ZN4llvm3sys2fs18create_directoriesERKNS_5TwineEbNS1_5permsE"]
    pub fn llvm_sys_fs_create_directories(
        path: *const llvm_Twine,
        IgnoreExisting: bool,
        Perms: llvm_sys_fs_perms,
    ) -> std_error_code;
}
extern "C" {
    #[doc = " Create the directory in path.\n\n @param path Directory to create.\n @returns errc::success if is_directory(path), otherwise a platform\n          specific error_code. If IgnoreExisting is false, also returns\n          error if the directory already existed."]
    #[link_name = "\u{1}_ZN4llvm3sys2fs16create_directoryERKNS_5TwineEbNS1_5permsE"]
    pub fn llvm_sys_fs_create_directory(
        path: *const llvm_Twine,
        IgnoreExisting: bool,
        Perms: llvm_sys_fs_perms,
    ) -> std_error_code;
}
extern "C" {
    #[doc = " Create a link from \\a from to \\a to.\n\n The link may be a soft or a hard link, depending on the platform. The caller\n may not assume which one. Currently on windows it creates a hard link since\n soft links require extra privileges. On unix, it creates a soft link since\n hard links don't work on SMB file systems.\n\n @param to The path to hard link to.\n @param from The path to hard link from. This is created.\n @returns errc::success if the link was created, otherwise a platform\n specific error_code."]
    #[link_name = "\u{1}_ZN4llvm3sys2fs11create_linkERKNS_5TwineES4_"]
    pub fn llvm_sys_fs_create_link(
        to: *const llvm_Twine,
        from: *const llvm_Twine,
    ) -> std_error_code;
}
extern "C" {
    #[doc = " Create a hard link from \\a from to \\a to, or return an error.\n\n @param to The path to hard link to.\n @param from The path to hard link from. This is created.\n @returns errc::success if the link was created, otherwise a platform\n specific error_code."]
    #[link_name = "\u{1}_ZN4llvm3sys2fs16create_hard_linkERKNS_5TwineES4_"]
    pub fn llvm_sys_fs_create_hard_link(
        to: *const llvm_Twine,
        from: *const llvm_Twine,
    ) -> std_error_code;
}
extern "C" {
    #[doc = " Collapse all . and .. patterns, resolve all symlinks, and optionally\n        expand ~ expressions to the user's home directory.\n\n @param path The path to resolve.\n @param output The location to store the resolved path.\n @param expand_tilde If true, resolves ~ expressions to the user's home\n                     directory."]
    #[link_name = "\u{1}_ZN4llvm3sys2fs9real_pathERKNS_5TwineERNS_15SmallVectorImplIcEEb"]
    pub fn llvm_sys_fs_real_path(
        path: *const llvm_Twine,
        output: *mut llvm_SmallVectorImpl,
        expand_tilde: bool,
    ) -> std_error_code;
}
extern "C" {
    #[doc = " Expands ~ expressions to the user's home directory. On Unix ~user\n directories are resolved as well.\n\n @param path The path to resolve."]
    #[link_name = "\u{1}_ZN4llvm3sys2fs12expand_tildeERKNS_5TwineERNS_15SmallVectorImplIcEE"]
    pub fn llvm_sys_fs_expand_tilde(path: *const llvm_Twine, output: *mut llvm_SmallVectorImpl);
}
extern "C" {
    #[doc = " Get the current path.\n\n @param result Holds the current path on return.\n @returns errc::success if the current path has been stored in result,\n          otherwise a platform-specific error_code."]
    #[link_name = "\u{1}_ZN4llvm3sys2fs12current_pathERNS_15SmallVectorImplIcEE"]
    pub fn llvm_sys_fs_current_path(result: *mut llvm_SmallVectorImpl) -> std_error_code;
}
extern "C" {
    #[doc = " Set the current path.\n\n @param path The path to set.\n @returns errc::success if the current path was successfully set,\n          otherwise a platform-specific error_code."]
    #[link_name = "\u{1}_ZN4llvm3sys2fs16set_current_pathERKNS_5TwineE"]
    pub fn llvm_sys_fs_set_current_path(path: *const llvm_Twine) -> std_error_code;
}
extern "C" {
    #[doc = " Remove path. Equivalent to POSIX remove().\n\n @param path Input path.\n @returns errc::success if path has been removed or didn't exist, otherwise a\n          platform-specific error code. If IgnoreNonExisting is false, also\n          returns error if the file didn't exist."]
    #[link_name = "\u{1}_ZN4llvm3sys2fs6removeERKNS_5TwineEb"]
    pub fn llvm_sys_fs_remove(path: *const llvm_Twine, IgnoreNonExisting: bool) -> std_error_code;
}
extern "C" {
    #[doc = " Recursively delete a directory.\n\n @param path Input path.\n @returns errc::success if path has been removed or didn't exist, otherwise a\n          platform-specific error code."]
    #[link_name = "\u{1}_ZN4llvm3sys2fs18remove_directoriesERKNS_5TwineEb"]
    pub fn llvm_sys_fs_remove_directories(
        path: *const llvm_Twine,
        IgnoreErrors: bool,
    ) -> std_error_code;
}
extern "C" {
    #[doc = " Rename \\a from to \\a to.\n\n Files are renamed as if by POSIX rename(), except that on Windows there may\n be a short interval of time during which the destination file does not\n exist.\n\n @param from The path to rename from.\n @param to The path to rename to. This is created."]
    #[link_name = "\u{1}_ZN4llvm3sys2fs6renameERKNS_5TwineES4_"]
    pub fn llvm_sys_fs_rename(from: *const llvm_Twine, to: *const llvm_Twine) -> std_error_code;
}
extern "C" {
    #[doc = " Copy the contents of \\a From to \\a To.\n\n @param From The path to copy from.\n @param To The path to copy to. This is created."]
    #[link_name = "\u{1}_ZN4llvm3sys2fs9copy_fileERKNS_5TwineES4_"]
    pub fn llvm_sys_fs_copy_file(From: *const llvm_Twine, To: *const llvm_Twine) -> std_error_code;
}
extern "C" {
    #[doc = " Copy the contents of \\a From to \\a To.\n\n @param From The path to copy from.\n @param ToFD The open file descriptor of the destination file."]
    #[link_name = "\u{1}_ZN4llvm3sys2fs9copy_fileERKNS_5TwineEi"]
    pub fn llvm_sys_fs_copy_file1(
        From: *const llvm_Twine,
        ToFD: ::std::os::raw::c_int,
    ) -> std_error_code;
}
extern "C" {
    #[doc = " Resize path to size. File is resized as if by POSIX truncate().\n\n @param FD Input file descriptor.\n @param Size Size to resize to.\n @returns errc::success if \\a path has been resized to \\a size, otherwise a\n          platform-specific error_code."]
    #[link_name = "\u{1}_ZN4llvm3sys2fs11resize_fileEim"]
    pub fn llvm_sys_fs_resize_file(FD: ::std::os::raw::c_int, Size: u64) -> std_error_code;
}
extern "C" {
    #[doc = " Compute an MD5 hash of a file's contents.\n\n @param FD Input file descriptor.\n @returns An MD5Result with the hash computed, if successful, otherwise a\n          std::error_code."]
    #[link_name = "\u{1}_ZN4llvm3sys2fs12md5_contentsEi"]
    pub fn llvm_sys_fs_md5_contents(FD: ::std::os::raw::c_int) -> llvm_ErrorOr;
}
extern "C" {
    #[doc = " Version of compute_md5 that doesn't require an open file descriptor."]
    #[link_name = "\u{1}_ZN4llvm3sys2fs12md5_contentsERKNS_5TwineE"]
    pub fn llvm_sys_fs_md5_contents1(Path: *const llvm_Twine) -> llvm_ErrorOr;
}
extern "C" {
    #[doc = " Does file exist?\n\n @param status A basic_file_status previously returned from stat.\n @returns True if the file represented by status exists, false if it does\n          not."]
    #[link_name = "\u{1}_ZN4llvm3sys2fs6existsERKNS1_17basic_file_statusE"]
    pub fn llvm_sys_fs_exists(status: *const llvm_sys_fs_basic_file_status) -> bool;
}
pub const llvm_sys_fs_AccessMode_Exist: llvm_sys_fs_AccessMode = 0;
pub const llvm_sys_fs_AccessMode_Write: llvm_sys_fs_AccessMode = 1;
pub const llvm_sys_fs_AccessMode_Execute: llvm_sys_fs_AccessMode = 2;
pub type llvm_sys_fs_AccessMode = ::std::os::raw::c_int;
extern "C" {
    #[doc = " Can the file be accessed?\n\n @param Path Input path.\n @returns errc::success if the path can be accessed, otherwise a\n          platform-specific error_code."]
    #[link_name = "\u{1}_ZN4llvm3sys2fs6accessERKNS_5TwineENS1_10AccessModeE"]
    pub fn llvm_sys_fs_access(
        Path: *const llvm_Twine,
        Mode: llvm_sys_fs_AccessMode,
    ) -> std_error_code;
}
extern "C" {
    #[doc = " Can we execute this file?\n\n @param Path Input path.\n @returns True if we can execute it, false otherwise."]
    #[link_name = "\u{1}_ZN4llvm3sys2fs11can_executeERKNS_5TwineE"]
    pub fn llvm_sys_fs_can_execute(Path: *const llvm_Twine) -> bool;
}
extern "C" {
    #[doc = " Do file_status's represent the same thing?\n\n @param A Input file_status.\n @param B Input file_status.\n\n assert(status_known(A) || status_known(B));\n\n @returns True if A and B both represent the same file system entity, false\n          otherwise."]
    #[link_name = "\u{1}_ZN4llvm3sys2fs10equivalentENS1_11file_statusES2_"]
    pub fn llvm_sys_fs_equivalent(A: llvm_sys_fs_file_status, B: llvm_sys_fs_file_status) -> bool;
}
extern "C" {
    #[doc = " Do paths represent the same thing?\n\n assert(status_known(A) || status_known(B));\n\n @param A Input path A.\n @param B Input path B.\n @param result Set to true if stat(A) and stat(B) have the same device and\n               inode (or equivalent).\n @returns errc::success if result has been successfully set, otherwise a\n          platform-specific error_code."]
    #[link_name = "\u{1}_ZN4llvm3sys2fs10equivalentERKNS_5TwineES4_Rb"]
    pub fn llvm_sys_fs_equivalent1(
        A: *const llvm_Twine,
        B: *const llvm_Twine,
        result: *mut bool,
    ) -> std_error_code;
}
extern "C" {
    #[doc = " Is the file mounted on a local filesystem?\n\n @param path Input path.\n @param result Set to true if \\a path is on fixed media such as a hard disk,\n               false if it is not.\n @returns errc::success if result has been successfully set, otherwise a\n          platform specific error_code."]
    #[link_name = "\u{1}_ZN4llvm3sys2fs8is_localERKNS_5TwineERb"]
    pub fn llvm_sys_fs_is_local(path: *const llvm_Twine, result: *mut bool) -> std_error_code;
}
extern "C" {
    #[doc = " Version of is_local accepting an open file descriptor."]
    #[link_name = "\u{1}_ZN4llvm3sys2fs8is_localEiRb"]
    pub fn llvm_sys_fs_is_local1(FD: ::std::os::raw::c_int, result: *mut bool) -> std_error_code;
}
extern "C" {
    #[doc = " Does status represent a directory?\n\n @param Path The path to get the type of.\n @param Follow For symbolic links, indicates whether to return the file type\n               of the link itself, or of the target.\n @returns A value from the file_type enumeration indicating the type of file."]
    #[link_name = "\u{1}_ZN4llvm3sys2fs13get_file_typeERKNS_5TwineEb"]
    pub fn llvm_sys_fs_get_file_type(
        Path: *const llvm_Twine,
        Follow: bool,
    ) -> llvm_sys_fs_file_type;
}
extern "C" {
    #[doc = " Does status represent a directory?\n\n @param status A basic_file_status previously returned from status.\n @returns status.type() == file_type::directory_file."]
    #[link_name = "\u{1}_ZN4llvm3sys2fs12is_directoryERKNS1_17basic_file_statusE"]
    pub fn llvm_sys_fs_is_directory(status: *const llvm_sys_fs_basic_file_status) -> bool;
}
extern "C" {
    #[doc = " Is path a directory?\n\n @param path Input path.\n @param result Set to true if \\a path is a directory (after following\n               symlinks, false if it is not. Undefined otherwise.\n @returns errc::success if result has been successfully set, otherwise a\n          platform-specific error_code."]
    #[link_name = "\u{1}_ZN4llvm3sys2fs12is_directoryERKNS_5TwineERb"]
    pub fn llvm_sys_fs_is_directory1(path: *const llvm_Twine, result: *mut bool) -> std_error_code;
}
extern "C" {
    #[doc = " Does status represent a regular file?\n\n @param status A basic_file_status previously returned from status.\n @returns status_known(status) && status.type() == file_type::regular_file."]
    #[link_name = "\u{1}_ZN4llvm3sys2fs15is_regular_fileERKNS1_17basic_file_statusE"]
    pub fn llvm_sys_fs_is_regular_file(status: *const llvm_sys_fs_basic_file_status) -> bool;
}
extern "C" {
    #[doc = " Is path a regular file?\n\n @param path Input path.\n @param result Set to true if \\a path is a regular file (after following\n               symlinks), false if it is not. Undefined otherwise.\n @returns errc::success if result has been successfully set, otherwise a\n          platform-specific error_code."]
    #[link_name = "\u{1}_ZN4llvm3sys2fs15is_regular_fileERKNS_5TwineERb"]
    pub fn llvm_sys_fs_is_regular_file1(
        path: *const llvm_Twine,
        result: *mut bool,
    ) -> std_error_code;
}
extern "C" {
    #[doc = " Does status represent a symlink file?\n\n @param status A basic_file_status previously returned from status.\n @returns status_known(status) && status.type() == file_type::symlink_file."]
    #[link_name = "\u{1}_ZN4llvm3sys2fs15is_symlink_fileERKNS1_17basic_file_statusE"]
    pub fn llvm_sys_fs_is_symlink_file(status: *const llvm_sys_fs_basic_file_status) -> bool;
}
extern "C" {
    #[doc = " Is path a symlink file?\n\n @param path Input path.\n @param result Set to true if \\a path is a symlink file, false if it is not.\n               Undefined otherwise.\n @returns errc::success if result has been successfully set, otherwise a\n          platform-specific error_code."]
    #[link_name = "\u{1}_ZN4llvm3sys2fs15is_symlink_fileERKNS_5TwineERb"]
    pub fn llvm_sys_fs_is_symlink_file1(
        path: *const llvm_Twine,
        result: *mut bool,
    ) -> std_error_code;
}
extern "C" {
    #[doc = " Does this status represent something that exists but is not a\n        directory or regular file?\n\n @param status A basic_file_status previously returned from status.\n @returns exists(s) && !is_regular_file(s) && !is_directory(s)"]
    #[link_name = "\u{1}_ZN4llvm3sys2fs8is_otherERKNS1_17basic_file_statusE"]
    pub fn llvm_sys_fs_is_other(status: *const llvm_sys_fs_basic_file_status) -> bool;
}
extern "C" {
    #[doc = " Is path something that exists but is not a directory,\n        regular file, or symlink?\n\n @param path Input path.\n @param result Set to true if \\a path exists, but is not a directory, regular\n               file, or a symlink, false if it does not. Undefined otherwise.\n @returns errc::success if result has been successfully set, otherwise a\n          platform-specific error_code."]
    #[link_name = "\u{1}_ZN4llvm3sys2fs8is_otherERKNS_5TwineERb"]
    pub fn llvm_sys_fs_is_other1(path: *const llvm_Twine, result: *mut bool) -> std_error_code;
}
extern "C" {
    #[doc = " Get file status as if by POSIX stat().\n\n @param path Input path.\n @param result Set to the file status.\n @param follow When true, follows symlinks.  Otherwise, the symlink itself is\n               statted.\n @returns errc::success if result has been successfully set, otherwise a\n          platform-specific error_code."]
    #[link_name = "\u{1}_ZN4llvm3sys2fs6statusERKNS_5TwineERNS1_11file_statusEb"]
    pub fn llvm_sys_fs_status(
        path: *const llvm_Twine,
        result: *mut llvm_sys_fs_file_status,
        follow: bool,
    ) -> std_error_code;
}
extern "C" {
    #[doc = " A version for when a file descriptor is already available."]
    #[link_name = "\u{1}_ZN4llvm3sys2fs6statusEiRNS1_11file_statusE"]
    pub fn llvm_sys_fs_status1(
        FD: ::std::os::raw::c_int,
        Result: *mut llvm_sys_fs_file_status,
    ) -> std_error_code;
}
extern "C" {
    #[doc = " Get file creation mode mask of the process.\n\n @returns Mask reported by umask(2)\n @note There is no umask on Windows. This function returns 0 always\n       on Windows. This function does not return an error_code because\n       umask(2) never fails. It is not thread safe."]
    #[link_name = "\u{1}_ZN4llvm3sys2fs8getUmaskEv"]
    pub fn llvm_sys_fs_getUmask() -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " Set file permissions.\n\n @param Path File to set permissions on.\n @param Permissions New file permissions.\n @returns errc::success if the permissions were successfully set, otherwise\n          a platform-specific error_code.\n @note On Windows, all permissions except *_write are ignored. Using any of\n       owner_write, group_write, or all_write will make the file writable.\n       Otherwise, the file will be marked as read-only."]
    #[link_name = "\u{1}_ZN4llvm3sys2fs14setPermissionsERKNS_5TwineENS1_5permsE"]
    pub fn llvm_sys_fs_setPermissions(
        Path: *const llvm_Twine,
        Permissions: llvm_sys_fs_perms,
    ) -> std_error_code;
}
extern "C" {
    #[doc = " Vesion of setPermissions accepting a file descriptor.\n TODO Delete the path based overload once we implement the FD based overload\n on Windows."]
    #[link_name = "\u{1}_ZN4llvm3sys2fs14setPermissionsEiNS1_5permsE"]
    pub fn llvm_sys_fs_setPermissions1(
        FD: ::std::os::raw::c_int,
        Permissions: llvm_sys_fs_perms,
    ) -> std_error_code;
}
extern "C" {
    #[doc = " Get file permissions.\n\n @param Path File to get permissions from.\n @returns the permissions if they were successfully retrieved, otherwise a\n          platform-specific error_code.\n @note On Windows, if the file does not have the FILE_ATTRIBUTE_READONLY\n       attribute, all_all will be returned. Otherwise, all_read | all_exe\n       will be returned."]
    #[link_name = "\u{1}_ZN4llvm3sys2fs14getPermissionsERKNS_5TwineE"]
    pub fn llvm_sys_fs_getPermissions(Path: *const llvm_Twine) -> llvm_ErrorOr;
}
extern "C" {
    #[doc = " Set the file modification and access time.\n\n @returns errc::success if the file times were successfully set, otherwise a\n          platform-specific error_code or errc::function_not_supported on\n          platforms where the functionality isn't available."]
    #[link_name = "\u{1}_ZN4llvm3sys2fs32setLastAccessAndModificationTimeEiNSt6chrono10time_pointINS2_3_V212system_clockENS2_8durationIlSt5ratioILl1ELl1000000000EEEEEESA_"]
    pub fn llvm_sys_fs_setLastAccessAndModificationTime(
        FD: ::std::os::raw::c_int,
        AccessTime: std_chrono_time_point<std_chrono_duration<::std::os::raw::c_long>>,
        ModificationTime: std_chrono_time_point<std_chrono_duration<::std::os::raw::c_long>>,
    ) -> std_error_code;
}
extern "C" {
    #[doc = " Is status available?\n\n @param s Input file status.\n @returns True if status() != status_error."]
    #[link_name = "\u{1}_ZN4llvm3sys2fs12status_knownERKNS1_17basic_file_statusE"]
    pub fn llvm_sys_fs_status_known(s: *const llvm_sys_fs_basic_file_status) -> bool;
}
extern "C" {
    #[doc = " Is status available?\n\n @param path Input path.\n @param result Set to true if status() != status_error.\n @returns errc::success if result has been successfully set, otherwise a\n          platform-specific error_code."]
    #[link_name = "\u{1}_ZN4llvm3sys2fs12status_knownERKNS_5TwineERb"]
    pub fn llvm_sys_fs_status_known1(path: *const llvm_Twine, result: *mut bool) -> std_error_code;
}
#[doc = " CD_CreateAlways - When opening a file:\n   * If it already exists, truncate it.\n   * If it does not already exist, create a new file."]
pub const llvm_sys_fs_CreationDisposition_CD_CreateAlways: llvm_sys_fs_CreationDisposition = 0;
#[doc = " CD_CreateNew - When opening a file:\n   * If it already exists, fail.\n   * If it does not already exist, create a new file."]
pub const llvm_sys_fs_CreationDisposition_CD_CreateNew: llvm_sys_fs_CreationDisposition = 1;
#[doc = " CD_OpenExisting - When opening a file:\n   * If it already exists, open the file with the offset set to 0.\n   * If it does not already exist, fail."]
pub const llvm_sys_fs_CreationDisposition_CD_OpenExisting: llvm_sys_fs_CreationDisposition = 2;
#[doc = " CD_OpenAlways - When opening a file:\n   * If it already exists, open the file with the offset set to 0.\n   * If it does not already exist, create a new file."]
pub const llvm_sys_fs_CreationDisposition_CD_OpenAlways: llvm_sys_fs_CreationDisposition = 3;
pub type llvm_sys_fs_CreationDisposition = ::std::os::raw::c_uint;
pub const llvm_sys_fs_FileAccess_FA_Read: llvm_sys_fs_FileAccess = 1;
pub const llvm_sys_fs_FileAccess_FA_Write: llvm_sys_fs_FileAccess = 2;
pub type llvm_sys_fs_FileAccess = ::std::os::raw::c_uint;
pub const llvm_sys_fs_OpenFlags_OF_None: llvm_sys_fs_OpenFlags = 0;
#[doc = " The file should be opened in text mode on platforms like z/OS that make\n this distinction."]
pub const llvm_sys_fs_OpenFlags_OF_Text: llvm_sys_fs_OpenFlags = 1;
#[doc = " The file should use a carriage linefeed '\\r\\n'. This flag should only be\n used with OF_Text. Only makes a difference on Windows."]
pub const llvm_sys_fs_OpenFlags_OF_CRLF: llvm_sys_fs_OpenFlags = 2;
#[doc = " The file should be opened in text mode and use a carriage linefeed '\\r\\n'.\n This flag has the same functionality as OF_Text on z/OS but adds a\n carriage linefeed on Windows."]
pub const llvm_sys_fs_OpenFlags_OF_TextWithCRLF: llvm_sys_fs_OpenFlags = 3;
#[doc = " The file should be opened in append mode."]
pub const llvm_sys_fs_OpenFlags_OF_Append: llvm_sys_fs_OpenFlags = 4;
#[doc = " The returned handle can be used for deleting the file. Only makes a\n difference on windows."]
pub const llvm_sys_fs_OpenFlags_OF_Delete: llvm_sys_fs_OpenFlags = 8;
#[doc = " When a child process is launched, this file should remain open in the\n child process."]
pub const llvm_sys_fs_OpenFlags_OF_ChildInherit: llvm_sys_fs_OpenFlags = 16;
#[doc = " Force files Atime to be updated on access. Only makes a difference on\n Windows."]
pub const llvm_sys_fs_OpenFlags_OF_UpdateAtime: llvm_sys_fs_OpenFlags = 32;
pub type llvm_sys_fs_OpenFlags = ::std::os::raw::c_uint;
extern "C" {
    #[doc = " Create a potentially unique file name but does not create it.\n\n Generates a unique path suitable for a temporary file but does not\n open or create the file. The name is based on \\a Model with '%'\n replaced by a random char in [0-9a-f]. If \\a MakeAbsolute is true\n then the system's temp directory is prepended first. If \\a MakeAbsolute\n is false the current directory will be used instead.\n\n This function does not check if the file exists. If you want to be sure\n that the file does not yet exist, you should use enough '%' characters\n in your model to ensure this. Each '%' gives 4-bits of entropy so you can\n use 32 of them to get 128 bits of entropy.\n\n Example: clang-%%-%%-%%-%%-%%.s => clang-a0-b1-c2-d3-e4.s\n\n @param Model Name to base unique path off of.\n @param ResultPath Set to the file's path.\n @param MakeAbsolute Whether to use the system temp directory."]
    #[link_name = "\u{1}_ZN4llvm3sys2fs16createUniquePathERKNS_5TwineERNS_15SmallVectorImplIcEEb"]
    pub fn llvm_sys_fs_createUniquePath(
        Model: *const llvm_Twine,
        ResultPath: *mut llvm_SmallVectorImpl,
        MakeAbsolute: bool,
    );
}
extern "C" {
    #[doc = " Create a uniquely named file.\n\n Generates a unique path suitable for a temporary file and then opens it as a\n file. The name is based on \\a Model with '%' replaced by a random char in\n [0-9a-f]. If \\a Model is not an absolute path, the temporary file will be\n created in the current directory.\n\n Example: clang-%%-%%-%%-%%-%%.s => clang-a0-b1-c2-d3-e4.s\n\n This is an atomic operation. Either the file is created and opened, or the\n file system is left untouched.\n\n The intended use is for files that are to be kept, possibly after\n renaming them. For example, when running 'clang -c foo.o', the file can\n be first created as foo-abc123.o and then renamed.\n\n @param Model Name to base unique path off of.\n @param ResultFD Set to the opened file's file descriptor.\n @param ResultPath Set to the opened file's absolute path.\n @param Flags Set to the opened file's flags.\n @param Mode Set to the opened file's permissions.\n @returns errc::success if Result{FD,Path} have been successfully set,\n          otherwise a platform-specific error_code."]
    #[link_name = "\u{1}_ZN4llvm3sys2fs16createUniqueFileERKNS_5TwineERiRNS_15SmallVectorImplIcEENS1_9OpenFlagsEj"]
    pub fn llvm_sys_fs_createUniqueFile(
        Model: *const llvm_Twine,
        ResultFD: *mut ::std::os::raw::c_int,
        ResultPath: *mut llvm_SmallVectorImpl,
        Flags: llvm_sys_fs_OpenFlags,
        Mode: ::std::os::raw::c_uint,
    ) -> std_error_code;
}
extern "C" {
    #[doc = " Simpler version for clients that don't want an open file. An empty\n file will still be created."]
    #[link_name = "\u{1}_ZN4llvm3sys2fs16createUniqueFileERKNS_5TwineERNS_15SmallVectorImplIcEEj"]
    pub fn llvm_sys_fs_createUniqueFile1(
        Model: *const llvm_Twine,
        ResultPath: *mut llvm_SmallVectorImpl,
        Mode: ::std::os::raw::c_uint,
    ) -> std_error_code;
}
#[doc = " Represents a temporary file.\n\n The temporary file must be eventually discarded or given a final name and\n kept.\n\n The destructor doesn't implicitly discard because there is no way to\n properly handle errors in a destructor."]
#[repr(C)]
pub struct llvm_sys_fs_TempFile {
    pub Done: bool,
    pub TmpName: std_string,
    pub FD: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_llvm_sys_fs_TempFile() {
    const UNINIT: ::std::mem::MaybeUninit<llvm_sys_fs_TempFile> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<llvm_sys_fs_TempFile>(),
        48usize,
        concat!("Size of: ", stringify!(llvm_sys_fs_TempFile))
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_sys_fs_TempFile>(),
        8usize,
        concat!("Alignment of ", stringify!(llvm_sys_fs_TempFile))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Done) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_sys_fs_TempFile),
            "::",
            stringify!(Done)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).TmpName) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_sys_fs_TempFile),
            "::",
            stringify!(TmpName)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).FD) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_sys_fs_TempFile),
            "::",
            stringify!(FD)
        )
    );
}
extern "C" {
    #[doc = " This creates a temporary file with createUniqueFile and schedules it for\n deletion with sys::RemoveFileOnSignal."]
    #[link_name = "\u{1}_ZN4llvm3sys2fs8TempFile6createERKNS_5TwineEjNS1_9OpenFlagsE"]
    pub fn llvm_sys_fs_TempFile_create(
        Model: *const llvm_Twine,
        Mode: ::std::os::raw::c_uint,
        ExtraFlags: llvm_sys_fs_OpenFlags,
    ) -> llvm_Expected;
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm3sys2fs8TempFile4keepERKNS_5TwineE"]
    pub fn llvm_sys_fs_TempFile_keep(
        this: *mut llvm_sys_fs_TempFile,
        Name: *const llvm_Twine,
    ) -> llvm_Error;
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm3sys2fs8TempFile4keepEv"]
    pub fn llvm_sys_fs_TempFile_keep1(this: *mut llvm_sys_fs_TempFile) -> llvm_Error;
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm3sys2fs8TempFile7discardEv"]
    pub fn llvm_sys_fs_TempFile_discard(this: *mut llvm_sys_fs_TempFile) -> llvm_Error;
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm3sys2fs8TempFileC1EOS2_"]
    pub fn llvm_sys_fs_TempFile_TempFile(
        this: *mut llvm_sys_fs_TempFile,
        Other: *mut llvm_sys_fs_TempFile,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm3sys2fs8TempFileD1Ev"]
    pub fn llvm_sys_fs_TempFile_TempFile_destructor(this: *mut llvm_sys_fs_TempFile);
}
impl llvm_sys_fs_TempFile {
    #[inline]
    pub unsafe fn create(
        Model: *const llvm_Twine,
        Mode: ::std::os::raw::c_uint,
        ExtraFlags: llvm_sys_fs_OpenFlags,
    ) -> llvm_Expected {
        llvm_sys_fs_TempFile_create(Model, Mode, ExtraFlags)
    }
    #[inline]
    pub unsafe fn keep(&mut self, Name: *const llvm_Twine) -> llvm_Error {
        llvm_sys_fs_TempFile_keep(self, Name)
    }
    #[inline]
    pub unsafe fn keep1(&mut self) -> llvm_Error {
        llvm_sys_fs_TempFile_keep1(self)
    }
    #[inline]
    pub unsafe fn discard(&mut self) -> llvm_Error {
        llvm_sys_fs_TempFile_discard(self)
    }
    #[inline]
    pub unsafe fn new(Other: *mut llvm_sys_fs_TempFile) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        llvm_sys_fs_TempFile_TempFile(__bindgen_tmp.as_mut_ptr(), Other);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn destruct(&mut self) {
        llvm_sys_fs_TempFile_TempFile_destructor(self)
    }
}
extern "C" {
    #[doc = " Create a file in the system temporary directory.\n\n The filename is of the form prefix-random_chars.suffix. Since the directory\n is not know to the caller, Prefix and Suffix cannot have path separators.\n The files are created with mode 0600.\n\n This should be used for things like a temporary .s that is removed after\n running the assembler."]
    #[link_name = "\u{1}_ZN4llvm3sys2fs19createTemporaryFileERKNS_5TwineENS_9StringRefERiRNS_15SmallVectorImplIcEENS1_9OpenFlagsE"]
    pub fn llvm_sys_fs_createTemporaryFile(
        Prefix: *const llvm_Twine,
        Suffix: llvm_StringRef,
        ResultFD: *mut ::std::os::raw::c_int,
        ResultPath: *mut llvm_SmallVectorImpl,
        Flags: llvm_sys_fs_OpenFlags,
    ) -> std_error_code;
}
extern "C" {
    #[doc = " Simpler version for clients that don't want an open file. An empty\n file will still be created."]
    #[link_name = "\u{1}_ZN4llvm3sys2fs19createTemporaryFileERKNS_5TwineENS_9StringRefERNS_15SmallVectorImplIcEENS1_9OpenFlagsE"]
    pub fn llvm_sys_fs_createTemporaryFile1(
        Prefix: *const llvm_Twine,
        Suffix: llvm_StringRef,
        ResultPath: *mut llvm_SmallVectorImpl,
        Flags: llvm_sys_fs_OpenFlags,
    ) -> std_error_code;
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm3sys2fs21createUniqueDirectoryERKNS_5TwineERNS_15SmallVectorImplIcEE"]
    pub fn llvm_sys_fs_createUniqueDirectory(
        Prefix: *const llvm_Twine,
        ResultPath: *mut llvm_SmallVectorImpl,
    ) -> std_error_code;
}
extern "C" {
    #[doc = " Get a unique name, not currently exisiting in the filesystem. Subject\n to race conditions, prefer to use createUniqueFile instead.\n\n Similar to createUniqueFile, but instead of creating a file only\n checks if it exists. This function is subject to race conditions, if you\n want to use the returned name to actually create a file, use\n createUniqueFile instead."]
    #[link_name = "\u{1}_ZN4llvm3sys2fs28getPotentiallyUniqueFileNameERKNS_5TwineERNS_15SmallVectorImplIcEE"]
    pub fn llvm_sys_fs_getPotentiallyUniqueFileName(
        Model: *const llvm_Twine,
        ResultPath: *mut llvm_SmallVectorImpl,
    ) -> std_error_code;
}
extern "C" {
    #[doc = " Get a unique temporary file name, not currently exisiting in the\n filesystem. Subject to race conditions, prefer to use createTemporaryFile\n instead.\n\n Similar to createTemporaryFile, but instead of creating a file only\n checks if it exists. This function is subject to race conditions, if you\n want to use the returned name to actually create a file, use\n createTemporaryFile instead."]
    #[link_name = "\u{1}_ZN4llvm3sys2fs32getPotentiallyUniqueTempFileNameERKNS_5TwineENS_9StringRefERNS_15SmallVectorImplIcEE"]
    pub fn llvm_sys_fs_getPotentiallyUniqueTempFileName(
        Prefix: *const llvm_Twine,
        Suffix: llvm_StringRef,
        ResultPath: *mut llvm_SmallVectorImpl,
    ) -> std_error_code;
}
extern "C" {
    #[doc = " @brief Opens a file with the specified creation disposition, access mode,\n and flags and returns a file descriptor.\n\n The caller is responsible for closing the file descriptor once they are\n finished with it.\n\n @param Name The path of the file to open, relative or absolute.\n @param ResultFD If the file could be opened successfully, its descriptor\n                 is stored in this location. Otherwise, this is set to -1.\n @param Disp Value specifying the existing-file behavior.\n @param Access Value specifying whether to open the file in read, write, or\n               read-write mode.\n @param Flags Additional flags.\n @param Mode The access permissions of the file, represented in octal.\n @returns errc::success if \\a Name has been opened, otherwise a\n          platform-specific error_code."]
    #[link_name = "\u{1}_ZN4llvm3sys2fs8openFileERKNS_5TwineERiNS1_19CreationDispositionENS1_10FileAccessENS1_9OpenFlagsEj"]
    pub fn llvm_sys_fs_openFile(
        Name: *const llvm_Twine,
        ResultFD: *mut ::std::os::raw::c_int,
        Disp: llvm_sys_fs_CreationDisposition,
        Access: llvm_sys_fs_FileAccess,
        Flags: llvm_sys_fs_OpenFlags,
        Mode: ::std::os::raw::c_uint,
    ) -> std_error_code;
}
extern "C" {
    #[doc = " @brief Opens a file with the specified creation disposition, access mode,\n and flags and returns a platform-specific file object.\n\n The caller is responsible for closing the file object once they are\n finished with it.\n\n @param Name The path of the file to open, relative or absolute.\n @param Disp Value specifying the existing-file behavior.\n @param Access Value specifying whether to open the file in read, write, or\n               read-write mode.\n @param Flags Additional flags.\n @param Mode The access permissions of the file, represented in octal.\n @returns errc::success if \\a Name has been opened, otherwise a\n          platform-specific error_code."]
    #[link_name = "\u{1}_ZN4llvm3sys2fs14openNativeFileERKNS_5TwineENS1_19CreationDispositionENS1_10FileAccessENS1_9OpenFlagsEj"]
    pub fn llvm_sys_fs_openNativeFile(
        Name: *const llvm_Twine,
        Disp: llvm_sys_fs_CreationDisposition,
        Access: llvm_sys_fs_FileAccess,
        Flags: llvm_sys_fs_OpenFlags,
        Mode: ::std::os::raw::c_uint,
    ) -> llvm_Expected;
}
extern "C" {
    #[doc = " Return an open handle to standard in. On Unix, this is typically FD 0.\n Returns kInvalidFile when the stream is closed."]
    #[link_name = "\u{1}_ZN4llvm3sys2fs14getStdinHandleEv"]
    pub fn llvm_sys_fs_getStdinHandle() -> llvm_sys_fs_file_t;
}
extern "C" {
    #[doc = " Return an open handle to standard out. On Unix, this is typically FD 1.\n Returns kInvalidFile when the stream is closed."]
    #[link_name = "\u{1}_ZN4llvm3sys2fs15getStdoutHandleEv"]
    pub fn llvm_sys_fs_getStdoutHandle() -> llvm_sys_fs_file_t;
}
extern "C" {
    #[doc = " Return an open handle to standard error. On Unix, this is typically FD 2.\n Returns kInvalidFile when the stream is closed."]
    #[link_name = "\u{1}_ZN4llvm3sys2fs15getStderrHandleEv"]
    pub fn llvm_sys_fs_getStderrHandle() -> llvm_sys_fs_file_t;
}
extern "C" {
    #[doc = " Reads \\p Buf.size() bytes from \\p FileHandle into \\p Buf. Returns the number\n of bytes actually read. On Unix, this is equivalent to `return ::read(FD,\n Buf.data(), Buf.size())`, with error reporting. Returns 0 when reaching EOF.\n\n @param FileHandle File to read from.\n @param Buf Buffer to read into.\n @returns The number of bytes read, or error."]
    #[link_name = "\u{1}_ZN4llvm3sys2fs14readNativeFileEiNS_15MutableArrayRefIcEE"]
    pub fn llvm_sys_fs_readNativeFile(
        FileHandle: llvm_sys_fs_file_t,
        Buf: llvm_MutableArrayRef<::std::os::raw::c_char>,
    ) -> llvm_Expected;
}
pub const DefaultReadChunkSize: llvm_sys_fs__bindgen_ty_1 = 16384;
#[doc = " Default chunk size for \\a readNativeFileToEOF()."]
pub type llvm_sys_fs__bindgen_ty_1 = usize;
extern "C" {
    #[doc = " Reads from \\p FileHandle until EOF, appending to \\p Buffer in chunks of\n size \\p ChunkSize.\n\n This calls \\a readNativeFile() in a loop. On Error, previous chunks that\n were read successfully are left in \\p Buffer and returned.\n\n Note: For reading the final chunk at EOF, \\p Buffer's capacity needs extra\n storage of \\p ChunkSize.\n\n \\param FileHandle File to read from.\n \\param Buffer Where to put the file content.\n \\param ChunkSize Size of chunks.\n \\returns The error if EOF was not found."]
    #[link_name = "\u{1}_ZN4llvm3sys2fs19readNativeFileToEOFEiRNS_15SmallVectorImplIcEEl"]
    pub fn llvm_sys_fs_readNativeFileToEOF(
        FileHandle: llvm_sys_fs_file_t,
        Buffer: *mut llvm_SmallVectorImpl,
        ChunkSize: isize,
    ) -> llvm_Error;
}
extern "C" {
    #[doc = " Reads \\p Buf.size() bytes from \\p FileHandle at offset \\p Offset into \\p\n Buf. If 'pread' is available, this will use that, otherwise it will use\n 'lseek'. Returns the number of bytes actually read. Returns 0 when reaching\n EOF.\n\n @param FileHandle File to read from.\n @param Buf Buffer to read into.\n @param Offset Offset into the file at which the read should occur.\n @returns The number of bytes read, or error."]
    #[link_name = "\u{1}_ZN4llvm3sys2fs19readNativeFileSliceEiNS_15MutableArrayRefIcEEm"]
    pub fn llvm_sys_fs_readNativeFileSlice(
        FileHandle: llvm_sys_fs_file_t,
        Buf: llvm_MutableArrayRef<::std::os::raw::c_char>,
        Offset: u64,
    ) -> llvm_Expected;
}
extern "C" {
    #[doc = " @brief Opens the file with the given name in a read-only mode, returning\n its open file descriptor.\n\n The caller is responsible for closing the file descriptor once they are\n finished with it.\n\n @param Name The path of the file to open, relative or absolute.\n @param ResultFD If the file could be opened successfully, its descriptor\n                 is stored in this location. Otherwise, this is set to -1.\n @param RealPath If nonnull, extra work is done to determine the real path\n                 of the opened file, and that path is stored in this\n                 location.\n @returns errc::success if \\a Name has been opened, otherwise a\n          platform-specific error_code."]
    #[link_name = "\u{1}_ZN4llvm3sys2fs15openFileForReadERKNS_5TwineERiNS1_9OpenFlagsEPNS_15SmallVectorImplIcEE"]
    pub fn llvm_sys_fs_openFileForRead(
        Name: *const llvm_Twine,
        ResultFD: *mut ::std::os::raw::c_int,
        Flags: llvm_sys_fs_OpenFlags,
        RealPath: *mut llvm_SmallVectorImpl,
    ) -> std_error_code;
}
extern "C" {
    #[doc = " @brief Opens the file with the given name in a read-only mode, returning\n its open file descriptor.\n\n The caller is responsible for closing the freeing the file once they are\n finished with it.\n\n @param Name The path of the file to open, relative or absolute.\n @param RealPath If nonnull, extra work is done to determine the real path\n                 of the opened file, and that path is stored in this\n                 location.\n @returns a platform-specific file descriptor if \\a Name has been opened,\n          otherwise an error object."]
    #[link_name = "\u{1}_ZN4llvm3sys2fs21openNativeFileForReadERKNS_5TwineENS1_9OpenFlagsEPNS_15SmallVectorImplIcEE"]
    pub fn llvm_sys_fs_openNativeFileForRead(
        Name: *const llvm_Twine,
        Flags: llvm_sys_fs_OpenFlags,
        RealPath: *mut llvm_SmallVectorImpl,
    ) -> llvm_Expected;
}
extern "C" {
    #[doc = " Try to locks the file during the specified time.\n\n This function implements advisory locking on entire file. If it returns\n <em>errc::success</em>, the file is locked by the calling process. Until the\n process unlocks the file by calling \\a unlockFile, all attempts to lock the\n same file will fail/block. The process that locked the file may assume that\n none of other processes read or write this file, provided that all processes\n lock the file prior to accessing its content.\n\n @param FD      The descriptor representing the file to lock.\n @param Timeout Time in milliseconds that the process should wait before\n                reporting lock failure. Zero value means try to get lock only\n                once.\n @returns errc::success if lock is successfully obtained,\n errc::no_lock_available if the file cannot be locked, or platform-specific\n error_code otherwise.\n\n @note Care should be taken when using this function in a multithreaded\n context, as it may not prevent other threads in the same process from\n obtaining a lock on the same file, even if they are using a different file\n descriptor."]
    #[link_name = "\u{1}_ZN4llvm3sys2fs11tryLockFileEiNSt6chrono8durationIlSt5ratioILl1ELl1000EEEE"]
    pub fn llvm_sys_fs_tryLockFile(
        FD: ::std::os::raw::c_int,
        Timeout: std_chrono_milliseconds,
    ) -> std_error_code;
}
extern "C" {
    #[doc = " Lock the file.\n\n This function acts as @ref tryLockFile but it waits infinitely."]
    #[link_name = "\u{1}_ZN4llvm3sys2fs8lockFileEi"]
    pub fn llvm_sys_fs_lockFile(FD: ::std::os::raw::c_int) -> std_error_code;
}
extern "C" {
    #[doc = " Unlock the file.\n\n @param FD The descriptor representing the file to unlock.\n @returns errc::success if lock is successfully released or platform-specific\n error_code otherwise."]
    #[link_name = "\u{1}_ZN4llvm3sys2fs10unlockFileEi"]
    pub fn llvm_sys_fs_unlockFile(FD: ::std::os::raw::c_int) -> std_error_code;
}
extern "C" {
    #[doc = " @brief Close the file object.  This should be used instead of ::close for\n portability. On error, the caller should assume the file is closed, as is\n the case for Process::SafelyCloseFileDescriptor\n\n @param F On input, this is the file to close.  On output, the file is\n set to kInvalidFile.\n\n @returns An error code if closing the file failed. Typically, an error here\n means that the filesystem may have failed to perform some buffered writes."]
    #[link_name = "\u{1}_ZN4llvm3sys2fs9closeFileERi"]
    pub fn llvm_sys_fs_closeFile(F: *mut llvm_sys_fs_file_t) -> std_error_code;
}
extern "C" {
    #[doc = " @brief Change ownership of a file.\n\n @param Owner The owner of the file to change to.\n @param Group The group of the file to change to.\n @returns errc::success if successfully updated file ownership, otherwise an\n          error code is returned."]
    #[link_name = "\u{1}_ZN4llvm3sys2fs19changeFileOwnershipEijj"]
    pub fn llvm_sys_fs_changeFileOwnership(
        FD: ::std::os::raw::c_int,
        Owner: u32,
        Group: u32,
    ) -> std_error_code;
}
#[doc = " RAII class that facilitates file locking."]
#[repr(C)]
#[derive(Debug)]
pub struct llvm_sys_fs_FileLocker {
    #[doc = "< Locked file handle."]
    pub FD: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_llvm_sys_fs_FileLocker() {
    const UNINIT: ::std::mem::MaybeUninit<llvm_sys_fs_FileLocker> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<llvm_sys_fs_FileLocker>(),
        4usize,
        concat!("Size of: ", stringify!(llvm_sys_fs_FileLocker))
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_sys_fs_FileLocker>(),
        4usize,
        concat!("Alignment of ", stringify!(llvm_sys_fs_FileLocker))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).FD) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_sys_fs_FileLocker),
            "::",
            stringify!(FD)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm3sys2fs11getUniqueIDENS_5TwineERNS1_8UniqueIDE"]
    pub fn llvm_sys_fs_getUniqueID(
        Path: llvm_Twine,
        Result: *mut llvm_sys_fs_UniqueID,
    ) -> std_error_code;
}
extern "C" {
    #[doc = " Get disk space usage information.\n\n Note: Users must be careful about \"Time Of Check, Time Of Use\" kind of bug.\n Note: Windows reports results according to the quota allocated to the user.\n\n @param Path Input path.\n @returns a space_info structure filled with the capacity, free, and\n available space on the device \\a Path is on. A platform specific error_code\n is returned on error."]
    #[link_name = "\u{1}_ZN4llvm3sys2fs10disk_spaceERKNS_5TwineE"]
    pub fn llvm_sys_fs_disk_space(Path: *const llvm_Twine) -> llvm_ErrorOr;
}
#[doc = " This class represents a memory mapped file. It is based on\n boost::iostreams::mapped_file."]
#[repr(C)]
#[derive(Debug)]
pub struct llvm_sys_fs_mapped_file_region {
    #[doc = " Platform-specific mapping state."]
    pub Size: usize,
    pub Mapping: *mut ::std::os::raw::c_void,
    pub Mode: llvm_sys_fs_mapped_file_region_mapmode,
}
#[doc = "< May only access map via const_data as read only."]
pub const llvm_sys_fs_mapped_file_region_mapmode_readonly: llvm_sys_fs_mapped_file_region_mapmode =
    0;
#[doc = "< May access map via data and modify it. Written to path."]
pub const llvm_sys_fs_mapped_file_region_mapmode_readwrite: llvm_sys_fs_mapped_file_region_mapmode =
    1;
#[doc = "< May modify via data, but changes are lost on destruction."]
pub const llvm_sys_fs_mapped_file_region_mapmode_priv_: llvm_sys_fs_mapped_file_region_mapmode = 2;
pub type llvm_sys_fs_mapped_file_region_mapmode = ::std::os::raw::c_uint;
#[test]
fn bindgen_test_layout_llvm_sys_fs_mapped_file_region() {
    const UNINIT: ::std::mem::MaybeUninit<llvm_sys_fs_mapped_file_region> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<llvm_sys_fs_mapped_file_region>(),
        24usize,
        concat!("Size of: ", stringify!(llvm_sys_fs_mapped_file_region))
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_sys_fs_mapped_file_region>(),
        8usize,
        concat!("Alignment of ", stringify!(llvm_sys_fs_mapped_file_region))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_sys_fs_mapped_file_region),
            "::",
            stringify!(Size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Mapping) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_sys_fs_mapped_file_region),
            "::",
            stringify!(Mapping)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Mode) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_sys_fs_mapped_file_region),
            "::",
            stringify!(Mode)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK4llvm3sys2fs18mapped_file_region4sizeEv"]
    pub fn llvm_sys_fs_mapped_file_region_size(
        this: *const llvm_sys_fs_mapped_file_region,
    ) -> usize;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4llvm3sys2fs18mapped_file_region4dataEv"]
    pub fn llvm_sys_fs_mapped_file_region_data(
        this: *const llvm_sys_fs_mapped_file_region,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Get a const view of the data. Modifying this memory has undefined\n behavior."]
    #[link_name = "\u{1}_ZNK4llvm3sys2fs18mapped_file_region10const_dataEv"]
    pub fn llvm_sys_fs_mapped_file_region_const_data(
        this: *const llvm_sys_fs_mapped_file_region,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " \\returns The minimum alignment offset must be."]
    #[link_name = "\u{1}_ZN4llvm3sys2fs18mapped_file_region9alignmentEv"]
    pub fn llvm_sys_fs_mapped_file_region_alignment() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\param fd An open file descriptor to map. Does not take ownership of fd."]
    #[link_name = "\u{1}_ZN4llvm3sys2fs18mapped_file_regionC1EiNS2_7mapmodeEmmRSt10error_code"]
    pub fn llvm_sys_fs_mapped_file_region_mapped_file_region(
        this: *mut llvm_sys_fs_mapped_file_region,
        fd: llvm_sys_fs_file_t,
        mode: llvm_sys_fs_mapped_file_region_mapmode,
        length: usize,
        offset: u64,
        ec: *mut std_error_code,
    );
}
impl llvm_sys_fs_mapped_file_region {
    #[inline]
    pub unsafe fn size(&self) -> usize {
        llvm_sys_fs_mapped_file_region_size(self)
    }
    #[inline]
    pub unsafe fn data(&self) -> *mut ::std::os::raw::c_char {
        llvm_sys_fs_mapped_file_region_data(self)
    }
    #[inline]
    pub unsafe fn const_data(&self) -> *const ::std::os::raw::c_char {
        llvm_sys_fs_mapped_file_region_const_data(self)
    }
    #[inline]
    pub unsafe fn alignment() -> ::std::os::raw::c_int {
        llvm_sys_fs_mapped_file_region_alignment()
    }
    #[inline]
    pub unsafe fn new(
        fd: llvm_sys_fs_file_t,
        mode: llvm_sys_fs_mapped_file_region_mapmode,
        length: usize,
        offset: u64,
        ec: *mut std_error_code,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        llvm_sys_fs_mapped_file_region_mapped_file_region(
            __bindgen_tmp.as_mut_ptr(),
            fd,
            mode,
            length,
            offset,
            ec,
        );
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[doc = " Return the path to the main executable, given the value of argv[0] from\n program startup and the address of main itself. In extremis, this function\n may fail and return an empty path."]
    #[link_name = "\u{1}_ZN4llvm3sys2fs17getMainExecutableB5cxx11EPKcPv"]
    pub fn llvm_sys_fs_getMainExecutable(
        argv0: *const ::std::os::raw::c_char,
        MainExecAddr: *mut ::std::os::raw::c_void,
    ) -> std_string;
}
#[doc = " directory_entry - A single entry in a directory."]
#[repr(C)]
pub struct llvm_sys_fs_directory_entry {
    pub Path: std_string,
    pub Type: llvm_sys_fs_file_type,
    pub FollowSymlinks: bool,
    pub Status: llvm_sys_fs_basic_file_status,
}
#[test]
fn bindgen_test_layout_llvm_sys_fs_directory_entry() {
    const UNINIT: ::std::mem::MaybeUninit<llvm_sys_fs_directory_entry> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<llvm_sys_fs_directory_entry>(),
        88usize,
        concat!("Size of: ", stringify!(llvm_sys_fs_directory_entry))
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_sys_fs_directory_entry>(),
        8usize,
        concat!("Alignment of ", stringify!(llvm_sys_fs_directory_entry))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Path) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_sys_fs_directory_entry),
            "::",
            stringify!(Path)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Type) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_sys_fs_directory_entry),
            "::",
            stringify!(Type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).FollowSymlinks) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_sys_fs_directory_entry),
            "::",
            stringify!(FollowSymlinks)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Status) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_sys_fs_directory_entry),
            "::",
            stringify!(Status)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm3sys2fs15directory_entry16replace_filenameERKNS_5TwineENS1_9file_typeENS1_17basic_file_statusE"]
    pub fn llvm_sys_fs_directory_entry_replace_filename(
        this: *mut llvm_sys_fs_directory_entry,
        Filename: *const llvm_Twine,
        Type: llvm_sys_fs_file_type,
        Status: llvm_sys_fs_basic_file_status,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK4llvm3sys2fs15directory_entry6statusEv"]
    pub fn llvm_sys_fs_directory_entry_status(
        this: *const llvm_sys_fs_directory_entry,
    ) -> llvm_ErrorOr;
}
impl llvm_sys_fs_directory_entry {
    #[inline]
    pub unsafe fn replace_filename(
        &mut self,
        Filename: *const llvm_Twine,
        Type: llvm_sys_fs_file_type,
        Status: llvm_sys_fs_basic_file_status,
    ) {
        llvm_sys_fs_directory_entry_replace_filename(self, Filename, Type, Status)
    }
    #[inline]
    pub unsafe fn status(&self) -> llvm_ErrorOr {
        llvm_sys_fs_directory_entry_status(self)
    }
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm3sys2fs6detail28directory_iterator_constructERNS2_12DirIterStateENS_9StringRefEb"]
    pub fn llvm_sys_fs_detail_directory_iterator_construct(
        arg1: *mut llvm_sys_fs_detail_DirIterState,
        arg2: llvm_StringRef,
        arg3: bool,
    ) -> std_error_code;
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm3sys2fs6detail28directory_iterator_incrementERNS2_12DirIterStateE"]
    pub fn llvm_sys_fs_detail_directory_iterator_increment(
        arg1: *mut llvm_sys_fs_detail_DirIterState,
    ) -> std_error_code;
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm3sys2fs6detail27directory_iterator_destructERNS2_12DirIterStateE"]
    pub fn llvm_sys_fs_detail_directory_iterator_destruct(
        arg1: *mut llvm_sys_fs_detail_DirIterState,
    ) -> std_error_code;
}
#[doc = " Keeps state for the directory_iterator."]
#[repr(C)]
pub struct llvm_sys_fs_detail_DirIterState {
    pub IterationHandle: isize,
    pub CurrentEntry: llvm_sys_fs_directory_entry,
}
#[test]
fn bindgen_test_layout_llvm_sys_fs_detail_DirIterState() {
    const UNINIT: ::std::mem::MaybeUninit<llvm_sys_fs_detail_DirIterState> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<llvm_sys_fs_detail_DirIterState>(),
        96usize,
        concat!("Size of: ", stringify!(llvm_sys_fs_detail_DirIterState))
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_sys_fs_detail_DirIterState>(),
        8usize,
        concat!("Alignment of ", stringify!(llvm_sys_fs_detail_DirIterState))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).IterationHandle) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_sys_fs_detail_DirIterState),
            "::",
            stringify!(IterationHandle)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).CurrentEntry) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_sys_fs_detail_DirIterState),
            "::",
            stringify!(CurrentEntry)
        )
    );
}
#[doc = " Keeps state for the recursive_directory_iterator."]
#[repr(C)]
pub struct llvm_sys_fs_detail_RecDirIterState {
    pub Stack: std_vector,
    pub Level: u16,
    pub HasNoPushRequest: bool,
}
#[test]
fn bindgen_test_layout_llvm_sys_fs_detail_RecDirIterState() {
    const UNINIT: ::std::mem::MaybeUninit<llvm_sys_fs_detail_RecDirIterState> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<llvm_sys_fs_detail_RecDirIterState>(),
        32usize,
        concat!("Size of: ", stringify!(llvm_sys_fs_detail_RecDirIterState))
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_sys_fs_detail_RecDirIterState>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(llvm_sys_fs_detail_RecDirIterState)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Stack) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_sys_fs_detail_RecDirIterState),
            "::",
            stringify!(Stack)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Level) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_sys_fs_detail_RecDirIterState),
            "::",
            stringify!(Level)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).HasNoPushRequest) as usize - ptr as usize },
        26usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_sys_fs_detail_RecDirIterState),
            "::",
            stringify!(HasNoPushRequest)
        )
    );
}
#[doc = " directory_iterator - Iterates through the entries in path. There is no\n operator++ because we need an error_code. If it's really needed we can make\n it call report_fatal_error on error."]
#[repr(C)]
pub struct llvm_sys_fs_directory_iterator {
    pub State: std_shared_ptr,
    pub FollowSymlinks: bool,
}
#[test]
fn bindgen_test_layout_llvm_sys_fs_directory_iterator() {
    const UNINIT: ::std::mem::MaybeUninit<llvm_sys_fs_directory_iterator> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<llvm_sys_fs_directory_iterator>(),
        24usize,
        concat!("Size of: ", stringify!(llvm_sys_fs_directory_iterator))
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_sys_fs_directory_iterator>(),
        8usize,
        concat!("Alignment of ", stringify!(llvm_sys_fs_directory_iterator))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).State) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_sys_fs_directory_iterator),
            "::",
            stringify!(State)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).FollowSymlinks) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_sys_fs_directory_iterator),
            "::",
            stringify!(FollowSymlinks)
        )
    );
}
#[doc = " recursive_directory_iterator - Same as directory_iterator except for it\n recurses down into child directories."]
#[repr(C)]
pub struct llvm_sys_fs_recursive_directory_iterator {
    pub State: std_shared_ptr,
    pub Follow: bool,
}
#[test]
fn bindgen_test_layout_llvm_sys_fs_recursive_directory_iterator() {
    const UNINIT: ::std::mem::MaybeUninit<llvm_sys_fs_recursive_directory_iterator> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<llvm_sys_fs_recursive_directory_iterator>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(llvm_sys_fs_recursive_directory_iterator)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_sys_fs_recursive_directory_iterator>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(llvm_sys_fs_recursive_directory_iterator)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).State) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_sys_fs_recursive_directory_iterator),
            "::",
            stringify!(State)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Follow) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_sys_fs_recursive_directory_iterator),
            "::",
            stringify!(Follow)
        )
    );
}
#[doc = " A time point on the system clock. This is provided for two reasons:\n - to insulate us against subtle differences in behavior to differences in\n   system clock precision (which is implementation-defined and differs\n   between platforms).\n - to shorten the type name\n The default precision is nanoseconds. If you need a specific precision\n specify it explicitly. If unsure, use the default. If you need a time point\n on a clock other than the system_clock, use std::chrono directly."]
pub type llvm_sys_TimePoint = std_chrono_time_point<_Dur>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_sys_UtcClock {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_llvm_sys_UtcClock() {
    assert_eq!(
        ::std::mem::size_of::<llvm_sys_UtcClock>(),
        1usize,
        concat!("Size of: ", stringify!(llvm_sys_UtcClock))
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_sys_UtcClock>(),
        1usize,
        concat!("Alignment of ", stringify!(llvm_sys_UtcClock))
    );
}
pub type llvm_sys_UtcTime<D> = std_chrono_time_point<D>;
extern "C" {
    #[doc = " getDefaultTargetTriple() - Return the default target triple the compiler\n has been configured to produce code for.\n\n The target triple is a string in the format of:\n   CPU_TYPE-VENDOR-OPERATING_SYSTEM\n or\n   CPU_TYPE-VENDOR-KERNEL-OPERATING_SYSTEM"]
    #[link_name = "\u{1}_ZN4llvm3sys22getDefaultTargetTripleB5cxx11Ev"]
    pub fn llvm_sys_getDefaultTargetTriple() -> std_string;
}
extern "C" {
    #[doc = " getProcessTriple() - Return an appropriate target triple for generating\n code to be loaded into the current process, e.g. when using the JIT."]
    #[link_name = "\u{1}_ZN4llvm3sys16getProcessTripleB5cxx11Ev"]
    pub fn llvm_sys_getProcessTriple() -> std_string;
}
extern "C" {
    #[doc = " getHostCPUName - Get the LLVM name for the host CPU. The particular format\n of the name is target dependent, and suitable for passing as -mcpu to the\n target which matches the host.\n\n \\return - The host CPU name, or empty if the CPU could not be determined."]
    #[link_name = "\u{1}_ZN4llvm3sys14getHostCPUNameEv"]
    pub fn llvm_sys_getHostCPUName() -> llvm_StringRef;
}
extern "C" {
    #[doc = " getHostCPUFeatures - Get the LLVM names for the host CPU features.\n The particular format of the names are target dependent, and suitable for\n passing as -mattr to the target which matches the host.\n\n \\return - A string map mapping feature names to either true (if enabled)\n or false (if disabled). This routine makes no guarantees about exactly\n which features may appear in this map, except that they are all valid LLVM\n feature names. The map can be empty, for example if feature detection\n fails."]
    #[link_name = "\u{1}_ZN4llvm3sys18getHostCPUFeaturesEv"]
    pub fn llvm_sys_getHostCPUFeatures() -> llvm_StringMap<llvm_MallocAllocator>;
}
extern "C" {
    #[doc = " This is a function compatible with cl::AddExtraVersionPrinter, which adds\n info about the current target triple and detected CPU."]
    #[link_name = "\u{1}_ZN4llvm3sys32printDefaultTargetAndDetectedCPUERNS_11raw_ostreamE"]
    pub fn llvm_sys_printDefaultTargetAndDetectedCPU(OS: *mut llvm_raw_ostream);
}
extern "C" {
    #[doc = " Helper functions to extract HostCPUName from /proc/cpuinfo on linux."]
    #[link_name = "\u{1}_ZN4llvm3sys6detail24getHostCPUNameForPowerPCENS_9StringRefE"]
    pub fn llvm_sys_detail_getHostCPUNameForPowerPC(
        ProcCpuinfoContent: llvm_StringRef,
    ) -> llvm_StringRef;
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm3sys6detail20getHostCPUNameForARMENS_9StringRefE"]
    pub fn llvm_sys_detail_getHostCPUNameForARM(
        ProcCpuinfoContent: llvm_StringRef,
    ) -> llvm_StringRef;
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm3sys6detail22getHostCPUNameForS390xENS_9StringRefE"]
    pub fn llvm_sys_detail_getHostCPUNameForS390x(
        ProcCpuinfoContent: llvm_StringRef,
    ) -> llvm_StringRef;
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm3sys6detail22getHostCPUNameForRISCVENS_9StringRefE"]
    pub fn llvm_sys_detail_getHostCPUNameForRISCV(
        ProcCpuinfoContent: llvm_StringRef,
    ) -> llvm_StringRef;
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm3sys6detail22getHostCPUNameForSPARCENS_9StringRefE"]
    pub fn llvm_sys_detail_getHostCPUNameForSPARC(
        ProcCpuinfoContent: llvm_StringRef,
    ) -> llvm_StringRef;
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm3sys6detail20getHostCPUNameForBPFEv"]
    pub fn llvm_sys_detail_getHostCPUNameForBPF() -> llvm_StringRef;
}
pub const llvm_sys_detail_x86_VendorSignatures_UNKNOWN: llvm_sys_detail_x86_VendorSignatures = 0;
pub const llvm_sys_detail_x86_VendorSignatures_GENUINE_INTEL: llvm_sys_detail_x86_VendorSignatures =
    1;
pub const llvm_sys_detail_x86_VendorSignatures_AUTHENTIC_AMD: llvm_sys_detail_x86_VendorSignatures =
    2;
pub type llvm_sys_detail_x86_VendorSignatures = ::std::os::raw::c_int;
extern "C" {
    #[doc = " Returns the host CPU's vendor.\n MaxLeaf: if a non-nullptr pointer is specified, the EAX value will be\n assigned to its pointee."]
    #[link_name = "\u{1}_ZN4llvm3sys6detail3x8618getVendorSignatureEPj"]
    pub fn llvm_sys_detail_x86_getVendorSignature(
        MaxLeaf: *mut ::std::os::raw::c_uint,
    ) -> llvm_sys_detail_x86_VendorSignatures;
}
#[doc = " Metafunction that determines whether the given type is either an\n integral type or an enumeration type, including enum classes.\n\n Note that this accepts potentially more integral types than is_integral\n because it is based on being implicitly convertible to an integral type.\n Also note that enum classes aren't implicitly convertible to integral types,\n the value may therefore need to be explicitly converted before being used."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_is_integral_or_enum {
    pub _address: u8,
}
pub type llvm_is_integral_or_enum_UnderlyingT = std_remove_reference_t;
#[doc = " If T is a pointer, just return it. If it is not, return T&."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_add_lvalue_reference_if_not_pointer {
    pub _address: u8,
}
pub type llvm_add_lvalue_reference_if_not_pointer_type<T> = *mut T;
#[doc = " If T is a pointer to X, return a pointer to const X. If it is not,\n return const T."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_add_const_past_pointer {
    pub _address: u8,
}
pub type llvm_add_const_past_pointer_type<T> = T;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_const_pointer_or_const_ref {
    pub _address: u8,
}
pub type llvm_const_pointer_or_const_ref_type<T> = *const T;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_is_copy_assignable {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_is_move_assignable {
    pub _address: u8,
}
#[doc = " An opaque object representing a hash code.\n\n This object represents the result of hashing some entity. It is intended to\n be used to implement hashtables or other hashing-based data structures.\n While it wraps and exposes a numeric value, this value should not be\n trusted to be stable or predictable across processes or executions.\n\n In order to obtain the hash_code for an object 'x':\n \\code\n   using llvm::hash_value;\n   llvm::hash_code code = hash_value(x);\n \\endcode"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_hash_code {
    pub value: usize,
}
#[test]
fn bindgen_test_layout_llvm_hash_code() {
    const UNINIT: ::std::mem::MaybeUninit<llvm_hash_code> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<llvm_hash_code>(),
        8usize,
        concat!("Size of: ", stringify!(llvm_hash_code))
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_hash_code>(),
        8usize,
        concat!("Alignment of ", stringify!(llvm_hash_code))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_hash_code),
            "::",
            stringify!(value)
        )
    );
}
extern "C" {
    #[doc = " Some primes between 2^63 and 2^64 for various uses."]
    #[link_name = "\u{1}_ZN4llvm7hashing6detailL2k0E"]
    pub static llvm_hashing_detail_k0: u64;
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm7hashing6detailL2k1E"]
    pub static llvm_hashing_detail_k1: u64;
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm7hashing6detailL2k2E"]
    pub static llvm_hashing_detail_k2: u64;
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm7hashing6detailL2k3E"]
    pub static llvm_hashing_detail_k3: u64;
}
#[doc = " The intermediate state used during hashing.\n Currently, the algorithm for computing hash codes is based on CityHash and\n keeps 56 bytes of arbitrary state."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_hashing_detail_hash_state {
    pub h0: u64,
    pub h1: u64,
    pub h2: u64,
    pub h3: u64,
    pub h4: u64,
    pub h5: u64,
    pub h6: u64,
}
#[test]
fn bindgen_test_layout_llvm_hashing_detail_hash_state() {
    const UNINIT: ::std::mem::MaybeUninit<llvm_hashing_detail_hash_state> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<llvm_hashing_detail_hash_state>(),
        56usize,
        concat!("Size of: ", stringify!(llvm_hashing_detail_hash_state))
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_hashing_detail_hash_state>(),
        8usize,
        concat!("Alignment of ", stringify!(llvm_hashing_detail_hash_state))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).h0) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_hashing_detail_hash_state),
            "::",
            stringify!(h0)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).h1) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_hashing_detail_hash_state),
            "::",
            stringify!(h1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).h2) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_hashing_detail_hash_state),
            "::",
            stringify!(h2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).h3) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_hashing_detail_hash_state),
            "::",
            stringify!(h3)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).h4) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_hashing_detail_hash_state),
            "::",
            stringify!(h4)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).h5) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_hashing_detail_hash_state),
            "::",
            stringify!(h5)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).h6) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_hashing_detail_hash_state),
            "::",
            stringify!(h6)
        )
    );
}
#[doc = " Trait to indicate whether a type's bits can be hashed directly.\n\n A type trait which is true if we want to combine values for hashing by\n reading the underlying data. It is false if values of this type must\n first be passed to hash_value, and the resulting hash_codes combined."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_hashing_detail_is_hashable_data {
    pub _address: u8,
}
#[doc = " Helper class to manage the recursive combining of hash_combine\n arguments.\n\n This class exists to manage the state and various calls involved in the\n recursive combining of arguments used in hash_combine. It is particularly\n useful at minimizing the code in the recursive calls to ease the pain\n caused by a lack of variadic functions."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_hashing_detail_hash_combine_recursive_helper {
    pub buffer: [::std::os::raw::c_char; 64usize],
    pub state: llvm_hashing_detail_hash_state,
    pub seed: u64,
}
#[test]
fn bindgen_test_layout_llvm_hashing_detail_hash_combine_recursive_helper() {
    const UNINIT: ::std::mem::MaybeUninit<llvm_hashing_detail_hash_combine_recursive_helper> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<llvm_hashing_detail_hash_combine_recursive_helper>(),
        128usize,
        concat!(
            "Size of: ",
            stringify!(llvm_hashing_detail_hash_combine_recursive_helper)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_hashing_detail_hash_combine_recursive_helper>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(llvm_hashing_detail_hash_combine_recursive_helper)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).buffer) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_hashing_detail_hash_combine_recursive_helper),
            "::",
            stringify!(buffer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).state) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_hashing_detail_hash_combine_recursive_helper),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).seed) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_hashing_detail_hash_combine_recursive_helper),
            "::",
            stringify!(seed)
        )
    );
}
#[test]
fn __bindgen_test_layout_llvm_DenseMapInfo_open0_llvm_hash_code_void_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<llvm_DenseMapInfo>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_DenseMapInfo)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_DenseMapInfo>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_DenseMapInfo)
        )
    );
}
#[doc = " An efficient, type-erasing, non-owning reference to a callable. This is\n intended for use as the type of a function parameter that is not used\n after the function in question returns.\n\n This class does not own the callable, so it is not in general safe to store\n a function_ref."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_function_ref {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_explicitly_convertible {
    pub _base: std_false_type,
}
#[doc = " A range adaptor for a pair of iterators.\n\n This just wraps two iterators into a range-compatible interface. Nothing\n fancy at all."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_iterator_range<IteratorT> {
    pub begin_iterator: IteratorT,
    pub end_iterator: IteratorT,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<IteratorT>>,
}
#[doc = " CRTP base class which implements the entire standard iterator facade\n in terms of a minimal subset of the interface.\n\n Use this when it is reasonable to implement most of the iterator\n functionality in terms of a core subset. If you need special behavior or\n there are performance implications for this, you may want to override the\n relevant members instead.\n\n Note, one abstraction that this does *not* provide is implementing\n subtraction in terms of addition by negating the difference. Negation isn't\n always information preserving, and I can see very reasonable iterator\n designs where this doesn't work well. It doesn't really force much added\n boilerplate anyways.\n\n Another abstraction that this doesn't provide is implementing increment in\n terms of addition of one. These aren't equivalent for all iterator\n categories, and respecting that adds a lot of complexity for little gain.\n\n Iterators are expected to have const rules analogous to pointers, with a\n single, const-qualified operator*() that returns ReferenceT. This matches\n the second and third pointers in the following example:\n \\code\n   int Value;\n   { int *I = &Value; }             // ReferenceT 'int&'\n   { int *const I = &Value; }       // ReferenceT 'int&'; const\n   { const int *I = &Value; }       // ReferenceT 'const int&'\n   { const int *const I = &Value; } // ReferenceT 'const int&'; const\n \\endcode\n If an iterator facade returns a handle to its own state, then T (and\n PointerT and ReferenceT) should usually be const-qualified. Otherwise, if\n clients are expected to modify the handle itself, the field can be declared\n mutable or use const_cast.\n\n Classes wishing to use `iterator_facade_base` should implement the following\n methods:\n\n Forward Iterators:\n   (All of the following methods)\n   - DerivedT &operator=(const DerivedT &R);\n   - bool operator==(const DerivedT &R) const;\n   - T &operator*() const;\n   - DerivedT &operator++();\n\n Bidirectional Iterators:\n   (All methods of forward iterators, plus the following)\n   - DerivedT &operator--();\n\n Random-access Iterators:\n   (All methods of bidirectional iterators excluding the following)\n   - DerivedT &operator++();\n   - DerivedT &operator--();\n   (and plus the following)\n   - bool operator<(const DerivedT &RHS) const;\n   - DifferenceTypeT operator-(const DerivedT &R) const;\n   - DerivedT &operator+=(DifferenceTypeT N);\n   - DerivedT &operator-=(DifferenceTypeT N);\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_iterator_facade_base {
    pub _address: u8,
}
pub type llvm_iterator_facade_base_iterator_category<IteratorCategoryT> = IteratorCategoryT;
pub type llvm_iterator_facade_base_value_type<T> = T;
pub type llvm_iterator_facade_base_difference_type<DifferenceTypeT> = DifferenceTypeT;
pub type llvm_iterator_facade_base_pointer<PointerT> = PointerT;
pub type llvm_iterator_facade_base_reference<ReferenceT> = ReferenceT;
pub const llvm_iterator_facade_base_IsRandomAccess: llvm_iterator_facade_base__bindgen_ty_1 = 0;
pub const llvm_iterator_facade_base_IsBidirectional: llvm_iterator_facade_base__bindgen_ty_1 = 0;
pub type llvm_iterator_facade_base__bindgen_ty_1 = i32;
#[doc = " A proxy object for computing a reference via indirecting a copy of an\n iterator. This is used in APIs which need to produce a reference via\n indirection but for which the iterator object might be a temporary. The\n proxy preserves the iterator internally and exposes the indirected\n reference via a conversion operator."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_iterator_facade_base_ReferenceProxy<DerivedT> {
    pub I: DerivedT,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<DerivedT>>,
}
#[doc = " A proxy object for computing a pointer via indirecting a copy of a\n reference. This is used in APIs which need to produce a pointer but for\n which the reference might be a temporary. The proxy preserves the\n reference internally and exposes the pointer via a arrow operator."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_iterator_facade_base_PointerProxy<ReferenceT> {
    pub R: ReferenceT,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<ReferenceT>>,
}
#[doc = " CRTP base class for adapting an iterator to a different type.\n\n This class can be used through CRTP to adapt one iterator into another.\n Typically this is done through providing in the derived class a custom \\c\n operator* implementation. Other methods can be overridden as well."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_iterator_adaptor_base<WrappedIteratorT> {
    pub I: WrappedIteratorT,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<WrappedIteratorT>>,
}
pub type llvm_iterator_adaptor_base_BaseT<WrappedIteratorT> =
    llvm_iterator_adaptor_base<WrappedIteratorT>;
pub type llvm_iterator_adaptor_base_difference_type<DifferenceTypeT> = DifferenceTypeT;
#[doc = " An iterator type that allows iterating over the pointees via some\n other iterator.\n\n The typical usage of this is to expose a type that iterates over Ts, but\n which is implemented with some iterator over T*s:\n\n \\code\n   using iterator = pointee_iterator<SmallVectorImpl<T *>::iterator>;\n \\endcode"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_pointee_iterator {
    pub _base: llvm_iterator_adaptor_base<WrappedIteratorT>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_pointer_iterator<T> {
    pub _base: llvm_iterator_adaptor_base<WrappedIteratorT>,
    pub Ptr: T,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<T>>,
}
pub type llvm_raw_pointer_iterator<T2> = llvm_pointer_iterator<T2>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_make_const_ptr {
    pub _address: u8,
}
pub type llvm_make_const_ptr_type = std_add_pointer_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_make_const_ref {
    pub _address: u8,
}
pub type llvm_make_const_ref_type = std_add_lvalue_reference_t;
#[doc = " Detects if a given trait holds for some set of arguments 'Args'.\n For example, the given trait could be used to detect if a given type\n has a copy assignment operator:\n   template<class T>\n   using has_copy_assign_t = decltype(std::declval<T&>()\n                                                 = std::declval<const T&>());\n   bool fooHasCopyAssign = is_detected<has_copy_assign_t, FooClass>::value;"]
pub type llvm_is_detected = llvm_detail_detector;
#[doc = " traits class for checking whether type T is one of any of the given\n types in the variadic list."]
pub type llvm_is_one_of = std_disjunction;
#[doc = " traits class for checking whether type T is a base class for all\n  the given types in the variadic list."]
pub type llvm_are_base_of = std_conjunction;
#[test]
fn __bindgen_test_layout_llvm_TypesAreDistinct_open0_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<llvm_TypesAreDistinct>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_TypesAreDistinct)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_TypesAreDistinct>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_TypesAreDistinct)
        )
    );
}
#[doc = " Determine if all types in Ts are distinct.\n\n Useful to statically assert when Ts is intended to describe a non-multi set\n of types.\n\n Expensive (currently quadratic in sizeof(Ts...)), and so should only be\n asserted once per instantiation of a type which requires it."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_TypesAreDistinct {
    pub _address: u8,
}
#[doc = " Find the first index where a type appears in a list of types.\n\n FirstIndexOfType<T, Us...>::value is the first index of T in Us.\n\n Typically only meaningful when it is otherwise statically known that the\n type pack has no duplicate types. This should be guaranteed explicitly with\n static_assert(TypesAreDistinct<Us...>::value).\n\n It is a compile-time error to instantiate when T is not present in Us, i.e.\n if is_one_of<T, Us...>::value is false."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_FirstIndexOfType {
    pub _address: u8,
}
#[doc = " Find the type at a given index in a list of types.\n\n TypeAtIndex<I, Ts...> is the type at index I in Ts."]
pub type llvm_TypeAtIndex = std_tuple_element_t;
pub type llvm_callable_detail_Callable_value_type = std_remove_reference_t;
pub type llvm_callable_detail_Callable_reference = *mut llvm_callable_detail_Callable_value_type;
pub type llvm_callable_detail_Callable_const_reference =
    *const llvm_callable_detail_Callable_value_type;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_mapped_iterator {
    pub _base: llvm_iterator_adaptor_base<WrappedIteratorT>,
    pub F: u8,
}
#[doc = " A base type of mapped iterator, that is useful for building derived\n iterators that do not need/want to store the map function (as in\n mapped_iterator). These iterators must simply provide a `mapElement` method\n that defines how to map a value of the iterator to the provided reference\n type."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_mapped_iterator_base {
    pub _base: llvm_iterator_adaptor_base<WrappedIteratorT>,
}
#[doc = " A base type of mapped iterator, that is useful for building derived\n iterators that do not need/want to store the map function (as in\n mapped_iterator). These iterators must simply provide a `mapElement` method\n that defines how to map a value of the iterator to the provided reference\n type."]
pub type llvm_mapped_iterator_base_BaseT = llvm_mapped_iterator_base;
#[doc = " An iterator adaptor that filters the elements of given inner iterators.\n\n The predicate parameter should be a callable object that accepts the wrapped\n iterator's reference type and returns a bool. When incrementing or\n decrementing the iterator, it will call the predicate on each element and\n skip any where it returns false.\n\n \\code\n   int A[] = { 1, 2, 3, 4 };\n   auto R = make_filter_range(A, [](int N) { return N % 2 == 1; });\n   // R contains { 1, 3 }.\n \\endcode\n\n Note: filter_iterator_base implements support for forward iteration.\n filter_iterator_impl exists to provide support for bidirectional iteration,\n conditional on whether the wrapped iterator supports it."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_filter_iterator_base<WrappedIteratorT, PredicateT> {
    pub _base: llvm_iterator_adaptor_base<WrappedIteratorT>,
    pub End: WrappedIteratorT,
    pub Pred: PredicateT,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<WrappedIteratorT>>,
    pub _phantom_1: ::std::marker::PhantomData<::std::cell::UnsafeCell<PredicateT>>,
}
pub type llvm_filter_iterator_base_BaseT<WrappedIteratorT, PredicateT> =
    llvm_filter_iterator_base<WrappedIteratorT, PredicateT>;
#[doc = " Specialization of filter_iterator_base for forward iteration only."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_filter_iterator_impl<WrappedIteratorT, PredicateT> {
    pub _base: llvm_filter_iterator_base<WrappedIteratorT, PredicateT>,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<WrappedIteratorT>>,
    pub _phantom_1: ::std::marker::PhantomData<::std::cell::UnsafeCell<PredicateT>>,
}
#[doc = " Defines filter_iterator to a suitable specialization of\n filter_iterator_impl, based on the underlying iterator's category."]
pub type llvm_filter_iterator = llvm_filter_iterator_impl<WrappedIteratorT, PredicateT>;
#[doc = " A pseudo-iterator adaptor that is designed to implement \"early increment\"\n style loops.\n\n This is *not a normal iterator* and should almost never be used directly. It\n is intended primarily to be used with range based for loops and some range\n algorithms.\n\n The iterator isn't quite an `OutputIterator` or an `InputIterator` but\n somewhere between them. The constraints of these iterators are:\n\n - On construction or after being incremented, it is comparable and\n   dereferencable. It is *not* incrementable.\n - After being dereferenced, it is neither comparable nor dereferencable, it\n   is only incrementable.\n\n This means you can only dereference the iterator once, and you can only\n increment it once between dereferences."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_early_inc_iterator_impl {
    pub _base: llvm_iterator_adaptor_base<WrappedIteratorT>,
    pub IsEarlyIncremented: bool,
}
pub type llvm_early_inc_iterator_impl_BaseT = llvm_early_inc_iterator_impl;
pub type llvm_early_inc_iterator_impl_PointerT = std_iterator_traits;
#[doc = " Iterator wrapper that concatenates sequences together.\n\n This can concatenate different iterators, even with different types, into\n a single iterator provided the value types of all the concatenated\n iterators expose `reference` and `pointer` types that can be converted to\n `ValueT &` and `ValueT *` respectively. It doesn't support more\n interesting/customized pointer or reference types.\n\n Currently this only supports forward or higher iterator categories as\n inputs and always exposes a forward iterator interface."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_concat_iterator {
    #[doc = " We store both the current and end iterators for each concatenated\n sequence in a tuple of pairs.\n\n Note that something like iterator_range seems nice at first here, but the\n range properties are of little benefit and end up getting in the way\n because we need to do mutation on the current iterators."]
    pub Begins: std_tuple,
    pub Ends: std_tuple,
}
pub type llvm_concat_iterator_BaseT = llvm_concat_iterator;
#[doc = " A utility class used to implement an iterator that contains some base object\n and an index. The iterator moves the index but keeps the base constant."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_indexed_accessor_iterator<BaseT> {
    pub base: BaseT,
    pub index: isize,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<BaseT>>,
}
#[doc = " This class provides an implementation of a range of\n indexed_accessor_iterators where the base is not indexable. Ranges with\n bases that are offsetable should derive from indexed_accessor_range_base\n instead. Derived range classes are expected to implement the following\n static method:\n   * ReferenceT dereference(const BaseT &base, ptrdiff_t index)\n     - Dereference an iterator pointing to a parent base at the given index."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_indexed_accessor_range {
    pub _base: llvm_detail_indexed_accessor_range_base<BaseT>,
}
#[doc = " Function object to check whether the first component of a container\n supported by std::get (like std::pair and std::tuple) compares less than the\n first component of another container."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_less_first {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_llvm_less_first() {
    assert_eq!(
        ::std::mem::size_of::<llvm_less_first>(),
        1usize,
        concat!("Size of: ", stringify!(llvm_less_first))
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_less_first>(),
        1usize,
        concat!("Alignment of ", stringify!(llvm_less_first))
    );
}
#[doc = " Function object to check whether the second component of a container\n supported by std::get (like std::pair and std::tuple) compares less than the\n second component of another container."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_less_second {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_llvm_less_second() {
    assert_eq!(
        ::std::mem::size_of::<llvm_less_second>(),
        1usize,
        concat!("Size of: ", stringify!(llvm_less_second))
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_less_second>(),
        1usize,
        concat!("Alignment of ", stringify!(llvm_less_second))
    );
}
#[doc = " \\brief Function object to apply a binary function to the first component of\n a std::pair."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_on_first<FuncTy> {
    pub func: FuncTy,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<FuncTy>>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_FreeDeleter {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_llvm_FreeDeleter() {
    assert_eq!(
        ::std::mem::size_of::<llvm_FreeDeleter>(),
        1usize,
        concat!("Size of: ", stringify!(llvm_FreeDeleter))
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_FreeDeleter>(),
        1usize,
        concat!("Alignment of ", stringify!(llvm_FreeDeleter))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_pair_hash {
    pub _address: u8,
}
#[doc = " Binary functor that adapts to any other binary functor after dereferencing\n operands."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_deref<T> {
    pub func: T,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<T>>,
}
#[doc = " Increasing range of `size_t` indices."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_index_range {
    pub Begin: usize,
    pub End: usize,
}
#[test]
fn bindgen_test_layout_llvm_index_range() {
    const UNINIT: ::std::mem::MaybeUninit<llvm_index_range> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<llvm_index_range>(),
        16usize,
        concat!("Size of: ", stringify!(llvm_index_range))
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_index_range>(),
        8usize,
        concat!("Alignment of ", stringify!(llvm_index_range))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Begin) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_index_range),
            "::",
            stringify!(Begin)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).End) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_index_range),
            "::",
            stringify!(End)
        )
    );
}
#[doc = " ArrayRef - Represent a constant reference to an array (0 or more elements\n consecutively in memory), i.e. a start pointer and a length.  It allows\n various APIs to take consecutive elements easily and conveniently.\n\n This class does not own the underlying data, it is expected to be used in\n situations where the data resides in some other buffer, whose lifetime\n extends past that of the ArrayRef. For this reason, it is not in general\n safe to store an ArrayRef.\n\n This is intended to be trivially copyable, so it should be passed by\n value."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_ArrayRef<T> {
    #[doc = " The start of the array, in an external buffer."]
    pub Data: *const T,
    #[doc = " The number of elements."]
    pub Length: llvm_ArrayRef_size_type,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<T>>,
}
pub type llvm_ArrayRef_value_type<T> = T;
pub type llvm_ArrayRef_pointer<T> = *mut llvm_ArrayRef_value_type<T>;
pub type llvm_ArrayRef_const_pointer<T> = *const llvm_ArrayRef_value_type<T>;
pub type llvm_ArrayRef_reference<T> = *mut llvm_ArrayRef_value_type<T>;
pub type llvm_ArrayRef_const_reference<T> = *const llvm_ArrayRef_value_type<T>;
pub type llvm_ArrayRef_iterator<T> = llvm_ArrayRef_const_pointer<T>;
pub type llvm_ArrayRef_const_iterator<T> = llvm_ArrayRef_const_pointer<T>;
pub type llvm_ArrayRef_reverse_iterator<T> = std_reverse_iterator<llvm_ArrayRef_iterator<T>>;
pub type llvm_ArrayRef_const_reverse_iterator<T> =
    std_reverse_iterator<llvm_ArrayRef_const_iterator<T>>;
pub type llvm_ArrayRef_size_type = usize;
pub type llvm_ArrayRef_difference_type = isize;
#[doc = " MutableArrayRef - Represent a mutable reference to an array (0 or more\n elements consecutively in memory), i.e. a start pointer and a length.  It\n allows various APIs to take and modify consecutive elements easily and\n conveniently.\n\n This class does not own the underlying data, it is expected to be used in\n situations where the data resides in some other buffer, whose lifetime\n extends past that of the MutableArrayRef. For this reason, it is not in\n general safe to store a MutableArrayRef.\n\n This is intended to be trivially copyable, so it should be passed by\n value."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_MutableArrayRef<T> {
    pub _base: llvm_ArrayRef<T>,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<T>>,
}
pub type llvm_MutableArrayRef_value_type<T> = T;
pub type llvm_MutableArrayRef_pointer<T> = *mut llvm_MutableArrayRef_value_type<T>;
pub type llvm_MutableArrayRef_const_pointer<T> = *const llvm_MutableArrayRef_value_type<T>;
pub type llvm_MutableArrayRef_reference<T> = *mut llvm_MutableArrayRef_value_type<T>;
pub type llvm_MutableArrayRef_const_reference<T> = *const llvm_MutableArrayRef_value_type<T>;
pub type llvm_MutableArrayRef_iterator<T> = llvm_MutableArrayRef_pointer<T>;
pub type llvm_MutableArrayRef_const_iterator<T> = llvm_MutableArrayRef_const_pointer<T>;
pub type llvm_MutableArrayRef_reverse_iterator<T> =
    std_reverse_iterator<llvm_MutableArrayRef_iterator<T>>;
pub type llvm_MutableArrayRef_const_reverse_iterator<T> =
    std_reverse_iterator<llvm_MutableArrayRef_const_iterator<T>>;
pub type llvm_MutableArrayRef_size_type = usize;
pub type llvm_MutableArrayRef_difference_type = isize;
#[doc = " This is a MutableArrayRef that owns its array."]
#[repr(C)]
#[derive(Debug)]
pub struct llvm_OwningArrayRef<T> {
    pub _base: llvm_MutableArrayRef<T>,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<T>>,
}
#[doc = " An information struct used to provide DenseMap with the various necessary\n components for a given value type `T`. `Enable` is an optional additional\n parameter that is used to support SFINAE (generally using std::enable_if_t)\n in derived DenseMapInfo specializations; in non-SFINAE use cases this should\n just be `void`."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_DenseMapInfo {
    pub _address: u8,
}
#[test]
fn __bindgen_test_layout_llvm_DenseMapInfo_open0_char_void_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<llvm_DenseMapInfo>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_DenseMapInfo)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_DenseMapInfo>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_DenseMapInfo)
        )
    );
}
#[test]
fn __bindgen_test_layout_llvm_DenseMapInfo_open0_unsigned_char_void_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<llvm_DenseMapInfo>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_DenseMapInfo)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_DenseMapInfo>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_DenseMapInfo)
        )
    );
}
#[test]
fn __bindgen_test_layout_llvm_DenseMapInfo_open0_unsigned_short_void_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<llvm_DenseMapInfo>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_DenseMapInfo)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_DenseMapInfo>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_DenseMapInfo)
        )
    );
}
#[test]
fn __bindgen_test_layout_llvm_DenseMapInfo_open0_unsigned_int_void_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<llvm_DenseMapInfo>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_DenseMapInfo)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_DenseMapInfo>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_DenseMapInfo)
        )
    );
}
#[test]
fn __bindgen_test_layout_llvm_DenseMapInfo_open0_unsigned_long_void_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<llvm_DenseMapInfo>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_DenseMapInfo)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_DenseMapInfo>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_DenseMapInfo)
        )
    );
}
#[test]
fn __bindgen_test_layout_llvm_DenseMapInfo_open0_unsigned_long_long_void_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<llvm_DenseMapInfo>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_DenseMapInfo)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_DenseMapInfo>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_DenseMapInfo)
        )
    );
}
#[test]
fn __bindgen_test_layout_llvm_DenseMapInfo_open0_short_void_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<llvm_DenseMapInfo>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_DenseMapInfo)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_DenseMapInfo>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_DenseMapInfo)
        )
    );
}
#[test]
fn __bindgen_test_layout_llvm_DenseMapInfo_open0_int_void_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<llvm_DenseMapInfo>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_DenseMapInfo)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_DenseMapInfo>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_DenseMapInfo)
        )
    );
}
#[test]
fn __bindgen_test_layout_llvm_DenseMapInfo_open0_long_void_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<llvm_DenseMapInfo>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_DenseMapInfo)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_DenseMapInfo>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_DenseMapInfo)
        )
    );
}
#[test]
fn __bindgen_test_layout_llvm_DenseMapInfo_open0_long_long_void_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<llvm_DenseMapInfo>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_DenseMapInfo)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_DenseMapInfo>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_DenseMapInfo)
        )
    );
}
extern "C" {
    #[doc = " Helper functions for StringRef::getAsInteger."]
    #[link_name = "\u{1}_ZN4llvm20getAsUnsignedIntegerENS_9StringRefEjRy"]
    pub fn llvm_getAsUnsignedInteger(
        Str: llvm_StringRef,
        Radix: ::std::os::raw::c_uint,
        Result: *mut ::std::os::raw::c_ulonglong,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm18getAsSignedIntegerENS_9StringRefEjRx"]
    pub fn llvm_getAsSignedInteger(
        Str: llvm_StringRef,
        Radix: ::std::os::raw::c_uint,
        Result: *mut ::std::os::raw::c_longlong,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm22consumeUnsignedIntegerERNS_9StringRefEjRy"]
    pub fn llvm_consumeUnsignedInteger(
        Str: *mut llvm_StringRef,
        Radix: ::std::os::raw::c_uint,
        Result: *mut ::std::os::raw::c_ulonglong,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm20consumeSignedIntegerERNS_9StringRefEjRx"]
    pub fn llvm_consumeSignedInteger(
        Str: *mut llvm_StringRef,
        Radix: ::std::os::raw::c_uint,
        Result: *mut ::std::os::raw::c_longlong,
    ) -> bool;
}
#[doc = " StringRef - Represent a constant reference to a string, i.e. a character\n array and a length, which need not be null terminated.\n\n This class does not own the string data, it is expected to be used in\n situations where the character data resides in some other buffer, whose\n lifetime extends past that of the StringRef. For this reason, it is not in\n general safe to store a StringRef."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_StringRef {
    #[doc = " The start of the string, in an external buffer."]
    pub Data: *const ::std::os::raw::c_char,
    #[doc = " The length of the string."]
    pub Length: usize,
}
pub type llvm_StringRef_iterator = *const ::std::os::raw::c_char;
pub type llvm_StringRef_const_iterator = *const ::std::os::raw::c_char;
pub type llvm_StringRef_size_type = usize;
pub type llvm_StringRef_value_type = ::std::os::raw::c_char;
pub type llvm_StringRef_reverse_iterator = std_reverse_iterator<llvm_StringRef_iterator>;
pub type llvm_StringRef_const_reverse_iterator =
    std_reverse_iterator<llvm_StringRef_const_iterator>;
extern "C" {
    #[link_name = "\u{1}_ZN4llvm9StringRef4nposE"]
    pub static llvm_StringRef_npos: usize;
}
#[test]
fn bindgen_test_layout_llvm_StringRef() {
    const UNINIT: ::std::mem::MaybeUninit<llvm_StringRef> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<llvm_StringRef>(),
        16usize,
        concat!("Size of: ", stringify!(llvm_StringRef))
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_StringRef>(),
        8usize,
        concat!("Alignment of ", stringify!(llvm_StringRef))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_StringRef),
            "::",
            stringify!(Data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Length) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_StringRef),
            "::",
            stringify!(Length)
        )
    );
}
extern "C" {
    #[doc = " Compare two strings, ignoring case."]
    #[link_name = "\u{1}_ZNK4llvm9StringRef19compare_insensitiveES0_"]
    pub fn llvm_StringRef_compare_insensitive(
        this: *const llvm_StringRef,
        RHS: llvm_StringRef,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " compare_numeric - Compare two strings, treating sequences of digits as\n numbers."]
    #[link_name = "\u{1}_ZNK4llvm9StringRef15compare_numericES0_"]
    pub fn llvm_StringRef_compare_numeric(
        this: *const llvm_StringRef,
        RHS: llvm_StringRef,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Determine the edit distance between this string and another\n string.\n\n \\param Other the string to compare this string against.\n\n \\param AllowReplacements whether to allow character\n replacements (change one character into another) as a single\n operation, rather than as two operations (an insertion and a\n removal).\n\n \\param MaxEditDistance If non-zero, the maximum edit distance that\n this routine is allowed to compute. If the edit distance will exceed\n that maximum, returns \\c MaxEditDistance+1.\n\n \\returns the minimum number of character insertions, removals,\n or (if \\p AllowReplacements is \\c true) replacements needed to\n transform one of the given strings into the other. If zero,\n the strings are identical."]
    #[link_name = "\u{1}_ZNK4llvm9StringRef13edit_distanceES0_bj"]
    pub fn llvm_StringRef_edit_distance(
        this: *const llvm_StringRef,
        Other: llvm_StringRef,
        AllowReplacements: bool,
        MaxEditDistance: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4llvm9StringRef25edit_distance_insensitiveES0_bj"]
    pub fn llvm_StringRef_edit_distance_insensitive(
        this: *const llvm_StringRef,
        Other: llvm_StringRef,
        AllowReplacements: bool,
        MaxEditDistance: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " Check if this string starts with the given \\p Prefix, ignoring case."]
    #[link_name = "\u{1}_ZNK4llvm9StringRef23starts_with_insensitiveES0_"]
    pub fn llvm_StringRef_starts_with_insensitive(
        this: *const llvm_StringRef,
        Prefix: llvm_StringRef,
    ) -> bool;
}
extern "C" {
    #[doc = " Check if this string ends with the given \\p Suffix, ignoring case."]
    #[link_name = "\u{1}_ZNK4llvm9StringRef21ends_with_insensitiveES0_"]
    pub fn llvm_StringRef_ends_with_insensitive(
        this: *const llvm_StringRef,
        Suffix: llvm_StringRef,
    ) -> bool;
}
extern "C" {
    #[doc = " Search for the first character \\p C in the string, ignoring case.\n\n \\returns The index of the first occurrence of \\p C, or npos if not\n found."]
    #[link_name = "\u{1}_ZNK4llvm9StringRef16find_insensitiveEcm"]
    pub fn llvm_StringRef_find_insensitive(
        this: *const llvm_StringRef,
        C: ::std::os::raw::c_char,
        From: usize,
    ) -> usize;
}
extern "C" {
    #[doc = " Search for the first string \\p Str in the string.\n\n \\returns The index of the first occurrence of \\p Str, or npos if not\n found."]
    #[link_name = "\u{1}_ZNK4llvm9StringRef4findES0_m"]
    pub fn llvm_StringRef_find(
        this: *const llvm_StringRef,
        Str: llvm_StringRef,
        From: usize,
    ) -> usize;
}
extern "C" {
    #[doc = " Search for the first string \\p Str in the string, ignoring case.\n\n \\returns The index of the first occurrence of \\p Str, or npos if not\n found."]
    #[link_name = "\u{1}_ZNK4llvm9StringRef16find_insensitiveES0_m"]
    pub fn llvm_StringRef_find_insensitive1(
        this: *const llvm_StringRef,
        Str: llvm_StringRef,
        From: usize,
    ) -> usize;
}
extern "C" {
    #[doc = " Search for the last character \\p C in the string, ignoring case.\n\n \\returns The index of the last occurrence of \\p C, or npos if not\n found."]
    #[link_name = "\u{1}_ZNK4llvm9StringRef17rfind_insensitiveEcm"]
    pub fn llvm_StringRef_rfind_insensitive(
        this: *const llvm_StringRef,
        C: ::std::os::raw::c_char,
        From: usize,
    ) -> usize;
}
extern "C" {
    #[doc = " Search for the last string \\p Str in the string.\n\n \\returns The index of the last occurrence of \\p Str, or npos if not\n found."]
    #[link_name = "\u{1}_ZNK4llvm9StringRef5rfindES0_"]
    pub fn llvm_StringRef_rfind(this: *const llvm_StringRef, Str: llvm_StringRef) -> usize;
}
extern "C" {
    #[doc = " Search for the last string \\p Str in the string, ignoring case.\n\n \\returns The index of the last occurrence of \\p Str, or npos if not\n found."]
    #[link_name = "\u{1}_ZNK4llvm9StringRef17rfind_insensitiveES0_"]
    pub fn llvm_StringRef_rfind_insensitive1(
        this: *const llvm_StringRef,
        Str: llvm_StringRef,
    ) -> usize;
}
extern "C" {
    #[doc = " Find the first character in the string that is in \\p Chars, or npos if\n not found.\n\n Complexity: O(size() + Chars.size())"]
    #[link_name = "\u{1}_ZNK4llvm9StringRef13find_first_ofES0_m"]
    pub fn llvm_StringRef_find_first_of(
        this: *const llvm_StringRef,
        Chars: llvm_StringRef,
        From: usize,
    ) -> usize;
}
extern "C" {
    #[doc = " Find the first character in the string that is not \\p C or npos if not\n found."]
    #[link_name = "\u{1}_ZNK4llvm9StringRef17find_first_not_ofEcm"]
    pub fn llvm_StringRef_find_first_not_of(
        this: *const llvm_StringRef,
        C: ::std::os::raw::c_char,
        From: usize,
    ) -> usize;
}
extern "C" {
    #[doc = " Find the first character in the string that is not in the string\n \\p Chars, or npos if not found.\n\n Complexity: O(size() + Chars.size())"]
    #[link_name = "\u{1}_ZNK4llvm9StringRef17find_first_not_ofES0_m"]
    pub fn llvm_StringRef_find_first_not_of1(
        this: *const llvm_StringRef,
        Chars: llvm_StringRef,
        From: usize,
    ) -> usize;
}
extern "C" {
    #[doc = " Find the last character in the string that is in \\p C, or npos if not\n found.\n\n Complexity: O(size() + Chars.size())"]
    #[link_name = "\u{1}_ZNK4llvm9StringRef12find_last_ofES0_m"]
    pub fn llvm_StringRef_find_last_of(
        this: *const llvm_StringRef,
        Chars: llvm_StringRef,
        From: usize,
    ) -> usize;
}
extern "C" {
    #[doc = " Find the last character in the string that is not \\p C, or npos if not\n found."]
    #[link_name = "\u{1}_ZNK4llvm9StringRef16find_last_not_ofEcm"]
    pub fn llvm_StringRef_find_last_not_of(
        this: *const llvm_StringRef,
        C: ::std::os::raw::c_char,
        From: usize,
    ) -> usize;
}
extern "C" {
    #[doc = " Find the last character in the string that is not in \\p Chars, or\n npos if not found.\n\n Complexity: O(size() + Chars.size())"]
    #[link_name = "\u{1}_ZNK4llvm9StringRef16find_last_not_ofES0_m"]
    pub fn llvm_StringRef_find_last_not_of1(
        this: *const llvm_StringRef,
        Chars: llvm_StringRef,
        From: usize,
    ) -> usize;
}
extern "C" {
    #[doc = " Return the number of non-overlapped occurrences of \\p Str in\n the string."]
    #[link_name = "\u{1}_ZNK4llvm9StringRef5countES0_"]
    pub fn llvm_StringRef_count(this: *const llvm_StringRef, Str: llvm_StringRef) -> usize;
}
extern "C" {
    #[doc = " Parse the current string as an integer of the specified \\p Radix, or of\n an autosensed radix if the \\p Radix given is 0.  The current value in\n \\p Result is discarded, and the storage is changed to be wide enough to\n store the parsed integer.\n\n \\returns true if the string does not solely consist of a valid\n non-empty number in the appropriate base.\n\n APInt::fromString is superficially similar but assumes the\n string is well-formed in the given radix."]
    #[link_name = "\u{1}_ZNK4llvm9StringRef12getAsIntegerEjRNS_5APIntE"]
    pub fn llvm_StringRef_getAsInteger(
        this: *const llvm_StringRef,
        Radix: ::std::os::raw::c_uint,
        Result: *mut llvm_APInt,
    ) -> bool;
}
extern "C" {
    #[doc = " Parse the current string as an integer of the specified \\p Radix.  If\n \\p Radix is specified as zero, this does radix autosensing using\n extended C rules: 0 is octal, 0x is hex, 0b is binary.\n\n If the string does not begin with a number of the specified radix,\n this returns true to signify the error. The string is considered\n erroneous if empty.\n The portion of the string representing the discovered numeric value\n is removed from the beginning of the string."]
    #[link_name = "\u{1}_ZN4llvm9StringRef14consumeIntegerEjRNS_5APIntE"]
    pub fn llvm_StringRef_consumeInteger(
        this: *mut llvm_StringRef,
        Radix: ::std::os::raw::c_uint,
        Result: *mut llvm_APInt,
    ) -> bool;
}
extern "C" {
    #[doc = " Parse the current string as an IEEE double-precision floating\n point value.  The string must be a well-formed double.\n\n If \\p AllowInexact is false, the function will fail if the string\n cannot be represented exactly.  Otherwise, the function only fails\n in case of an overflow or underflow, or an invalid floating point\n representation."]
    #[link_name = "\u{1}_ZNK4llvm9StringRef11getAsDoubleERdb"]
    pub fn llvm_StringRef_getAsDouble(
        this: *const llvm_StringRef,
        Result: *mut f64,
        AllowInexact: bool,
    ) -> bool;
}
extern "C" {
    #[doc = " @}\n @name String Operations\n @{"]
    #[link_name = "\u{1}_ZNK4llvm9StringRef5lowerB5cxx11Ev"]
    pub fn llvm_StringRef_lower(this: *const llvm_StringRef) -> std_string;
}
extern "C" {
    #[doc = " Convert the given ASCII string to uppercase."]
    #[link_name = "\u{1}_ZNK4llvm9StringRef5upperB5cxx11Ev"]
    pub fn llvm_StringRef_upper(this: *const llvm_StringRef) -> std_string;
}
extern "C" {
    #[doc = " Split into substrings around the occurrences of a separator string.\n\n Each substring is stored in \\p A. If \\p MaxSplit is >= 0, at most\n \\p MaxSplit splits are done and consequently <= \\p MaxSplit + 1\n elements are added to A.\n If \\p KeepEmpty is false, empty strings are not added to \\p A. They\n still count when considering \\p MaxSplit\n An useful invariant is that\n Separator.join(A) == *this if MaxSplit == -1 and KeepEmpty == true\n\n \\param A - Where to put the substrings.\n \\param Separator - The string to split on.\n \\param MaxSplit - The maximum number of times the string is split.\n \\param KeepEmpty - True if empty substring should be added."]
    #[link_name = "\u{1}_ZNK4llvm9StringRef5splitERNS_15SmallVectorImplIS0_EES0_ib"]
    pub fn llvm_StringRef_split(
        this: *const llvm_StringRef,
        A: *mut llvm_SmallVectorImpl,
        Separator: llvm_StringRef,
        MaxSplit: ::std::os::raw::c_int,
        KeepEmpty: bool,
    );
}
extern "C" {
    #[doc = " Split into substrings around the occurrences of a separator character.\n\n Each substring is stored in \\p A. If \\p MaxSplit is >= 0, at most\n \\p MaxSplit splits are done and consequently <= \\p MaxSplit + 1\n elements are added to A.\n If \\p KeepEmpty is false, empty strings are not added to \\p A. They\n still count when considering \\p MaxSplit\n An useful invariant is that\n Separator.join(A) == *this if MaxSplit == -1 and KeepEmpty == true\n\n \\param A - Where to put the substrings.\n \\param Separator - The string to split on.\n \\param MaxSplit - The maximum number of times the string is split.\n \\param KeepEmpty - True if empty substring should be added."]
    #[link_name = "\u{1}_ZNK4llvm9StringRef5splitERNS_15SmallVectorImplIS0_EEcib"]
    pub fn llvm_StringRef_split1(
        this: *const llvm_StringRef,
        A: *mut llvm_SmallVectorImpl,
        Separator: ::std::os::raw::c_char,
        MaxSplit: ::std::os::raw::c_int,
        KeepEmpty: bool,
    );
}
impl llvm_StringRef {
    #[inline]
    pub unsafe fn compare_insensitive(&self, RHS: llvm_StringRef) -> ::std::os::raw::c_int {
        llvm_StringRef_compare_insensitive(self, RHS)
    }
    #[inline]
    pub unsafe fn compare_numeric(&self, RHS: llvm_StringRef) -> ::std::os::raw::c_int {
        llvm_StringRef_compare_numeric(self, RHS)
    }
    #[inline]
    pub unsafe fn edit_distance(
        &self,
        Other: llvm_StringRef,
        AllowReplacements: bool,
        MaxEditDistance: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_uint {
        llvm_StringRef_edit_distance(self, Other, AllowReplacements, MaxEditDistance)
    }
    #[inline]
    pub unsafe fn edit_distance_insensitive(
        &self,
        Other: llvm_StringRef,
        AllowReplacements: bool,
        MaxEditDistance: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_uint {
        llvm_StringRef_edit_distance_insensitive(self, Other, AllowReplacements, MaxEditDistance)
    }
    #[inline]
    pub unsafe fn starts_with_insensitive(&self, Prefix: llvm_StringRef) -> bool {
        llvm_StringRef_starts_with_insensitive(self, Prefix)
    }
    #[inline]
    pub unsafe fn ends_with_insensitive(&self, Suffix: llvm_StringRef) -> bool {
        llvm_StringRef_ends_with_insensitive(self, Suffix)
    }
    #[inline]
    pub unsafe fn find_insensitive(&self, C: ::std::os::raw::c_char, From: usize) -> usize {
        llvm_StringRef_find_insensitive(self, C, From)
    }
    #[inline]
    pub unsafe fn find(&self, Str: llvm_StringRef, From: usize) -> usize {
        llvm_StringRef_find(self, Str, From)
    }
    #[inline]
    pub unsafe fn find_insensitive1(&self, Str: llvm_StringRef, From: usize) -> usize {
        llvm_StringRef_find_insensitive1(self, Str, From)
    }
    #[inline]
    pub unsafe fn rfind_insensitive(&self, C: ::std::os::raw::c_char, From: usize) -> usize {
        llvm_StringRef_rfind_insensitive(self, C, From)
    }
    #[inline]
    pub unsafe fn rfind(&self, Str: llvm_StringRef) -> usize {
        llvm_StringRef_rfind(self, Str)
    }
    #[inline]
    pub unsafe fn rfind_insensitive1(&self, Str: llvm_StringRef) -> usize {
        llvm_StringRef_rfind_insensitive1(self, Str)
    }
    #[inline]
    pub unsafe fn find_first_of(&self, Chars: llvm_StringRef, From: usize) -> usize {
        llvm_StringRef_find_first_of(self, Chars, From)
    }
    #[inline]
    pub unsafe fn find_first_not_of(&self, C: ::std::os::raw::c_char, From: usize) -> usize {
        llvm_StringRef_find_first_not_of(self, C, From)
    }
    #[inline]
    pub unsafe fn find_first_not_of1(&self, Chars: llvm_StringRef, From: usize) -> usize {
        llvm_StringRef_find_first_not_of1(self, Chars, From)
    }
    #[inline]
    pub unsafe fn find_last_of(&self, Chars: llvm_StringRef, From: usize) -> usize {
        llvm_StringRef_find_last_of(self, Chars, From)
    }
    #[inline]
    pub unsafe fn find_last_not_of(&self, C: ::std::os::raw::c_char, From: usize) -> usize {
        llvm_StringRef_find_last_not_of(self, C, From)
    }
    #[inline]
    pub unsafe fn find_last_not_of1(&self, Chars: llvm_StringRef, From: usize) -> usize {
        llvm_StringRef_find_last_not_of1(self, Chars, From)
    }
    #[inline]
    pub unsafe fn count(&self, Str: llvm_StringRef) -> usize {
        llvm_StringRef_count(self, Str)
    }
    #[inline]
    pub unsafe fn getAsInteger(
        &self,
        Radix: ::std::os::raw::c_uint,
        Result: *mut llvm_APInt,
    ) -> bool {
        llvm_StringRef_getAsInteger(self, Radix, Result)
    }
    #[inline]
    pub unsafe fn consumeInteger(
        &mut self,
        Radix: ::std::os::raw::c_uint,
        Result: *mut llvm_APInt,
    ) -> bool {
        llvm_StringRef_consumeInteger(self, Radix, Result)
    }
    #[inline]
    pub unsafe fn getAsDouble(&self, Result: *mut f64, AllowInexact: bool) -> bool {
        llvm_StringRef_getAsDouble(self, Result, AllowInexact)
    }
    #[inline]
    pub unsafe fn lower(&self) -> std_string {
        llvm_StringRef_lower(self)
    }
    #[inline]
    pub unsafe fn upper(&self) -> std_string {
        llvm_StringRef_upper(self)
    }
    #[inline]
    pub unsafe fn split(
        &self,
        A: *mut llvm_SmallVectorImpl,
        Separator: llvm_StringRef,
        MaxSplit: ::std::os::raw::c_int,
        KeepEmpty: bool,
    ) {
        llvm_StringRef_split(self, A, Separator, MaxSplit, KeepEmpty)
    }
    #[inline]
    pub unsafe fn split1(
        &self,
        A: *mut llvm_SmallVectorImpl,
        Separator: ::std::os::raw::c_char,
        MaxSplit: ::std::os::raw::c_int,
        KeepEmpty: bool,
    ) {
        llvm_StringRef_split1(self, A, Separator, MaxSplit, KeepEmpty)
    }
}
#[doc = " A wrapper around a string literal that serves as a proxy for constructing\n global tables of StringRefs with the length computed at compile time.\n In order to avoid the invocation of a global constructor, StringLiteral\n should *only* be used in a constexpr context, as such:\n\n constexpr StringLiteral S(\"test\");\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_StringLiteral {
    pub _base: llvm_StringRef,
}
#[test]
fn bindgen_test_layout_llvm_StringLiteral() {
    assert_eq!(
        ::std::mem::size_of::<llvm_StringLiteral>(),
        16usize,
        concat!("Size of: ", stringify!(llvm_StringLiteral))
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_StringLiteral>(),
        8usize,
        concat!("Alignment of ", stringify!(llvm_StringLiteral))
    );
}
extern "C" {
    #[doc = " Compute a hash_code for a StringRef."]
    #[link_name = "\u{1}_ZN4llvm10hash_valueENS_9StringRefE"]
    pub fn llvm_hash_value(S: llvm_StringRef) -> llvm_hash_code;
}
#[test]
fn __bindgen_test_layout_llvm_DenseMapInfo_open0_llvm_StringRef_void_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<llvm_DenseMapInfo>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_DenseMapInfo)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_DenseMapInfo>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_DenseMapInfo)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_formatv_object_base {
    _unused: [u8; 0],
}
#[doc = " Twine - A lightweight data structure for efficiently representing the\n concatenation of temporary values as strings.\n\n A Twine is a kind of rope, it represents a concatenated string using a\n binary-tree, where the string is the preorder of the nodes. Since the\n Twine can be efficiently rendered into a buffer when its result is used,\n it avoids the cost of generating temporary values for intermediate string\n results -- particularly in cases when the Twine result is never\n required. By explicitly tracking the type of leaf nodes, we can also avoid\n the creation of temporary strings for conversions operations (such as\n appending an integer to a string).\n\n A Twine is not intended for use directly and should not be stored, its\n implementation relies on the ability to store pointers to temporary stack\n objects which may be deallocated at the end of a statement. Twines should\n only be used as const references in arguments, when an API wishes\n to accept possibly-concatenated strings.\n\n Twines support a special 'null' value, which always concatenates to form\n itself, and renders as an empty string. This can be returned from APIs to\n effectively nullify any concatenations performed on the result.\n\n \\b Implementation\n\n Given the nature of a Twine, it is not possible for the Twine's\n concatenation method to construct interior nodes; the result must be\n represented inside the returned value. For this reason a Twine object\n actually holds two values, the left- and right-hand sides of a\n concatenation. We also have nullary Twine objects, which are effectively\n sentinel values that represent empty strings.\n\n Thus, a Twine can effectively have zero, one, or two children. The \\see\n isNullary(), \\see isUnary(), and \\see isBinary() predicates exist for\n testing the number of children.\n\n We maintain a number of invariants on Twine objects (FIXME: Why):\n  - Nullary twines are always represented with their Kind on the left-hand\n    side, and the Empty kind on the right-hand side.\n  - Unary twines are always represented with the value on the left-hand\n    side, and the Empty kind on the right-hand side.\n  - If a Twine has another Twine as a child, that child should always be\n    binary (otherwise it could have been folded into the parent).\n\n These invariants are check by \\see isValid().\n\n \\b Efficiency Considerations\n\n The Twine is designed to yield efficient and small code for common\n situations. For this reason, the concat() method is inlined so that\n concatenations of leaf nodes can be optimized into stores directly into a\n single stack allocated object.\n\n In practice, not all compilers can be trusted to optimize concat() fully,\n so we provide two additional methods (and accompanying operator+\n overloads) to guarantee that particularly important cases (cstring plus\n StringRef) codegen as desired."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct llvm_Twine {
    #[doc = " LHS - The prefix in the concatenation, which may be uninitialized for\n Null or Empty kinds."]
    pub LHS: llvm_Twine_Child,
    #[doc = " RHS - The suffix in the concatenation, which may be uninitialized for\n Null or Empty kinds."]
    pub RHS: llvm_Twine_Child,
    #[doc = " LHSKind - The NodeKind of the left hand side, \\see getLHSKind()."]
    pub LHSKind: llvm_Twine_NodeKind,
    #[doc = " RHSKind - The NodeKind of the right hand side, \\see getRHSKind()."]
    pub RHSKind: llvm_Twine_NodeKind,
}
#[doc = " An empty string; the result of concatenating anything with it is also\n empty."]
pub const llvm_Twine_NodeKind_NullKind: llvm_Twine_NodeKind = 0;
#[doc = " The empty string."]
pub const llvm_Twine_NodeKind_EmptyKind: llvm_Twine_NodeKind = 1;
#[doc = " A pointer to a Twine instance."]
pub const llvm_Twine_NodeKind_TwineKind: llvm_Twine_NodeKind = 2;
#[doc = " A pointer to a C string instance."]
pub const llvm_Twine_NodeKind_CStringKind: llvm_Twine_NodeKind = 3;
#[doc = " A pointer to an std::string instance."]
pub const llvm_Twine_NodeKind_StdStringKind: llvm_Twine_NodeKind = 4;
#[doc = " A Pointer and Length representation. Used for std::string_view,\n StringRef, and SmallString.  Can't use a StringRef here\n because they are not trivally constructible."]
pub const llvm_Twine_NodeKind_PtrAndLengthKind: llvm_Twine_NodeKind = 5;
#[doc = " A pointer and length representation that's also null-terminated.\n Guaranteed to be constructed from a compile-time string literal."]
pub const llvm_Twine_NodeKind_StringLiteralKind: llvm_Twine_NodeKind = 6;
#[doc = " A pointer to a formatv_object_base instance."]
pub const llvm_Twine_NodeKind_FormatvObjectKind: llvm_Twine_NodeKind = 7;
#[doc = " A char value, to render as a character."]
pub const llvm_Twine_NodeKind_CharKind: llvm_Twine_NodeKind = 8;
#[doc = " An unsigned int value, to render as an unsigned decimal integer."]
pub const llvm_Twine_NodeKind_DecUIKind: llvm_Twine_NodeKind = 9;
#[doc = " An int value, to render as a signed decimal integer."]
pub const llvm_Twine_NodeKind_DecIKind: llvm_Twine_NodeKind = 10;
#[doc = " A pointer to an unsigned long value, to render as an unsigned decimal\n integer."]
pub const llvm_Twine_NodeKind_DecULKind: llvm_Twine_NodeKind = 11;
#[doc = " A pointer to a long value, to render as a signed decimal integer."]
pub const llvm_Twine_NodeKind_DecLKind: llvm_Twine_NodeKind = 12;
#[doc = " A pointer to an unsigned long long value, to render as an unsigned\n decimal integer."]
pub const llvm_Twine_NodeKind_DecULLKind: llvm_Twine_NodeKind = 13;
#[doc = " A pointer to a long long value, to render as a signed decimal integer."]
pub const llvm_Twine_NodeKind_DecLLKind: llvm_Twine_NodeKind = 14;
#[doc = " A pointer to a uint64_t value, to render as an unsigned hexadecimal\n integer."]
pub const llvm_Twine_NodeKind_UHexKind: llvm_Twine_NodeKind = 15;
#[doc = " NodeKind - Represent the type of an argument."]
pub type llvm_Twine_NodeKind = ::std::os::raw::c_uchar;
#[repr(C)]
#[derive(Copy, Clone)]
pub union llvm_Twine_Child {
    pub twine: *const llvm_Twine,
    pub cString: *const ::std::os::raw::c_char,
    pub stdString: *const std_string,
    pub ptrAndLength: llvm_Twine_Child__bindgen_ty_1,
    pub formatvObject: *const llvm_formatv_object_base,
    pub character: ::std::os::raw::c_char,
    pub decUI: ::std::os::raw::c_uint,
    pub decI: ::std::os::raw::c_int,
    pub decUL: *const ::std::os::raw::c_ulong,
    pub decL: *const ::std::os::raw::c_long,
    pub decULL: *const ::std::os::raw::c_ulonglong,
    pub decLL: *const ::std::os::raw::c_longlong,
    pub uHex: *const u64,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_Twine_Child__bindgen_ty_1 {
    pub ptr: *const ::std::os::raw::c_char,
    pub length: usize,
}
#[test]
fn bindgen_test_layout_llvm_Twine_Child__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<llvm_Twine_Child__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<llvm_Twine_Child__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(llvm_Twine_Child__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_Twine_Child__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(llvm_Twine_Child__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ptr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_Twine_Child__bindgen_ty_1),
            "::",
            stringify!(ptr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_Twine_Child__bindgen_ty_1),
            "::",
            stringify!(length)
        )
    );
}
#[test]
fn bindgen_test_layout_llvm_Twine_Child() {
    const UNINIT: ::std::mem::MaybeUninit<llvm_Twine_Child> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<llvm_Twine_Child>(),
        16usize,
        concat!("Size of: ", stringify!(llvm_Twine_Child))
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_Twine_Child>(),
        8usize,
        concat!("Alignment of ", stringify!(llvm_Twine_Child))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).twine) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_Twine_Child),
            "::",
            stringify!(twine)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cString) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_Twine_Child),
            "::",
            stringify!(cString)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).stdString) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_Twine_Child),
            "::",
            stringify!(stdString)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ptrAndLength) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_Twine_Child),
            "::",
            stringify!(ptrAndLength)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).formatvObject) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_Twine_Child),
            "::",
            stringify!(formatvObject)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).character) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_Twine_Child),
            "::",
            stringify!(character)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).decUI) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_Twine_Child),
            "::",
            stringify!(decUI)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).decI) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_Twine_Child),
            "::",
            stringify!(decI)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).decUL) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_Twine_Child),
            "::",
            stringify!(decUL)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).decL) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_Twine_Child),
            "::",
            stringify!(decL)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).decULL) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_Twine_Child),
            "::",
            stringify!(decULL)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).decLL) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_Twine_Child),
            "::",
            stringify!(decLL)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).uHex) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_Twine_Child),
            "::",
            stringify!(uHex)
        )
    );
}
#[test]
fn bindgen_test_layout_llvm_Twine() {
    const UNINIT: ::std::mem::MaybeUninit<llvm_Twine> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<llvm_Twine>(),
        40usize,
        concat!("Size of: ", stringify!(llvm_Twine))
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_Twine>(),
        8usize,
        concat!("Alignment of ", stringify!(llvm_Twine))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LHS) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_Twine),
            "::",
            stringify!(LHS)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).RHS) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_Twine),
            "::",
            stringify!(RHS)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LHSKind) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_Twine),
            "::",
            stringify!(LHSKind)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).RHSKind) as usize - ptr as usize },
        33usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_Twine),
            "::",
            stringify!(RHSKind)
        )
    );
}
extern "C" {
    #[doc = " Return the twine contents as a std::string."]
    #[link_name = "\u{1}_ZNK4llvm5Twine3strB5cxx11Ev"]
    pub fn llvm_Twine_str(this: *const llvm_Twine) -> std_string;
}
extern "C" {
    #[doc = " Append the concatenated string into the given SmallString or SmallVector."]
    #[link_name = "\u{1}_ZNK4llvm5Twine8toVectorERNS_15SmallVectorImplIcEE"]
    pub fn llvm_Twine_toVector(this: *const llvm_Twine, Out: *mut llvm_SmallVectorImpl);
}
extern "C" {
    #[doc = " This returns the twine as a single null terminated StringRef if it\n can be represented as such. Otherwise the twine is written into the\n given SmallVector and a StringRef to the SmallVector's data is returned.\n\n The returned StringRef's size does not include the null terminator."]
    #[link_name = "\u{1}_ZNK4llvm5Twine25toNullTerminatedStringRefERNS_15SmallVectorImplIcEE"]
    pub fn llvm_Twine_toNullTerminatedStringRef(
        this: *const llvm_Twine,
        Out: *mut llvm_SmallVectorImpl,
    ) -> llvm_StringRef;
}
extern "C" {
    #[doc = " Write the concatenated string represented by this twine to the\n stream \\p OS."]
    #[link_name = "\u{1}_ZNK4llvm5Twine5printERNS_11raw_ostreamE"]
    pub fn llvm_Twine_print(this: *const llvm_Twine, OS: *mut llvm_raw_ostream);
}
extern "C" {
    #[doc = " Dump the concatenated string represented by this twine to stderr."]
    #[link_name = "\u{1}_ZNK4llvm5Twine4dumpEv"]
    pub fn llvm_Twine_dump(this: *const llvm_Twine);
}
extern "C" {
    #[doc = " Write the representation of this twine to the stream \\p OS."]
    #[link_name = "\u{1}_ZNK4llvm5Twine9printReprERNS_11raw_ostreamE"]
    pub fn llvm_Twine_printRepr(this: *const llvm_Twine, OS: *mut llvm_raw_ostream);
}
extern "C" {
    #[doc = " Dump the representation of this twine to stderr."]
    #[link_name = "\u{1}_ZNK4llvm5Twine8dumpReprEv"]
    pub fn llvm_Twine_dumpRepr(this: *const llvm_Twine);
}
impl llvm_Twine {
    #[inline]
    pub unsafe fn str_(&self) -> std_string {
        llvm_Twine_str(self)
    }
    #[inline]
    pub unsafe fn toVector(&self, Out: *mut llvm_SmallVectorImpl) {
        llvm_Twine_toVector(self, Out)
    }
    #[inline]
    pub unsafe fn toNullTerminatedStringRef(
        &self,
        Out: *mut llvm_SmallVectorImpl,
    ) -> llvm_StringRef {
        llvm_Twine_toNullTerminatedStringRef(self, Out)
    }
    #[inline]
    pub unsafe fn print(&self, OS: *mut llvm_raw_ostream) {
        llvm_Twine_print(self, OS)
    }
    #[inline]
    pub unsafe fn dump(&self) {
        llvm_Twine_dump(self)
    }
    #[inline]
    pub unsafe fn printRepr(&self, OS: *mut llvm_raw_ostream) {
        llvm_Twine_printRepr(self, OS)
    }
    #[inline]
    pub unsafe fn dumpRepr(&self) {
        llvm_Twine_dumpRepr(self)
    }
}
#[doc = " Some template parameter helpers to optimize for bitwidth, for functions that\n take multiple arguments."]
pub type llvm_enableif_int = std_enable_if_t;
pub type llvm_common_uint = std_common_type_t;
pub type llvm_common_sint = std_common_type_t;
pub const llvm_numbers_e: f64 = 2.718281828459045;
pub const llvm_numbers_egamma: f64 = 0.5772156649015329;
pub const llvm_numbers_ln2: f64 = 0.6931471805599453;
pub const llvm_numbers_ln10: f64 = 2.302585092994046;
pub const llvm_numbers_log2e: f64 = 1.4426950408889634;
pub const llvm_numbers_log10e: f64 = 0.4342944819032518;
pub const llvm_numbers_pi: f64 = 3.141592653589793;
pub const llvm_numbers_inv_pi: f64 = 0.3183098861837907;
pub const llvm_numbers_sqrtpi: f64 = 1.772453850905516;
pub const llvm_numbers_inv_sqrtpi: f64 = 0.5641895835477563;
pub const llvm_numbers_sqrt2: f64 = 1.4142135623730951;
pub const llvm_numbers_inv_sqrt2: f64 = 0.7071067811865476;
pub const llvm_numbers_sqrt3: f64 = 1.7320508075688772;
pub const llvm_numbers_inv_sqrt3: f64 = 0.5773502691896257;
pub const llvm_numbers_phi: f64 = 1.618033988749895;
pub const llvm_numbers_ef: f32 = 2.7182817459106445;
pub const llvm_numbers_egammaf: f32 = 0.5772156715393066;
pub const llvm_numbers_ln2f: f32 = 0.6931471824645996;
pub const llvm_numbers_ln10f: f32 = 2.3025851249694824;
pub const llvm_numbers_log2ef: f32 = 1.4426950216293335;
pub const llvm_numbers_log10ef: f32 = 0.4342944920063019;
pub const llvm_numbers_pif: f32 = 3.1415927410125732;
pub const llvm_numbers_inv_pif: f32 = 0.31830987334251404;
pub const llvm_numbers_sqrtpif: f32 = 1.7724539041519165;
pub const llvm_numbers_inv_sqrtpif: f32 = 0.564189612865448;
pub const llvm_numbers_sqrt2f: f32 = 1.4142135381698608;
pub const llvm_numbers_inv_sqrt2f: f32 = 0.7071067690849304;
pub const llvm_numbers_sqrt3f: f32 = 1.7320507764816284;
pub const llvm_numbers_inv_sqrt3f: f32 = 0.5773502588272095;
pub const llvm_numbers_phif: f32 = 1.6180340051651;
extern "C" {
    #[doc = " Macro compressed bit reversal table for 256 bits.\n\n http://graphics.stanford.edu/~seander/bithacks.html#BitReverseTable"]
    #[link_name = "\u{1}_ZN4llvmL18BitReverseTable256E"]
    pub static llvm_BitReverseTable256: [::std::os::raw::c_uchar; 256usize];
}
extern "C" {
    #[doc = " Use this rather than HUGE_VALF; the latter causes warnings on MSVC."]
    #[link_name = "\u{1}_ZN4llvm9huge_valfE"]
    pub static llvm_huge_valf: f32;
}
pub type llvm_stack_float_t = f32;
#[doc = " This struct is a compact representation of a valid (non-zero power of two)\n alignment.\n It is suitable for use as static global constants."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_Align {
    pub ShiftValue: u8,
}
#[doc = " A trivial type to allow construction of constexpr Align.\n This is currently needed to workaround a bug in GCC 5.3 which prevents\n definition of constexpr assign operators.\n https://stackoverflow.com/questions/46756288/explicitly-defaulted-function-cannot-be-declared-as-constexpr-because-the-implic\n FIXME: Remove this, make all assign operators constexpr and introduce user\n defined literals when we don't have to support GCC 5.3 anymore.\n https://llvm.org/docs/GettingStarted.html#getting-a-modern-host-c-toolchain"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_Align_LogValue {
    pub Log: u8,
}
#[test]
fn bindgen_test_layout_llvm_Align_LogValue() {
    const UNINIT: ::std::mem::MaybeUninit<llvm_Align_LogValue> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<llvm_Align_LogValue>(),
        1usize,
        concat!("Size of: ", stringify!(llvm_Align_LogValue))
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_Align_LogValue>(),
        1usize,
        concat!("Alignment of ", stringify!(llvm_Align_LogValue))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Log) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_Align_LogValue),
            "::",
            stringify!(Log)
        )
    );
}
#[test]
fn bindgen_test_layout_llvm_Align() {
    const UNINIT: ::std::mem::MaybeUninit<llvm_Align> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<llvm_Align>(),
        1usize,
        concat!("Size of: ", stringify!(llvm_Align))
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_Align>(),
        1usize,
        concat!("Alignment of ", stringify!(llvm_Align))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ShiftValue) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_Align),
            "::",
            stringify!(ShiftValue)
        )
    );
}
#[doc = " This struct is a compact representation of a valid (power of two) or\n undefined (0) alignment."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_MaybeAlign {
    pub _address: u8,
}
pub type llvm_MaybeAlign_UP = std_optional;
#[test]
fn bindgen_test_layout_llvm_MaybeAlign() {
    assert_eq!(
        ::std::mem::size_of::<llvm_MaybeAlign>(),
        2usize,
        concat!("Size of: ", stringify!(llvm_MaybeAlign))
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_MaybeAlign>(),
        1usize,
        concat!("Alignment of ", stringify!(llvm_MaybeAlign))
    );
}
#[doc = " Define a template that can be specialized by smart pointers to reflect the\n fact that they are automatically dereferenced, and are not involved with the\n template selection process...  the default implementation is a noop."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_simplify_type {
    pub _address: u8,
}
pub type llvm_simplify_type_SimpleType<From> = From;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_isa_impl {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_isa_impl_cl {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_isa_impl_wrap {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_cast_retty_impl {
    pub _address: u8,
}
pub type llvm_cast_retty_impl_ret_type<To> = *mut To;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_cast_retty_wrap {
    pub _address: u8,
}
pub type llvm_cast_retty_wrap_ret_type = llvm_cast_retty;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_cast_retty {
    pub _address: u8,
}
pub type llvm_cast_retty_ret_type = llvm_cast_retty_wrap;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_cast_convert_val {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_is_simple_type {
    pub _address: u8,
}
#[doc = " This struct provides a way to check if a given cast is possible. It provides\n a static function called isPossible that is used to check if a cast can be\n performed. It should be overridden like this:\n\n template<> struct CastIsPossible<foo, bar> {\n   static inline bool isPossible(const bar &b) {\n     return bar.isFoo();\n   }\n };"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_CastIsPossible {
    pub _address: u8,
}
#[doc = " This cast trait just provides castFailed for the specified `To` type to make\n CastInfo specializations more declarative. In order to use this, the target\n result type must be `To` and `To` must be constructible from `nullptr`."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_NullableValueCastFailed {
    pub _address: u8,
}
#[doc = " This cast trait just provides the default implementation of doCastIfPossible\n to make CastInfo specializations more declarative. The `Derived` template\n parameter *must* be provided for forwarding castFailed and doCast."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_DefaultDoCastIfPossible {
    pub _address: u8,
}
#[doc = " This cast trait provides casting for the specific case of casting to a\n value-typed object from a pointer-typed object. Note that `To` must be\n nullable/constructible from a pointer to `From` to use this cast."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_ValueFromPointerCast {
    pub _address: u8,
}
#[doc = " This cast trait provides std::unique_ptr casting. It has the semantics of\n moving the contents of the input unique_ptr into the output unique_ptr\n during the cast. It's also a good example of how to implement a move-only\n cast."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_UniquePtrCast {
    pub _address: u8,
}
pub type llvm_UniquePtrCast_Self = llvm_detail_SelfType;
pub type llvm_UniquePtrCast_CastResultType = std_unique_ptr;
#[doc = " This cast trait provides std::optional<T> casting. This means that if you\n have a value type, you can cast it to another value type and have dyn_cast\n return an std::optional<T>."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_OptionalValueCast {
    pub _address: u8,
}
#[doc = " Provides a cast trait that strips `const` from types to make it easier to\n implement a const-version of a non-const cast. It just removes boilerplate\n and reduces the amount of code you as the user need to implement. You can\n use it like this:\n\n template<> struct CastInfo<foo, bar> {\n   ...verbose implementation...\n };\n\n template<> struct CastInfo<foo, const bar> : public\n        ConstStrippingForwardingCast<foo, const bar, CastInfo<foo, bar>> {};\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_ConstStrippingForwardingCast {
    pub _address: u8,
}
pub type llvm_ConstStrippingForwardingCast_DecayedFrom = std_remove_cv_t;
pub type llvm_ConstStrippingForwardingCast_NonConstFrom = std_conditional_t;
#[doc = " Provides a cast trait that uses a defined pointer to pointer cast as a base\n for reference-to-reference casts. Note that it does not provide castFailed\n and doCastIfPossible because a pointer-to-pointer cast would likely just\n return `nullptr` which could cause nullptr dereference. You can use it like\n this:\n\n   template <> struct CastInfo<foo, bar *> { ... verbose implementation... };\n\n   template <>\n   struct CastInfo<foo, bar>\n       : public ForwardToPointerCast<foo, bar, CastInfo<foo, bar *>> {};\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_ForwardToPointerCast {
    pub _address: u8,
}
#[doc = " This struct provides a method for customizing the way a cast is performed.\n It inherits from CastIsPossible, to support the case of declaring many\n CastIsPossible specializations without having to specialize the full\n CastInfo.\n\n In order to specialize different behaviors, specify different functions in\n your CastInfo specialization.\n For isa<> customization, provide:\n\n   `static bool isPossible(const From &f)`\n\n For cast<> customization, provide:\n\n  `static To doCast(const From &f)`\n\n For dyn_cast<> and the *_if_present<> variants' customization, provide:\n\n  `static To castFailed()` and `static To doCastIfPossible(const From &f)`\n\n Your specialization might look something like this:\n\n  template<> struct CastInfo<foo, bar> : public CastIsPossible<foo, bar> {\n    static inline foo doCast(const bar &b) {\n      return foo(const_cast<bar &>(b));\n    }\n    static inline foo castFailed() { return foo(); }\n    static inline foo doCastIfPossible(const bar &b) {\n      if (!CastInfo<foo, bar>::isPossible(b))\n        return castFailed();\n      return doCast(b);\n    }\n  };"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_CastInfo {
    pub _address: u8,
}
#[doc = " This struct provides a method for customizing the way a cast is performed.\n It inherits from CastIsPossible, to support the case of declaring many\n CastIsPossible specializations without having to specialize the full\n CastInfo.\n\n In order to specialize different behaviors, specify different functions in\n your CastInfo specialization.\n For isa<> customization, provide:\n\n   `static bool isPossible(const From &f)`\n\n For cast<> customization, provide:\n\n  `static To doCast(const From &f)`\n\n For dyn_cast<> and the *_if_present<> variants' customization, provide:\n\n  `static To castFailed()` and `static To doCastIfPossible(const From &f)`\n\n Your specialization might look something like this:\n\n  template<> struct CastInfo<foo, bar> : public CastIsPossible<foo, bar> {\n    static inline foo doCast(const bar &b) {\n      return foo(const_cast<bar &>(b));\n    }\n    static inline foo castFailed() { return foo(); }\n    static inline foo doCastIfPossible(const bar &b) {\n      if (!CastInfo<foo, bar>::isPossible(b))\n        return castFailed();\n      return doCast(b);\n    }\n  };"]
pub type llvm_CastInfo_Self = llvm_CastInfo;
pub type llvm_CastInfo_CastReturnType = llvm_cast_retty;
#[doc = " ValueIsPresent provides a way to check if a value is, well, present. For\n pointers, this is the equivalent of checking against nullptr, for Optionals\n this is the equivalent of checking hasValue(). It also provides a method for\n unwrapping a value (think calling .value() on an optional)."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_ValueIsPresent {
    pub _address: u8,
}
pub type llvm_ValueIsPresent_UnwrappedType<T> = T;
#[doc = " A suitably aligned and sized character array member which can hold elements\n of any type.\n\n This template is equivalent to std::aligned_union_t<1, ...>, but we cannot\n use it due to a bug in the MSVC x86 compiler:\n https://github.com/microsoft/STL/issues/1533\n Using `alignas` here works around the bug."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_AlignedCharArrayUnion {
    pub buffer: *mut ::std::os::raw::c_char,
}
pub type llvm_AlignedCharArrayUnion_AlignedUnion = std_aligned_union_t;
#[doc = " Represents either an error or a value T.\n\n ErrorOr<T> is a pointer-like class that represents the result of an\n operation. The result is either an error, or a value of type T. This is\n designed to emulate the usage of returning a pointer where nullptr indicates\n failure. However instead of just knowing that the operation failed, we also\n have an error_code and optional user data that describes why it failed.\n\n It is used like the following.\n \\code\n   ErrorOr<Buffer> getBuffer();\n\n   auto buffer = getBuffer();\n   if (error_code ec = buffer.getError())\n     return ec;\n   buffer->write(\"adena\");\n \\endcode\n\n\n Implicit conversion to bool returns true if there is a usable value. The\n unary * and -> operators provide pointer like access to the value. Accessing\n the value when there is an error has undefined behavior.\n\n When T is a reference type the behavior is slightly different. The reference\n is held in a std::reference_wrapper<std::remove_reference<T>::type>, and\n there is special handling to make operator -> work as if T was not a\n reference.\n\n T cannot be a rvalue reference."]
#[repr(C)]
pub struct llvm_ErrorOr {
    pub __bindgen_anon_1: llvm_ErrorOr__bindgen_ty_1,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
pub type llvm_ErrorOr_wrap = std_reference_wrapper<_Tp>;
pub type llvm_ErrorOr_storage_type = std_conditional_t;
pub type llvm_ErrorOr_reference = *mut std_remove_reference_t;
pub type llvm_ErrorOr_const_reference = *const std_remove_reference_t;
pub type llvm_ErrorOr_pointer = *mut std_remove_reference_t;
pub type llvm_ErrorOr_const_pointer = *const std_remove_reference_t;
#[repr(C)]
pub union llvm_ErrorOr__bindgen_ty_1 {
    pub TStorage: llvm_AlignedCharArrayUnion,
    pub ErrorStorage: llvm_AlignedCharArrayUnion,
}
impl llvm_ErrorOr {
    #[inline]
    pub fn HasError(&self) -> bool {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_HasError(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(HasError: bool) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let HasError: u8 = unsafe { ::std::mem::transmute(HasError) };
            HasError as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_MemoryBufferRef {
    pub Buffer: llvm_StringRef,
    pub Identifier: llvm_StringRef,
}
#[test]
fn bindgen_test_layout_llvm_MemoryBufferRef() {
    const UNINIT: ::std::mem::MaybeUninit<llvm_MemoryBufferRef> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<llvm_MemoryBufferRef>(),
        32usize,
        concat!("Size of: ", stringify!(llvm_MemoryBufferRef))
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_MemoryBufferRef>(),
        8usize,
        concat!("Alignment of ", stringify!(llvm_MemoryBufferRef))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Buffer) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_MemoryBufferRef),
            "::",
            stringify!(Buffer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Identifier) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_MemoryBufferRef),
            "::",
            stringify!(Identifier)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm15MemoryBufferRefC1ERKNS_12MemoryBufferE"]
    pub fn llvm_MemoryBufferRef_MemoryBufferRef(
        this: *mut llvm_MemoryBufferRef,
        Buffer: *const llvm_MemoryBuffer,
    );
}
impl llvm_MemoryBufferRef {
    #[inline]
    pub unsafe fn new(Buffer: *const llvm_MemoryBuffer) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        llvm_MemoryBufferRef_MemoryBufferRef(__bindgen_tmp.as_mut_ptr(), Buffer);
        __bindgen_tmp.assume_init()
    }
}
#[repr(C)]
pub struct llvm_MemoryBuffer__bindgen_vtable(::std::os::raw::c_void);
#[doc = " This interface provides simple read-only access to a block of memory, and\n provides simple methods for reading files and standard input into a memory\n buffer.  In addition to basic access to the characters in the file, this\n interface guarantees you can read one character past the end of the file,\n and that this character will read as '\\0'.\n\n The '\\0' guarantee is needed to support an optimization -- it's intended to\n be more efficient for clients which are reading all the data to stop\n reading when they encounter a '\\0' than to continually check the file\n position to see if it has reached the end of the file."]
#[repr(C)]
#[derive(Debug)]
pub struct llvm_MemoryBuffer {
    pub vtable_: *const llvm_MemoryBuffer__bindgen_vtable,
    pub BufferStart: *const ::std::os::raw::c_char,
    pub BufferEnd: *const ::std::os::raw::c_char,
}
pub const llvm_MemoryBuffer_BufferKind_MemoryBuffer_Malloc: llvm_MemoryBuffer_BufferKind = 0;
pub const llvm_MemoryBuffer_BufferKind_MemoryBuffer_MMap: llvm_MemoryBuffer_BufferKind = 1;
#[doc = " The kind of memory backing used to support the MemoryBuffer."]
pub type llvm_MemoryBuffer_BufferKind = ::std::os::raw::c_uint;
#[test]
fn bindgen_test_layout_llvm_MemoryBuffer() {
    const UNINIT: ::std::mem::MaybeUninit<llvm_MemoryBuffer> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<llvm_MemoryBuffer>(),
        24usize,
        concat!("Size of: ", stringify!(llvm_MemoryBuffer))
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_MemoryBuffer>(),
        8usize,
        concat!("Alignment of ", stringify!(llvm_MemoryBuffer))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).BufferStart) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_MemoryBuffer),
            "::",
            stringify!(BufferStart)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).BufferEnd) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_MemoryBuffer),
            "::",
            stringify!(BufferEnd)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm12MemoryBuffer4initEPKcS2_b"]
    pub fn llvm_MemoryBuffer_init(
        this: *mut llvm_MemoryBuffer,
        BufStart: *const ::std::os::raw::c_char,
        BufEnd: *const ::std::os::raw::c_char,
        RequiresNullTerminator: bool,
    );
}
extern "C" {
    #[doc = " Open the specified file as a MemoryBuffer, returning a new MemoryBuffer\n if successful, otherwise returning null.\n\n \\param IsText Set to true to indicate that the file should be read in\n text mode.\n\n \\param IsVolatile Set to true to indicate that the contents of the file\n can change outside the user's control, e.g. when libclang tries to parse\n while the user is editing/updating the file or if the file is on an NFS.\n\n \\param Alignment Set to indicate that the buffer should be aligned to at\n least the specified alignment."]
    #[link_name = "\u{1}_ZN4llvm12MemoryBuffer7getFileERKNS_5TwineEbbbSt8optionalINS_5AlignEE"]
    pub fn llvm_MemoryBuffer_getFile(
        Filename: *const llvm_Twine,
        IsText: bool,
        RequiresNullTerminator: bool,
        IsVolatile: bool,
        Alignment: std_optional,
    ) -> llvm_ErrorOr;
}
extern "C" {
    #[doc = " Read all of the specified file into a MemoryBuffer as a stream\n (i.e. until EOF reached). This is useful for special files that\n look like a regular file but have 0 size (e.g. /proc/cpuinfo on Linux)."]
    #[link_name = "\u{1}_ZN4llvm12MemoryBuffer15getFileAsStreamERKNS_5TwineE"]
    pub fn llvm_MemoryBuffer_getFileAsStream(Filename: *const llvm_Twine) -> llvm_ErrorOr;
}
extern "C" {
    #[doc = " Given an already-open file descriptor, map some slice of it into a\n MemoryBuffer. The slice is specified by an \\p Offset and \\p MapSize.\n Since this is in the middle of a file, the buffer is not null terminated."]
    #[link_name = "\u{1}_ZN4llvm12MemoryBuffer16getOpenFileSliceEiRKNS_5TwineEmlbSt8optionalINS_5AlignEE"]
    pub fn llvm_MemoryBuffer_getOpenFileSlice(
        FD: llvm_sys_fs_file_t,
        Filename: *const llvm_Twine,
        MapSize: u64,
        Offset: i64,
        IsVolatile: bool,
        Alignment: std_optional,
    ) -> llvm_ErrorOr;
}
extern "C" {
    #[doc = " Given an already-open file descriptor, read the file and return a\n MemoryBuffer.\n\n \\param IsVolatile Set to true to indicate that the contents of the file\n can change outside the user's control, e.g. when libclang tries to parse\n while the user is editing/updating the file or if the file is on an NFS.\n\n \\param Alignment Set to indicate that the buffer should be aligned to at\n least the specified alignment."]
    #[link_name = "\u{1}_ZN4llvm12MemoryBuffer11getOpenFileEiRKNS_5TwineEmbbSt8optionalINS_5AlignEE"]
    pub fn llvm_MemoryBuffer_getOpenFile(
        FD: llvm_sys_fs_file_t,
        Filename: *const llvm_Twine,
        FileSize: u64,
        RequiresNullTerminator: bool,
        IsVolatile: bool,
        Alignment: std_optional,
    ) -> llvm_ErrorOr;
}
extern "C" {
    #[doc = " Open the specified memory range as a MemoryBuffer. Note that InputData\n must be null terminated if RequiresNullTerminator is true."]
    #[link_name = "\u{1}_ZN4llvm12MemoryBuffer12getMemBufferENS_9StringRefES1_b"]
    pub fn llvm_MemoryBuffer_getMemBuffer(
        InputData: llvm_StringRef,
        BufferName: llvm_StringRef,
        RequiresNullTerminator: bool,
    ) -> std_unique_ptr;
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm12MemoryBuffer12getMemBufferENS_15MemoryBufferRefEb"]
    pub fn llvm_MemoryBuffer_getMemBuffer1(
        Ref: llvm_MemoryBufferRef,
        RequiresNullTerminator: bool,
    ) -> std_unique_ptr;
}
extern "C" {
    #[doc = " Open the specified memory range as a MemoryBuffer, copying the contents\n and taking ownership of it. InputData does not have to be null terminated."]
    #[link_name = "\u{1}_ZN4llvm12MemoryBuffer16getMemBufferCopyENS_9StringRefERKNS_5TwineE"]
    pub fn llvm_MemoryBuffer_getMemBufferCopy(
        InputData: llvm_StringRef,
        BufferName: *const llvm_Twine,
    ) -> std_unique_ptr;
}
extern "C" {
    #[doc = " Read all of stdin into a file buffer, and return it."]
    #[link_name = "\u{1}_ZN4llvm12MemoryBuffer8getSTDINEv"]
    pub fn llvm_MemoryBuffer_getSTDIN() -> llvm_ErrorOr;
}
extern "C" {
    #[doc = " Open the specified file as a MemoryBuffer, or open stdin if the Filename\n is \"-\"."]
    #[link_name = "\u{1}_ZN4llvm12MemoryBuffer14getFileOrSTDINERKNS_5TwineEbbSt8optionalINS_5AlignEE"]
    pub fn llvm_MemoryBuffer_getFileOrSTDIN(
        Filename: *const llvm_Twine,
        IsText: bool,
        RequiresNullTerminator: bool,
        Alignment: std_optional,
    ) -> llvm_ErrorOr;
}
extern "C" {
    #[doc = " Map a subrange of the specified file as a MemoryBuffer."]
    #[link_name = "\u{1}_ZN4llvm12MemoryBuffer12getFileSliceERKNS_5TwineEmmbSt8optionalINS_5AlignEE"]
    pub fn llvm_MemoryBuffer_getFileSlice(
        Filename: *const llvm_Twine,
        MapSize: u64,
        Offset: u64,
        IsVolatile: bool,
        Alignment: std_optional,
    ) -> llvm_ErrorOr;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4llvm12MemoryBuffer15getMemBufferRefEv"]
    pub fn llvm_MemoryBuffer_getMemBufferRef(
        this: *const llvm_MemoryBuffer,
    ) -> llvm_MemoryBufferRef;
}
impl llvm_MemoryBuffer {
    #[inline]
    pub unsafe fn init(
        &mut self,
        BufStart: *const ::std::os::raw::c_char,
        BufEnd: *const ::std::os::raw::c_char,
        RequiresNullTerminator: bool,
    ) {
        llvm_MemoryBuffer_init(self, BufStart, BufEnd, RequiresNullTerminator)
    }
    #[inline]
    pub unsafe fn getFile(
        Filename: *const llvm_Twine,
        IsText: bool,
        RequiresNullTerminator: bool,
        IsVolatile: bool,
        Alignment: std_optional,
    ) -> llvm_ErrorOr {
        llvm_MemoryBuffer_getFile(
            Filename,
            IsText,
            RequiresNullTerminator,
            IsVolatile,
            Alignment,
        )
    }
    #[inline]
    pub unsafe fn getFileAsStream(Filename: *const llvm_Twine) -> llvm_ErrorOr {
        llvm_MemoryBuffer_getFileAsStream(Filename)
    }
    #[inline]
    pub unsafe fn getOpenFileSlice(
        FD: llvm_sys_fs_file_t,
        Filename: *const llvm_Twine,
        MapSize: u64,
        Offset: i64,
        IsVolatile: bool,
        Alignment: std_optional,
    ) -> llvm_ErrorOr {
        llvm_MemoryBuffer_getOpenFileSlice(FD, Filename, MapSize, Offset, IsVolatile, Alignment)
    }
    #[inline]
    pub unsafe fn getOpenFile(
        FD: llvm_sys_fs_file_t,
        Filename: *const llvm_Twine,
        FileSize: u64,
        RequiresNullTerminator: bool,
        IsVolatile: bool,
        Alignment: std_optional,
    ) -> llvm_ErrorOr {
        llvm_MemoryBuffer_getOpenFile(
            FD,
            Filename,
            FileSize,
            RequiresNullTerminator,
            IsVolatile,
            Alignment,
        )
    }
    #[inline]
    pub unsafe fn getMemBuffer(
        InputData: llvm_StringRef,
        BufferName: llvm_StringRef,
        RequiresNullTerminator: bool,
    ) -> std_unique_ptr {
        llvm_MemoryBuffer_getMemBuffer(InputData, BufferName, RequiresNullTerminator)
    }
    #[inline]
    pub unsafe fn getMemBuffer1(
        Ref: llvm_MemoryBufferRef,
        RequiresNullTerminator: bool,
    ) -> std_unique_ptr {
        llvm_MemoryBuffer_getMemBuffer1(Ref, RequiresNullTerminator)
    }
    #[inline]
    pub unsafe fn getMemBufferCopy(
        InputData: llvm_StringRef,
        BufferName: *const llvm_Twine,
    ) -> std_unique_ptr {
        llvm_MemoryBuffer_getMemBufferCopy(InputData, BufferName)
    }
    #[inline]
    pub unsafe fn getSTDIN() -> llvm_ErrorOr {
        llvm_MemoryBuffer_getSTDIN()
    }
    #[inline]
    pub unsafe fn getFileOrSTDIN(
        Filename: *const llvm_Twine,
        IsText: bool,
        RequiresNullTerminator: bool,
        Alignment: std_optional,
    ) -> llvm_ErrorOr {
        llvm_MemoryBuffer_getFileOrSTDIN(Filename, IsText, RequiresNullTerminator, Alignment)
    }
    #[inline]
    pub unsafe fn getFileSlice(
        Filename: *const llvm_Twine,
        MapSize: u64,
        Offset: u64,
        IsVolatile: bool,
        Alignment: std_optional,
    ) -> llvm_ErrorOr {
        llvm_MemoryBuffer_getFileSlice(Filename, MapSize, Offset, IsVolatile, Alignment)
    }
    #[inline]
    pub unsafe fn getMemBufferRef(&self) -> llvm_MemoryBufferRef {
        llvm_MemoryBuffer_getMemBufferRef(self)
    }
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm12MemoryBufferD1Ev"]
    pub fn llvm_MemoryBuffer_MemoryBuffer_destructor(this: *mut llvm_MemoryBuffer);
}
#[doc = " This class is an extension of MemoryBuffer, which allows copy-on-write\n access to the underlying contents.  It only supports creation methods that\n are guaranteed to produce a writable buffer.  For example, mapping a file\n read-only is not supported."]
#[repr(C)]
#[derive(Debug)]
pub struct llvm_WritableMemoryBuffer {
    pub _base: llvm_MemoryBuffer,
}
#[test]
fn bindgen_test_layout_llvm_WritableMemoryBuffer() {
    assert_eq!(
        ::std::mem::size_of::<llvm_WritableMemoryBuffer>(),
        24usize,
        concat!("Size of: ", stringify!(llvm_WritableMemoryBuffer))
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_WritableMemoryBuffer>(),
        8usize,
        concat!("Alignment of ", stringify!(llvm_WritableMemoryBuffer))
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm20WritableMemoryBuffer7getFileERKNS_5TwineEbSt8optionalINS_5AlignEE"]
    pub fn llvm_WritableMemoryBuffer_getFile(
        Filename: *const llvm_Twine,
        IsVolatile: bool,
        Alignment: std_optional,
    ) -> llvm_ErrorOr;
}
extern "C" {
    #[doc = " Map a subrange of the specified file as a WritableMemoryBuffer."]
    #[link_name = "\u{1}_ZN4llvm20WritableMemoryBuffer12getFileSliceERKNS_5TwineEmmbSt8optionalINS_5AlignEE"]
    pub fn llvm_WritableMemoryBuffer_getFileSlice(
        Filename: *const llvm_Twine,
        MapSize: u64,
        Offset: u64,
        IsVolatile: bool,
        Alignment: std_optional,
    ) -> llvm_ErrorOr;
}
extern "C" {
    #[doc = " Allocate a new MemoryBuffer of the specified size that is not initialized.\n Note that the caller should initialize the memory allocated by this\n method. The memory is owned by the MemoryBuffer object.\n\n \\param Alignment Set to indicate that the buffer should be aligned to at\n least the specified alignment."]
    #[link_name = "\u{1}_ZN4llvm20WritableMemoryBuffer21getNewUninitMemBufferEmRKNS_5TwineESt8optionalINS_5AlignEE"]
    pub fn llvm_WritableMemoryBuffer_getNewUninitMemBuffer(
        Size: usize,
        BufferName: *const llvm_Twine,
        Alignment: std_optional,
    ) -> std_unique_ptr;
}
extern "C" {
    #[doc = " Allocate a new zero-initialized MemoryBuffer of the specified size. Note\n that the caller need not initialize the memory allocated by this method.\n The memory is owned by the MemoryBuffer object."]
    #[link_name = "\u{1}_ZN4llvm20WritableMemoryBuffer15getNewMemBufferEmRKNS_5TwineE"]
    pub fn llvm_WritableMemoryBuffer_getNewMemBuffer(
        Size: usize,
        BufferName: *const llvm_Twine,
    ) -> std_unique_ptr;
}
impl llvm_WritableMemoryBuffer {
    #[inline]
    pub unsafe fn getFile(
        Filename: *const llvm_Twine,
        IsVolatile: bool,
        Alignment: std_optional,
    ) -> llvm_ErrorOr {
        llvm_WritableMemoryBuffer_getFile(Filename, IsVolatile, Alignment)
    }
    #[inline]
    pub unsafe fn getFileSlice(
        Filename: *const llvm_Twine,
        MapSize: u64,
        Offset: u64,
        IsVolatile: bool,
        Alignment: std_optional,
    ) -> llvm_ErrorOr {
        llvm_WritableMemoryBuffer_getFileSlice(Filename, MapSize, Offset, IsVolatile, Alignment)
    }
    #[inline]
    pub unsafe fn getNewUninitMemBuffer(
        Size: usize,
        BufferName: *const llvm_Twine,
        Alignment: std_optional,
    ) -> std_unique_ptr {
        llvm_WritableMemoryBuffer_getNewUninitMemBuffer(Size, BufferName, Alignment)
    }
    #[inline]
    pub unsafe fn getNewMemBuffer(Size: usize, BufferName: *const llvm_Twine) -> std_unique_ptr {
        llvm_WritableMemoryBuffer_getNewMemBuffer(Size, BufferName)
    }
}
#[doc = " This class is an extension of MemoryBuffer, which allows write access to\n the underlying contents and committing those changes to the original source.\n It only supports creation methods that are guaranteed to produce a writable\n buffer.  For example, mapping a file read-only is not supported."]
#[repr(C)]
#[derive(Debug)]
pub struct llvm_WriteThroughMemoryBuffer {
    pub _base: llvm_MemoryBuffer,
}
#[test]
fn bindgen_test_layout_llvm_WriteThroughMemoryBuffer() {
    assert_eq!(
        ::std::mem::size_of::<llvm_WriteThroughMemoryBuffer>(),
        24usize,
        concat!("Size of: ", stringify!(llvm_WriteThroughMemoryBuffer))
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_WriteThroughMemoryBuffer>(),
        8usize,
        concat!("Alignment of ", stringify!(llvm_WriteThroughMemoryBuffer))
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm24WriteThroughMemoryBuffer7getFileERKNS_5TwineEl"]
    pub fn llvm_WriteThroughMemoryBuffer_getFile(
        Filename: *const llvm_Twine,
        FileSize: i64,
    ) -> llvm_ErrorOr;
}
extern "C" {
    #[doc = " Map a subrange of the specified file as a ReadWriteMemoryBuffer."]
    #[link_name = "\u{1}_ZN4llvm24WriteThroughMemoryBuffer12getFileSliceERKNS_5TwineEmm"]
    pub fn llvm_WriteThroughMemoryBuffer_getFileSlice(
        Filename: *const llvm_Twine,
        MapSize: u64,
        Offset: u64,
    ) -> llvm_ErrorOr;
}
impl llvm_WriteThroughMemoryBuffer {
    #[inline]
    pub unsafe fn getFile(Filename: *const llvm_Twine, FileSize: i64) -> llvm_ErrorOr {
        llvm_WriteThroughMemoryBuffer_getFile(Filename, FileSize)
    }
    #[inline]
    pub unsafe fn getFileSlice(
        Filename: *const llvm_Twine,
        MapSize: u64,
        Offset: u64,
    ) -> llvm_ErrorOr {
        llvm_WriteThroughMemoryBuffer_getFileSlice(Filename, MapSize, Offset)
    }
}
#[doc = " Represents a location in source code."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_SMLoc {
    pub Ptr: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_llvm_SMLoc() {
    const UNINIT: ::std::mem::MaybeUninit<llvm_SMLoc> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<llvm_SMLoc>(),
        8usize,
        concat!("Size of: ", stringify!(llvm_SMLoc))
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_SMLoc>(),
        8usize,
        concat!("Alignment of ", stringify!(llvm_SMLoc))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Ptr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_SMLoc),
            "::",
            stringify!(Ptr)
        )
    );
}
#[doc = " Represents a range in source code.\n\n SMRange is implemented using a half-open range, as is the convention in C++.\n In the string \"abc\", the range [1,3) represents the substring \"bc\", and the\n range [2,2) represents an empty range between the characters \"b\" and \"c\"."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_SMRange {
    pub Start: llvm_SMLoc,
    pub End: llvm_SMLoc,
}
#[test]
fn bindgen_test_layout_llvm_SMRange() {
    const UNINIT: ::std::mem::MaybeUninit<llvm_SMRange> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<llvm_SMRange>(),
        16usize,
        concat!("Size of: ", stringify!(llvm_SMRange))
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_SMRange>(),
        8usize,
        concat!("Alignment of ", stringify!(llvm_SMRange))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Start) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_SMRange),
            "::",
            stringify!(Start)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).End) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_SMRange),
            "::",
            stringify!(End)
        )
    );
}
#[doc = " This owns the files read by a parser, handles include stacks,\n and handles diagnostic wrangling."]
#[repr(C)]
pub struct llvm_SourceMgr {
    #[doc = " This is all of the buffers that we are reading from."]
    pub Buffers: std_vector,
    pub IncludeDirectories: std_vector,
    pub DiagHandler: llvm_SourceMgr_DiagHandlerTy,
    pub DiagContext: *mut ::std::os::raw::c_void,
}
pub const llvm_SourceMgr_DiagKind_DK_Error: llvm_SourceMgr_DiagKind = 0;
pub const llvm_SourceMgr_DiagKind_DK_Warning: llvm_SourceMgr_DiagKind = 1;
pub const llvm_SourceMgr_DiagKind_DK_Remark: llvm_SourceMgr_DiagKind = 2;
pub const llvm_SourceMgr_DiagKind_DK_Note: llvm_SourceMgr_DiagKind = 3;
pub type llvm_SourceMgr_DiagKind = ::std::os::raw::c_uint;
#[doc = " Clients that want to handle their own diagnostics in a custom way can\n register a function pointer+context as a diagnostic handler.\n It gets called each time PrintMessage is invoked."]
pub type llvm_SourceMgr_DiagHandlerTy = ::std::option::Option<
    unsafe extern "C" fn(arg1: *const llvm_SMDiagnostic, Context: *mut ::std::os::raw::c_void),
>;
#[repr(C)]
#[derive(Debug)]
pub struct llvm_SourceMgr_SrcBuffer {
    #[doc = " The memory buffer for the file."]
    pub Buffer: std_unique_ptr,
    #[doc = " Vector of offsets into Buffer at which there are line-endings\n (lazily populated). Once populated, the '\\n' that marks the end of\n line number N from [1..] is at Buffer[OffsetCache[N-1]]. Since\n these offsets are in sorted (ascending) order, they can be\n binary-searched for the first one after any given offset (eg. an\n offset corresponding to a particular SMLoc).\n\n Since we're storing offsets into relatively small files (often smaller\n than 2^8 or 2^16 bytes), we select the offset vector element type\n dynamically based on the size of Buffer."]
    pub OffsetCache: *mut ::std::os::raw::c_void,
    #[doc = " This is the location of the parent include, or null if at the top level."]
    pub IncludeLoc: llvm_SMLoc,
}
#[test]
fn bindgen_test_layout_llvm_SourceMgr_SrcBuffer() {
    const UNINIT: ::std::mem::MaybeUninit<llvm_SourceMgr_SrcBuffer> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<llvm_SourceMgr_SrcBuffer>(),
        24usize,
        concat!("Size of: ", stringify!(llvm_SourceMgr_SrcBuffer))
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_SourceMgr_SrcBuffer>(),
        8usize,
        concat!("Alignment of ", stringify!(llvm_SourceMgr_SrcBuffer))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Buffer) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_SourceMgr_SrcBuffer),
            "::",
            stringify!(Buffer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).OffsetCache) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_SourceMgr_SrcBuffer),
            "::",
            stringify!(OffsetCache)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).IncludeLoc) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_SourceMgr_SrcBuffer),
            "::",
            stringify!(IncludeLoc)
        )
    );
}
extern "C" {
    #[doc = " Look up a given \\p Ptr in the buffer, determining which line it came\n from."]
    #[link_name = "\u{1}_ZNK4llvm9SourceMgr9SrcBuffer13getLineNumberEPKc"]
    pub fn llvm_SourceMgr_SrcBuffer_getLineNumber(
        this: *const llvm_SourceMgr_SrcBuffer,
        Ptr: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " Return a pointer to the first character of the specified line number or\n null if the line number is invalid."]
    #[link_name = "\u{1}_ZNK4llvm9SourceMgr9SrcBuffer23getPointerForLineNumberEj"]
    pub fn llvm_SourceMgr_SrcBuffer_getPointerForLineNumber(
        this: *const llvm_SourceMgr_SrcBuffer,
        LineNo: ::std::os::raw::c_uint,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm9SourceMgr9SrcBufferC1EOS1_"]
    pub fn llvm_SourceMgr_SrcBuffer_SrcBuffer(
        this: *mut llvm_SourceMgr_SrcBuffer,
        arg1: *mut llvm_SourceMgr_SrcBuffer,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm9SourceMgr9SrcBufferD1Ev"]
    pub fn llvm_SourceMgr_SrcBuffer_SrcBuffer_destructor(this: *mut llvm_SourceMgr_SrcBuffer);
}
impl llvm_SourceMgr_SrcBuffer {
    #[inline]
    pub unsafe fn getLineNumber(
        &self,
        Ptr: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_uint {
        llvm_SourceMgr_SrcBuffer_getLineNumber(self, Ptr)
    }
    #[inline]
    pub unsafe fn getPointerForLineNumber(
        &self,
        LineNo: ::std::os::raw::c_uint,
    ) -> *const ::std::os::raw::c_char {
        llvm_SourceMgr_SrcBuffer_getPointerForLineNumber(self, LineNo)
    }
    #[inline]
    pub unsafe fn new(arg1: *mut llvm_SourceMgr_SrcBuffer) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        llvm_SourceMgr_SrcBuffer_SrcBuffer(__bindgen_tmp.as_mut_ptr(), arg1);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn destruct(&mut self) {
        llvm_SourceMgr_SrcBuffer_SrcBuffer_destructor(self)
    }
}
#[test]
fn bindgen_test_layout_llvm_SourceMgr() {
    const UNINIT: ::std::mem::MaybeUninit<llvm_SourceMgr> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<llvm_SourceMgr>(),
        64usize,
        concat!("Size of: ", stringify!(llvm_SourceMgr))
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_SourceMgr>(),
        8usize,
        concat!("Alignment of ", stringify!(llvm_SourceMgr))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Buffers) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_SourceMgr),
            "::",
            stringify!(Buffers)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).IncludeDirectories) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_SourceMgr),
            "::",
            stringify!(IncludeDirectories)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).DiagHandler) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_SourceMgr),
            "::",
            stringify!(DiagHandler)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).DiagContext) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_SourceMgr),
            "::",
            stringify!(DiagContext)
        )
    );
}
extern "C" {
    #[doc = " Search for a file with the specified name in the current directory or in\n one of the IncludeDirs.\n\n If no file is found, this returns 0, otherwise it returns the buffer ID\n of the stacked file. The full path to the included file can be found in\n \\p IncludedFile."]
    #[link_name = "\u{1}_ZN4llvm9SourceMgr14AddIncludeFileERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEENS_5SMLocERS6_"]
    pub fn llvm_SourceMgr_AddIncludeFile(
        this: *mut llvm_SourceMgr,
        Filename: *const std_string,
        IncludeLoc: llvm_SMLoc,
        IncludedFile: *mut std_string,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " Search for a file with the specified name in the current directory or in\n one of the IncludeDirs, and try to open it **without** adding to the\n SourceMgr. If the opened file is intended to be added to the source\n manager, prefer `AddIncludeFile` instead.\n\n If no file is found, this returns an Error, otherwise it returns the\n buffer of the stacked file. The full path to the included file can be\n found in \\p IncludedFile."]
    #[link_name = "\u{1}_ZN4llvm9SourceMgr15OpenIncludeFileERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEERS6_"]
    pub fn llvm_SourceMgr_OpenIncludeFile(
        this: *mut llvm_SourceMgr,
        Filename: *const std_string,
        IncludedFile: *mut std_string,
    ) -> llvm_ErrorOr;
}
extern "C" {
    #[doc = " Return the ID of the buffer containing the specified location.\n\n 0 is returned if the buffer is not found."]
    #[link_name = "\u{1}_ZNK4llvm9SourceMgr23FindBufferContainingLocENS_5SMLocE"]
    pub fn llvm_SourceMgr_FindBufferContainingLoc(
        this: *const llvm_SourceMgr,
        Loc: llvm_SMLoc,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " Find the line and column number for the specified location in the\n specified file. This is not a fast method."]
    #[link_name = "\u{1}_ZNK4llvm9SourceMgr16getLineAndColumnENS_5SMLocEj"]
    pub fn llvm_SourceMgr_getLineAndColumn(
        this: *const llvm_SourceMgr,
        Loc: llvm_SMLoc,
        BufferID: ::std::os::raw::c_uint,
    ) -> std_pair<::std::os::raw::c_uint, ::std::os::raw::c_uint>;
}
extern "C" {
    #[doc = " Get a string with the \\p SMLoc filename and line number\n formatted in the standard style."]
    #[link_name = "\u{1}_ZNK4llvm9SourceMgr28getFormattedLocationNoOffsetB5cxx11ENS_5SMLocEb"]
    pub fn llvm_SourceMgr_getFormattedLocationNoOffset(
        this: *const llvm_SourceMgr,
        Loc: llvm_SMLoc,
        IncludePath: bool,
    ) -> std_string;
}
extern "C" {
    #[doc = " Given a line and column number in a mapped buffer, turn it into an SMLoc.\n This will return a null SMLoc if the line/column location is invalid."]
    #[link_name = "\u{1}_ZN4llvm9SourceMgr23FindLocForLineAndColumnEjjj"]
    pub fn llvm_SourceMgr_FindLocForLineAndColumn(
        this: *mut llvm_SourceMgr,
        BufferID: ::std::os::raw::c_uint,
        LineNo: ::std::os::raw::c_uint,
        ColNo: ::std::os::raw::c_uint,
    ) -> llvm_SMLoc;
}
extern "C" {
    #[doc = " Emit a message about the specified location with the specified string.\n\n \\param ShowColors Display colored messages if output is a terminal and\n the default error handler is used."]
    #[link_name = "\u{1}_ZNK4llvm9SourceMgr12PrintMessageERNS_11raw_ostreamENS_5SMLocENS0_8DiagKindERKNS_5TwineENS_8ArrayRefINS_7SMRangeEEENS8_INS_7SMFixItEEEb"]
    pub fn llvm_SourceMgr_PrintMessage(
        this: *const llvm_SourceMgr,
        OS: *mut llvm_raw_ostream,
        Loc: llvm_SMLoc,
        Kind: llvm_SourceMgr_DiagKind,
        Msg: *const llvm_Twine,
        Ranges: llvm_ArrayRef<llvm_SMRange>,
        FixIts: llvm_ArrayRef<llvm_SMFixIt>,
        ShowColors: bool,
    );
}
extern "C" {
    #[doc = " Emits a diagnostic to llvm::errs()."]
    #[link_name = "\u{1}_ZNK4llvm9SourceMgr12PrintMessageENS_5SMLocENS0_8DiagKindERKNS_5TwineENS_8ArrayRefINS_7SMRangeEEENS6_INS_7SMFixItEEEb"]
    pub fn llvm_SourceMgr_PrintMessage1(
        this: *const llvm_SourceMgr,
        Loc: llvm_SMLoc,
        Kind: llvm_SourceMgr_DiagKind,
        Msg: *const llvm_Twine,
        Ranges: llvm_ArrayRef<llvm_SMRange>,
        FixIts: llvm_ArrayRef<llvm_SMFixIt>,
        ShowColors: bool,
    );
}
extern "C" {
    #[doc = " Emits a manually-constructed diagnostic to the given output stream.\n\n \\param ShowColors Display colored messages if output is a terminal and\n the default error handler is used."]
    #[link_name = "\u{1}_ZNK4llvm9SourceMgr12PrintMessageERNS_11raw_ostreamERKNS_12SMDiagnosticEb"]
    pub fn llvm_SourceMgr_PrintMessage2(
        this: *const llvm_SourceMgr,
        OS: *mut llvm_raw_ostream,
        Diagnostic: *const llvm_SMDiagnostic,
        ShowColors: bool,
    );
}
extern "C" {
    #[doc = " Return an SMDiagnostic at the specified location with the specified\n string.\n\n \\param Msg If non-null, the kind of message (e.g., \"error\") which is\n prefixed to the message."]
    #[link_name = "\u{1}_ZNK4llvm9SourceMgr10GetMessageENS_5SMLocENS0_8DiagKindERKNS_5TwineENS_8ArrayRefINS_7SMRangeEEENS6_INS_7SMFixItEEE"]
    pub fn llvm_SourceMgr_GetMessage(
        this: *const llvm_SourceMgr,
        Loc: llvm_SMLoc,
        Kind: llvm_SourceMgr_DiagKind,
        Msg: *const llvm_Twine,
        Ranges: llvm_ArrayRef<llvm_SMRange>,
        FixIts: llvm_ArrayRef<llvm_SMFixIt>,
    ) -> llvm_SMDiagnostic;
}
extern "C" {
    #[doc = " Prints the names of included files and the line of the file they were\n included from. A diagnostic handler can use this before printing its\n custom formatted message.\n\n \\param IncludeLoc The location of the include.\n \\param OS the raw_ostream to print on."]
    #[link_name = "\u{1}_ZNK4llvm9SourceMgr17PrintIncludeStackENS_5SMLocERNS_11raw_ostreamE"]
    pub fn llvm_SourceMgr_PrintIncludeStack(
        this: *const llvm_SourceMgr,
        IncludeLoc: llvm_SMLoc,
        OS: *mut llvm_raw_ostream,
    );
}
impl llvm_SourceMgr {
    #[inline]
    pub unsafe fn AddIncludeFile(
        &mut self,
        Filename: *const std_string,
        IncludeLoc: llvm_SMLoc,
        IncludedFile: *mut std_string,
    ) -> ::std::os::raw::c_uint {
        llvm_SourceMgr_AddIncludeFile(self, Filename, IncludeLoc, IncludedFile)
    }
    #[inline]
    pub unsafe fn OpenIncludeFile(
        &mut self,
        Filename: *const std_string,
        IncludedFile: *mut std_string,
    ) -> llvm_ErrorOr {
        llvm_SourceMgr_OpenIncludeFile(self, Filename, IncludedFile)
    }
    #[inline]
    pub unsafe fn FindBufferContainingLoc(&self, Loc: llvm_SMLoc) -> ::std::os::raw::c_uint {
        llvm_SourceMgr_FindBufferContainingLoc(self, Loc)
    }
    #[inline]
    pub unsafe fn getLineAndColumn(
        &self,
        Loc: llvm_SMLoc,
        BufferID: ::std::os::raw::c_uint,
    ) -> std_pair<::std::os::raw::c_uint, ::std::os::raw::c_uint> {
        llvm_SourceMgr_getLineAndColumn(self, Loc, BufferID)
    }
    #[inline]
    pub unsafe fn getFormattedLocationNoOffset(
        &self,
        Loc: llvm_SMLoc,
        IncludePath: bool,
    ) -> std_string {
        llvm_SourceMgr_getFormattedLocationNoOffset(self, Loc, IncludePath)
    }
    #[inline]
    pub unsafe fn FindLocForLineAndColumn(
        &mut self,
        BufferID: ::std::os::raw::c_uint,
        LineNo: ::std::os::raw::c_uint,
        ColNo: ::std::os::raw::c_uint,
    ) -> llvm_SMLoc {
        llvm_SourceMgr_FindLocForLineAndColumn(self, BufferID, LineNo, ColNo)
    }
    #[inline]
    pub unsafe fn PrintMessage(
        &self,
        OS: *mut llvm_raw_ostream,
        Loc: llvm_SMLoc,
        Kind: llvm_SourceMgr_DiagKind,
        Msg: *const llvm_Twine,
        Ranges: llvm_ArrayRef<llvm_SMRange>,
        FixIts: llvm_ArrayRef<llvm_SMFixIt>,
        ShowColors: bool,
    ) {
        llvm_SourceMgr_PrintMessage(self, OS, Loc, Kind, Msg, Ranges, FixIts, ShowColors)
    }
    #[inline]
    pub unsafe fn PrintMessage1(
        &self,
        Loc: llvm_SMLoc,
        Kind: llvm_SourceMgr_DiagKind,
        Msg: *const llvm_Twine,
        Ranges: llvm_ArrayRef<llvm_SMRange>,
        FixIts: llvm_ArrayRef<llvm_SMFixIt>,
        ShowColors: bool,
    ) {
        llvm_SourceMgr_PrintMessage1(self, Loc, Kind, Msg, Ranges, FixIts, ShowColors)
    }
    #[inline]
    pub unsafe fn PrintMessage2(
        &self,
        OS: *mut llvm_raw_ostream,
        Diagnostic: *const llvm_SMDiagnostic,
        ShowColors: bool,
    ) {
        llvm_SourceMgr_PrintMessage2(self, OS, Diagnostic, ShowColors)
    }
    #[inline]
    pub unsafe fn GetMessage(
        &self,
        Loc: llvm_SMLoc,
        Kind: llvm_SourceMgr_DiagKind,
        Msg: *const llvm_Twine,
        Ranges: llvm_ArrayRef<llvm_SMRange>,
        FixIts: llvm_ArrayRef<llvm_SMFixIt>,
    ) -> llvm_SMDiagnostic {
        llvm_SourceMgr_GetMessage(self, Loc, Kind, Msg, Ranges, FixIts)
    }
    #[inline]
    pub unsafe fn PrintIncludeStack(&self, IncludeLoc: llvm_SMLoc, OS: *mut llvm_raw_ostream) {
        llvm_SourceMgr_PrintIncludeStack(self, IncludeLoc, OS)
    }
}
#[doc = " Represents a single fixit, a replacement of one range of text with another."]
#[repr(C)]
pub struct llvm_SMFixIt {
    pub Range: llvm_SMRange,
    pub Text: std_string,
}
#[test]
fn bindgen_test_layout_llvm_SMFixIt() {
    const UNINIT: ::std::mem::MaybeUninit<llvm_SMFixIt> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<llvm_SMFixIt>(),
        48usize,
        concat!("Size of: ", stringify!(llvm_SMFixIt))
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_SMFixIt>(),
        8usize,
        concat!("Alignment of ", stringify!(llvm_SMFixIt))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Range) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_SMFixIt),
            "::",
            stringify!(Range)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Text) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_SMFixIt),
            "::",
            stringify!(Text)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm7SMFixItC1ENS_7SMRangeERKNS_5TwineE"]
    pub fn llvm_SMFixIt_SMFixIt(
        this: *mut llvm_SMFixIt,
        R: llvm_SMRange,
        Replacement: *const llvm_Twine,
    );
}
impl llvm_SMFixIt {
    #[inline]
    pub unsafe fn new(R: llvm_SMRange, Replacement: *const llvm_Twine) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        llvm_SMFixIt_SMFixIt(__bindgen_tmp.as_mut_ptr(), R, Replacement);
        __bindgen_tmp.assume_init()
    }
}
#[doc = " Instances of this class encapsulate one diagnostic report, allowing\n printing to a raw_ostream as a caret diagnostic."]
#[repr(C)]
pub struct llvm_SMDiagnostic {
    pub SM: *const llvm_SourceMgr,
    pub Loc: llvm_SMLoc,
    pub Filename: std_string,
    pub LineNo: ::std::os::raw::c_int,
    pub ColumnNo: ::std::os::raw::c_int,
    pub Kind: llvm_SourceMgr_DiagKind,
    pub Message: std_string,
    pub LineContents: std_string,
    pub Ranges: std_vector,
    pub FixIts: [u64; 26usize],
}
#[test]
fn bindgen_test_layout_llvm_SMDiagnostic() {
    const UNINIT: ::std::mem::MaybeUninit<llvm_SMDiagnostic> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<llvm_SMDiagnostic>(),
        360usize,
        concat!("Size of: ", stringify!(llvm_SMDiagnostic))
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_SMDiagnostic>(),
        8usize,
        concat!("Alignment of ", stringify!(llvm_SMDiagnostic))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).SM) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_SMDiagnostic),
            "::",
            stringify!(SM)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Loc) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_SMDiagnostic),
            "::",
            stringify!(Loc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Filename) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_SMDiagnostic),
            "::",
            stringify!(Filename)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LineNo) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_SMDiagnostic),
            "::",
            stringify!(LineNo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ColumnNo) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_SMDiagnostic),
            "::",
            stringify!(ColumnNo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Kind) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_SMDiagnostic),
            "::",
            stringify!(Kind)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Message) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_SMDiagnostic),
            "::",
            stringify!(Message)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LineContents) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_SMDiagnostic),
            "::",
            stringify!(LineContents)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Ranges) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_SMDiagnostic),
            "::",
            stringify!(Ranges)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).FixIts) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_SMDiagnostic),
            "::",
            stringify!(FixIts)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK4llvm12SMDiagnostic5printEPKcRNS_11raw_ostreamEbbb"]
    pub fn llvm_SMDiagnostic_print(
        this: *const llvm_SMDiagnostic,
        ProgName: *const ::std::os::raw::c_char,
        S: *mut llvm_raw_ostream,
        ShowColors: bool,
        ShowKindLabel: bool,
        ShowLocation: bool,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm12SMDiagnosticC1ERKNS_9SourceMgrENS_5SMLocENS_9StringRefEiiNS1_8DiagKindES5_S5_NS_8ArrayRefISt4pairIjjEEENS7_INS_7SMFixItEEE"]
    pub fn llvm_SMDiagnostic_SMDiagnostic(
        this: *mut llvm_SMDiagnostic,
        sm: *const llvm_SourceMgr,
        L: llvm_SMLoc,
        FN: llvm_StringRef,
        Line: ::std::os::raw::c_int,
        Col: ::std::os::raw::c_int,
        Kind: llvm_SourceMgr_DiagKind,
        Msg: llvm_StringRef,
        LineStr: llvm_StringRef,
        Ranges: llvm_ArrayRef<std_pair<::std::os::raw::c_uint, ::std::os::raw::c_uint>>,
        FixIts: llvm_ArrayRef<llvm_SMFixIt>,
    );
}
impl llvm_SMDiagnostic {
    #[inline]
    pub unsafe fn print(
        &self,
        ProgName: *const ::std::os::raw::c_char,
        S: *mut llvm_raw_ostream,
        ShowColors: bool,
        ShowKindLabel: bool,
        ShowLocation: bool,
    ) {
        llvm_SMDiagnostic_print(self, ProgName, S, ShowColors, ShowKindLabel, ShowLocation)
    }
    #[inline]
    pub unsafe fn new(
        sm: *const llvm_SourceMgr,
        L: llvm_SMLoc,
        FN: llvm_StringRef,
        Line: ::std::os::raw::c_int,
        Col: ::std::os::raw::c_int,
        Kind: llvm_SourceMgr_DiagKind,
        Msg: llvm_StringRef,
        LineStr: llvm_StringRef,
        Ranges: llvm_ArrayRef<std_pair<::std::os::raw::c_uint, ::std::os::raw::c_uint>>,
        FixIts: llvm_ArrayRef<llvm_SMFixIt>,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        llvm_SMDiagnostic_SMDiagnostic(
            __bindgen_tmp.as_mut_ptr(),
            sm,
            L,
            FN,
            Line,
            Col,
            Kind,
            Msg,
            LineStr,
            Ranges,
            FixIts,
        );
        __bindgen_tmp.assume_init()
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_DiagnosticInfo {
    _unused: [u8; 0],
}
#[repr(C)]
pub struct llvm_DiagnosticHandler__bindgen_vtable(::std::os::raw::c_void);
#[doc = " This is the base class for diagnostic handling in LLVM.\n The handleDiagnostics method must be overriden by the subclasses to handle\n diagnostic. The *RemarkEnabled methods can be overriden to control\n which remarks are enabled."]
#[repr(C)]
#[derive(Debug)]
pub struct llvm_DiagnosticHandler {
    pub vtable_: *const llvm_DiagnosticHandler__bindgen_vtable,
    pub DiagnosticContext: *mut ::std::os::raw::c_void,
    pub HasErrors: bool,
    #[doc = " DiagHandlerCallback is settable from the C API and base implementation\n of DiagnosticHandler will call it from handleDiagnostics(). Any derived\n class of DiagnosticHandler should not use callback but\n implement handleDiagnostics()."]
    pub DiagHandlerCallback: llvm_DiagnosticHandler_DiagnosticHandlerTy,
}
pub type llvm_DiagnosticHandler_DiagnosticHandlerTy = ::std::option::Option<
    unsafe extern "C" fn(DI: *const llvm_DiagnosticInfo, Context: *mut ::std::os::raw::c_void),
>;
#[test]
fn bindgen_test_layout_llvm_DiagnosticHandler() {
    const UNINIT: ::std::mem::MaybeUninit<llvm_DiagnosticHandler> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<llvm_DiagnosticHandler>(),
        32usize,
        concat!("Size of: ", stringify!(llvm_DiagnosticHandler))
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_DiagnosticHandler>(),
        8usize,
        concat!("Alignment of ", stringify!(llvm_DiagnosticHandler))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).DiagnosticContext) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_DiagnosticHandler),
            "::",
            stringify!(DiagnosticContext)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).HasErrors) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_DiagnosticHandler),
            "::",
            stringify!(HasErrors)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).DiagHandlerCallback) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_DiagnosticHandler),
            "::",
            stringify!(DiagHandlerCallback)
        )
    );
}
extern "C" {
    #[doc = " Return true if analysis remarks are enabled, override\n to provide different implementation."]
    #[link_name = "\u{1}_ZNK4llvm17DiagnosticHandler23isAnalysisRemarkEnabledENS_9StringRefE"]
    pub fn llvm_DiagnosticHandler_isAnalysisRemarkEnabled(
        this: *mut ::std::os::raw::c_void,
        PassName: llvm_StringRef,
    ) -> bool;
}
extern "C" {
    #[doc = " Return true if missed optimization remarks are enabled, override\n to provide different implementation."]
    #[link_name = "\u{1}_ZNK4llvm17DiagnosticHandler24isMissedOptRemarkEnabledENS_9StringRefE"]
    pub fn llvm_DiagnosticHandler_isMissedOptRemarkEnabled(
        this: *mut ::std::os::raw::c_void,
        PassName: llvm_StringRef,
    ) -> bool;
}
extern "C" {
    #[doc = " Return true if passed optimization remarks are enabled, override\n to provide different implementation."]
    #[link_name = "\u{1}_ZNK4llvm17DiagnosticHandler24isPassedOptRemarkEnabledENS_9StringRefE"]
    pub fn llvm_DiagnosticHandler_isPassedOptRemarkEnabled(
        this: *mut ::std::os::raw::c_void,
        PassName: llvm_StringRef,
    ) -> bool;
}
extern "C" {
    #[doc = " Return true if any type of remarks are enabled for any pass."]
    #[link_name = "\u{1}_ZNK4llvm17DiagnosticHandler18isAnyRemarkEnabledEv"]
    pub fn llvm_DiagnosticHandler_isAnyRemarkEnabled(this: *mut ::std::os::raw::c_void) -> bool;
}
pub type llvm_DiagnosticSeverity = ::std::os::raw::c_char;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_LLVMContextImpl {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_OptPassGate {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_LLVMRemarkStreamer {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_remarks_RemarkStreamer {
    _unused: [u8; 0],
}
pub type llvm_SyncScope_ID = u8;
#[doc = " Synchronized with respect to signal handlers executing in the same thread."]
pub const SingleThread: llvm_SyncScope__bindgen_ty_1 = 0;
#[doc = " Synchronized with respect to all concurrently executing threads."]
pub const System: llvm_SyncScope__bindgen_ty_1 = 1;
#[doc = " Known synchronization scope IDs, which always have the same value.  All\n synchronization scope IDs that LLVM has special knowledge of are listed\n here.  Additionally, this scheme allows LLVM to efficiently check for\n specific synchronization scope ID without comparing strings."]
pub type llvm_SyncScope__bindgen_ty_1 = ::std::os::raw::c_uint;
#[doc = " This is an important class for using LLVM in a threaded context.  It\n (opaquely) owns and manages the core \"global\" data of LLVM's core\n infrastructure, including the type and constant uniquing tables.\n LLVMContext itself provides no locking guarantees, so you should be careful\n to have one context per thread."]
#[repr(C)]
#[derive(Debug)]
pub struct llvm_LLVMContext {
    pub pImpl: *mut llvm_LLVMContextImpl,
}
pub const llvm_LLVMContext_MD_dbg: llvm_LLVMContext__bindgen_ty_1 = 0;
pub const llvm_LLVMContext_MD_tbaa: llvm_LLVMContext__bindgen_ty_1 = 1;
pub const llvm_LLVMContext_MD_prof: llvm_LLVMContext__bindgen_ty_1 = 2;
pub const llvm_LLVMContext_MD_fpmath: llvm_LLVMContext__bindgen_ty_1 = 3;
pub const llvm_LLVMContext_MD_range: llvm_LLVMContext__bindgen_ty_1 = 4;
pub const llvm_LLVMContext_MD_tbaa_struct: llvm_LLVMContext__bindgen_ty_1 = 5;
pub const llvm_LLVMContext_MD_invariant_load: llvm_LLVMContext__bindgen_ty_1 = 6;
pub const llvm_LLVMContext_MD_alias_scope: llvm_LLVMContext__bindgen_ty_1 = 7;
pub const llvm_LLVMContext_MD_noalias: llvm_LLVMContext__bindgen_ty_1 = 8;
pub const llvm_LLVMContext_MD_nontemporal: llvm_LLVMContext__bindgen_ty_1 = 9;
pub const llvm_LLVMContext_MD_mem_parallel_loop_access: llvm_LLVMContext__bindgen_ty_1 = 10;
pub const llvm_LLVMContext_MD_nonnull: llvm_LLVMContext__bindgen_ty_1 = 11;
pub const llvm_LLVMContext_MD_dereferenceable: llvm_LLVMContext__bindgen_ty_1 = 12;
pub const llvm_LLVMContext_MD_dereferenceable_or_null: llvm_LLVMContext__bindgen_ty_1 = 13;
pub const llvm_LLVMContext_MD_make_implicit: llvm_LLVMContext__bindgen_ty_1 = 14;
pub const llvm_LLVMContext_MD_unpredictable: llvm_LLVMContext__bindgen_ty_1 = 15;
pub const llvm_LLVMContext_MD_invariant_group: llvm_LLVMContext__bindgen_ty_1 = 16;
pub const llvm_LLVMContext_MD_align: llvm_LLVMContext__bindgen_ty_1 = 17;
pub const llvm_LLVMContext_MD_loop: llvm_LLVMContext__bindgen_ty_1 = 18;
pub const llvm_LLVMContext_MD_type: llvm_LLVMContext__bindgen_ty_1 = 19;
pub const llvm_LLVMContext_MD_section_prefix: llvm_LLVMContext__bindgen_ty_1 = 20;
pub const llvm_LLVMContext_MD_absolute_symbol: llvm_LLVMContext__bindgen_ty_1 = 21;
pub const llvm_LLVMContext_MD_associated: llvm_LLVMContext__bindgen_ty_1 = 22;
pub const llvm_LLVMContext_MD_callees: llvm_LLVMContext__bindgen_ty_1 = 23;
pub const llvm_LLVMContext_MD_irr_loop: llvm_LLVMContext__bindgen_ty_1 = 24;
pub const llvm_LLVMContext_MD_access_group: llvm_LLVMContext__bindgen_ty_1 = 25;
pub const llvm_LLVMContext_MD_callback: llvm_LLVMContext__bindgen_ty_1 = 26;
pub const llvm_LLVMContext_MD_preserve_access_index: llvm_LLVMContext__bindgen_ty_1 = 27;
pub const llvm_LLVMContext_MD_vcall_visibility: llvm_LLVMContext__bindgen_ty_1 = 28;
pub const llvm_LLVMContext_MD_noundef: llvm_LLVMContext__bindgen_ty_1 = 29;
pub const llvm_LLVMContext_MD_annotation: llvm_LLVMContext__bindgen_ty_1 = 30;
pub const llvm_LLVMContext_MD_nosanitize: llvm_LLVMContext__bindgen_ty_1 = 31;
pub const llvm_LLVMContext_MD_func_sanitize: llvm_LLVMContext__bindgen_ty_1 = 32;
pub const llvm_LLVMContext_MD_exclude: llvm_LLVMContext__bindgen_ty_1 = 33;
pub const llvm_LLVMContext_MD_memprof: llvm_LLVMContext__bindgen_ty_1 = 34;
pub const llvm_LLVMContext_MD_callsite: llvm_LLVMContext__bindgen_ty_1 = 35;
pub const llvm_LLVMContext_MD_kcfi_type: llvm_LLVMContext__bindgen_ty_1 = 36;
pub const llvm_LLVMContext_MD_pcsections: llvm_LLVMContext__bindgen_ty_1 = 37;
pub const llvm_LLVMContext_MD_DIAssignID: llvm_LLVMContext__bindgen_ty_1 = 38;
pub const llvm_LLVMContext_MD_coro_outside_frame: llvm_LLVMContext__bindgen_ty_1 = 39;
pub const llvm_LLVMContext_MD_mmra: llvm_LLVMContext__bindgen_ty_1 = 40;
pub type llvm_LLVMContext__bindgen_ty_1 = ::std::os::raw::c_uint;
pub const llvm_LLVMContext_OB_deopt: llvm_LLVMContext__bindgen_ty_2 = 0;
pub const llvm_LLVMContext_OB_funclet: llvm_LLVMContext__bindgen_ty_2 = 1;
pub const llvm_LLVMContext_OB_gc_transition: llvm_LLVMContext__bindgen_ty_2 = 2;
pub const llvm_LLVMContext_OB_cfguardtarget: llvm_LLVMContext__bindgen_ty_2 = 3;
pub const llvm_LLVMContext_OB_preallocated: llvm_LLVMContext__bindgen_ty_2 = 4;
pub const llvm_LLVMContext_OB_gc_live: llvm_LLVMContext__bindgen_ty_2 = 5;
pub const llvm_LLVMContext_OB_clang_arc_attachedcall: llvm_LLVMContext__bindgen_ty_2 = 6;
pub const llvm_LLVMContext_OB_ptrauth: llvm_LLVMContext__bindgen_ty_2 = 7;
pub const llvm_LLVMContext_OB_kcfi: llvm_LLVMContext__bindgen_ty_2 = 8;
pub const llvm_LLVMContext_OB_convergencectrl: llvm_LLVMContext__bindgen_ty_2 = 9;
#[doc = " Known operand bundle tag IDs, which always have the same value.  All\n operand bundle tags that LLVM has special knowledge of are listed here.\n Additionally, this scheme allows LLVM to efficiently check for specific\n operand bundle tags without comparing strings. Keep this in sync with\n LLVMContext::LLVMContext()."]
pub type llvm_LLVMContext__bindgen_ty_2 = ::std::os::raw::c_uint;
#[doc = " Defines the type of a yield callback.\n \\see LLVMContext::setYieldCallback."]
pub type llvm_LLVMContext_YieldCallbackTy = ::std::option::Option<
    unsafe extern "C" fn(Context: *mut llvm_LLVMContext, OpaqueHandle: *mut ::std::os::raw::c_void),
>;
#[test]
fn bindgen_test_layout_llvm_LLVMContext() {
    const UNINIT: ::std::mem::MaybeUninit<llvm_LLVMContext> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<llvm_LLVMContext>(),
        8usize,
        concat!("Size of: ", stringify!(llvm_LLVMContext))
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_LLVMContext>(),
        8usize,
        concat!("Alignment of ", stringify!(llvm_LLVMContext))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pImpl) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_LLVMContext),
            "::",
            stringify!(pImpl)
        )
    );
}
extern "C" {
    #[doc = " getMDKindID - Return a unique non-zero ID for the specified metadata kind.\n This ID is uniqued across modules in the current LLVMContext."]
    #[link_name = "\u{1}_ZNK4llvm11LLVMContext11getMDKindIDENS_9StringRefE"]
    pub fn llvm_LLVMContext_getMDKindID(
        this: *const llvm_LLVMContext,
        Name: llvm_StringRef,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " getMDKindNames - Populate client supplied SmallVector with the name for\n custom metadata IDs registered in this LLVMContext."]
    #[link_name = "\u{1}_ZNK4llvm11LLVMContext14getMDKindNamesERNS_15SmallVectorImplINS_9StringRefEEE"]
    pub fn llvm_LLVMContext_getMDKindNames(
        this: *const llvm_LLVMContext,
        Result: *mut llvm_SmallVectorImpl,
    );
}
extern "C" {
    #[doc = " getOperandBundleTags - Populate client supplied SmallVector with the\n bundle tags registered in this LLVMContext.  The bundle tags are ordered\n by increasing bundle IDs.\n \\see LLVMContext::getOperandBundleTagID"]
    #[link_name = "\u{1}_ZNK4llvm11LLVMContext20getOperandBundleTagsERNS_15SmallVectorImplINS_9StringRefEEE"]
    pub fn llvm_LLVMContext_getOperandBundleTags(
        this: *const llvm_LLVMContext,
        Result: *mut llvm_SmallVectorImpl,
    );
}
extern "C" {
    #[doc = " getOrInsertBundleTag - Returns the Tag to use for an operand bundle of\n name TagName."]
    #[link_name = "\u{1}_ZNK4llvm11LLVMContext20getOrInsertBundleTagENS_9StringRefE"]
    pub fn llvm_LLVMContext_getOrInsertBundleTag(
        this: *const llvm_LLVMContext,
        TagName: llvm_StringRef,
    ) -> *mut llvm_StringMapEntry<u32>;
}
extern "C" {
    #[doc = " getOperandBundleTagID - Maps a bundle tag to an integer ID.  Every bundle\n tag registered with an LLVMContext has an unique ID."]
    #[link_name = "\u{1}_ZNK4llvm11LLVMContext21getOperandBundleTagIDENS_9StringRefE"]
    pub fn llvm_LLVMContext_getOperandBundleTagID(
        this: *const llvm_LLVMContext,
        Tag: llvm_StringRef,
    ) -> u32;
}
extern "C" {
    #[doc = " getOrInsertSyncScopeID - Maps synchronization scope name to\n synchronization scope ID.  Every synchronization scope registered with\n LLVMContext has unique ID except pre-defined ones."]
    #[link_name = "\u{1}_ZN4llvm11LLVMContext22getOrInsertSyncScopeIDENS_9StringRefE"]
    pub fn llvm_LLVMContext_getOrInsertSyncScopeID(
        this: *mut llvm_LLVMContext,
        SSN: llvm_StringRef,
    ) -> llvm_SyncScope_ID;
}
extern "C" {
    #[doc = " getSyncScopeNames - Populates client supplied SmallVector with\n synchronization scope names registered with LLVMContext.  Synchronization\n scope names are ordered by increasing synchronization scope IDs."]
    #[link_name = "\u{1}_ZNK4llvm11LLVMContext17getSyncScopeNamesERNS_15SmallVectorImplINS_9StringRefEEE"]
    pub fn llvm_LLVMContext_getSyncScopeNames(
        this: *const llvm_LLVMContext,
        SSNs: *mut llvm_SmallVectorImpl,
    );
}
extern "C" {
    #[doc = " Define the GC for a function"]
    #[link_name = "\u{1}_ZN4llvm11LLVMContext5setGCERKNS_8FunctionENSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE"]
    pub fn llvm_LLVMContext_setGC(
        this: *mut llvm_LLVMContext,
        Fn: *const llvm_Function,
        GCName: std_string,
    );
}
extern "C" {
    #[doc = " Return the GC for a function"]
    #[link_name = "\u{1}_ZN4llvm11LLVMContext5getGCB5cxx11ERKNS_8FunctionE"]
    pub fn llvm_LLVMContext_getGC(
        this: *mut llvm_LLVMContext,
        Fn: *const llvm_Function,
    ) -> *const std_string;
}
extern "C" {
    #[doc = " Remove the GC for a function"]
    #[link_name = "\u{1}_ZN4llvm11LLVMContext8deleteGCERKNS_8FunctionE"]
    pub fn llvm_LLVMContext_deleteGC(this: *mut llvm_LLVMContext, Fn: *const llvm_Function);
}
extern "C" {
    #[doc = " Return true if the Context runtime configuration is set to discard all\n value names. When true, only GlobalValue names will be available in the\n IR."]
    #[link_name = "\u{1}_ZNK4llvm11LLVMContext23shouldDiscardValueNamesEv"]
    pub fn llvm_LLVMContext_shouldDiscardValueNames(this: *const llvm_LLVMContext) -> bool;
}
extern "C" {
    #[doc = " Set the Context runtime configuration to discard all value name (but\n GlobalValue). Clients can use this flag to save memory and runtime,\n especially in release mode."]
    #[link_name = "\u{1}_ZN4llvm11LLVMContext20setDiscardValueNamesEb"]
    pub fn llvm_LLVMContext_setDiscardValueNames(this: *mut llvm_LLVMContext, Discard: bool);
}
extern "C" {
    #[doc = " Whether there is a string map for uniquing debug info\n identifiers across the context.  Off by default."]
    #[link_name = "\u{1}_ZNK4llvm11LLVMContext23isODRUniquingDebugTypesEv"]
    pub fn llvm_LLVMContext_isODRUniquingDebugTypes(this: *const llvm_LLVMContext) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm11LLVMContext26enableDebugTypeODRUniquingEv"]
    pub fn llvm_LLVMContext_enableDebugTypeODRUniquing(this: *mut llvm_LLVMContext);
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm11LLVMContext27disableDebugTypeODRUniquingEv"]
    pub fn llvm_LLVMContext_disableDebugTypeODRUniquing(this: *mut llvm_LLVMContext);
}
extern "C" {
    #[doc = " generateMachineFunctionNum - Get a unique number for MachineFunction\n that associated with the given Function."]
    #[link_name = "\u{1}_ZN4llvm11LLVMContext26generateMachineFunctionNumERNS_8FunctionE"]
    pub fn llvm_LLVMContext_generateMachineFunctionNum(
        this: *mut llvm_LLVMContext,
        arg1: *mut llvm_Function,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " setDiagnosticHandlerCallBack - This method sets a handler call back\n that is invoked when the backend needs to report anything to the user.\n The first argument is a function pointer and the second is a context pointer\n that gets passed into the DiagHandler.  The third argument should be set to\n true if the handler only expects enabled diagnostics.\n\n LLVMContext doesn't take ownership or interpret either of these\n pointers."]
    #[link_name = "\u{1}_ZN4llvm11LLVMContext28setDiagnosticHandlerCallBackEPFvPKNS_14DiagnosticInfoEPvES4_b"]
    pub fn llvm_LLVMContext_setDiagnosticHandlerCallBack(
        this: *mut llvm_LLVMContext,
        DiagHandler: llvm_DiagnosticHandler_DiagnosticHandlerTy,
        DiagContext: *mut ::std::os::raw::c_void,
        RespectFilters: bool,
    );
}
extern "C" {
    #[doc = " setDiagnosticHandler - This method sets unique_ptr to object of\n DiagnosticHandler to provide custom diagnostic handling. The first\n argument is unique_ptr of object of type DiagnosticHandler or a derived\n of that. The second argument should be set to true if the handler only\n expects enabled diagnostics.\n\n Ownership of this pointer is moved to LLVMContextImpl."]
    #[link_name = "\u{1}_ZN4llvm11LLVMContext20setDiagnosticHandlerEOSt10unique_ptrINS_17DiagnosticHandlerESt14default_deleteIS2_EEb"]
    pub fn llvm_LLVMContext_setDiagnosticHandler(
        this: *mut llvm_LLVMContext,
        DH: *mut std_unique_ptr,
        RespectFilters: bool,
    );
}
extern "C" {
    #[doc = " getDiagnosticHandlerCallBack - Return the diagnostic handler call back set by\n setDiagnosticHandlerCallBack."]
    #[link_name = "\u{1}_ZNK4llvm11LLVMContext28getDiagnosticHandlerCallBackEv"]
    pub fn llvm_LLVMContext_getDiagnosticHandlerCallBack(
        this: *const llvm_LLVMContext,
    ) -> llvm_DiagnosticHandler_DiagnosticHandlerTy;
}
extern "C" {
    #[doc = " getDiagnosticContext - Return the diagnostic context set by\n setDiagnosticContext."]
    #[link_name = "\u{1}_ZNK4llvm11LLVMContext20getDiagnosticContextEv"]
    pub fn llvm_LLVMContext_getDiagnosticContext(
        this: *const llvm_LLVMContext,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " getDiagHandlerPtr - Returns const raw pointer of DiagnosticHandler set by\n setDiagnosticHandler."]
    #[link_name = "\u{1}_ZNK4llvm11LLVMContext17getDiagHandlerPtrEv"]
    pub fn llvm_LLVMContext_getDiagHandlerPtr(
        this: *const llvm_LLVMContext,
    ) -> *const llvm_DiagnosticHandler;
}
extern "C" {
    #[doc = " getDiagnosticHandler - transfers ownership of DiagnosticHandler unique_ptr\n to caller."]
    #[link_name = "\u{1}_ZN4llvm11LLVMContext20getDiagnosticHandlerEv"]
    pub fn llvm_LLVMContext_getDiagnosticHandler(this: *mut llvm_LLVMContext) -> std_unique_ptr;
}
extern "C" {
    #[doc = " Return if a code hotness metric should be included in optimization\n diagnostics."]
    #[link_name = "\u{1}_ZNK4llvm11LLVMContext30getDiagnosticsHotnessRequestedEv"]
    pub fn llvm_LLVMContext_getDiagnosticsHotnessRequested(this: *const llvm_LLVMContext) -> bool;
}
extern "C" {
    #[doc = " Set if a code hotness metric should be included in optimization\n diagnostics."]
    #[link_name = "\u{1}_ZN4llvm11LLVMContext30setDiagnosticsHotnessRequestedEb"]
    pub fn llvm_LLVMContext_setDiagnosticsHotnessRequested(
        this: *mut llvm_LLVMContext,
        Requested: bool,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK4llvm11LLVMContext28getMisExpectWarningRequestedEv"]
    pub fn llvm_LLVMContext_getMisExpectWarningRequested(this: *const llvm_LLVMContext) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm11LLVMContext28setMisExpectWarningRequestedEb"]
    pub fn llvm_LLVMContext_setMisExpectWarningRequested(
        this: *mut llvm_LLVMContext,
        Requested: bool,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm11LLVMContext32setDiagnosticsMisExpectToleranceESt8optionalIjE"]
    pub fn llvm_LLVMContext_setDiagnosticsMisExpectTolerance(
        this: *mut llvm_LLVMContext,
        Tolerance: std_optional,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK4llvm11LLVMContext32getDiagnosticsMisExpectToleranceEv"]
    pub fn llvm_LLVMContext_getDiagnosticsMisExpectTolerance(this: *const llvm_LLVMContext) -> u32;
}
extern "C" {
    #[doc = " Return the minimum hotness value a diagnostic would need in order\n to be included in optimization diagnostics.\n\n Three possible return values:\n 0            - threshold is disabled. Everything will be printed out.\n positive int - threshold is set.\n UINT64_MAX   - threshold is not yet set, and needs to be synced from\n                profile summary. Note that in case of missing profile\n                summary, threshold will be kept at \"MAX\", effectively\n                suppresses all remarks output."]
    #[link_name = "\u{1}_ZNK4llvm11LLVMContext30getDiagnosticsHotnessThresholdEv"]
    pub fn llvm_LLVMContext_getDiagnosticsHotnessThreshold(this: *const llvm_LLVMContext) -> u64;
}
extern "C" {
    #[doc = " Set the minimum hotness value a diagnostic needs in order to be\n included in optimization diagnostics."]
    #[link_name = "\u{1}_ZN4llvm11LLVMContext30setDiagnosticsHotnessThresholdESt8optionalImE"]
    pub fn llvm_LLVMContext_setDiagnosticsHotnessThreshold(
        this: *mut llvm_LLVMContext,
        Threshold: std_optional,
    );
}
extern "C" {
    #[doc = " Return if hotness threshold is requested from PSI."]
    #[link_name = "\u{1}_ZNK4llvm11LLVMContext39isDiagnosticsHotnessThresholdSetFromPSIEv"]
    pub fn llvm_LLVMContext_isDiagnosticsHotnessThresholdSetFromPSI(
        this: *const llvm_LLVMContext,
    ) -> bool;
}
extern "C" {
    #[doc = " The \"main remark streamer\" used by all the specialized remark streamers.\n This streamer keeps generic remark metadata in memory throughout the life\n of the LLVMContext. This metadata may be emitted in a section in object\n files depending on the format requirements.\n\n All specialized remark streamers should convert remarks to\n llvm::remarks::Remark and emit them through this streamer."]
    #[link_name = "\u{1}_ZN4llvm11LLVMContext21getMainRemarkStreamerEv"]
    pub fn llvm_LLVMContext_getMainRemarkStreamer(
        this: *mut llvm_LLVMContext,
    ) -> *mut llvm_remarks_RemarkStreamer;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4llvm11LLVMContext21getMainRemarkStreamerEv"]
    pub fn llvm_LLVMContext_getMainRemarkStreamer1(
        this: *const llvm_LLVMContext,
    ) -> *const llvm_remarks_RemarkStreamer;
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm11LLVMContext21setMainRemarkStreamerESt10unique_ptrINS_7remarks14RemarkStreamerESt14default_deleteIS3_EE"]
    pub fn llvm_LLVMContext_setMainRemarkStreamer(
        this: *mut llvm_LLVMContext,
        MainRemarkStreamer: std_unique_ptr,
    );
}
extern "C" {
    #[doc = " The \"LLVM remark streamer\" used by LLVM to serialize remark diagnostics\n comming from IR and MIR passes.\n\n If it does not exist, diagnostics are not saved in a file but only emitted\n via the diagnostic handler."]
    #[link_name = "\u{1}_ZN4llvm11LLVMContext21getLLVMRemarkStreamerEv"]
    pub fn llvm_LLVMContext_getLLVMRemarkStreamer(
        this: *mut llvm_LLVMContext,
    ) -> *mut llvm_LLVMRemarkStreamer;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4llvm11LLVMContext21getLLVMRemarkStreamerEv"]
    pub fn llvm_LLVMContext_getLLVMRemarkStreamer1(
        this: *const llvm_LLVMContext,
    ) -> *const llvm_LLVMRemarkStreamer;
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm11LLVMContext21setLLVMRemarkStreamerESt10unique_ptrINS_18LLVMRemarkStreamerESt14default_deleteIS2_EE"]
    pub fn llvm_LLVMContext_setLLVMRemarkStreamer(
        this: *mut llvm_LLVMContext,
        RemarkStreamer: std_unique_ptr,
    );
}
extern "C" {
    #[doc = " Get the prefix that should be printed in front of a diagnostic of\n        the given \\p Severity"]
    #[link_name = "\u{1}_ZN4llvm11LLVMContext26getDiagnosticMessagePrefixENS_18DiagnosticSeverityE"]
    pub fn llvm_LLVMContext_getDiagnosticMessagePrefix(
        Severity: llvm_DiagnosticSeverity,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Report a message to the currently installed diagnostic handler.\n\n This function returns, in particular in the case of error reporting\n (DI.Severity == \\a DS_Error), so the caller should leave the compilation\n process in a self-consistent state, even though the generated code\n need not be correct.\n\n The diagnostic message will be implicitly prefixed with a severity keyword\n according to \\p DI.getSeverity(), i.e., \"error: \" for \\a DS_Error,\n \"warning: \" for \\a DS_Warning, and \"note: \" for \\a DS_Note."]
    #[link_name = "\u{1}_ZN4llvm11LLVMContext8diagnoseERKNS_14DiagnosticInfoE"]
    pub fn llvm_LLVMContext_diagnose(this: *mut llvm_LLVMContext, DI: *const llvm_DiagnosticInfo);
}
extern "C" {
    #[doc = " Registers a yield callback with the given context.\n\n The yield callback function may be called by LLVM to transfer control back\n to the client that invoked the LLVM compilation. This can be used to yield\n control of the thread, or perform periodic work needed by the client.\n There is no guaranteed frequency at which callbacks must occur; in fact,\n the client is not guaranteed to ever receive this callback. It is at the\n sole discretion of LLVM to do so and only if it can guarantee that\n suspending the thread won't block any forward progress in other LLVM\n contexts in the same process.\n\n At a suspend point, the state of the current LLVM context is intentionally\n undefined. No assumptions about it can or should be made. Only LLVM\n context API calls that explicitly state that they can be used during a\n yield callback are allowed to be used. Any other API calls into the\n context are not supported until the yield callback function returns\n control to LLVM. Other LLVM contexts are unaffected by this restriction."]
    #[link_name = "\u{1}_ZN4llvm11LLVMContext16setYieldCallbackEPFvPS0_PvES2_"]
    pub fn llvm_LLVMContext_setYieldCallback(
        this: *mut llvm_LLVMContext,
        Callback: llvm_LLVMContext_YieldCallbackTy,
        OpaqueHandle: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = " Calls the yield callback (if applicable).\n\n This transfers control of the current thread back to the client, which may\n suspend the current thread. Only call this method when LLVM doesn't hold\n any global mutex or cannot block the execution in another LLVM context."]
    #[link_name = "\u{1}_ZN4llvm11LLVMContext5yieldEv"]
    pub fn llvm_LLVMContext_yield(this: *mut llvm_LLVMContext);
}
extern "C" {
    #[doc = " emitError - Emit an error message to the currently installed error handler\n with optional location information.  This function returns, so code should\n be prepared to drop the erroneous construct on the floor and \"not crash\".\n The generated code need not be correct.  The error message will be\n implicitly prefixed with \"error: \" and should not end with a \".\"."]
    #[link_name = "\u{1}_ZN4llvm11LLVMContext9emitErrorEmRKNS_5TwineE"]
    pub fn llvm_LLVMContext_emitError(
        this: *mut llvm_LLVMContext,
        LocCookie: u64,
        ErrorStr: *const llvm_Twine,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm11LLVMContext9emitErrorEPKNS_11InstructionERKNS_5TwineE"]
    pub fn llvm_LLVMContext_emitError1(
        this: *mut llvm_LLVMContext,
        I: *const llvm_Instruction,
        ErrorStr: *const llvm_Twine,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm11LLVMContext9emitErrorERKNS_5TwineE"]
    pub fn llvm_LLVMContext_emitError2(this: *mut llvm_LLVMContext, ErrorStr: *const llvm_Twine);
}
extern "C" {
    #[doc = " Access the object which can disable optional passes and individual\n optimizations at compile time."]
    #[link_name = "\u{1}_ZNK4llvm11LLVMContext14getOptPassGateEv"]
    pub fn llvm_LLVMContext_getOptPassGate(this: *const llvm_LLVMContext) -> *mut llvm_OptPassGate;
}
extern "C" {
    #[doc = " Set the object which can disable optional passes and individual\n optimizations at compile time.\n\n The lifetime of the object must be guaranteed to extend as long as the\n LLVMContext is used by compilation."]
    #[link_name = "\u{1}_ZN4llvm11LLVMContext14setOptPassGateERNS_11OptPassGateE"]
    pub fn llvm_LLVMContext_setOptPassGate(
        this: *mut llvm_LLVMContext,
        arg1: *mut llvm_OptPassGate,
    );
}
extern "C" {
    #[doc = " Set whether opaque pointers are enabled. The method may be called multiple\n times, but only with the same value. Note that creating a pointer type or\n otherwise querying the opaque pointer mode performs an implicit set to\n the default value."]
    #[link_name = "\u{1}_ZNK4llvm11LLVMContext17setOpaquePointersEb"]
    pub fn llvm_LLVMContext_setOpaquePointers(this: *const llvm_LLVMContext, Enable: bool);
}
extern "C" {
    #[doc = " Whether typed pointers are supported. If false, all pointers are opaque."]
    #[link_name = "\u{1}_ZNK4llvm11LLVMContext21supportsTypedPointersEv"]
    pub fn llvm_LLVMContext_supportsTypedPointers(this: *const llvm_LLVMContext) -> bool;
}
extern "C" {
    #[doc = " Get or set the current \"default\" target CPU (target-cpu function\n attribute). The intent is that compiler frontends will set this to a value\n that reflects the attribute that a function would get \"by default\" without\n any specific function attributes, and compiler passes will attach the\n attribute to newly created functions that are not associated with a\n particular function, such as global initializers.\n Function::createWithDefaultAttr() will create functions with this\n attribute. This function should only be called by passes that run at\n compile time and not by the backend or LTO passes."]
    #[link_name = "\u{1}_ZN4llvm11LLVMContext19getDefaultTargetCPUEv"]
    pub fn llvm_LLVMContext_getDefaultTargetCPU(this: *mut llvm_LLVMContext) -> llvm_StringRef;
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm11LLVMContext19setDefaultTargetCPUENS_9StringRefE"]
    pub fn llvm_LLVMContext_setDefaultTargetCPU(this: *mut llvm_LLVMContext, CPU: llvm_StringRef);
}
extern "C" {
    #[doc = " Similar to {get,set}DefaultTargetCPU() but for default target-features."]
    #[link_name = "\u{1}_ZN4llvm11LLVMContext24getDefaultTargetFeaturesEv"]
    pub fn llvm_LLVMContext_getDefaultTargetFeatures(this: *mut llvm_LLVMContext)
        -> llvm_StringRef;
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm11LLVMContext24setDefaultTargetFeaturesENS_9StringRefE"]
    pub fn llvm_LLVMContext_setDefaultTargetFeatures(
        this: *mut llvm_LLVMContext,
        Features: llvm_StringRef,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm11LLVMContextC1Ev"]
    pub fn llvm_LLVMContext_LLVMContext(this: *mut llvm_LLVMContext);
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm11LLVMContextD1Ev"]
    pub fn llvm_LLVMContext_LLVMContext_destructor(this: *mut llvm_LLVMContext);
}
impl llvm_LLVMContext {
    #[inline]
    pub unsafe fn getMDKindID(&self, Name: llvm_StringRef) -> ::std::os::raw::c_uint {
        llvm_LLVMContext_getMDKindID(self, Name)
    }
    #[inline]
    pub unsafe fn getMDKindNames(&self, Result: *mut llvm_SmallVectorImpl) {
        llvm_LLVMContext_getMDKindNames(self, Result)
    }
    #[inline]
    pub unsafe fn getOperandBundleTags(&self, Result: *mut llvm_SmallVectorImpl) {
        llvm_LLVMContext_getOperandBundleTags(self, Result)
    }
    #[inline]
    pub unsafe fn getOrInsertBundleTag(
        &self,
        TagName: llvm_StringRef,
    ) -> *mut llvm_StringMapEntry<u32> {
        llvm_LLVMContext_getOrInsertBundleTag(self, TagName)
    }
    #[inline]
    pub unsafe fn getOperandBundleTagID(&self, Tag: llvm_StringRef) -> u32 {
        llvm_LLVMContext_getOperandBundleTagID(self, Tag)
    }
    #[inline]
    pub unsafe fn getOrInsertSyncScopeID(&mut self, SSN: llvm_StringRef) -> llvm_SyncScope_ID {
        llvm_LLVMContext_getOrInsertSyncScopeID(self, SSN)
    }
    #[inline]
    pub unsafe fn getSyncScopeNames(&self, SSNs: *mut llvm_SmallVectorImpl) {
        llvm_LLVMContext_getSyncScopeNames(self, SSNs)
    }
    #[inline]
    pub unsafe fn setGC(&mut self, Fn: *const llvm_Function, GCName: std_string) {
        llvm_LLVMContext_setGC(self, Fn, GCName)
    }
    #[inline]
    pub unsafe fn getGC(&mut self, Fn: *const llvm_Function) -> *const std_string {
        llvm_LLVMContext_getGC(self, Fn)
    }
    #[inline]
    pub unsafe fn deleteGC(&mut self, Fn: *const llvm_Function) {
        llvm_LLVMContext_deleteGC(self, Fn)
    }
    #[inline]
    pub unsafe fn shouldDiscardValueNames(&self) -> bool {
        llvm_LLVMContext_shouldDiscardValueNames(self)
    }
    #[inline]
    pub unsafe fn setDiscardValueNames(&mut self, Discard: bool) {
        llvm_LLVMContext_setDiscardValueNames(self, Discard)
    }
    #[inline]
    pub unsafe fn isODRUniquingDebugTypes(&self) -> bool {
        llvm_LLVMContext_isODRUniquingDebugTypes(self)
    }
    #[inline]
    pub unsafe fn enableDebugTypeODRUniquing(&mut self) {
        llvm_LLVMContext_enableDebugTypeODRUniquing(self)
    }
    #[inline]
    pub unsafe fn disableDebugTypeODRUniquing(&mut self) {
        llvm_LLVMContext_disableDebugTypeODRUniquing(self)
    }
    #[inline]
    pub unsafe fn generateMachineFunctionNum(
        &mut self,
        arg1: *mut llvm_Function,
    ) -> ::std::os::raw::c_uint {
        llvm_LLVMContext_generateMachineFunctionNum(self, arg1)
    }
    #[inline]
    pub unsafe fn setDiagnosticHandlerCallBack(
        &mut self,
        DiagHandler: llvm_DiagnosticHandler_DiagnosticHandlerTy,
        DiagContext: *mut ::std::os::raw::c_void,
        RespectFilters: bool,
    ) {
        llvm_LLVMContext_setDiagnosticHandlerCallBack(
            self,
            DiagHandler,
            DiagContext,
            RespectFilters,
        )
    }
    #[inline]
    pub unsafe fn setDiagnosticHandler(&mut self, DH: *mut std_unique_ptr, RespectFilters: bool) {
        llvm_LLVMContext_setDiagnosticHandler(self, DH, RespectFilters)
    }
    #[inline]
    pub unsafe fn getDiagnosticHandlerCallBack(
        &self,
    ) -> llvm_DiagnosticHandler_DiagnosticHandlerTy {
        llvm_LLVMContext_getDiagnosticHandlerCallBack(self)
    }
    #[inline]
    pub unsafe fn getDiagnosticContext(&self) -> *mut ::std::os::raw::c_void {
        llvm_LLVMContext_getDiagnosticContext(self)
    }
    #[inline]
    pub unsafe fn getDiagHandlerPtr(&self) -> *const llvm_DiagnosticHandler {
        llvm_LLVMContext_getDiagHandlerPtr(self)
    }
    #[inline]
    pub unsafe fn getDiagnosticHandler(&mut self) -> std_unique_ptr {
        llvm_LLVMContext_getDiagnosticHandler(self)
    }
    #[inline]
    pub unsafe fn getDiagnosticsHotnessRequested(&self) -> bool {
        llvm_LLVMContext_getDiagnosticsHotnessRequested(self)
    }
    #[inline]
    pub unsafe fn setDiagnosticsHotnessRequested(&mut self, Requested: bool) {
        llvm_LLVMContext_setDiagnosticsHotnessRequested(self, Requested)
    }
    #[inline]
    pub unsafe fn getMisExpectWarningRequested(&self) -> bool {
        llvm_LLVMContext_getMisExpectWarningRequested(self)
    }
    #[inline]
    pub unsafe fn setMisExpectWarningRequested(&mut self, Requested: bool) {
        llvm_LLVMContext_setMisExpectWarningRequested(self, Requested)
    }
    #[inline]
    pub unsafe fn setDiagnosticsMisExpectTolerance(&mut self, Tolerance: std_optional) {
        llvm_LLVMContext_setDiagnosticsMisExpectTolerance(self, Tolerance)
    }
    #[inline]
    pub unsafe fn getDiagnosticsMisExpectTolerance(&self) -> u32 {
        llvm_LLVMContext_getDiagnosticsMisExpectTolerance(self)
    }
    #[inline]
    pub unsafe fn getDiagnosticsHotnessThreshold(&self) -> u64 {
        llvm_LLVMContext_getDiagnosticsHotnessThreshold(self)
    }
    #[inline]
    pub unsafe fn setDiagnosticsHotnessThreshold(&mut self, Threshold: std_optional) {
        llvm_LLVMContext_setDiagnosticsHotnessThreshold(self, Threshold)
    }
    #[inline]
    pub unsafe fn isDiagnosticsHotnessThresholdSetFromPSI(&self) -> bool {
        llvm_LLVMContext_isDiagnosticsHotnessThresholdSetFromPSI(self)
    }
    #[inline]
    pub unsafe fn getMainRemarkStreamer(&mut self) -> *mut llvm_remarks_RemarkStreamer {
        llvm_LLVMContext_getMainRemarkStreamer(self)
    }
    #[inline]
    pub unsafe fn getMainRemarkStreamer1(&self) -> *const llvm_remarks_RemarkStreamer {
        llvm_LLVMContext_getMainRemarkStreamer1(self)
    }
    #[inline]
    pub unsafe fn setMainRemarkStreamer(&mut self, MainRemarkStreamer: std_unique_ptr) {
        llvm_LLVMContext_setMainRemarkStreamer(self, MainRemarkStreamer)
    }
    #[inline]
    pub unsafe fn getLLVMRemarkStreamer(&mut self) -> *mut llvm_LLVMRemarkStreamer {
        llvm_LLVMContext_getLLVMRemarkStreamer(self)
    }
    #[inline]
    pub unsafe fn getLLVMRemarkStreamer1(&self) -> *const llvm_LLVMRemarkStreamer {
        llvm_LLVMContext_getLLVMRemarkStreamer1(self)
    }
    #[inline]
    pub unsafe fn setLLVMRemarkStreamer(&mut self, RemarkStreamer: std_unique_ptr) {
        llvm_LLVMContext_setLLVMRemarkStreamer(self, RemarkStreamer)
    }
    #[inline]
    pub unsafe fn getDiagnosticMessagePrefix(
        Severity: llvm_DiagnosticSeverity,
    ) -> *const ::std::os::raw::c_char {
        llvm_LLVMContext_getDiagnosticMessagePrefix(Severity)
    }
    #[inline]
    pub unsafe fn diagnose(&mut self, DI: *const llvm_DiagnosticInfo) {
        llvm_LLVMContext_diagnose(self, DI)
    }
    #[inline]
    pub unsafe fn setYieldCallback(
        &mut self,
        Callback: llvm_LLVMContext_YieldCallbackTy,
        OpaqueHandle: *mut ::std::os::raw::c_void,
    ) {
        llvm_LLVMContext_setYieldCallback(self, Callback, OpaqueHandle)
    }
    #[inline]
    pub unsafe fn yield_(&mut self) {
        llvm_LLVMContext_yield(self)
    }
    #[inline]
    pub unsafe fn emitError(&mut self, LocCookie: u64, ErrorStr: *const llvm_Twine) {
        llvm_LLVMContext_emitError(self, LocCookie, ErrorStr)
    }
    #[inline]
    pub unsafe fn emitError1(&mut self, I: *const llvm_Instruction, ErrorStr: *const llvm_Twine) {
        llvm_LLVMContext_emitError1(self, I, ErrorStr)
    }
    #[inline]
    pub unsafe fn emitError2(&mut self, ErrorStr: *const llvm_Twine) {
        llvm_LLVMContext_emitError2(self, ErrorStr)
    }
    #[inline]
    pub unsafe fn getOptPassGate(&self) -> *mut llvm_OptPassGate {
        llvm_LLVMContext_getOptPassGate(self)
    }
    #[inline]
    pub unsafe fn setOptPassGate(&mut self, arg1: *mut llvm_OptPassGate) {
        llvm_LLVMContext_setOptPassGate(self, arg1)
    }
    #[inline]
    pub unsafe fn setOpaquePointers(&self, Enable: bool) {
        llvm_LLVMContext_setOpaquePointers(self, Enable)
    }
    #[inline]
    pub unsafe fn supportsTypedPointers(&self) -> bool {
        llvm_LLVMContext_supportsTypedPointers(self)
    }
    #[inline]
    pub unsafe fn getDefaultTargetCPU(&mut self) -> llvm_StringRef {
        llvm_LLVMContext_getDefaultTargetCPU(self)
    }
    #[inline]
    pub unsafe fn setDefaultTargetCPU(&mut self, CPU: llvm_StringRef) {
        llvm_LLVMContext_setDefaultTargetCPU(self, CPU)
    }
    #[inline]
    pub unsafe fn getDefaultTargetFeatures(&mut self) -> llvm_StringRef {
        llvm_LLVMContext_getDefaultTargetFeatures(self)
    }
    #[inline]
    pub unsafe fn setDefaultTargetFeatures(&mut self, Features: llvm_StringRef) {
        llvm_LLVMContext_setDefaultTargetFeatures(self, Features)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        llvm_LLVMContext_LLVMContext(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn destruct(&mut self) {
        llvm_LLVMContext_LLVMContext_destructor(self)
    }
}
#[doc = " StringMapEntryBase - Shared base class of StringMapEntry instances."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_StringMapEntryBase {
    pub keyLength: usize,
}
#[test]
fn bindgen_test_layout_llvm_StringMapEntryBase() {
    const UNINIT: ::std::mem::MaybeUninit<llvm_StringMapEntryBase> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<llvm_StringMapEntryBase>(),
        8usize,
        concat!("Size of: ", stringify!(llvm_StringMapEntryBase))
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_StringMapEntryBase>(),
        8usize,
        concat!("Alignment of ", stringify!(llvm_StringMapEntryBase))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).keyLength) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_StringMapEntryBase),
            "::",
            stringify!(keyLength)
        )
    );
}
#[doc = " StringMapEntryStorage - Holds the value in a StringMapEntry.\n\n Factored out into a separate base class to make it easier to specialize.\n This is primarily intended to support StringSet, which doesn't need a value\n stored at all."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_StringMapEntryStorage<ValueTy> {
    pub _base: llvm_StringMapEntryBase,
    pub second: ValueTy,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<ValueTy>>,
}
#[test]
fn __bindgen_test_layout_llvm_StringMapEntryStorage_open0_std_nullopt_t_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<llvm_StringMapEntryStorage<std_nullopt_t>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_StringMapEntryStorage<std_nullopt_t>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_StringMapEntryStorage<std_nullopt_t>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_StringMapEntryStorage<std_nullopt_t>)
        )
    );
}
#[doc = " StringMapEntry - This is used to represent one value that is inserted into\n a StringMap.  It contains the Value itself and the key: the string length\n and data."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_StringMapEntry<ValueTy> {
    pub _base: llvm_StringMapEntryStorage<ValueTy>,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<ValueTy>>,
}
pub type llvm_StringMapEntry_ValueType<ValueTy> = ValueTy;
extern "C" {
    #[doc = " Allocate a buffer of memory with the given size and alignment.\n\n When the compiler supports aligned operator new, this will use it to\n handle even over-aligned allocations.\n\n However, this doesn't make any attempt to leverage the fancier techniques\n like posix_memalign due to portability. It is mostly intended to allow\n compatibility with platforms that, after aligned allocation was added, use\n reduced default alignment."]
    #[link_name = "\u{1}_ZN4llvm15allocate_bufferEmm"]
    pub fn llvm_allocate_buffer(Size: usize, Alignment: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " Deallocate a buffer of memory with the given size and alignment.\n\n If supported, this will used the sized delete operator. Also if supported,\n this will pass the alignment to the delete operator.\n\n The pointer must have been allocated with the corresponding new operator,\n most likely using the above helper."]
    #[link_name = "\u{1}_ZN4llvm17deallocate_bufferEPvmm"]
    pub fn llvm_deallocate_buffer(Ptr: *mut ::std::os::raw::c_void, Size: usize, Alignment: usize);
}
#[doc = " CRTP base class providing obvious overloads for the core \\c\n Allocate() methods of LLVM-style allocators.\n\n This base class both documents the full public interface exposed by all\n LLVM-style allocators, and redirects all of the overloads to a single core\n set of methods which the derived class must define."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_AllocatorBase {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_MallocAllocator {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_llvm_MallocAllocator() {
    assert_eq!(
        ::std::mem::size_of::<llvm_MallocAllocator>(),
        1usize,
        concat!("Size of: ", stringify!(llvm_MallocAllocator))
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_MallocAllocator>(),
        1usize,
        concat!("Alignment of ", stringify!(llvm_MallocAllocator))
    );
}
#[doc = " A traits type that is used to handle pointer types and things that are just\n wrappers for pointers as a uniform entity."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_PointerLikeTypeTraits {
    pub _address: u8,
}
#[test]
fn __bindgen_test_layout_llvm_PointerLikeTypeTraits_open0_ptr_void_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<llvm_PointerLikeTypeTraits>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_PointerLikeTypeTraits)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_PointerLikeTypeTraits>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_PointerLikeTypeTraits)
        )
    );
}
#[test]
fn __bindgen_test_layout_llvm_PointerLikeTypeTraits_open0_unsigned_long_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<llvm_PointerLikeTypeTraits>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_PointerLikeTypeTraits)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_PointerLikeTypeTraits>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_PointerLikeTypeTraits)
        )
    );
}
#[doc = " StringMapImpl - This is the base class of StringMap that is shared among\n all of its instantiations."]
#[repr(C)]
#[derive(Debug)]
pub struct llvm_StringMapImpl {
    pub TheTable: *mut *mut llvm_StringMapEntryBase,
    pub NumBuckets: ::std::os::raw::c_uint,
    pub NumItems: ::std::os::raw::c_uint,
    pub NumTombstones: ::std::os::raw::c_uint,
    pub ItemSize: ::std::os::raw::c_uint,
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm13StringMapImpl15TombstoneIntValE"]
    pub static llvm_StringMapImpl_TombstoneIntVal: usize;
}
#[test]
fn bindgen_test_layout_llvm_StringMapImpl() {
    const UNINIT: ::std::mem::MaybeUninit<llvm_StringMapImpl> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<llvm_StringMapImpl>(),
        24usize,
        concat!("Size of: ", stringify!(llvm_StringMapImpl))
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_StringMapImpl>(),
        8usize,
        concat!("Alignment of ", stringify!(llvm_StringMapImpl))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).TheTable) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_StringMapImpl),
            "::",
            stringify!(TheTable)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).NumBuckets) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_StringMapImpl),
            "::",
            stringify!(NumBuckets)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).NumItems) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_StringMapImpl),
            "::",
            stringify!(NumItems)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).NumTombstones) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_StringMapImpl),
            "::",
            stringify!(NumTombstones)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ItemSize) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_StringMapImpl),
            "::",
            stringify!(ItemSize)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm13StringMapImpl11RehashTableEj"]
    pub fn llvm_StringMapImpl_RehashTable(
        this: *mut llvm_StringMapImpl,
        BucketNo: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " Overload that explicitly takes precomputed hash(Key)."]
    #[link_name = "\u{1}_ZN4llvm13StringMapImpl15LookupBucketForENS_9StringRefEj"]
    pub fn llvm_StringMapImpl_LookupBucketFor(
        this: *mut llvm_StringMapImpl,
        Key: llvm_StringRef,
        FullHashValue: u32,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " Overload that explicitly takes precomputed hash(Key)."]
    #[link_name = "\u{1}_ZNK4llvm13StringMapImpl7FindKeyENS_9StringRefEj"]
    pub fn llvm_StringMapImpl_FindKey(
        this: *const llvm_StringMapImpl,
        Key: llvm_StringRef,
        FullHashValue: u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " RemoveKey - Remove the specified StringMapEntry from the table, but do not\n delete it.  This aborts if the value isn't in the table."]
    #[link_name = "\u{1}_ZN4llvm13StringMapImpl9RemoveKeyEPNS_18StringMapEntryBaseE"]
    pub fn llvm_StringMapImpl_RemoveKey(
        this: *mut llvm_StringMapImpl,
        V: *mut llvm_StringMapEntryBase,
    );
}
extern "C" {
    #[doc = " RemoveKey - Remove the StringMapEntry for the specified key from the\n table, returning it.  If the key is not in the table, this returns null."]
    #[link_name = "\u{1}_ZN4llvm13StringMapImpl9RemoveKeyENS_9StringRefE"]
    pub fn llvm_StringMapImpl_RemoveKey1(
        this: *mut llvm_StringMapImpl,
        Key: llvm_StringRef,
    ) -> *mut llvm_StringMapEntryBase;
}
extern "C" {
    #[doc = " Allocate the table with the specified number of buckets and otherwise\n setup the map as empty."]
    #[link_name = "\u{1}_ZN4llvm13StringMapImpl4initEj"]
    pub fn llvm_StringMapImpl_init(this: *mut llvm_StringMapImpl, Size: ::std::os::raw::c_uint);
}
extern "C" {
    #[doc = " Returns the hash value that will be used for the given string.\n This allows precomputing the value and passing it explicitly\n to some of the functions.\n The implementation of this function is not guaranteed to be stable\n and may change."]
    #[link_name = "\u{1}_ZN4llvm13StringMapImpl4hashENS_9StringRefE"]
    pub fn llvm_StringMapImpl_hash(Key: llvm_StringRef) -> u32;
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm13StringMapImplC1Ejj"]
    pub fn llvm_StringMapImpl_StringMapImpl(
        this: *mut llvm_StringMapImpl,
        InitSize: ::std::os::raw::c_uint,
        ItemSize: ::std::os::raw::c_uint,
    );
}
impl llvm_StringMapImpl {
    #[inline]
    pub unsafe fn RehashTable(
        &mut self,
        BucketNo: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_uint {
        llvm_StringMapImpl_RehashTable(self, BucketNo)
    }
    #[inline]
    pub unsafe fn LookupBucketFor(
        &mut self,
        Key: llvm_StringRef,
        FullHashValue: u32,
    ) -> ::std::os::raw::c_uint {
        llvm_StringMapImpl_LookupBucketFor(self, Key, FullHashValue)
    }
    #[inline]
    pub unsafe fn FindKey(&self, Key: llvm_StringRef, FullHashValue: u32) -> ::std::os::raw::c_int {
        llvm_StringMapImpl_FindKey(self, Key, FullHashValue)
    }
    #[inline]
    pub unsafe fn RemoveKey(&mut self, V: *mut llvm_StringMapEntryBase) {
        llvm_StringMapImpl_RemoveKey(self, V)
    }
    #[inline]
    pub unsafe fn RemoveKey1(&mut self, Key: llvm_StringRef) -> *mut llvm_StringMapEntryBase {
        llvm_StringMapImpl_RemoveKey1(self, Key)
    }
    #[inline]
    pub unsafe fn init(&mut self, Size: ::std::os::raw::c_uint) {
        llvm_StringMapImpl_init(self, Size)
    }
    #[inline]
    pub unsafe fn hash(Key: llvm_StringRef) -> u32 {
        llvm_StringMapImpl_hash(Key)
    }
    #[inline]
    pub unsafe fn new(InitSize: ::std::os::raw::c_uint, ItemSize: ::std::os::raw::c_uint) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        llvm_StringMapImpl_StringMapImpl(__bindgen_tmp.as_mut_ptr(), InitSize, ItemSize);
        __bindgen_tmp.assume_init()
    }
}
#[doc = " StringMap - This is an unconventional map that is specialized for handling\n keys that are \"strings\", which are basically ranges of bytes. This does some\n funky memory allocation and hashing things to make it extremely efficient,\n storing the string data *after* the value in the map."]
#[repr(C)]
#[derive(Debug)]
pub struct llvm_StringMap<AllocatorTy> {
    pub _base: llvm_StringMapImpl,
    pub _base_1: llvm_detail_AllocatorHolder<AllocatorTy>,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<AllocatorTy>>,
}
pub type llvm_StringMap_AllocTy<AllocatorTy> = llvm_detail_AllocatorHolder<AllocatorTy>;
#[doc = " StringMapEntry - This is used to represent one value that is inserted into\n a StringMap.  It contains the Value itself and the key: the string length\n and data."]
pub type llvm_StringMap_MapEntryTy<ValueTy> = llvm_StringMapEntry<ValueTy>;
pub type llvm_StringMap_key_type = *const ::std::os::raw::c_char;
pub type llvm_StringMap_mapped_type<ValueTy> = ValueTy;
#[doc = " StringMapEntry - This is used to represent one value that is inserted into\n a StringMap.  It contains the Value itself and the key: the string length\n and data."]
pub type llvm_StringMap_value_type<ValueTy> = llvm_StringMapEntry<ValueTy>;
pub type llvm_StringMap_size_type = usize;
pub type llvm_StringMap_const_iterator = llvm_StringMapConstIterator;
pub type llvm_StringMap_iterator = llvm_StringMapIterator;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_StringMapIterBase {
    pub Ptr: *mut *mut llvm_StringMapEntryBase,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_StringMapConstIterator {
    pub _base: llvm_StringMapIterBase,
}
pub type llvm_StringMapConstIterator_base = llvm_StringMapIterBase;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_StringMapIterator {
    pub _base: llvm_StringMapIterBase,
}
pub type llvm_StringMapIterator_base = llvm_StringMapIterBase;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_StringMapKeyIterator {
    pub _base: llvm_iterator_adaptor_base<WrappedIteratorT>,
}
#[doc = " CRTP base class for adapting an iterator to a different type.\n\n This class can be used through CRTP to adapt one iterator into another.\n Typically this is done through providing in the derived class a custom \\c\n operator* implementation. Other methods can be overridden as well."]
pub type llvm_StringMapKeyIterator_base = llvm_iterator_adaptor_base<WrappedIteratorT>;
#[doc = " Traits class to determine whether an enum has a\n LLVM_BITMASK_LARGEST_ENUMERATOR enumerator."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_is_bitmask_enum {
    pub _base: std_false_type,
}
#[doc = " Trait class to determine bitmask enumeration largest bit."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_largest_bitmask_enum_bit {
    pub _address: u8,
}
pub const llvm_Reloc_Model_Static: llvm_Reloc_Model = 0;
pub const llvm_Reloc_Model_PIC_: llvm_Reloc_Model = 1;
pub const llvm_Reloc_Model_DynamicNoPIC: llvm_Reloc_Model = 2;
pub const llvm_Reloc_Model_ROPI: llvm_Reloc_Model = 3;
pub const llvm_Reloc_Model_RWPI: llvm_Reloc_Model = 4;
pub const llvm_Reloc_Model_ROPI_RWPI: llvm_Reloc_Model = 5;
pub type llvm_Reloc_Model = ::std::os::raw::c_uint;
pub const llvm_CodeModel_Model_Tiny: llvm_CodeModel_Model = 0;
pub const llvm_CodeModel_Model_Small: llvm_CodeModel_Model = 1;
pub const llvm_CodeModel_Model_Kernel: llvm_CodeModel_Model = 2;
pub const llvm_CodeModel_Model_Medium: llvm_CodeModel_Model = 3;
pub const llvm_CodeModel_Model_Large: llvm_CodeModel_Model = 4;
pub type llvm_CodeModel_Model = ::std::os::raw::c_uint;
pub const llvm_PICLevel_Level_NotPIC: llvm_PICLevel_Level = 0;
pub const llvm_PICLevel_Level_SmallPIC: llvm_PICLevel_Level = 1;
pub const llvm_PICLevel_Level_BigPIC: llvm_PICLevel_Level = 2;
pub type llvm_PICLevel_Level = ::std::os::raw::c_uint;
pub const llvm_PIELevel_Level_Default: llvm_PIELevel_Level = 0;
pub const llvm_PIELevel_Level_Small: llvm_PIELevel_Level = 1;
pub const llvm_PIELevel_Level_Large: llvm_PIELevel_Level = 2;
pub type llvm_PIELevel_Level = ::std::os::raw::c_uint;
pub const llvm_TLSModel_Model_GeneralDynamic: llvm_TLSModel_Model = 0;
pub const llvm_TLSModel_Model_LocalDynamic: llvm_TLSModel_Model = 1;
pub const llvm_TLSModel_Model_InitialExec: llvm_TLSModel_Model = 2;
pub const llvm_TLSModel_Model_LocalExec: llvm_TLSModel_Model = 3;
pub type llvm_TLSModel_Model = ::std::os::raw::c_uint;
#[doc = "< -O0"]
pub const llvm_CodeGenOptLevel_None: llvm_CodeGenOptLevel = 0;
#[doc = "< -O1"]
pub const llvm_CodeGenOptLevel_Less: llvm_CodeGenOptLevel = 1;
#[doc = "< -O2, -Os"]
pub const llvm_CodeGenOptLevel_Default: llvm_CodeGenOptLevel = 2;
#[doc = "< -O3"]
pub const llvm_CodeGenOptLevel_Aggressive: llvm_CodeGenOptLevel = 3;
#[doc = " Code generation optimization level."]
pub type llvm_CodeGenOptLevel = ::std::os::raw::c_int;
pub const llvm_CodeGenFileType_AssemblyFile: llvm_CodeGenFileType = 0;
pub const llvm_CodeGenFileType_ObjectFile: llvm_CodeGenFileType = 1;
pub const llvm_CodeGenFileType_Null: llvm_CodeGenFileType = 2;
#[doc = " These enums are meant to be passed into addPassesToEmitFile to indicate\n what type of file to emit, and returned by it to indicate what type of\n file could actually be made."]
pub type llvm_CodeGenFileType = ::std::os::raw::c_int;
pub const llvm_FramePointerKind_None: llvm_FramePointerKind = 0;
pub const llvm_FramePointerKind_NonLeaf: llvm_FramePointerKind = 1;
pub const llvm_FramePointerKind_All: llvm_FramePointerKind = 2;
pub const llvm_FramePointerKind_Reserved: llvm_FramePointerKind = 3;
pub type llvm_FramePointerKind = ::std::os::raw::c_int;
pub const llvm_ZeroCallUsedRegs_ONLY_USED: ::std::os::raw::c_uint = 2;
pub const llvm_ZeroCallUsedRegs_ONLY_GPR: ::std::os::raw::c_uint = 4;
pub const llvm_ZeroCallUsedRegs_ONLY_ARG: ::std::os::raw::c_uint = 8;
pub const llvm_ZeroCallUsedRegs_ZeroCallUsedRegsKind_Skip:
    llvm_ZeroCallUsedRegs_ZeroCallUsedRegsKind = 1;
pub const llvm_ZeroCallUsedRegs_ZeroCallUsedRegsKind_UsedGPRArg:
    llvm_ZeroCallUsedRegs_ZeroCallUsedRegsKind = 14;
pub const llvm_ZeroCallUsedRegs_ZeroCallUsedRegsKind_UsedGPR:
    llvm_ZeroCallUsedRegs_ZeroCallUsedRegsKind = 6;
pub const llvm_ZeroCallUsedRegs_ZeroCallUsedRegsKind_UsedArg:
    llvm_ZeroCallUsedRegs_ZeroCallUsedRegsKind = 10;
pub const llvm_ZeroCallUsedRegs_ZeroCallUsedRegsKind_Used:
    llvm_ZeroCallUsedRegs_ZeroCallUsedRegsKind = 2;
pub const llvm_ZeroCallUsedRegs_ZeroCallUsedRegsKind_AllGPRArg:
    llvm_ZeroCallUsedRegs_ZeroCallUsedRegsKind = 12;
pub const llvm_ZeroCallUsedRegs_ZeroCallUsedRegsKind_AllGPR:
    llvm_ZeroCallUsedRegs_ZeroCallUsedRegsKind = 4;
pub const llvm_ZeroCallUsedRegs_ZeroCallUsedRegsKind_AllArg:
    llvm_ZeroCallUsedRegs_ZeroCallUsedRegsKind = 8;
pub const llvm_ZeroCallUsedRegs_ZeroCallUsedRegsKind_All:
    llvm_ZeroCallUsedRegs_ZeroCallUsedRegsKind = 0;
pub type llvm_ZeroCallUsedRegs_ZeroCallUsedRegsKind = ::std::os::raw::c_uint;
#[doc = "< No unwind table requested"]
pub const llvm_UWTableKind_None: llvm_UWTableKind = 0;
#[doc = "< \"Synchronous\" unwind tables"]
pub const llvm_UWTableKind_Sync: llvm_UWTableKind = 1;
#[doc = "< \"Asynchronous\" unwind tables (instr precise)"]
pub const llvm_UWTableKind_Async: llvm_UWTableKind = 2;
pub const llvm_UWTableKind_Default: llvm_UWTableKind = 2;
pub type llvm_UWTableKind = ::std::os::raw::c_int;
#[doc = "< No function return thunk."]
pub const llvm_FunctionReturnThunksKind_Keep: llvm_FunctionReturnThunksKind = 0;
#[doc = "< Replace returns with jump to thunk, don't emit thunk."]
pub const llvm_FunctionReturnThunksKind_Extern: llvm_FunctionReturnThunksKind = 1;
#[doc = "< Not used."]
pub const llvm_FunctionReturnThunksKind_Invalid: llvm_FunctionReturnThunksKind = 2;
pub type llvm_FunctionReturnThunksKind = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_enum_iteration_traits {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_force_iteration_on_noniterable_enum_t {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_llvm_force_iteration_on_noniterable_enum_t() {
    assert_eq!(
        ::std::mem::size_of::<llvm_force_iteration_on_noniterable_enum_t>(),
        1usize,
        concat!(
            "Size of: ",
            stringify!(llvm_force_iteration_on_noniterable_enum_t)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_force_iteration_on_noniterable_enum_t>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(llvm_force_iteration_on_noniterable_enum_t)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm35force_iteration_on_noniterable_enumE"]
    pub static llvm_force_iteration_on_noniterable_enum: llvm_force_iteration_on_noniterable_enum_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_iota_range {
    pub BeginValue: llvm_iota_range_iterator,
    pub PastEndValue: llvm_iota_range_iterator,
}
pub type llvm_iota_range_value_type<T> = T;
pub type llvm_iota_range_reference<T> = *mut T;
pub type llvm_iota_range_const_reference<T> = *const T;
pub type llvm_iota_range_iterator = u8;
pub type llvm_iota_range_const_iterator = llvm_iota_range_iterator;
pub type llvm_iota_range_reverse_iterator = u8;
pub type llvm_iota_range_const_reverse_iterator = llvm_iota_range_reverse_iterator;
pub type llvm_iota_range_difference_type = intmax_t;
pub type llvm_iota_range_size_type = usize;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_Duration {
    _unused: [u8; 0],
}
#[repr(C)]
pub struct llvm_raw_ostream__bindgen_vtable(::std::os::raw::c_void);
#[doc = " This class implements an extremely fast bulk output stream that can *only*\n output to a stream.  It does not support seeking, reopening, rewinding, line\n buffered disciplines etc. It is a simple buffer that outputs\n a chunk at a time."]
#[repr(C)]
#[derive(Debug)]
pub struct llvm_raw_ostream {
    pub vtable_: *const llvm_raw_ostream__bindgen_vtable,
    pub Kind: llvm_raw_ostream_OStreamKind,
    #[doc = " The buffer is handled in such a way that the buffer is\n uninitialized, unbuffered, or out of space when OutBufCur >=\n OutBufEnd. Thus a single comparison suffices to determine if we\n need to take the slow path to write a single character.\n\n The buffer is in one of three states:\n  1. Unbuffered (BufferMode == Unbuffered)\n  1. Uninitialized (BufferMode != Unbuffered && OutBufStart == 0).\n  2. Buffered (BufferMode != Unbuffered && OutBufStart != 0 &&\n               OutBufEnd - OutBufStart >= 1).\n\n If buffered, then the raw_ostream owns the buffer if (BufferMode ==\n InternalBuffer); otherwise the buffer has been set via SetBuffer and is\n managed by the subclass.\n\n If a subclass installs an external buffer using SetBuffer then it can wait\n for a \\see write_impl() call to handle the data which has been put into\n this buffer."]
    pub OutBufStart: *mut ::std::os::raw::c_char,
    #[doc = " The buffer is handled in such a way that the buffer is\n uninitialized, unbuffered, or out of space when OutBufCur >=\n OutBufEnd. Thus a single comparison suffices to determine if we\n need to take the slow path to write a single character.\n\n The buffer is in one of three states:\n  1. Unbuffered (BufferMode == Unbuffered)\n  1. Uninitialized (BufferMode != Unbuffered && OutBufStart == 0).\n  2. Buffered (BufferMode != Unbuffered && OutBufStart != 0 &&\n               OutBufEnd - OutBufStart >= 1).\n\n If buffered, then the raw_ostream owns the buffer if (BufferMode ==\n InternalBuffer); otherwise the buffer has been set via SetBuffer and is\n managed by the subclass.\n\n If a subclass installs an external buffer using SetBuffer then it can wait\n for a \\see write_impl() call to handle the data which has been put into\n this buffer."]
    pub OutBufEnd: *mut ::std::os::raw::c_char,
    #[doc = " The buffer is handled in such a way that the buffer is\n uninitialized, unbuffered, or out of space when OutBufCur >=\n OutBufEnd. Thus a single comparison suffices to determine if we\n need to take the slow path to write a single character.\n\n The buffer is in one of three states:\n  1. Unbuffered (BufferMode == Unbuffered)\n  1. Uninitialized (BufferMode != Unbuffered && OutBufStart == 0).\n  2. Buffered (BufferMode != Unbuffered && OutBufStart != 0 &&\n               OutBufEnd - OutBufStart >= 1).\n\n If buffered, then the raw_ostream owns the buffer if (BufferMode ==\n InternalBuffer); otherwise the buffer has been set via SetBuffer and is\n managed by the subclass.\n\n If a subclass installs an external buffer using SetBuffer then it can wait\n for a \\see write_impl() call to handle the data which has been put into\n this buffer."]
    pub OutBufCur: *mut ::std::os::raw::c_char,
    pub ColorEnabled: bool,
    pub BufferMode: llvm_raw_ostream_BufferKind,
}
pub const llvm_raw_ostream_OStreamKind_OK_OStream: llvm_raw_ostream_OStreamKind = 0;
pub const llvm_raw_ostream_OStreamKind_OK_FDStream: llvm_raw_ostream_OStreamKind = 1;
pub const llvm_raw_ostream_OStreamKind_OK_SVecStream: llvm_raw_ostream_OStreamKind = 2;
pub type llvm_raw_ostream_OStreamKind = ::std::os::raw::c_int;
pub const llvm_raw_ostream_BufferKind_Unbuffered: llvm_raw_ostream_BufferKind = 0;
pub const llvm_raw_ostream_BufferKind_InternalBuffer: llvm_raw_ostream_BufferKind = 1;
pub const llvm_raw_ostream_BufferKind_ExternalBuffer: llvm_raw_ostream_BufferKind = 2;
pub type llvm_raw_ostream_BufferKind = ::std::os::raw::c_int;
pub const llvm_raw_ostream_Colors_BLACK: llvm_raw_ostream_Colors = 0;
pub const llvm_raw_ostream_Colors_RED: llvm_raw_ostream_Colors = 1;
pub const llvm_raw_ostream_Colors_GREEN: llvm_raw_ostream_Colors = 2;
pub const llvm_raw_ostream_Colors_YELLOW: llvm_raw_ostream_Colors = 3;
pub const llvm_raw_ostream_Colors_BLUE: llvm_raw_ostream_Colors = 4;
pub const llvm_raw_ostream_Colors_MAGENTA: llvm_raw_ostream_Colors = 5;
pub const llvm_raw_ostream_Colors_CYAN: llvm_raw_ostream_Colors = 6;
pub const llvm_raw_ostream_Colors_WHITE: llvm_raw_ostream_Colors = 7;
pub const llvm_raw_ostream_Colors_BRIGHT_BLACK: llvm_raw_ostream_Colors = 8;
pub const llvm_raw_ostream_Colors_BRIGHT_RED: llvm_raw_ostream_Colors = 9;
pub const llvm_raw_ostream_Colors_BRIGHT_GREEN: llvm_raw_ostream_Colors = 10;
pub const llvm_raw_ostream_Colors_BRIGHT_YELLOW: llvm_raw_ostream_Colors = 11;
pub const llvm_raw_ostream_Colors_BRIGHT_BLUE: llvm_raw_ostream_Colors = 12;
pub const llvm_raw_ostream_Colors_BRIGHT_MAGENTA: llvm_raw_ostream_Colors = 13;
pub const llvm_raw_ostream_Colors_BRIGHT_CYAN: llvm_raw_ostream_Colors = 14;
pub const llvm_raw_ostream_Colors_BRIGHT_WHITE: llvm_raw_ostream_Colors = 15;
pub const llvm_raw_ostream_Colors_SAVEDCOLOR: llvm_raw_ostream_Colors = 16;
pub const llvm_raw_ostream_Colors_RESET: llvm_raw_ostream_Colors = 17;
pub type llvm_raw_ostream_Colors = ::std::os::raw::c_int;
#[doc = " Output a formatted UUID with dash separators."]
pub type llvm_raw_ostream_uuid_t = [u8; 16usize];
extern "C" {
    #[link_name = "\u{1}_ZN4llvm11raw_ostream5BLACKE"]
    pub static llvm_raw_ostream_BLACK: llvm_raw_ostream_Colors;
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm11raw_ostream3REDE"]
    pub static llvm_raw_ostream_RED: llvm_raw_ostream_Colors;
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm11raw_ostream5GREENE"]
    pub static llvm_raw_ostream_GREEN: llvm_raw_ostream_Colors;
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm11raw_ostream6YELLOWE"]
    pub static llvm_raw_ostream_YELLOW: llvm_raw_ostream_Colors;
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm11raw_ostream4BLUEE"]
    pub static llvm_raw_ostream_BLUE: llvm_raw_ostream_Colors;
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm11raw_ostream7MAGENTAE"]
    pub static llvm_raw_ostream_MAGENTA: llvm_raw_ostream_Colors;
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm11raw_ostream4CYANE"]
    pub static llvm_raw_ostream_CYAN: llvm_raw_ostream_Colors;
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm11raw_ostream5WHITEE"]
    pub static llvm_raw_ostream_WHITE: llvm_raw_ostream_Colors;
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm11raw_ostream12BRIGHT_BLACKE"]
    pub static llvm_raw_ostream_BRIGHT_BLACK: llvm_raw_ostream_Colors;
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm11raw_ostream10BRIGHT_REDE"]
    pub static llvm_raw_ostream_BRIGHT_RED: llvm_raw_ostream_Colors;
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm11raw_ostream12BRIGHT_GREENE"]
    pub static llvm_raw_ostream_BRIGHT_GREEN: llvm_raw_ostream_Colors;
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm11raw_ostream13BRIGHT_YELLOWE"]
    pub static llvm_raw_ostream_BRIGHT_YELLOW: llvm_raw_ostream_Colors;
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm11raw_ostream11BRIGHT_BLUEE"]
    pub static llvm_raw_ostream_BRIGHT_BLUE: llvm_raw_ostream_Colors;
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm11raw_ostream14BRIGHT_MAGENTAE"]
    pub static llvm_raw_ostream_BRIGHT_MAGENTA: llvm_raw_ostream_Colors;
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm11raw_ostream11BRIGHT_CYANE"]
    pub static llvm_raw_ostream_BRIGHT_CYAN: llvm_raw_ostream_Colors;
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm11raw_ostream12BRIGHT_WHITEE"]
    pub static llvm_raw_ostream_BRIGHT_WHITE: llvm_raw_ostream_Colors;
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm11raw_ostream10SAVEDCOLORE"]
    pub static llvm_raw_ostream_SAVEDCOLOR: llvm_raw_ostream_Colors;
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm11raw_ostream5RESETE"]
    pub static llvm_raw_ostream_RESET: llvm_raw_ostream_Colors;
}
#[test]
fn bindgen_test_layout_llvm_raw_ostream() {
    const UNINIT: ::std::mem::MaybeUninit<llvm_raw_ostream> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<llvm_raw_ostream>(),
        48usize,
        concat!("Size of: ", stringify!(llvm_raw_ostream))
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_raw_ostream>(),
        8usize,
        concat!("Alignment of ", stringify!(llvm_raw_ostream))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Kind) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_raw_ostream),
            "::",
            stringify!(Kind)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).OutBufStart) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_raw_ostream),
            "::",
            stringify!(OutBufStart)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).OutBufEnd) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_raw_ostream),
            "::",
            stringify!(OutBufEnd)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).OutBufCur) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_raw_ostream),
            "::",
            stringify!(OutBufCur)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ColorEnabled) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_raw_ostream),
            "::",
            stringify!(ColorEnabled)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).BufferMode) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_raw_ostream),
            "::",
            stringify!(BufferMode)
        )
    );
}
extern "C" {
    #[doc = " Set the stream to be buffered, with an automatically determined buffer\n size."]
    #[link_name = "\u{1}_ZN4llvm11raw_ostream11SetBufferedEv"]
    pub fn llvm_raw_ostream_SetBuffered(this: *mut llvm_raw_ostream);
}
extern "C" {
    #[doc = " Output \\p N in hexadecimal, without any prefix or padding."]
    #[link_name = "\u{1}_ZN4llvm11raw_ostream9write_hexEy"]
    pub fn llvm_raw_ostream_write_hex(
        this: *mut llvm_raw_ostream,
        N: ::std::os::raw::c_ulonglong,
    ) -> *mut llvm_raw_ostream;
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm11raw_ostream10write_uuidEPKh"]
    pub fn llvm_raw_ostream_write_uuid(
        this: *mut llvm_raw_ostream,
        UUID: *mut u8,
    ) -> *mut llvm_raw_ostream;
}
extern "C" {
    #[doc = " Output \\p Str, turning '\\\\', '\\t', '\\n', '\"', and anything that doesn't\n satisfy llvm::isPrint into an escape sequence."]
    #[link_name = "\u{1}_ZN4llvm11raw_ostream13write_escapedENS_9StringRefEb"]
    pub fn llvm_raw_ostream_write_escaped(
        this: *mut llvm_raw_ostream,
        Str: llvm_StringRef,
        UseHexEscapes: bool,
    ) -> *mut llvm_raw_ostream;
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm11raw_ostream5writeEh"]
    pub fn llvm_raw_ostream_write(
        this: *mut llvm_raw_ostream,
        C: ::std::os::raw::c_uchar,
    ) -> *mut llvm_raw_ostream;
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm11raw_ostream5writeEPKcm"]
    pub fn llvm_raw_ostream_write1(
        this: *mut llvm_raw_ostream,
        Ptr: *const ::std::os::raw::c_char,
        Size: usize,
    ) -> *mut llvm_raw_ostream;
}
extern "C" {
    #[doc = " indent - Insert 'NumSpaces' spaces."]
    #[link_name = "\u{1}_ZN4llvm11raw_ostream6indentEj"]
    pub fn llvm_raw_ostream_indent(
        this: *mut llvm_raw_ostream,
        NumSpaces: ::std::os::raw::c_uint,
    ) -> *mut llvm_raw_ostream;
}
extern "C" {
    #[doc = " write_zeros - Insert 'NumZeros' nulls."]
    #[link_name = "\u{1}_ZN4llvm11raw_ostream11write_zerosEj"]
    pub fn llvm_raw_ostream_write_zeros(
        this: *mut llvm_raw_ostream,
        NumZeros: ::std::os::raw::c_uint,
    ) -> *mut llvm_raw_ostream;
}
impl llvm_raw_ostream {
    #[inline]
    pub unsafe fn SetBuffered(&mut self) {
        llvm_raw_ostream_SetBuffered(self)
    }
    #[inline]
    pub unsafe fn write_hex(&mut self, N: ::std::os::raw::c_ulonglong) -> *mut llvm_raw_ostream {
        llvm_raw_ostream_write_hex(self, N)
    }
    #[inline]
    pub unsafe fn write_uuid(&mut self, UUID: *mut u8) -> *mut llvm_raw_ostream {
        llvm_raw_ostream_write_uuid(self, UUID)
    }
    #[inline]
    pub unsafe fn write_escaped(
        &mut self,
        Str: llvm_StringRef,
        UseHexEscapes: bool,
    ) -> *mut llvm_raw_ostream {
        llvm_raw_ostream_write_escaped(self, Str, UseHexEscapes)
    }
    #[inline]
    pub unsafe fn write(&mut self, C: ::std::os::raw::c_uchar) -> *mut llvm_raw_ostream {
        llvm_raw_ostream_write(self, C)
    }
    #[inline]
    pub unsafe fn write1(
        &mut self,
        Ptr: *const ::std::os::raw::c_char,
        Size: usize,
    ) -> *mut llvm_raw_ostream {
        llvm_raw_ostream_write1(self, Ptr, Size)
    }
    #[inline]
    pub unsafe fn indent(&mut self, NumSpaces: ::std::os::raw::c_uint) -> *mut llvm_raw_ostream {
        llvm_raw_ostream_indent(self, NumSpaces)
    }
    #[inline]
    pub unsafe fn write_zeros(
        &mut self,
        NumZeros: ::std::os::raw::c_uint,
    ) -> *mut llvm_raw_ostream {
        llvm_raw_ostream_write_zeros(self, NumZeros)
    }
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm11raw_ostreamD1Ev"]
    pub fn llvm_raw_ostream_raw_ostream_destructor(this: *mut llvm_raw_ostream);
}
extern "C" {
    #[doc = " Changes the foreground color of text that will be output from this point\n forward.\n @param Color ANSI color to use, the special SAVEDCOLOR can be used to\n change only the bold attribute, and keep colors untouched\n @param Bold bold/brighter text, default false\n @param BG if true change the background, default: change foreground\n @returns itself so it can be used within << invocations"]
    #[link_name = "\u{1}_ZN4llvm11raw_ostream11changeColorENS0_6ColorsEbb"]
    pub fn llvm_raw_ostream_changeColor(
        this: *mut ::std::os::raw::c_void,
        Color: llvm_raw_ostream_Colors,
        Bold: bool,
        BG: bool,
    ) -> *mut llvm_raw_ostream;
}
extern "C" {
    #[doc = " Resets the colors to terminal defaults. Call this when you are done\n outputting colored text, or before program exit."]
    #[link_name = "\u{1}_ZN4llvm11raw_ostream10resetColorEv"]
    pub fn llvm_raw_ostream_resetColor(this: *mut ::std::os::raw::c_void) -> *mut llvm_raw_ostream;
}
extern "C" {
    #[doc = " Reverses the foreground and background colors."]
    #[link_name = "\u{1}_ZN4llvm11raw_ostream12reverseColorEv"]
    pub fn llvm_raw_ostream_reverseColor(
        this: *mut ::std::os::raw::c_void,
    ) -> *mut llvm_raw_ostream;
}
extern "C" {
    #[doc = " Return an efficient buffer size for the underlying output mechanism."]
    #[link_name = "\u{1}_ZNK4llvm11raw_ostream21preferred_buffer_sizeEv"]
    pub fn llvm_raw_ostream_preferred_buffer_size(this: *mut ::std::os::raw::c_void) -> usize;
}
#[doc = " An abstract base class for streams implementations that also support a\n pwrite operation. This is useful for code that can mostly stream out data,\n but needs to patch in a header that needs to know the output size."]
#[repr(C)]
#[derive(Debug)]
pub struct llvm_raw_pwrite_stream {
    pub _base: llvm_raw_ostream,
}
#[test]
fn bindgen_test_layout_llvm_raw_pwrite_stream() {
    assert_eq!(
        ::std::mem::size_of::<llvm_raw_pwrite_stream>(),
        48usize,
        concat!("Size of: ", stringify!(llvm_raw_pwrite_stream))
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_raw_pwrite_stream>(),
        8usize,
        concat!("Alignment of ", stringify!(llvm_raw_pwrite_stream))
    );
}
#[doc = " A raw_ostream that writes to a file descriptor.\n"]
#[repr(C)]
#[derive(Debug)]
pub struct llvm_raw_fd_ostream {
    pub _base: llvm_raw_pwrite_stream,
    pub FD: ::std::os::raw::c_int,
    pub ShouldClose: bool,
    pub SupportsSeeking: bool,
    pub IsRegularFile: bool,
    pub HasColors: std_optional,
    #[doc = " Optional stream this stream is tied to. If this stream is written to, the\n tied-to stream will be flushed first."]
    pub TiedStream: *mut llvm_raw_ostream,
    pub EC: std_error_code,
    pub pos: u64,
}
#[test]
fn bindgen_test_layout_llvm_raw_fd_ostream() {
    const UNINIT: ::std::mem::MaybeUninit<llvm_raw_fd_ostream> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<llvm_raw_fd_ostream>(),
        96usize,
        concat!("Size of: ", stringify!(llvm_raw_fd_ostream))
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_raw_fd_ostream>(),
        8usize,
        concat!("Alignment of ", stringify!(llvm_raw_fd_ostream))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).FD) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_raw_fd_ostream),
            "::",
            stringify!(FD)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ShouldClose) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_raw_fd_ostream),
            "::",
            stringify!(ShouldClose)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).SupportsSeeking) as usize - ptr as usize },
        53usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_raw_fd_ostream),
            "::",
            stringify!(SupportsSeeking)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).IsRegularFile) as usize - ptr as usize },
        54usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_raw_fd_ostream),
            "::",
            stringify!(IsRegularFile)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).HasColors) as usize - ptr as usize },
        55usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_raw_fd_ostream),
            "::",
            stringify!(HasColors)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).TiedStream) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_raw_fd_ostream),
            "::",
            stringify!(TiedStream)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).EC) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_raw_fd_ostream),
            "::",
            stringify!(EC)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pos) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_raw_fd_ostream),
            "::",
            stringify!(pos)
        )
    );
}
extern "C" {
    #[doc = " Manually flush the stream and close the file. Note that this does not call\n fsync."]
    #[link_name = "\u{1}_ZN4llvm14raw_fd_ostream5closeEv"]
    pub fn llvm_raw_fd_ostream_close(this: *mut llvm_raw_fd_ostream);
}
extern "C" {
    #[doc = " Flushes the stream and repositions the underlying file descriptor position\n to the offset specified from the beginning of the file."]
    #[link_name = "\u{1}_ZN4llvm14raw_fd_ostream4seekEm"]
    pub fn llvm_raw_fd_ostream_seek(this: *mut llvm_raw_fd_ostream, off: u64) -> u64;
}
extern "C" {
    #[doc = " Locks the underlying file.\n\n @returns RAII object that releases the lock upon leaving the scope, if the\n          locking was successful. Otherwise returns corresponding\n          error code.\n\n The function blocks the current thread until the lock become available or\n error occurs.\n\n Possible use of this function may be as follows:\n\n   @code{.cpp}\n   if (auto L = stream.lock()) {\n     // ... do action that require file to be locked.\n   } else {\n     handleAllErrors(std::move(L.takeError()), [&](ErrorInfoBase &EIB) {\n       // ... handle lock error.\n     });\n   }\n   @endcode"]
    #[link_name = "\u{1}_ZN4llvm14raw_fd_ostream4lockEv"]
    pub fn llvm_raw_fd_ostream_lock(this: *mut llvm_raw_fd_ostream) -> llvm_Expected;
}
extern "C" {
    #[doc = " Tries to lock the underlying file within the specified period.\n\n @returns RAII object that releases the lock upon leaving the scope, if the\n          locking was successful. Otherwise returns corresponding\n          error code.\n\n It is used as @ref lock."]
    #[link_name = "\u{1}_ZN4llvm14raw_fd_ostream10tryLockForERKNS_8DurationE"]
    pub fn llvm_raw_fd_ostream_tryLockFor(
        this: *mut llvm_raw_fd_ostream,
        Timeout: *const llvm_Duration,
    ) -> llvm_Expected;
}
extern "C" {
    #[doc = " Open the specified file for writing. If an error occurs, information\n about the error is put into EC, and the stream should be immediately\n destroyed;\n \\p Flags allows optional flags to control how the file will be opened.\n\n As a special case, if Filename is \"-\", then the stream will use\n STDOUT_FILENO instead of opening a file. This will not close the stdout\n descriptor."]
    #[link_name = "\u{1}_ZN4llvm14raw_fd_ostreamC1ENS_9StringRefERSt10error_code"]
    pub fn llvm_raw_fd_ostream_raw_fd_ostream(
        this: *mut llvm_raw_fd_ostream,
        Filename: llvm_StringRef,
        EC: *mut std_error_code,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm14raw_fd_ostreamC1ENS_9StringRefERSt10error_codeNS_3sys2fs19CreationDispositionE"]
    pub fn llvm_raw_fd_ostream_raw_fd_ostream1(
        this: *mut llvm_raw_fd_ostream,
        Filename: llvm_StringRef,
        EC: *mut std_error_code,
        Disp: llvm_sys_fs_CreationDisposition,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm14raw_fd_ostreamC1ENS_9StringRefERSt10error_codeNS_3sys2fs10FileAccessE"]
    pub fn llvm_raw_fd_ostream_raw_fd_ostream2(
        this: *mut llvm_raw_fd_ostream,
        Filename: llvm_StringRef,
        EC: *mut std_error_code,
        Access: llvm_sys_fs_FileAccess,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm14raw_fd_ostreamC1ENS_9StringRefERSt10error_codeNS_3sys2fs9OpenFlagsE"]
    pub fn llvm_raw_fd_ostream_raw_fd_ostream3(
        this: *mut llvm_raw_fd_ostream,
        Filename: llvm_StringRef,
        EC: *mut std_error_code,
        Flags: llvm_sys_fs_OpenFlags,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm14raw_fd_ostreamC1ENS_9StringRefERSt10error_codeNS_3sys2fs19CreationDispositionENS5_10FileAccessENS5_9OpenFlagsE"]
    pub fn llvm_raw_fd_ostream_raw_fd_ostream4(
        this: *mut llvm_raw_fd_ostream,
        Filename: llvm_StringRef,
        EC: *mut std_error_code,
        Disp: llvm_sys_fs_CreationDisposition,
        Access: llvm_sys_fs_FileAccess,
        Flags: llvm_sys_fs_OpenFlags,
    );
}
extern "C" {
    #[doc = " FD is the file descriptor that this writes to.  If ShouldClose is true,\n this closes the file when the stream is destroyed. If FD is for stdout or\n stderr, it will not be closed."]
    #[link_name = "\u{1}_ZN4llvm14raw_fd_ostreamC1EibbNS_11raw_ostream11OStreamKindE"]
    pub fn llvm_raw_fd_ostream_raw_fd_ostream5(
        this: *mut llvm_raw_fd_ostream,
        fd: ::std::os::raw::c_int,
        shouldClose: bool,
        unbuffered: bool,
        K: llvm_raw_ostream_OStreamKind,
    );
}
impl llvm_raw_fd_ostream {
    #[inline]
    pub unsafe fn close(&mut self) {
        llvm_raw_fd_ostream_close(self)
    }
    #[inline]
    pub unsafe fn seek(&mut self, off: u64) -> u64 {
        llvm_raw_fd_ostream_seek(self, off)
    }
    #[inline]
    pub unsafe fn lock(&mut self) -> llvm_Expected {
        llvm_raw_fd_ostream_lock(self)
    }
    #[inline]
    pub unsafe fn tryLockFor(&mut self, Timeout: *const llvm_Duration) -> llvm_Expected {
        llvm_raw_fd_ostream_tryLockFor(self, Timeout)
    }
    #[inline]
    pub unsafe fn new(Filename: llvm_StringRef, EC: *mut std_error_code) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        llvm_raw_fd_ostream_raw_fd_ostream(__bindgen_tmp.as_mut_ptr(), Filename, EC);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(
        Filename: llvm_StringRef,
        EC: *mut std_error_code,
        Disp: llvm_sys_fs_CreationDisposition,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        llvm_raw_fd_ostream_raw_fd_ostream1(__bindgen_tmp.as_mut_ptr(), Filename, EC, Disp);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new2(
        Filename: llvm_StringRef,
        EC: *mut std_error_code,
        Access: llvm_sys_fs_FileAccess,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        llvm_raw_fd_ostream_raw_fd_ostream2(__bindgen_tmp.as_mut_ptr(), Filename, EC, Access);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new3(
        Filename: llvm_StringRef,
        EC: *mut std_error_code,
        Flags: llvm_sys_fs_OpenFlags,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        llvm_raw_fd_ostream_raw_fd_ostream3(__bindgen_tmp.as_mut_ptr(), Filename, EC, Flags);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new4(
        Filename: llvm_StringRef,
        EC: *mut std_error_code,
        Disp: llvm_sys_fs_CreationDisposition,
        Access: llvm_sys_fs_FileAccess,
        Flags: llvm_sys_fs_OpenFlags,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        llvm_raw_fd_ostream_raw_fd_ostream4(
            __bindgen_tmp.as_mut_ptr(),
            Filename,
            EC,
            Disp,
            Access,
            Flags,
        );
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new5(
        fd: ::std::os::raw::c_int,
        shouldClose: bool,
        unbuffered: bool,
        K: llvm_raw_ostream_OStreamKind,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        llvm_raw_fd_ostream_raw_fd_ostream5(
            __bindgen_tmp.as_mut_ptr(),
            fd,
            shouldClose,
            unbuffered,
            K,
        );
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm14raw_fd_ostreamD1Ev"]
    pub fn llvm_raw_fd_ostream_raw_fd_ostream_destructor(this: *mut llvm_raw_fd_ostream);
}
extern "C" {
    #[link_name = "\u{1}_ZNK4llvm14raw_fd_ostream12is_displayedEv"]
    pub fn llvm_raw_fd_ostream_is_displayed(this: *mut ::std::os::raw::c_void) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4llvm14raw_fd_ostream10has_colorsEv"]
    pub fn llvm_raw_fd_ostream_has_colors(this: *mut ::std::os::raw::c_void) -> bool;
}
extern "C" {
    #[doc = " This returns a reference to a raw_fd_ostream for standard output. Use it\n like: outs() << \"foo\" << \"bar\";"]
    #[link_name = "\u{1}_ZN4llvm4outsEv"]
    pub fn llvm_outs() -> *mut llvm_raw_fd_ostream;
}
extern "C" {
    #[doc = " This returns a reference to a raw_ostream for standard error.\n Use it like: errs() << \"foo\" << \"bar\";\n By default, the stream is tied to stdout to ensure stdout is flushed before\n stderr is written, to ensure the error messages are written in their\n expected place."]
    #[link_name = "\u{1}_ZN4llvm4errsEv"]
    pub fn llvm_errs() -> *mut llvm_raw_fd_ostream;
}
extern "C" {
    #[doc = " This returns a reference to a raw_ostream which simply discards output."]
    #[link_name = "\u{1}_ZN4llvm5nullsEv"]
    pub fn llvm_nulls() -> *mut llvm_raw_ostream;
}
#[doc = " A raw_ostream of a file for reading/writing/seeking.\n"]
#[repr(C)]
#[derive(Debug)]
pub struct llvm_raw_fd_stream {
    pub _base: llvm_raw_fd_ostream,
}
#[test]
fn bindgen_test_layout_llvm_raw_fd_stream() {
    assert_eq!(
        ::std::mem::size_of::<llvm_raw_fd_stream>(),
        96usize,
        concat!("Size of: ", stringify!(llvm_raw_fd_stream))
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_raw_fd_stream>(),
        8usize,
        concat!("Alignment of ", stringify!(llvm_raw_fd_stream))
    );
}
extern "C" {
    #[doc = " This reads the \\p Size bytes into a buffer pointed by \\p Ptr.\n\n \\param Ptr The start of the buffer to hold data to be read.\n\n \\param Size The number of bytes to be read.\n\n On success, the number of bytes read is returned, and the file position is\n advanced by this number. On error, -1 is returned, use error() to get the\n error code."]
    #[link_name = "\u{1}_ZN4llvm13raw_fd_stream4readEPcm"]
    pub fn llvm_raw_fd_stream_read(
        this: *mut llvm_raw_fd_stream,
        Ptr: *mut ::std::os::raw::c_char,
        Size: usize,
    ) -> isize;
}
extern "C" {
    #[doc = " Check if \\p OS is a pointer of type raw_fd_stream*."]
    #[link_name = "\u{1}_ZN4llvm13raw_fd_stream7classofEPKNS_11raw_ostreamE"]
    pub fn llvm_raw_fd_stream_classof(OS: *const llvm_raw_ostream) -> bool;
}
extern "C" {
    #[doc = " Open the specified file for reading/writing/seeking. If an error occurs,\n information about the error is put into EC, and the stream should be\n immediately destroyed."]
    #[link_name = "\u{1}_ZN4llvm13raw_fd_streamC1ENS_9StringRefERSt10error_code"]
    pub fn llvm_raw_fd_stream_raw_fd_stream(
        this: *mut llvm_raw_fd_stream,
        Filename: llvm_StringRef,
        EC: *mut std_error_code,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm13raw_fd_streamC1Eib"]
    pub fn llvm_raw_fd_stream_raw_fd_stream1(
        this: *mut llvm_raw_fd_stream,
        fd: ::std::os::raw::c_int,
        shouldClose: bool,
    );
}
impl llvm_raw_fd_stream {
    #[inline]
    pub unsafe fn read(&mut self, Ptr: *mut ::std::os::raw::c_char, Size: usize) -> isize {
        llvm_raw_fd_stream_read(self, Ptr, Size)
    }
    #[inline]
    pub unsafe fn classof(OS: *const llvm_raw_ostream) -> bool {
        llvm_raw_fd_stream_classof(OS)
    }
    #[inline]
    pub unsafe fn new(Filename: llvm_StringRef, EC: *mut std_error_code) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        llvm_raw_fd_stream_raw_fd_stream(__bindgen_tmp.as_mut_ptr(), Filename, EC);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(fd: ::std::os::raw::c_int, shouldClose: bool) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        llvm_raw_fd_stream_raw_fd_stream1(__bindgen_tmp.as_mut_ptr(), fd, shouldClose);
        __bindgen_tmp.assume_init()
    }
}
#[doc = " A raw_ostream that writes to an std::string.  This is a simple adaptor\n class. This class does not encounter output errors.\n raw_string_ostream operates without a buffer, delegating all memory\n management to the std::string. Thus the std::string is always up-to-date,\n may be used directly and there is no need to call flush()."]
#[repr(C)]
#[derive(Debug)]
pub struct llvm_raw_string_ostream {
    pub _base: llvm_raw_ostream,
    pub OS: *mut std_string,
}
#[test]
fn bindgen_test_layout_llvm_raw_string_ostream() {
    const UNINIT: ::std::mem::MaybeUninit<llvm_raw_string_ostream> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<llvm_raw_string_ostream>(),
        56usize,
        concat!("Size of: ", stringify!(llvm_raw_string_ostream))
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_raw_string_ostream>(),
        8usize,
        concat!("Alignment of ", stringify!(llvm_raw_string_ostream))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).OS) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_raw_string_ostream),
            "::",
            stringify!(OS)
        )
    );
}
#[doc = " A raw_ostream that writes to an SmallVector or SmallString.  This is a\n simple adaptor class. This class does not encounter output errors.\n raw_svector_ostream operates without a buffer, delegating all memory\n management to the SmallString. Thus the SmallString is always up-to-date,\n may be used directly and there is no need to call flush()."]
#[repr(C)]
#[derive(Debug)]
pub struct llvm_raw_svector_ostream {
    pub _base: llvm_raw_pwrite_stream,
    pub OS: *mut llvm_SmallVectorImpl,
}
#[test]
fn bindgen_test_layout_llvm_raw_svector_ostream() {
    const UNINIT: ::std::mem::MaybeUninit<llvm_raw_svector_ostream> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<llvm_raw_svector_ostream>(),
        56usize,
        concat!("Size of: ", stringify!(llvm_raw_svector_ostream))
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_raw_svector_ostream>(),
        8usize,
        concat!("Alignment of ", stringify!(llvm_raw_svector_ostream))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).OS) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_raw_svector_ostream),
            "::",
            stringify!(OS)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm19raw_svector_ostream7classofEPKNS_11raw_ostreamE"]
    pub fn llvm_raw_svector_ostream_classof(OS: *const llvm_raw_ostream) -> bool;
}
impl llvm_raw_svector_ostream {
    #[inline]
    pub unsafe fn classof(OS: *const llvm_raw_ostream) -> bool {
        llvm_raw_svector_ostream_classof(OS)
    }
}
#[doc = " A raw_ostream that discards all output."]
#[repr(C)]
#[derive(Debug)]
pub struct llvm_raw_null_ostream {
    pub _base: llvm_raw_pwrite_stream,
}
#[test]
fn bindgen_test_layout_llvm_raw_null_ostream() {
    assert_eq!(
        ::std::mem::size_of::<llvm_raw_null_ostream>(),
        48usize,
        concat!("Size of: ", stringify!(llvm_raw_null_ostream))
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_raw_null_ostream>(),
        8usize,
        concat!("Alignment of ", stringify!(llvm_raw_null_ostream))
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm16raw_null_ostreamD1Ev"]
    pub fn llvm_raw_null_ostream_raw_null_ostream_destructor(this: *mut llvm_raw_null_ostream);
}
#[repr(C)]
#[derive(Debug)]
pub struct llvm_buffer_ostream {
    pub _base: llvm_raw_svector_ostream,
    pub OS: *mut llvm_raw_ostream,
    pub Buffer: [u64; 3usize],
}
#[test]
fn bindgen_test_layout_llvm_buffer_ostream() {
    const UNINIT: ::std::mem::MaybeUninit<llvm_buffer_ostream> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<llvm_buffer_ostream>(),
        88usize,
        concat!("Size of: ", stringify!(llvm_buffer_ostream))
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_buffer_ostream>(),
        8usize,
        concat!("Alignment of ", stringify!(llvm_buffer_ostream))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).OS) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_buffer_ostream),
            "::",
            stringify!(OS)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Buffer) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_buffer_ostream),
            "::",
            stringify!(Buffer)
        )
    );
}
#[repr(C)]
#[derive(Debug)]
pub struct llvm_buffer_unique_ostream {
    pub _base: llvm_raw_svector_ostream,
    pub OS: std_unique_ptr,
    pub Buffer: [u64; 3usize],
}
#[test]
fn bindgen_test_layout_llvm_buffer_unique_ostream() {
    const UNINIT: ::std::mem::MaybeUninit<llvm_buffer_unique_ostream> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<llvm_buffer_unique_ostream>(),
        88usize,
        concat!("Size of: ", stringify!(llvm_buffer_unique_ostream))
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_buffer_unique_ostream>(),
        8usize,
        concat!("Alignment of ", stringify!(llvm_buffer_unique_ostream))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).OS) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_buffer_unique_ostream),
            "::",
            stringify!(OS)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Buffer) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_buffer_unique_ostream),
            "::",
            stringify!(Buffer)
        )
    );
}
extern "C" {
    #[doc = " This helper creates an output stream and then passes it to \\p Write.\n The stream created is based on the specified \\p OutputFileName:\n llvm::outs for \"-\", raw_null_ostream for \"/dev/null\", and raw_fd_ostream\n for other names. For raw_fd_ostream instances, the stream writes to\n a temporary file. The final output file is atomically replaced with the\n temporary file after the \\p Write function is finished."]
    #[link_name = "\u{1}_ZN4llvm13writeToOutputENS_9StringRefESt8functionIFNS_5ErrorERNS_11raw_ostreamEEE"]
    pub fn llvm_writeToOutput(OutputFileName: llvm_StringRef, Write: std_function) -> llvm_Error;
}
#[doc = " The access neither references nor modifies the value stored in memory."]
pub const llvm_ModRefInfo_NoModRef: llvm_ModRefInfo = 0;
#[doc = " The access may reference the value stored in memory."]
pub const llvm_ModRefInfo_Ref: llvm_ModRefInfo = 1;
#[doc = " The access may modify the value stored in memory."]
pub const llvm_ModRefInfo_Mod: llvm_ModRefInfo = 2;
#[doc = " The access may reference and may modify the value stored in memory."]
pub const llvm_ModRefInfo_ModRef: llvm_ModRefInfo = 3;
#[doc = " The access may reference and may modify the value stored in memory."]
pub const llvm_ModRefInfo_LLVM_BITMASK_LARGEST_ENUMERATOR: llvm_ModRefInfo = 3;
#[doc = " Flags indicating whether a memory access modifies or references memory.\n\n This is no access at all, a modification, a reference, or both\n a modification and a reference."]
pub type llvm_ModRefInfo = u8;
#[doc = " Access to memory via argument pointers."]
pub const llvm_IRMemLocation_ArgMem: llvm_IRMemLocation = 0;
#[doc = " Memory that is inaccessible via LLVM IR."]
pub const llvm_IRMemLocation_InaccessibleMem: llvm_IRMemLocation = 1;
#[doc = " Any other memory."]
pub const llvm_IRMemLocation_Other: llvm_IRMemLocation = 2;
#[doc = " Helpers to iterate all locations in the MemoryEffectsBase class."]
pub const llvm_IRMemLocation_First: llvm_IRMemLocation = 0;
#[doc = " Helpers to iterate all locations in the MemoryEffectsBase class."]
pub const llvm_IRMemLocation_Last: llvm_IRMemLocation = 2;
#[doc = " The locations at which a function might access memory."]
pub type llvm_IRMemLocation = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_MemoryEffectsBase {
    pub Data: u32,
}
pub type llvm_MemoryEffectsBase_Location<LocationEnum> = LocationEnum;
#[doc = " Summary of how a function affects memory in the program.\n\n Loads from constant globals are not considered memory accesses for this\n interface. Also, functions may freely modify stack space local to their\n invocation without having to report it through these interfaces."]
pub type llvm_MemoryEffects = llvm_MemoryEffectsBase;
pub type llvm_FunctionModRefBehavior = llvm_MemoryEffects;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_AttributeMask {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_AttributeImpl {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_AttributeListImpl {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_AttributeSetNode {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_ConstantRange {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_ConstantRangeList {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_FoldingSetNodeID {
    _unused: [u8; 0],
}
pub const llvm_AllocFnKind_Unknown: llvm_AllocFnKind = 0;
pub const llvm_AllocFnKind_Alloc: llvm_AllocFnKind = 1;
pub const llvm_AllocFnKind_Realloc: llvm_AllocFnKind = 2;
pub const llvm_AllocFnKind_Free: llvm_AllocFnKind = 4;
pub const llvm_AllocFnKind_Uninitialized: llvm_AllocFnKind = 8;
pub const llvm_AllocFnKind_Zeroed: llvm_AllocFnKind = 16;
pub const llvm_AllocFnKind_Aligned: llvm_AllocFnKind = 32;
pub const llvm_AllocFnKind_LLVM_BITMASK_LARGEST_ENUMERATOR: llvm_AllocFnKind = 32;
pub type llvm_AllocFnKind = u64;
#[doc = " \\class\n Functions, function parameters, and return types can have attributes\n to indicate how they should be treated by optimizations and code\n generation. This class represents one of those attributes. It's light-weight\n and should be passed around by-value."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_Attribute {
    pub pImpl: *mut llvm_AttributeImpl,
}
#[doc = "< No attributes have been set"]
pub const llvm_Attribute_AttrKind_None: llvm_Attribute_AttrKind = 0;
pub const llvm_Attribute_AttrKind_FirstEnumAttr: llvm_Attribute_AttrKind = 1;
pub const llvm_Attribute_AttrKind_AllocAlign: llvm_Attribute_AttrKind = 1;
pub const llvm_Attribute_AttrKind_AllocatedPointer: llvm_Attribute_AttrKind = 2;
pub const llvm_Attribute_AttrKind_AlwaysInline: llvm_Attribute_AttrKind = 3;
pub const llvm_Attribute_AttrKind_Builtin: llvm_Attribute_AttrKind = 4;
pub const llvm_Attribute_AttrKind_Cold: llvm_Attribute_AttrKind = 5;
pub const llvm_Attribute_AttrKind_Convergent: llvm_Attribute_AttrKind = 6;
pub const llvm_Attribute_AttrKind_CoroDestroyOnlyWhenComplete: llvm_Attribute_AttrKind = 7;
pub const llvm_Attribute_AttrKind_DeadOnUnwind: llvm_Attribute_AttrKind = 8;
pub const llvm_Attribute_AttrKind_DisableSanitizerInstrumentation: llvm_Attribute_AttrKind = 9;
pub const llvm_Attribute_AttrKind_FnRetThunkExtern: llvm_Attribute_AttrKind = 10;
pub const llvm_Attribute_AttrKind_Hot: llvm_Attribute_AttrKind = 11;
pub const llvm_Attribute_AttrKind_HybridPatchable: llvm_Attribute_AttrKind = 12;
pub const llvm_Attribute_AttrKind_ImmArg: llvm_Attribute_AttrKind = 13;
pub const llvm_Attribute_AttrKind_InReg: llvm_Attribute_AttrKind = 14;
pub const llvm_Attribute_AttrKind_InlineHint: llvm_Attribute_AttrKind = 15;
pub const llvm_Attribute_AttrKind_JumpTable: llvm_Attribute_AttrKind = 16;
pub const llvm_Attribute_AttrKind_MinSize: llvm_Attribute_AttrKind = 17;
pub const llvm_Attribute_AttrKind_MustProgress: llvm_Attribute_AttrKind = 18;
pub const llvm_Attribute_AttrKind_Naked: llvm_Attribute_AttrKind = 19;
pub const llvm_Attribute_AttrKind_Nest: llvm_Attribute_AttrKind = 20;
pub const llvm_Attribute_AttrKind_NoAlias: llvm_Attribute_AttrKind = 21;
pub const llvm_Attribute_AttrKind_NoBuiltin: llvm_Attribute_AttrKind = 22;
pub const llvm_Attribute_AttrKind_NoCallback: llvm_Attribute_AttrKind = 23;
pub const llvm_Attribute_AttrKind_NoCapture: llvm_Attribute_AttrKind = 24;
pub const llvm_Attribute_AttrKind_NoCfCheck: llvm_Attribute_AttrKind = 25;
pub const llvm_Attribute_AttrKind_NoDuplicate: llvm_Attribute_AttrKind = 26;
pub const llvm_Attribute_AttrKind_NoFree: llvm_Attribute_AttrKind = 27;
pub const llvm_Attribute_AttrKind_NoImplicitFloat: llvm_Attribute_AttrKind = 28;
pub const llvm_Attribute_AttrKind_NoInline: llvm_Attribute_AttrKind = 29;
pub const llvm_Attribute_AttrKind_NoMerge: llvm_Attribute_AttrKind = 30;
pub const llvm_Attribute_AttrKind_NoProfile: llvm_Attribute_AttrKind = 31;
pub const llvm_Attribute_AttrKind_NoRecurse: llvm_Attribute_AttrKind = 32;
pub const llvm_Attribute_AttrKind_NoRedZone: llvm_Attribute_AttrKind = 33;
pub const llvm_Attribute_AttrKind_NoReturn: llvm_Attribute_AttrKind = 34;
pub const llvm_Attribute_AttrKind_NoSanitizeBounds: llvm_Attribute_AttrKind = 35;
pub const llvm_Attribute_AttrKind_NoSanitizeCoverage: llvm_Attribute_AttrKind = 36;
pub const llvm_Attribute_AttrKind_NoSync: llvm_Attribute_AttrKind = 37;
pub const llvm_Attribute_AttrKind_NoUndef: llvm_Attribute_AttrKind = 38;
pub const llvm_Attribute_AttrKind_NoUnwind: llvm_Attribute_AttrKind = 39;
pub const llvm_Attribute_AttrKind_NonLazyBind: llvm_Attribute_AttrKind = 40;
pub const llvm_Attribute_AttrKind_NonNull: llvm_Attribute_AttrKind = 41;
pub const llvm_Attribute_AttrKind_NullPointerIsValid: llvm_Attribute_AttrKind = 42;
pub const llvm_Attribute_AttrKind_OptForFuzzing: llvm_Attribute_AttrKind = 43;
pub const llvm_Attribute_AttrKind_OptimizeForDebugging: llvm_Attribute_AttrKind = 44;
pub const llvm_Attribute_AttrKind_OptimizeForSize: llvm_Attribute_AttrKind = 45;
pub const llvm_Attribute_AttrKind_OptimizeNone: llvm_Attribute_AttrKind = 46;
pub const llvm_Attribute_AttrKind_PresplitCoroutine: llvm_Attribute_AttrKind = 47;
pub const llvm_Attribute_AttrKind_ReadNone: llvm_Attribute_AttrKind = 48;
pub const llvm_Attribute_AttrKind_ReadOnly: llvm_Attribute_AttrKind = 49;
pub const llvm_Attribute_AttrKind_Returned: llvm_Attribute_AttrKind = 50;
pub const llvm_Attribute_AttrKind_ReturnsTwice: llvm_Attribute_AttrKind = 51;
pub const llvm_Attribute_AttrKind_SExt: llvm_Attribute_AttrKind = 52;
pub const llvm_Attribute_AttrKind_SafeStack: llvm_Attribute_AttrKind = 53;
pub const llvm_Attribute_AttrKind_SanitizeAddress: llvm_Attribute_AttrKind = 54;
pub const llvm_Attribute_AttrKind_SanitizeHWAddress: llvm_Attribute_AttrKind = 55;
pub const llvm_Attribute_AttrKind_SanitizeMemTag: llvm_Attribute_AttrKind = 56;
pub const llvm_Attribute_AttrKind_SanitizeMemory: llvm_Attribute_AttrKind = 57;
pub const llvm_Attribute_AttrKind_SanitizeNumericalStability: llvm_Attribute_AttrKind = 58;
pub const llvm_Attribute_AttrKind_SanitizeRealtime: llvm_Attribute_AttrKind = 59;
pub const llvm_Attribute_AttrKind_SanitizeThread: llvm_Attribute_AttrKind = 60;
pub const llvm_Attribute_AttrKind_ShadowCallStack: llvm_Attribute_AttrKind = 61;
pub const llvm_Attribute_AttrKind_SkipProfile: llvm_Attribute_AttrKind = 62;
pub const llvm_Attribute_AttrKind_Speculatable: llvm_Attribute_AttrKind = 63;
pub const llvm_Attribute_AttrKind_SpeculativeLoadHardening: llvm_Attribute_AttrKind = 64;
pub const llvm_Attribute_AttrKind_StackProtect: llvm_Attribute_AttrKind = 65;
pub const llvm_Attribute_AttrKind_StackProtectReq: llvm_Attribute_AttrKind = 66;
pub const llvm_Attribute_AttrKind_StackProtectStrong: llvm_Attribute_AttrKind = 67;
pub const llvm_Attribute_AttrKind_StrictFP: llvm_Attribute_AttrKind = 68;
pub const llvm_Attribute_AttrKind_SwiftAsync: llvm_Attribute_AttrKind = 69;
pub const llvm_Attribute_AttrKind_SwiftError: llvm_Attribute_AttrKind = 70;
pub const llvm_Attribute_AttrKind_SwiftSelf: llvm_Attribute_AttrKind = 71;
pub const llvm_Attribute_AttrKind_WillReturn: llvm_Attribute_AttrKind = 72;
pub const llvm_Attribute_AttrKind_Writable: llvm_Attribute_AttrKind = 73;
pub const llvm_Attribute_AttrKind_WriteOnly: llvm_Attribute_AttrKind = 74;
pub const llvm_Attribute_AttrKind_ZExt: llvm_Attribute_AttrKind = 75;
pub const llvm_Attribute_AttrKind_LastEnumAttr: llvm_Attribute_AttrKind = 75;
pub const llvm_Attribute_AttrKind_FirstTypeAttr: llvm_Attribute_AttrKind = 76;
pub const llvm_Attribute_AttrKind_ByRef: llvm_Attribute_AttrKind = 76;
pub const llvm_Attribute_AttrKind_ByVal: llvm_Attribute_AttrKind = 77;
pub const llvm_Attribute_AttrKind_ElementType: llvm_Attribute_AttrKind = 78;
pub const llvm_Attribute_AttrKind_InAlloca: llvm_Attribute_AttrKind = 79;
pub const llvm_Attribute_AttrKind_Preallocated: llvm_Attribute_AttrKind = 80;
pub const llvm_Attribute_AttrKind_StructRet: llvm_Attribute_AttrKind = 81;
pub const llvm_Attribute_AttrKind_LastTypeAttr: llvm_Attribute_AttrKind = 81;
pub const llvm_Attribute_AttrKind_FirstIntAttr: llvm_Attribute_AttrKind = 82;
pub const llvm_Attribute_AttrKind_Alignment: llvm_Attribute_AttrKind = 82;
pub const llvm_Attribute_AttrKind_AllocKind: llvm_Attribute_AttrKind = 83;
pub const llvm_Attribute_AttrKind_AllocSize: llvm_Attribute_AttrKind = 84;
pub const llvm_Attribute_AttrKind_Dereferenceable: llvm_Attribute_AttrKind = 85;
pub const llvm_Attribute_AttrKind_DereferenceableOrNull: llvm_Attribute_AttrKind = 86;
pub const llvm_Attribute_AttrKind_Memory: llvm_Attribute_AttrKind = 87;
pub const llvm_Attribute_AttrKind_NoFPClass: llvm_Attribute_AttrKind = 88;
pub const llvm_Attribute_AttrKind_StackAlignment: llvm_Attribute_AttrKind = 89;
pub const llvm_Attribute_AttrKind_UWTable: llvm_Attribute_AttrKind = 90;
pub const llvm_Attribute_AttrKind_VScaleRange: llvm_Attribute_AttrKind = 91;
pub const llvm_Attribute_AttrKind_LastIntAttr: llvm_Attribute_AttrKind = 91;
pub const llvm_Attribute_AttrKind_FirstConstantRangeAttr: llvm_Attribute_AttrKind = 92;
pub const llvm_Attribute_AttrKind_Range: llvm_Attribute_AttrKind = 92;
pub const llvm_Attribute_AttrKind_LastConstantRangeAttr: llvm_Attribute_AttrKind = 92;
pub const llvm_Attribute_AttrKind_FirstConstantRangeListAttr: llvm_Attribute_AttrKind = 93;
pub const llvm_Attribute_AttrKind_Initializes: llvm_Attribute_AttrKind = 93;
pub const llvm_Attribute_AttrKind_LastConstantRangeListAttr: llvm_Attribute_AttrKind = 93;
#[doc = "< Sentinel value useful for loops"]
pub const llvm_Attribute_AttrKind_EndAttrKinds: llvm_Attribute_AttrKind = 94;
#[doc = "< Use as Empty key for DenseMap of AttrKind"]
pub const llvm_Attribute_AttrKind_EmptyKey: llvm_Attribute_AttrKind = 95;
#[doc = "< Use as Tombstone key for DenseMap of AttrKind"]
pub const llvm_Attribute_AttrKind_TombstoneKey: llvm_Attribute_AttrKind = 96;
#[doc = " This enumeration lists the attributes that can be associated with\n parameters, function results, or the function itself.\n\n Note: The `uwtable' attribute is about the ABI or the user mandating an\n entry in the unwind table. The `nounwind' attribute is about an exception\n passing by the function.\n\n In a theoretical system that uses tables for profiling and SjLj for\n exceptions, they would be fully independent. In a normal system that uses\n tables for both, the semantics are:\n\n nil                = Needs an entry because an exception might pass by.\n nounwind           = No need for an entry\n uwtable            = Needs an entry because the ABI says so and because\n                      an exception might pass by.\n uwtable + nounwind = Needs an entry because the ABI says so."]
pub type llvm_Attribute_AttrKind = ::std::os::raw::c_uint;
pub const llvm_Attribute_NumIntAttrKinds: ::std::os::raw::c_uint = 10;
pub const llvm_Attribute_NumTypeAttrKinds: ::std::os::raw::c_uint = 6;
#[test]
fn bindgen_test_layout_llvm_Attribute() {
    const UNINIT: ::std::mem::MaybeUninit<llvm_Attribute> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<llvm_Attribute>(),
        8usize,
        concat!("Size of: ", stringify!(llvm_Attribute))
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_Attribute>(),
        8usize,
        concat!("Alignment of ", stringify!(llvm_Attribute))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pImpl) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_Attribute),
            "::",
            stringify!(pImpl)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm9Attribute14canUseAsFnAttrENS0_8AttrKindE"]
    pub fn llvm_Attribute_canUseAsFnAttr(Kind: llvm_Attribute_AttrKind) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm9Attribute17canUseAsParamAttrENS0_8AttrKindE"]
    pub fn llvm_Attribute_canUseAsParamAttr(Kind: llvm_Attribute_AttrKind) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm9Attribute15canUseAsRetAttrENS0_8AttrKindE"]
    pub fn llvm_Attribute_canUseAsRetAttr(Kind: llvm_Attribute_AttrKind) -> bool;
}
extern "C" {
    #[doc = " Return a uniquified Attribute object."]
    #[link_name = "\u{1}_ZN4llvm9Attribute3getERNS_11LLVMContextENS0_8AttrKindEm"]
    pub fn llvm_Attribute_get(
        Context: *mut llvm_LLVMContext,
        Kind: llvm_Attribute_AttrKind,
        Val: u64,
    ) -> llvm_Attribute;
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm9Attribute3getERNS_11LLVMContextENS_9StringRefES3_"]
    pub fn llvm_Attribute_get1(
        Context: *mut llvm_LLVMContext,
        Kind: llvm_StringRef,
        Val: llvm_StringRef,
    ) -> llvm_Attribute;
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm9Attribute3getERNS_11LLVMContextENS0_8AttrKindEPNS_4TypeE"]
    pub fn llvm_Attribute_get2(
        Context: *mut llvm_LLVMContext,
        Kind: llvm_Attribute_AttrKind,
        Ty: *mut llvm_Type,
    ) -> llvm_Attribute;
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm9Attribute3getERNS_11LLVMContextENS0_8AttrKindERKNS_13ConstantRangeE"]
    pub fn llvm_Attribute_get3(
        Context: *mut llvm_LLVMContext,
        Kind: llvm_Attribute_AttrKind,
        CR: *const llvm_ConstantRange,
    ) -> llvm_Attribute;
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm9Attribute3getERNS_11LLVMContextENS0_8AttrKindENS_8ArrayRefINS_13ConstantRangeEEE"]
    pub fn llvm_Attribute_get4(
        Context: *mut llvm_LLVMContext,
        Kind: llvm_Attribute_AttrKind,
        Val: llvm_ArrayRef<llvm_ConstantRange>,
    ) -> llvm_Attribute;
}
extern "C" {
    #[doc = " Return a uniquified Attribute object that has the specific\n alignment set."]
    #[link_name = "\u{1}_ZN4llvm9Attribute16getWithAlignmentERNS_11LLVMContextENS_5AlignE"]
    pub fn llvm_Attribute_getWithAlignment(
        Context: *mut llvm_LLVMContext,
        Alignment: llvm_Align,
    ) -> llvm_Attribute;
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm9Attribute21getWithStackAlignmentERNS_11LLVMContextENS_5AlignE"]
    pub fn llvm_Attribute_getWithStackAlignment(
        Context: *mut llvm_LLVMContext,
        Alignment: llvm_Align,
    ) -> llvm_Attribute;
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm9Attribute27getWithDereferenceableBytesERNS_11LLVMContextEm"]
    pub fn llvm_Attribute_getWithDereferenceableBytes(
        Context: *mut llvm_LLVMContext,
        Bytes: u64,
    ) -> llvm_Attribute;
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm9Attribute33getWithDereferenceableOrNullBytesERNS_11LLVMContextEm"]
    pub fn llvm_Attribute_getWithDereferenceableOrNullBytes(
        Context: *mut llvm_LLVMContext,
        Bytes: u64,
    ) -> llvm_Attribute;
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm9Attribute20getWithAllocSizeArgsERNS_11LLVMContextEjRKSt8optionalIjE"]
    pub fn llvm_Attribute_getWithAllocSizeArgs(
        Context: *mut llvm_LLVMContext,
        ElemSizeArg: ::std::os::raw::c_uint,
        NumElemsArg: *const std_optional,
    ) -> llvm_Attribute;
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm9Attribute22getWithVScaleRangeArgsERNS_11LLVMContextEjj"]
    pub fn llvm_Attribute_getWithVScaleRangeArgs(
        Context: *mut llvm_LLVMContext,
        MinValue: ::std::os::raw::c_uint,
        MaxValue: ::std::os::raw::c_uint,
    ) -> llvm_Attribute;
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm9Attribute16getWithByValTypeERNS_11LLVMContextEPNS_4TypeE"]
    pub fn llvm_Attribute_getWithByValType(
        Context: *mut llvm_LLVMContext,
        Ty: *mut llvm_Type,
    ) -> llvm_Attribute;
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm9Attribute20getWithStructRetTypeERNS_11LLVMContextEPNS_4TypeE"]
    pub fn llvm_Attribute_getWithStructRetType(
        Context: *mut llvm_LLVMContext,
        Ty: *mut llvm_Type,
    ) -> llvm_Attribute;
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm9Attribute16getWithByRefTypeERNS_11LLVMContextEPNS_4TypeE"]
    pub fn llvm_Attribute_getWithByRefType(
        Context: *mut llvm_LLVMContext,
        Ty: *mut llvm_Type,
    ) -> llvm_Attribute;
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm9Attribute23getWithPreallocatedTypeERNS_11LLVMContextEPNS_4TypeE"]
    pub fn llvm_Attribute_getWithPreallocatedType(
        Context: *mut llvm_LLVMContext,
        Ty: *mut llvm_Type,
    ) -> llvm_Attribute;
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm9Attribute19getWithInAllocaTypeERNS_11LLVMContextEPNS_4TypeE"]
    pub fn llvm_Attribute_getWithInAllocaType(
        Context: *mut llvm_LLVMContext,
        Ty: *mut llvm_Type,
    ) -> llvm_Attribute;
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm9Attribute18getWithUWTableKindERNS_11LLVMContextENS_11UWTableKindE"]
    pub fn llvm_Attribute_getWithUWTableKind(
        Context: *mut llvm_LLVMContext,
        Kind: llvm_UWTableKind,
    ) -> llvm_Attribute;
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm9Attribute20getWithMemoryEffectsERNS_11LLVMContextENS_17MemoryEffectsBaseINS_13IRMemLocationEEE"]
    pub fn llvm_Attribute_getWithMemoryEffects(
        Context: *mut llvm_LLVMContext,
        ME: llvm_MemoryEffects,
    ) -> llvm_Attribute;
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm9Attribute16getWithNoFPClassERNS_11LLVMContextENS_11FPClassTestE"]
    pub fn llvm_Attribute_getWithNoFPClass(
        Context: *mut llvm_LLVMContext,
        Mask: llvm_FPClassTest,
    ) -> llvm_Attribute;
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm9Attribute19getAttrKindFromNameENS_9StringRefE"]
    pub fn llvm_Attribute_getAttrKindFromName(AttrName: llvm_StringRef) -> llvm_Attribute_AttrKind;
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm9Attribute19getNameFromAttrKindENS0_8AttrKindE"]
    pub fn llvm_Attribute_getNameFromAttrKind(AttrKind: llvm_Attribute_AttrKind) -> llvm_StringRef;
}
extern "C" {
    #[doc = " Return true if the provided string matches the IR name of an attribute.\n example: \"noalias\" return true but not \"NoAlias\""]
    #[link_name = "\u{1}_ZN4llvm9Attribute19isExistingAttributeENS_9StringRefE"]
    pub fn llvm_Attribute_isExistingAttribute(Name: llvm_StringRef) -> bool;
}
extern "C" {
    #[doc = " Return true if the attribute is an Attribute::AttrKind type."]
    #[link_name = "\u{1}_ZNK4llvm9Attribute15isEnumAttributeEv"]
    pub fn llvm_Attribute_isEnumAttribute(this: *const llvm_Attribute) -> bool;
}
extern "C" {
    #[doc = " Return true if the attribute is an integer attribute."]
    #[link_name = "\u{1}_ZNK4llvm9Attribute14isIntAttributeEv"]
    pub fn llvm_Attribute_isIntAttribute(this: *const llvm_Attribute) -> bool;
}
extern "C" {
    #[doc = " Return true if the attribute is a string (target-dependent)\n attribute."]
    #[link_name = "\u{1}_ZNK4llvm9Attribute17isStringAttributeEv"]
    pub fn llvm_Attribute_isStringAttribute(this: *const llvm_Attribute) -> bool;
}
extern "C" {
    #[doc = " Return true if the attribute is a type attribute."]
    #[link_name = "\u{1}_ZNK4llvm9Attribute15isTypeAttributeEv"]
    pub fn llvm_Attribute_isTypeAttribute(this: *const llvm_Attribute) -> bool;
}
extern "C" {
    #[doc = " Return true if the attribute is a ConstantRange attribute."]
    #[link_name = "\u{1}_ZNK4llvm9Attribute24isConstantRangeAttributeEv"]
    pub fn llvm_Attribute_isConstantRangeAttribute(this: *const llvm_Attribute) -> bool;
}
extern "C" {
    #[doc = " Return true if the attribute is a ConstantRangeList attribute."]
    #[link_name = "\u{1}_ZNK4llvm9Attribute28isConstantRangeListAttributeEv"]
    pub fn llvm_Attribute_isConstantRangeListAttribute(this: *const llvm_Attribute) -> bool;
}
extern "C" {
    #[doc = " Return true if the attribute is present."]
    #[link_name = "\u{1}_ZNK4llvm9Attribute12hasAttributeENS0_8AttrKindE"]
    pub fn llvm_Attribute_hasAttribute(
        this: *const llvm_Attribute,
        Val: llvm_Attribute_AttrKind,
    ) -> bool;
}
extern "C" {
    #[doc = " Return true if the target-dependent attribute is present."]
    #[link_name = "\u{1}_ZNK4llvm9Attribute12hasAttributeENS_9StringRefE"]
    pub fn llvm_Attribute_hasAttribute1(this: *const llvm_Attribute, Val: llvm_StringRef) -> bool;
}
extern "C" {
    #[doc = " Return the attribute's kind as an enum (Attribute::AttrKind). This\n requires the attribute to be an enum, integer, or type attribute."]
    #[link_name = "\u{1}_ZNK4llvm9Attribute13getKindAsEnumEv"]
    pub fn llvm_Attribute_getKindAsEnum(this: *const llvm_Attribute) -> llvm_Attribute_AttrKind;
}
extern "C" {
    #[doc = " Return the attribute's value as an integer. This requires that the\n attribute be an integer attribute."]
    #[link_name = "\u{1}_ZNK4llvm9Attribute13getValueAsIntEv"]
    pub fn llvm_Attribute_getValueAsInt(this: *const llvm_Attribute) -> u64;
}
extern "C" {
    #[doc = " Return the attribute's value as a boolean. This requires that the\n attribute be a string attribute."]
    #[link_name = "\u{1}_ZNK4llvm9Attribute14getValueAsBoolEv"]
    pub fn llvm_Attribute_getValueAsBool(this: *const llvm_Attribute) -> bool;
}
extern "C" {
    #[doc = " Return the attribute's kind as a string. This requires the\n attribute to be a string attribute."]
    #[link_name = "\u{1}_ZNK4llvm9Attribute15getKindAsStringEv"]
    pub fn llvm_Attribute_getKindAsString(this: *const llvm_Attribute) -> llvm_StringRef;
}
extern "C" {
    #[doc = " Return the attribute's value as a string. This requires the\n attribute to be a string attribute."]
    #[link_name = "\u{1}_ZNK4llvm9Attribute16getValueAsStringEv"]
    pub fn llvm_Attribute_getValueAsString(this: *const llvm_Attribute) -> llvm_StringRef;
}
extern "C" {
    #[doc = " Return the attribute's value as a Type. This requires the attribute to be\n a type attribute."]
    #[link_name = "\u{1}_ZNK4llvm9Attribute14getValueAsTypeEv"]
    pub fn llvm_Attribute_getValueAsType(this: *const llvm_Attribute) -> *mut llvm_Type;
}
extern "C" {
    #[doc = " Return the attribute's value as a ConstantRange. This requires the\n attribute to be a ConstantRange attribute."]
    #[link_name = "\u{1}_ZNK4llvm9Attribute23getValueAsConstantRangeEv"]
    pub fn llvm_Attribute_getValueAsConstantRange(
        this: *const llvm_Attribute,
    ) -> *const llvm_ConstantRange;
}
extern "C" {
    #[doc = " Return the attribute's value as a ConstantRange array. This requires the\n attribute to be a ConstantRangeList attribute."]
    #[link_name = "\u{1}_ZNK4llvm9Attribute27getValueAsConstantRangeListEv"]
    pub fn llvm_Attribute_getValueAsConstantRangeList(
        this: *const llvm_Attribute,
    ) -> llvm_ArrayRef<llvm_ConstantRange>;
}
extern "C" {
    #[doc = " Returns the alignment field of an attribute as a byte alignment\n value."]
    #[link_name = "\u{1}_ZNK4llvm9Attribute12getAlignmentEv"]
    pub fn llvm_Attribute_getAlignment(this: *const llvm_Attribute) -> llvm_MaybeAlign;
}
extern "C" {
    #[doc = " Returns the stack alignment field of an attribute as a byte\n alignment value."]
    #[link_name = "\u{1}_ZNK4llvm9Attribute17getStackAlignmentEv"]
    pub fn llvm_Attribute_getStackAlignment(this: *const llvm_Attribute) -> llvm_MaybeAlign;
}
extern "C" {
    #[doc = " Returns the number of dereferenceable bytes from the\n dereferenceable attribute."]
    #[link_name = "\u{1}_ZNK4llvm9Attribute23getDereferenceableBytesEv"]
    pub fn llvm_Attribute_getDereferenceableBytes(this: *const llvm_Attribute) -> u64;
}
extern "C" {
    #[doc = " Returns the number of dereferenceable_or_null bytes from the\n dereferenceable_or_null attribute."]
    #[link_name = "\u{1}_ZNK4llvm9Attribute29getDereferenceableOrNullBytesEv"]
    pub fn llvm_Attribute_getDereferenceableOrNullBytes(this: *const llvm_Attribute) -> u64;
}
extern "C" {
    #[doc = " Returns the argument numbers for the allocsize attribute."]
    #[link_name = "\u{1}_ZNK4llvm9Attribute16getAllocSizeArgsEv"]
    pub fn llvm_Attribute_getAllocSizeArgs(
        this: *const llvm_Attribute,
    ) -> std_pair<::std::os::raw::c_uint, std_optional>;
}
extern "C" {
    #[doc = " Returns the minimum value for the vscale_range attribute."]
    #[link_name = "\u{1}_ZNK4llvm9Attribute17getVScaleRangeMinEv"]
    pub fn llvm_Attribute_getVScaleRangeMin(this: *const llvm_Attribute) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " Returns the maximum value for the vscale_range attribute or std::nullopt\n when unknown."]
    #[link_name = "\u{1}_ZNK4llvm9Attribute17getVScaleRangeMaxEv"]
    pub fn llvm_Attribute_getVScaleRangeMax(this: *const llvm_Attribute) -> std_optional;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4llvm9Attribute14getUWTableKindEv"]
    pub fn llvm_Attribute_getUWTableKind(this: *const llvm_Attribute) -> llvm_UWTableKind;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4llvm9Attribute12getAllocKindEv"]
    pub fn llvm_Attribute_getAllocKind(this: *const llvm_Attribute) -> llvm_AllocFnKind;
}
extern "C" {
    #[doc = " Returns memory effects."]
    #[link_name = "\u{1}_ZNK4llvm9Attribute16getMemoryEffectsEv"]
    pub fn llvm_Attribute_getMemoryEffects(this: *const llvm_Attribute) -> llvm_MemoryEffects;
}
extern "C" {
    #[doc = " Return the FPClassTest for nofpclass"]
    #[link_name = "\u{1}_ZNK4llvm9Attribute12getNoFPClassEv"]
    pub fn llvm_Attribute_getNoFPClass(this: *const llvm_Attribute) -> llvm_FPClassTest;
}
extern "C" {
    #[doc = " Returns the value of the range attribute."]
    #[link_name = "\u{1}_ZNK4llvm9Attribute8getRangeEv"]
    pub fn llvm_Attribute_getRange(this: *const llvm_Attribute) -> *const llvm_ConstantRange;
}
extern "C" {
    #[doc = " Returns the value of the initializes attribute."]
    #[link_name = "\u{1}_ZNK4llvm9Attribute14getInitializesEv"]
    pub fn llvm_Attribute_getInitializes(
        this: *const llvm_Attribute,
    ) -> llvm_ArrayRef<llvm_ConstantRange>;
}
extern "C" {
    #[doc = " The Attribute is converted to a string of equivalent mnemonic. This\n is, presumably, for writing out the mnemonics for the assembly writer."]
    #[link_name = "\u{1}_ZNK4llvm9Attribute11getAsStringB5cxx11Eb"]
    pub fn llvm_Attribute_getAsString(this: *const llvm_Attribute, InAttrGrp: bool) -> std_string;
}
extern "C" {
    #[doc = " Return true if this attribute belongs to the LLVMContext."]
    #[link_name = "\u{1}_ZNK4llvm9Attribute16hasParentContextERNS_11LLVMContextE"]
    pub fn llvm_Attribute_hasParentContext(
        this: *const llvm_Attribute,
        C: *mut llvm_LLVMContext,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4llvm9Attribute7ProfileERNS_16FoldingSetNodeIDE"]
    pub fn llvm_Attribute_Profile(this: *const llvm_Attribute, ID: *mut llvm_FoldingSetNodeID);
}
impl llvm_Attribute {
    #[inline]
    pub unsafe fn canUseAsFnAttr(Kind: llvm_Attribute_AttrKind) -> bool {
        llvm_Attribute_canUseAsFnAttr(Kind)
    }
    #[inline]
    pub unsafe fn canUseAsParamAttr(Kind: llvm_Attribute_AttrKind) -> bool {
        llvm_Attribute_canUseAsParamAttr(Kind)
    }
    #[inline]
    pub unsafe fn canUseAsRetAttr(Kind: llvm_Attribute_AttrKind) -> bool {
        llvm_Attribute_canUseAsRetAttr(Kind)
    }
    #[inline]
    pub unsafe fn get(
        Context: *mut llvm_LLVMContext,
        Kind: llvm_Attribute_AttrKind,
        Val: u64,
    ) -> llvm_Attribute {
        llvm_Attribute_get(Context, Kind, Val)
    }
    #[inline]
    pub unsafe fn get1(
        Context: *mut llvm_LLVMContext,
        Kind: llvm_StringRef,
        Val: llvm_StringRef,
    ) -> llvm_Attribute {
        llvm_Attribute_get1(Context, Kind, Val)
    }
    #[inline]
    pub unsafe fn get2(
        Context: *mut llvm_LLVMContext,
        Kind: llvm_Attribute_AttrKind,
        Ty: *mut llvm_Type,
    ) -> llvm_Attribute {
        llvm_Attribute_get2(Context, Kind, Ty)
    }
    #[inline]
    pub unsafe fn get3(
        Context: *mut llvm_LLVMContext,
        Kind: llvm_Attribute_AttrKind,
        CR: *const llvm_ConstantRange,
    ) -> llvm_Attribute {
        llvm_Attribute_get3(Context, Kind, CR)
    }
    #[inline]
    pub unsafe fn get4(
        Context: *mut llvm_LLVMContext,
        Kind: llvm_Attribute_AttrKind,
        Val: llvm_ArrayRef<llvm_ConstantRange>,
    ) -> llvm_Attribute {
        llvm_Attribute_get4(Context, Kind, Val)
    }
    #[inline]
    pub unsafe fn getWithAlignment(
        Context: *mut llvm_LLVMContext,
        Alignment: llvm_Align,
    ) -> llvm_Attribute {
        llvm_Attribute_getWithAlignment(Context, Alignment)
    }
    #[inline]
    pub unsafe fn getWithStackAlignment(
        Context: *mut llvm_LLVMContext,
        Alignment: llvm_Align,
    ) -> llvm_Attribute {
        llvm_Attribute_getWithStackAlignment(Context, Alignment)
    }
    #[inline]
    pub unsafe fn getWithDereferenceableBytes(
        Context: *mut llvm_LLVMContext,
        Bytes: u64,
    ) -> llvm_Attribute {
        llvm_Attribute_getWithDereferenceableBytes(Context, Bytes)
    }
    #[inline]
    pub unsafe fn getWithDereferenceableOrNullBytes(
        Context: *mut llvm_LLVMContext,
        Bytes: u64,
    ) -> llvm_Attribute {
        llvm_Attribute_getWithDereferenceableOrNullBytes(Context, Bytes)
    }
    #[inline]
    pub unsafe fn getWithAllocSizeArgs(
        Context: *mut llvm_LLVMContext,
        ElemSizeArg: ::std::os::raw::c_uint,
        NumElemsArg: *const std_optional,
    ) -> llvm_Attribute {
        llvm_Attribute_getWithAllocSizeArgs(Context, ElemSizeArg, NumElemsArg)
    }
    #[inline]
    pub unsafe fn getWithVScaleRangeArgs(
        Context: *mut llvm_LLVMContext,
        MinValue: ::std::os::raw::c_uint,
        MaxValue: ::std::os::raw::c_uint,
    ) -> llvm_Attribute {
        llvm_Attribute_getWithVScaleRangeArgs(Context, MinValue, MaxValue)
    }
    #[inline]
    pub unsafe fn getWithByValType(
        Context: *mut llvm_LLVMContext,
        Ty: *mut llvm_Type,
    ) -> llvm_Attribute {
        llvm_Attribute_getWithByValType(Context, Ty)
    }
    #[inline]
    pub unsafe fn getWithStructRetType(
        Context: *mut llvm_LLVMContext,
        Ty: *mut llvm_Type,
    ) -> llvm_Attribute {
        llvm_Attribute_getWithStructRetType(Context, Ty)
    }
    #[inline]
    pub unsafe fn getWithByRefType(
        Context: *mut llvm_LLVMContext,
        Ty: *mut llvm_Type,
    ) -> llvm_Attribute {
        llvm_Attribute_getWithByRefType(Context, Ty)
    }
    #[inline]
    pub unsafe fn getWithPreallocatedType(
        Context: *mut llvm_LLVMContext,
        Ty: *mut llvm_Type,
    ) -> llvm_Attribute {
        llvm_Attribute_getWithPreallocatedType(Context, Ty)
    }
    #[inline]
    pub unsafe fn getWithInAllocaType(
        Context: *mut llvm_LLVMContext,
        Ty: *mut llvm_Type,
    ) -> llvm_Attribute {
        llvm_Attribute_getWithInAllocaType(Context, Ty)
    }
    #[inline]
    pub unsafe fn getWithUWTableKind(
        Context: *mut llvm_LLVMContext,
        Kind: llvm_UWTableKind,
    ) -> llvm_Attribute {
        llvm_Attribute_getWithUWTableKind(Context, Kind)
    }
    #[inline]
    pub unsafe fn getWithMemoryEffects(
        Context: *mut llvm_LLVMContext,
        ME: llvm_MemoryEffects,
    ) -> llvm_Attribute {
        llvm_Attribute_getWithMemoryEffects(Context, ME)
    }
    #[inline]
    pub unsafe fn getWithNoFPClass(
        Context: *mut llvm_LLVMContext,
        Mask: llvm_FPClassTest,
    ) -> llvm_Attribute {
        llvm_Attribute_getWithNoFPClass(Context, Mask)
    }
    #[inline]
    pub unsafe fn getAttrKindFromName(AttrName: llvm_StringRef) -> llvm_Attribute_AttrKind {
        llvm_Attribute_getAttrKindFromName(AttrName)
    }
    #[inline]
    pub unsafe fn getNameFromAttrKind(AttrKind: llvm_Attribute_AttrKind) -> llvm_StringRef {
        llvm_Attribute_getNameFromAttrKind(AttrKind)
    }
    #[inline]
    pub unsafe fn isExistingAttribute(Name: llvm_StringRef) -> bool {
        llvm_Attribute_isExistingAttribute(Name)
    }
    #[inline]
    pub unsafe fn isEnumAttribute(&self) -> bool {
        llvm_Attribute_isEnumAttribute(self)
    }
    #[inline]
    pub unsafe fn isIntAttribute(&self) -> bool {
        llvm_Attribute_isIntAttribute(self)
    }
    #[inline]
    pub unsafe fn isStringAttribute(&self) -> bool {
        llvm_Attribute_isStringAttribute(self)
    }
    #[inline]
    pub unsafe fn isTypeAttribute(&self) -> bool {
        llvm_Attribute_isTypeAttribute(self)
    }
    #[inline]
    pub unsafe fn isConstantRangeAttribute(&self) -> bool {
        llvm_Attribute_isConstantRangeAttribute(self)
    }
    #[inline]
    pub unsafe fn isConstantRangeListAttribute(&self) -> bool {
        llvm_Attribute_isConstantRangeListAttribute(self)
    }
    #[inline]
    pub unsafe fn hasAttribute(&self, Val: llvm_Attribute_AttrKind) -> bool {
        llvm_Attribute_hasAttribute(self, Val)
    }
    #[inline]
    pub unsafe fn hasAttribute1(&self, Val: llvm_StringRef) -> bool {
        llvm_Attribute_hasAttribute1(self, Val)
    }
    #[inline]
    pub unsafe fn getKindAsEnum(&self) -> llvm_Attribute_AttrKind {
        llvm_Attribute_getKindAsEnum(self)
    }
    #[inline]
    pub unsafe fn getValueAsInt(&self) -> u64 {
        llvm_Attribute_getValueAsInt(self)
    }
    #[inline]
    pub unsafe fn getValueAsBool(&self) -> bool {
        llvm_Attribute_getValueAsBool(self)
    }
    #[inline]
    pub unsafe fn getKindAsString(&self) -> llvm_StringRef {
        llvm_Attribute_getKindAsString(self)
    }
    #[inline]
    pub unsafe fn getValueAsString(&self) -> llvm_StringRef {
        llvm_Attribute_getValueAsString(self)
    }
    #[inline]
    pub unsafe fn getValueAsType(&self) -> *mut llvm_Type {
        llvm_Attribute_getValueAsType(self)
    }
    #[inline]
    pub unsafe fn getValueAsConstantRange(&self) -> *const llvm_ConstantRange {
        llvm_Attribute_getValueAsConstantRange(self)
    }
    #[inline]
    pub unsafe fn getValueAsConstantRangeList(&self) -> llvm_ArrayRef<llvm_ConstantRange> {
        llvm_Attribute_getValueAsConstantRangeList(self)
    }
    #[inline]
    pub unsafe fn getAlignment(&self) -> llvm_MaybeAlign {
        llvm_Attribute_getAlignment(self)
    }
    #[inline]
    pub unsafe fn getStackAlignment(&self) -> llvm_MaybeAlign {
        llvm_Attribute_getStackAlignment(self)
    }
    #[inline]
    pub unsafe fn getDereferenceableBytes(&self) -> u64 {
        llvm_Attribute_getDereferenceableBytes(self)
    }
    #[inline]
    pub unsafe fn getDereferenceableOrNullBytes(&self) -> u64 {
        llvm_Attribute_getDereferenceableOrNullBytes(self)
    }
    #[inline]
    pub unsafe fn getAllocSizeArgs(&self) -> std_pair<::std::os::raw::c_uint, std_optional> {
        llvm_Attribute_getAllocSizeArgs(self)
    }
    #[inline]
    pub unsafe fn getVScaleRangeMin(&self) -> ::std::os::raw::c_uint {
        llvm_Attribute_getVScaleRangeMin(self)
    }
    #[inline]
    pub unsafe fn getVScaleRangeMax(&self) -> std_optional {
        llvm_Attribute_getVScaleRangeMax(self)
    }
    #[inline]
    pub unsafe fn getUWTableKind(&self) -> llvm_UWTableKind {
        llvm_Attribute_getUWTableKind(self)
    }
    #[inline]
    pub unsafe fn getAllocKind(&self) -> llvm_AllocFnKind {
        llvm_Attribute_getAllocKind(self)
    }
    #[inline]
    pub unsafe fn getMemoryEffects(&self) -> llvm_MemoryEffects {
        llvm_Attribute_getMemoryEffects(self)
    }
    #[inline]
    pub unsafe fn getNoFPClass(&self) -> llvm_FPClassTest {
        llvm_Attribute_getNoFPClass(self)
    }
    #[inline]
    pub unsafe fn getRange(&self) -> *const llvm_ConstantRange {
        llvm_Attribute_getRange(self)
    }
    #[inline]
    pub unsafe fn getInitializes(&self) -> llvm_ArrayRef<llvm_ConstantRange> {
        llvm_Attribute_getInitializes(self)
    }
    #[inline]
    pub unsafe fn getAsString(&self, InAttrGrp: bool) -> std_string {
        llvm_Attribute_getAsString(self, InAttrGrp)
    }
    #[inline]
    pub unsafe fn hasParentContext(&self, C: *mut llvm_LLVMContext) -> bool {
        llvm_Attribute_hasParentContext(self, C)
    }
    #[inline]
    pub unsafe fn Profile(&self, ID: *mut llvm_FoldingSetNodeID) {
        llvm_Attribute_Profile(self, ID)
    }
}
#[doc = " \\class\n This class holds the attributes for a particular argument, parameter,\n function, or return value. It is an immutable value type that is cheap to\n copy. Adding and removing enum attributes is intended to be fast, but adding\n and removing string or integer attributes involves a FoldingSet lookup."]
#[repr(C)]
#[derive(Debug)]
pub struct llvm_AttributeSet {
    #[doc = " Private implementation pointer."]
    pub SetNode: *mut llvm_AttributeSetNode,
}
pub type llvm_AttributeSet_iterator = *const llvm_Attribute;
#[test]
fn bindgen_test_layout_llvm_AttributeSet() {
    const UNINIT: ::std::mem::MaybeUninit<llvm_AttributeSet> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<llvm_AttributeSet>(),
        8usize,
        concat!("Size of: ", stringify!(llvm_AttributeSet))
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_AttributeSet>(),
        8usize,
        concat!("Alignment of ", stringify!(llvm_AttributeSet))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).SetNode) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_AttributeSet),
            "::",
            stringify!(SetNode)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm12AttributeSet3getERNS_11LLVMContextERKNS_11AttrBuilderE"]
    pub fn llvm_AttributeSet_get(
        C: *mut llvm_LLVMContext,
        B: *const llvm_AttrBuilder,
    ) -> llvm_AttributeSet;
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm12AttributeSet3getERNS_11LLVMContextENS_8ArrayRefINS_9AttributeEEE"]
    pub fn llvm_AttributeSet_get1(
        C: *mut llvm_LLVMContext,
        Attrs: llvm_ArrayRef<llvm_Attribute>,
    ) -> llvm_AttributeSet;
}
extern "C" {
    #[doc = " Add an argument attribute. Returns a new set because attribute sets are\n immutable."]
    #[link_name = "\u{1}_ZNK4llvm12AttributeSet12addAttributeERNS_11LLVMContextENS_9Attribute8AttrKindE"]
    pub fn llvm_AttributeSet_addAttribute(
        this: *const llvm_AttributeSet,
        C: *mut llvm_LLVMContext,
        Kind: llvm_Attribute_AttrKind,
    ) -> llvm_AttributeSet;
}
extern "C" {
    #[doc = " Add a target-dependent attribute. Returns a new set because attribute sets\n are immutable."]
    #[link_name = "\u{1}_ZNK4llvm12AttributeSet12addAttributeERNS_11LLVMContextENS_9StringRefES3_"]
    pub fn llvm_AttributeSet_addAttribute1(
        this: *const llvm_AttributeSet,
        C: *mut llvm_LLVMContext,
        Kind: llvm_StringRef,
        Value: llvm_StringRef,
    ) -> llvm_AttributeSet;
}
extern "C" {
    #[doc = " Add attributes to the attribute set. Returns a new set because attribute\n sets are immutable."]
    #[link_name = "\u{1}_ZNK4llvm12AttributeSet13addAttributesERNS_11LLVMContextES0_"]
    pub fn llvm_AttributeSet_addAttributes(
        this: *const llvm_AttributeSet,
        C: *mut llvm_LLVMContext,
        AS: llvm_AttributeSet,
    ) -> llvm_AttributeSet;
}
extern "C" {
    #[doc = " Remove the specified attribute from this set. Returns a new set because\n attribute sets are immutable."]
    #[link_name = "\u{1}_ZNK4llvm12AttributeSet15removeAttributeERNS_11LLVMContextENS_9Attribute8AttrKindE"]
    pub fn llvm_AttributeSet_removeAttribute(
        this: *const llvm_AttributeSet,
        C: *mut llvm_LLVMContext,
        Kind: llvm_Attribute_AttrKind,
    ) -> llvm_AttributeSet;
}
extern "C" {
    #[doc = " Remove the specified attribute from this set. Returns a new set because\n attribute sets are immutable."]
    #[link_name = "\u{1}_ZNK4llvm12AttributeSet15removeAttributeERNS_11LLVMContextENS_9StringRefE"]
    pub fn llvm_AttributeSet_removeAttribute1(
        this: *const llvm_AttributeSet,
        C: *mut llvm_LLVMContext,
        Kind: llvm_StringRef,
    ) -> llvm_AttributeSet;
}
extern "C" {
    #[doc = " Remove the specified attributes from this set. Returns a new set because\n attribute sets are immutable."]
    #[link_name = "\u{1}_ZNK4llvm12AttributeSet16removeAttributesERNS_11LLVMContextERKNS_13AttributeMaskE"]
    pub fn llvm_AttributeSet_removeAttributes(
        this: *const llvm_AttributeSet,
        C: *mut llvm_LLVMContext,
        AttrsToRemove: *const llvm_AttributeMask,
    ) -> llvm_AttributeSet;
}
extern "C" {
    #[doc = " Return the number of attributes in this set."]
    #[link_name = "\u{1}_ZNK4llvm12AttributeSet16getNumAttributesEv"]
    pub fn llvm_AttributeSet_getNumAttributes(
        this: *const llvm_AttributeSet,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " Return true if the attribute exists in this set."]
    #[link_name = "\u{1}_ZNK4llvm12AttributeSet12hasAttributeENS_9Attribute8AttrKindE"]
    pub fn llvm_AttributeSet_hasAttribute(
        this: *const llvm_AttributeSet,
        Kind: llvm_Attribute_AttrKind,
    ) -> bool;
}
extern "C" {
    #[doc = " Return true if the attribute exists in this set."]
    #[link_name = "\u{1}_ZNK4llvm12AttributeSet12hasAttributeENS_9StringRefE"]
    pub fn llvm_AttributeSet_hasAttribute1(
        this: *const llvm_AttributeSet,
        Kind: llvm_StringRef,
    ) -> bool;
}
extern "C" {
    #[doc = " Return the attribute object."]
    #[link_name = "\u{1}_ZNK4llvm12AttributeSet12getAttributeENS_9Attribute8AttrKindE"]
    pub fn llvm_AttributeSet_getAttribute(
        this: *const llvm_AttributeSet,
        Kind: llvm_Attribute_AttrKind,
    ) -> llvm_Attribute;
}
extern "C" {
    #[doc = " Return the target-dependent attribute object."]
    #[link_name = "\u{1}_ZNK4llvm12AttributeSet12getAttributeENS_9StringRefE"]
    pub fn llvm_AttributeSet_getAttribute1(
        this: *const llvm_AttributeSet,
        Kind: llvm_StringRef,
    ) -> llvm_Attribute;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4llvm12AttributeSet12getAlignmentEv"]
    pub fn llvm_AttributeSet_getAlignment(this: *const llvm_AttributeSet) -> llvm_MaybeAlign;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4llvm12AttributeSet17getStackAlignmentEv"]
    pub fn llvm_AttributeSet_getStackAlignment(this: *const llvm_AttributeSet) -> llvm_MaybeAlign;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4llvm12AttributeSet23getDereferenceableBytesEv"]
    pub fn llvm_AttributeSet_getDereferenceableBytes(this: *const llvm_AttributeSet) -> u64;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4llvm12AttributeSet29getDereferenceableOrNullBytesEv"]
    pub fn llvm_AttributeSet_getDereferenceableOrNullBytes(this: *const llvm_AttributeSet) -> u64;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4llvm12AttributeSet12getByValTypeEv"]
    pub fn llvm_AttributeSet_getByValType(this: *const llvm_AttributeSet) -> *mut llvm_Type;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4llvm12AttributeSet16getStructRetTypeEv"]
    pub fn llvm_AttributeSet_getStructRetType(this: *const llvm_AttributeSet) -> *mut llvm_Type;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4llvm12AttributeSet12getByRefTypeEv"]
    pub fn llvm_AttributeSet_getByRefType(this: *const llvm_AttributeSet) -> *mut llvm_Type;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4llvm12AttributeSet19getPreallocatedTypeEv"]
    pub fn llvm_AttributeSet_getPreallocatedType(this: *const llvm_AttributeSet) -> *mut llvm_Type;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4llvm12AttributeSet15getInAllocaTypeEv"]
    pub fn llvm_AttributeSet_getInAllocaType(this: *const llvm_AttributeSet) -> *mut llvm_Type;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4llvm12AttributeSet14getElementTypeEv"]
    pub fn llvm_AttributeSet_getElementType(this: *const llvm_AttributeSet) -> *mut llvm_Type;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4llvm12AttributeSet16getAllocSizeArgsEv"]
    pub fn llvm_AttributeSet_getAllocSizeArgs(this: *const llvm_AttributeSet) -> std_optional;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4llvm12AttributeSet17getVScaleRangeMinEv"]
    pub fn llvm_AttributeSet_getVScaleRangeMin(
        this: *const llvm_AttributeSet,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4llvm12AttributeSet17getVScaleRangeMaxEv"]
    pub fn llvm_AttributeSet_getVScaleRangeMax(this: *const llvm_AttributeSet) -> std_optional;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4llvm12AttributeSet14getUWTableKindEv"]
    pub fn llvm_AttributeSet_getUWTableKind(this: *const llvm_AttributeSet) -> llvm_UWTableKind;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4llvm12AttributeSet12getAllocKindEv"]
    pub fn llvm_AttributeSet_getAllocKind(this: *const llvm_AttributeSet) -> llvm_AllocFnKind;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4llvm12AttributeSet16getMemoryEffectsEv"]
    pub fn llvm_AttributeSet_getMemoryEffects(this: *const llvm_AttributeSet)
        -> llvm_MemoryEffects;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4llvm12AttributeSet12getNoFPClassEv"]
    pub fn llvm_AttributeSet_getNoFPClass(this: *const llvm_AttributeSet) -> llvm_FPClassTest;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4llvm12AttributeSet11getAsStringB5cxx11Eb"]
    pub fn llvm_AttributeSet_getAsString(
        this: *const llvm_AttributeSet,
        InAttrGrp: bool,
    ) -> std_string;
}
extern "C" {
    #[doc = " Return true if this attribute set belongs to the LLVMContext."]
    #[link_name = "\u{1}_ZNK4llvm12AttributeSet16hasParentContextERNS_11LLVMContextE"]
    pub fn llvm_AttributeSet_hasParentContext(
        this: *const llvm_AttributeSet,
        C: *mut llvm_LLVMContext,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4llvm12AttributeSet5beginEv"]
    pub fn llvm_AttributeSet_begin(this: *const llvm_AttributeSet) -> llvm_AttributeSet_iterator;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4llvm12AttributeSet3endEv"]
    pub fn llvm_AttributeSet_end(this: *const llvm_AttributeSet) -> llvm_AttributeSet_iterator;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4llvm12AttributeSet4dumpEv"]
    pub fn llvm_AttributeSet_dump(this: *const llvm_AttributeSet);
}
impl llvm_AttributeSet {
    #[inline]
    pub unsafe fn get(C: *mut llvm_LLVMContext, B: *const llvm_AttrBuilder) -> llvm_AttributeSet {
        llvm_AttributeSet_get(C, B)
    }
    #[inline]
    pub unsafe fn get1(
        C: *mut llvm_LLVMContext,
        Attrs: llvm_ArrayRef<llvm_Attribute>,
    ) -> llvm_AttributeSet {
        llvm_AttributeSet_get1(C, Attrs)
    }
    #[inline]
    pub unsafe fn addAttribute(
        &self,
        C: *mut llvm_LLVMContext,
        Kind: llvm_Attribute_AttrKind,
    ) -> llvm_AttributeSet {
        llvm_AttributeSet_addAttribute(self, C, Kind)
    }
    #[inline]
    pub unsafe fn addAttribute1(
        &self,
        C: *mut llvm_LLVMContext,
        Kind: llvm_StringRef,
        Value: llvm_StringRef,
    ) -> llvm_AttributeSet {
        llvm_AttributeSet_addAttribute1(self, C, Kind, Value)
    }
    #[inline]
    pub unsafe fn addAttributes(
        &self,
        C: *mut llvm_LLVMContext,
        AS: llvm_AttributeSet,
    ) -> llvm_AttributeSet {
        llvm_AttributeSet_addAttributes(self, C, AS)
    }
    #[inline]
    pub unsafe fn removeAttribute(
        &self,
        C: *mut llvm_LLVMContext,
        Kind: llvm_Attribute_AttrKind,
    ) -> llvm_AttributeSet {
        llvm_AttributeSet_removeAttribute(self, C, Kind)
    }
    #[inline]
    pub unsafe fn removeAttribute1(
        &self,
        C: *mut llvm_LLVMContext,
        Kind: llvm_StringRef,
    ) -> llvm_AttributeSet {
        llvm_AttributeSet_removeAttribute1(self, C, Kind)
    }
    #[inline]
    pub unsafe fn removeAttributes(
        &self,
        C: *mut llvm_LLVMContext,
        AttrsToRemove: *const llvm_AttributeMask,
    ) -> llvm_AttributeSet {
        llvm_AttributeSet_removeAttributes(self, C, AttrsToRemove)
    }
    #[inline]
    pub unsafe fn getNumAttributes(&self) -> ::std::os::raw::c_uint {
        llvm_AttributeSet_getNumAttributes(self)
    }
    #[inline]
    pub unsafe fn hasAttribute(&self, Kind: llvm_Attribute_AttrKind) -> bool {
        llvm_AttributeSet_hasAttribute(self, Kind)
    }
    #[inline]
    pub unsafe fn hasAttribute1(&self, Kind: llvm_StringRef) -> bool {
        llvm_AttributeSet_hasAttribute1(self, Kind)
    }
    #[inline]
    pub unsafe fn getAttribute(&self, Kind: llvm_Attribute_AttrKind) -> llvm_Attribute {
        llvm_AttributeSet_getAttribute(self, Kind)
    }
    #[inline]
    pub unsafe fn getAttribute1(&self, Kind: llvm_StringRef) -> llvm_Attribute {
        llvm_AttributeSet_getAttribute1(self, Kind)
    }
    #[inline]
    pub unsafe fn getAlignment(&self) -> llvm_MaybeAlign {
        llvm_AttributeSet_getAlignment(self)
    }
    #[inline]
    pub unsafe fn getStackAlignment(&self) -> llvm_MaybeAlign {
        llvm_AttributeSet_getStackAlignment(self)
    }
    #[inline]
    pub unsafe fn getDereferenceableBytes(&self) -> u64 {
        llvm_AttributeSet_getDereferenceableBytes(self)
    }
    #[inline]
    pub unsafe fn getDereferenceableOrNullBytes(&self) -> u64 {
        llvm_AttributeSet_getDereferenceableOrNullBytes(self)
    }
    #[inline]
    pub unsafe fn getByValType(&self) -> *mut llvm_Type {
        llvm_AttributeSet_getByValType(self)
    }
    #[inline]
    pub unsafe fn getStructRetType(&self) -> *mut llvm_Type {
        llvm_AttributeSet_getStructRetType(self)
    }
    #[inline]
    pub unsafe fn getByRefType(&self) -> *mut llvm_Type {
        llvm_AttributeSet_getByRefType(self)
    }
    #[inline]
    pub unsafe fn getPreallocatedType(&self) -> *mut llvm_Type {
        llvm_AttributeSet_getPreallocatedType(self)
    }
    #[inline]
    pub unsafe fn getInAllocaType(&self) -> *mut llvm_Type {
        llvm_AttributeSet_getInAllocaType(self)
    }
    #[inline]
    pub unsafe fn getElementType(&self) -> *mut llvm_Type {
        llvm_AttributeSet_getElementType(self)
    }
    #[inline]
    pub unsafe fn getAllocSizeArgs(&self) -> std_optional {
        llvm_AttributeSet_getAllocSizeArgs(self)
    }
    #[inline]
    pub unsafe fn getVScaleRangeMin(&self) -> ::std::os::raw::c_uint {
        llvm_AttributeSet_getVScaleRangeMin(self)
    }
    #[inline]
    pub unsafe fn getVScaleRangeMax(&self) -> std_optional {
        llvm_AttributeSet_getVScaleRangeMax(self)
    }
    #[inline]
    pub unsafe fn getUWTableKind(&self) -> llvm_UWTableKind {
        llvm_AttributeSet_getUWTableKind(self)
    }
    #[inline]
    pub unsafe fn getAllocKind(&self) -> llvm_AllocFnKind {
        llvm_AttributeSet_getAllocKind(self)
    }
    #[inline]
    pub unsafe fn getMemoryEffects(&self) -> llvm_MemoryEffects {
        llvm_AttributeSet_getMemoryEffects(self)
    }
    #[inline]
    pub unsafe fn getNoFPClass(&self) -> llvm_FPClassTest {
        llvm_AttributeSet_getNoFPClass(self)
    }
    #[inline]
    pub unsafe fn getAsString(&self, InAttrGrp: bool) -> std_string {
        llvm_AttributeSet_getAsString(self, InAttrGrp)
    }
    #[inline]
    pub unsafe fn hasParentContext(&self, C: *mut llvm_LLVMContext) -> bool {
        llvm_AttributeSet_hasParentContext(self, C)
    }
    #[inline]
    pub unsafe fn begin(&self) -> llvm_AttributeSet_iterator {
        llvm_AttributeSet_begin(self)
    }
    #[inline]
    pub unsafe fn end(&self) -> llvm_AttributeSet_iterator {
        llvm_AttributeSet_end(self)
    }
    #[inline]
    pub unsafe fn dump(&self) {
        llvm_AttributeSet_dump(self)
    }
}
#[test]
fn __bindgen_test_layout_llvm_DenseMapInfo_open0_llvm_AttributeSet_void_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<llvm_DenseMapInfo>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_DenseMapInfo)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_DenseMapInfo>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_DenseMapInfo)
        )
    );
}
#[doc = " \\class\n This class holds the attributes for a function, its return value, and\n its parameters. You access the attributes for each of them via an index into\n the AttributeList object. The function attributes are at index\n `AttributeList::FunctionIndex', the return value is at index\n `AttributeList::ReturnIndex', and the attributes for the parameters start at\n index `AttributeList::FirstArgIndex'."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_AttributeList {
    #[doc = " The attributes that we are managing. This can be null to represent\n the empty attributes list."]
    pub pImpl: *mut llvm_AttributeListImpl,
}
pub const llvm_AttributeList_AttrIndex_ReturnIndex: llvm_AttributeList_AttrIndex = 0;
pub const llvm_AttributeList_AttrIndex_FunctionIndex: llvm_AttributeList_AttrIndex = 4294967295;
pub const llvm_AttributeList_AttrIndex_FirstArgIndex: llvm_AttributeList_AttrIndex = 1;
pub type llvm_AttributeList_AttrIndex = ::std::os::raw::c_uint;
pub type llvm_AttributeList_iterator = *const llvm_AttributeSet;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_AttributeList_index_iterator {
    pub NumAttrSets: ::std::os::raw::c_uint,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_AttributeList_index_iterator_int_wrapper {
    pub i: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_llvm_AttributeList_index_iterator_int_wrapper() {
    const UNINIT: ::std::mem::MaybeUninit<llvm_AttributeList_index_iterator_int_wrapper> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<llvm_AttributeList_index_iterator_int_wrapper>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(llvm_AttributeList_index_iterator_int_wrapper)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_AttributeList_index_iterator_int_wrapper>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(llvm_AttributeList_index_iterator_int_wrapper)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).i) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_AttributeList_index_iterator_int_wrapper),
            "::",
            stringify!(i)
        )
    );
}
#[test]
fn bindgen_test_layout_llvm_AttributeList_index_iterator() {
    const UNINIT: ::std::mem::MaybeUninit<llvm_AttributeList_index_iterator> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<llvm_AttributeList_index_iterator>(),
        4usize,
        concat!("Size of: ", stringify!(llvm_AttributeList_index_iterator))
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_AttributeList_index_iterator>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(llvm_AttributeList_index_iterator)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).NumAttrSets) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_AttributeList_index_iterator),
            "::",
            stringify!(NumAttrSets)
        )
    );
}
#[test]
fn bindgen_test_layout_llvm_AttributeList() {
    const UNINIT: ::std::mem::MaybeUninit<llvm_AttributeList> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<llvm_AttributeList>(),
        8usize,
        concat!("Size of: ", stringify!(llvm_AttributeList))
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_AttributeList>(),
        8usize,
        concat!("Alignment of ", stringify!(llvm_AttributeList))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pImpl) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_AttributeList),
            "::",
            stringify!(pImpl)
        )
    );
}
extern "C" {
    #[doc = " Create an AttributeList with the specified parameters in it."]
    #[link_name = "\u{1}_ZN4llvm13AttributeList3getERNS_11LLVMContextENS_8ArrayRefISt4pairIjNS_9AttributeEEEE"]
    pub fn llvm_AttributeList_get(
        C: *mut llvm_LLVMContext,
        Attrs: llvm_ArrayRef<std_pair<::std::os::raw::c_uint, llvm_Attribute>>,
    ) -> llvm_AttributeList;
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm13AttributeList3getERNS_11LLVMContextENS_8ArrayRefISt4pairIjNS_12AttributeSetEEEE"]
    pub fn llvm_AttributeList_get1(
        C: *mut llvm_LLVMContext,
        Attrs: llvm_ArrayRef<std_pair<::std::os::raw::c_uint, llvm_AttributeSet>>,
    ) -> llvm_AttributeList;
}
extern "C" {
    #[doc = " Create an AttributeList from attribute sets for a function, its\n return value, and all of its arguments."]
    #[link_name = "\u{1}_ZN4llvm13AttributeList3getERNS_11LLVMContextENS_12AttributeSetES3_NS_8ArrayRefIS3_EE"]
    pub fn llvm_AttributeList_get2(
        C: *mut llvm_LLVMContext,
        FnAttrs: llvm_AttributeSet,
        RetAttrs: llvm_AttributeSet,
        ArgAttrs: llvm_ArrayRef<llvm_AttributeSet>,
    ) -> llvm_AttributeList;
}
extern "C" {
    #[doc = " Return an AttributeList with the specified parameters in it."]
    #[link_name = "\u{1}_ZN4llvm13AttributeList3getERNS_11LLVMContextENS_8ArrayRefIS0_EE"]
    pub fn llvm_AttributeList_get3(
        C: *mut llvm_LLVMContext,
        Attrs: llvm_ArrayRef<llvm_AttributeList>,
    ) -> llvm_AttributeList;
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm13AttributeList3getERNS_11LLVMContextEjNS_8ArrayRefINS_9Attribute8AttrKindEEE"]
    pub fn llvm_AttributeList_get4(
        C: *mut llvm_LLVMContext,
        Index: ::std::os::raw::c_uint,
        Kinds: llvm_ArrayRef<llvm_Attribute_AttrKind>,
    ) -> llvm_AttributeList;
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm13AttributeList3getERNS_11LLVMContextEjNS_8ArrayRefINS_9Attribute8AttrKindEEENS3_ImEE"]
    pub fn llvm_AttributeList_get5(
        C: *mut llvm_LLVMContext,
        Index: ::std::os::raw::c_uint,
        Kinds: llvm_ArrayRef<llvm_Attribute_AttrKind>,
        Values: llvm_ArrayRef<u64>,
    ) -> llvm_AttributeList;
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm13AttributeList3getERNS_11LLVMContextEjNS_8ArrayRefINS_9StringRefEEE"]
    pub fn llvm_AttributeList_get6(
        C: *mut llvm_LLVMContext,
        Index: ::std::os::raw::c_uint,
        Kind: llvm_ArrayRef<llvm_StringRef>,
    ) -> llvm_AttributeList;
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm13AttributeList3getERNS_11LLVMContextEjNS_12AttributeSetE"]
    pub fn llvm_AttributeList_get7(
        C: *mut llvm_LLVMContext,
        Index: ::std::os::raw::c_uint,
        Attrs: llvm_AttributeSet,
    ) -> llvm_AttributeList;
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm13AttributeList3getERNS_11LLVMContextEjRKNS_11AttrBuilderE"]
    pub fn llvm_AttributeList_get8(
        C: *mut llvm_LLVMContext,
        Index: ::std::os::raw::c_uint,
        B: *const llvm_AttrBuilder,
    ) -> llvm_AttributeList;
}
extern "C" {
    #[doc = " Add an attribute to the attribute set at the given index.\n Returns a new list because attribute lists are immutable."]
    #[link_name = "\u{1}_ZNK4llvm13AttributeList19addAttributeAtIndexERNS_11LLVMContextEjNS_9Attribute8AttrKindE"]
    pub fn llvm_AttributeList_addAttributeAtIndex(
        this: *const llvm_AttributeList,
        C: *mut llvm_LLVMContext,
        Index: ::std::os::raw::c_uint,
        Kind: llvm_Attribute_AttrKind,
    ) -> llvm_AttributeList;
}
extern "C" {
    #[doc = " Add an attribute to the attribute set at the given index.\n Returns a new list because attribute lists are immutable."]
    #[link_name = "\u{1}_ZNK4llvm13AttributeList19addAttributeAtIndexERNS_11LLVMContextEjNS_9StringRefES3_"]
    pub fn llvm_AttributeList_addAttributeAtIndex1(
        this: *const llvm_AttributeList,
        C: *mut llvm_LLVMContext,
        Index: ::std::os::raw::c_uint,
        Kind: llvm_StringRef,
        Value: llvm_StringRef,
    ) -> llvm_AttributeList;
}
extern "C" {
    #[doc = " Add an attribute to the attribute set at the given index.\n Returns a new list because attribute lists are immutable."]
    #[link_name = "\u{1}_ZNK4llvm13AttributeList19addAttributeAtIndexERNS_11LLVMContextEjNS_9AttributeE"]
    pub fn llvm_AttributeList_addAttributeAtIndex2(
        this: *const llvm_AttributeList,
        C: *mut llvm_LLVMContext,
        Index: ::std::os::raw::c_uint,
        A: llvm_Attribute,
    ) -> llvm_AttributeList;
}
extern "C" {
    #[doc = " Add attributes to the attribute set at the given index.\n Returns a new list because attribute lists are immutable."]
    #[link_name = "\u{1}_ZNK4llvm13AttributeList20addAttributesAtIndexERNS_11LLVMContextEjRKNS_11AttrBuilderE"]
    pub fn llvm_AttributeList_addAttributesAtIndex(
        this: *const llvm_AttributeList,
        C: *mut llvm_LLVMContext,
        Index: ::std::os::raw::c_uint,
        B: *const llvm_AttrBuilder,
    ) -> llvm_AttributeList;
}
extern "C" {
    #[doc = " Add an attribute to the attribute list at the given arg indices. Returns a\n new list because attribute lists are immutable."]
    #[link_name = "\u{1}_ZNK4llvm13AttributeList17addParamAttributeERNS_11LLVMContextENS_8ArrayRefIjEENS_9AttributeE"]
    pub fn llvm_AttributeList_addParamAttribute(
        this: *const llvm_AttributeList,
        C: *mut llvm_LLVMContext,
        ArgNos: llvm_ArrayRef<::std::os::raw::c_uint>,
        A: llvm_Attribute,
    ) -> llvm_AttributeList;
}
extern "C" {
    #[doc = " Remove the specified attribute at the specified index from this\n attribute list. Returns a new list because attribute lists are immutable."]
    #[link_name = "\u{1}_ZNK4llvm13AttributeList22removeAttributeAtIndexERNS_11LLVMContextEjNS_9Attribute8AttrKindE"]
    pub fn llvm_AttributeList_removeAttributeAtIndex(
        this: *const llvm_AttributeList,
        C: *mut llvm_LLVMContext,
        Index: ::std::os::raw::c_uint,
        Kind: llvm_Attribute_AttrKind,
    ) -> llvm_AttributeList;
}
extern "C" {
    #[doc = " Remove the specified attribute at the specified index from this\n attribute list. Returns a new list because attribute lists are immutable."]
    #[link_name = "\u{1}_ZNK4llvm13AttributeList22removeAttributeAtIndexERNS_11LLVMContextEjNS_9StringRefE"]
    pub fn llvm_AttributeList_removeAttributeAtIndex1(
        this: *const llvm_AttributeList,
        C: *mut llvm_LLVMContext,
        Index: ::std::os::raw::c_uint,
        Kind: llvm_StringRef,
    ) -> llvm_AttributeList;
}
extern "C" {
    #[doc = " Remove the specified attributes at the specified index from this\n attribute list. Returns a new list because attribute lists are immutable."]
    #[link_name = "\u{1}_ZNK4llvm13AttributeList23removeAttributesAtIndexERNS_11LLVMContextEjRKNS_13AttributeMaskE"]
    pub fn llvm_AttributeList_removeAttributesAtIndex(
        this: *const llvm_AttributeList,
        C: *mut llvm_LLVMContext,
        Index: ::std::os::raw::c_uint,
        AttrsToRemove: *const llvm_AttributeMask,
    ) -> llvm_AttributeList;
}
extern "C" {
    #[doc = " Remove all attributes at the specified index from this\n attribute list. Returns a new list because attribute lists are immutable."]
    #[link_name = "\u{1}_ZNK4llvm13AttributeList23removeAttributesAtIndexERNS_11LLVMContextEj"]
    pub fn llvm_AttributeList_removeAttributesAtIndex1(
        this: *const llvm_AttributeList,
        C: *mut llvm_LLVMContext,
        Index: ::std::os::raw::c_uint,
    ) -> llvm_AttributeList;
}
extern "C" {
    #[doc = " \\brief Add the dereferenceable attribute to the attribute set at the given\n index. Returns a new list because attribute lists are immutable."]
    #[link_name = "\u{1}_ZNK4llvm13AttributeList25addDereferenceableRetAttrERNS_11LLVMContextEm"]
    pub fn llvm_AttributeList_addDereferenceableRetAttr(
        this: *const llvm_AttributeList,
        C: *mut llvm_LLVMContext,
        Bytes: u64,
    ) -> llvm_AttributeList;
}
extern "C" {
    #[doc = " \\brief Add the dereferenceable attribute to the attribute set at the given\n arg index. Returns a new list because attribute lists are immutable."]
    #[link_name = "\u{1}_ZNK4llvm13AttributeList27addDereferenceableParamAttrERNS_11LLVMContextEjm"]
    pub fn llvm_AttributeList_addDereferenceableParamAttr(
        this: *const llvm_AttributeList,
        C: *mut llvm_LLVMContext,
        ArgNo: ::std::os::raw::c_uint,
        Bytes: u64,
    ) -> llvm_AttributeList;
}
extern "C" {
    #[doc = " Add the dereferenceable_or_null attribute to the attribute set at\n the given arg index. Returns a new list because attribute lists are\n immutable."]
    #[link_name = "\u{1}_ZNK4llvm13AttributeList33addDereferenceableOrNullParamAttrERNS_11LLVMContextEjm"]
    pub fn llvm_AttributeList_addDereferenceableOrNullParamAttr(
        this: *const llvm_AttributeList,
        C: *mut llvm_LLVMContext,
        ArgNo: ::std::os::raw::c_uint,
        Bytes: u64,
    ) -> llvm_AttributeList;
}
extern "C" {
    #[doc = " Add the range attribute to the attribute set at the return value index.\n Returns a new list because attribute lists are immutable."]
    #[link_name = "\u{1}_ZNK4llvm13AttributeList15addRangeRetAttrERNS_11LLVMContextERKNS_13ConstantRangeE"]
    pub fn llvm_AttributeList_addRangeRetAttr(
        this: *const llvm_AttributeList,
        C: *mut llvm_LLVMContext,
        CR: *const llvm_ConstantRange,
    ) -> llvm_AttributeList;
}
extern "C" {
    #[doc = " Add the allocsize attribute to the attribute set at the given arg index.\n Returns a new list because attribute lists are immutable."]
    #[link_name = "\u{1}_ZN4llvm13AttributeList21addAllocSizeParamAttrERNS_11LLVMContextEjjRKSt8optionalIjE"]
    pub fn llvm_AttributeList_addAllocSizeParamAttr(
        this: *mut llvm_AttributeList,
        C: *mut llvm_LLVMContext,
        ArgNo: ::std::os::raw::c_uint,
        ElemSizeArg: ::std::os::raw::c_uint,
        NumElemsArg: *const std_optional,
    ) -> llvm_AttributeList;
}
extern "C" {
    #[doc = " The attributes for the specified index are returned."]
    #[link_name = "\u{1}_ZNK4llvm13AttributeList13getAttributesEj"]
    pub fn llvm_AttributeList_getAttributes(
        this: *const llvm_AttributeList,
        Index: ::std::os::raw::c_uint,
    ) -> llvm_AttributeSet;
}
extern "C" {
    #[doc = " The attributes for the argument or parameter at the given index are\n returned."]
    #[link_name = "\u{1}_ZNK4llvm13AttributeList13getParamAttrsEj"]
    pub fn llvm_AttributeList_getParamAttrs(
        this: *const llvm_AttributeList,
        ArgNo: ::std::os::raw::c_uint,
    ) -> llvm_AttributeSet;
}
extern "C" {
    #[doc = " The attributes for the ret value are returned."]
    #[link_name = "\u{1}_ZNK4llvm13AttributeList11getRetAttrsEv"]
    pub fn llvm_AttributeList_getRetAttrs(this: *const llvm_AttributeList) -> llvm_AttributeSet;
}
extern "C" {
    #[doc = " The function attributes are returned."]
    #[link_name = "\u{1}_ZNK4llvm13AttributeList10getFnAttrsEv"]
    pub fn llvm_AttributeList_getFnAttrs(this: *const llvm_AttributeList) -> llvm_AttributeSet;
}
extern "C" {
    #[doc = " Return true if the attribute exists at the given index."]
    #[link_name = "\u{1}_ZNK4llvm13AttributeList19hasAttributeAtIndexEjNS_9Attribute8AttrKindE"]
    pub fn llvm_AttributeList_hasAttributeAtIndex(
        this: *const llvm_AttributeList,
        Index: ::std::os::raw::c_uint,
        Kind: llvm_Attribute_AttrKind,
    ) -> bool;
}
extern "C" {
    #[doc = " Return true if the attribute exists at the given index."]
    #[link_name = "\u{1}_ZNK4llvm13AttributeList19hasAttributeAtIndexEjNS_9StringRefE"]
    pub fn llvm_AttributeList_hasAttributeAtIndex1(
        this: *const llvm_AttributeList,
        Index: ::std::os::raw::c_uint,
        Kind: llvm_StringRef,
    ) -> bool;
}
extern "C" {
    #[doc = " Return true if attribute exists at the given index."]
    #[link_name = "\u{1}_ZNK4llvm13AttributeList20hasAttributesAtIndexEj"]
    pub fn llvm_AttributeList_hasAttributesAtIndex(
        this: *const llvm_AttributeList,
        Index: ::std::os::raw::c_uint,
    ) -> bool;
}
extern "C" {
    #[doc = " Return true if the attribute exists for the function."]
    #[link_name = "\u{1}_ZNK4llvm13AttributeList9hasFnAttrENS_9Attribute8AttrKindE"]
    pub fn llvm_AttributeList_hasFnAttr(
        this: *const llvm_AttributeList,
        Kind: llvm_Attribute_AttrKind,
    ) -> bool;
}
extern "C" {
    #[doc = " Return true if the attribute exists for the function."]
    #[link_name = "\u{1}_ZNK4llvm13AttributeList9hasFnAttrENS_9StringRefE"]
    pub fn llvm_AttributeList_hasFnAttr1(
        this: *const llvm_AttributeList,
        Kind: llvm_StringRef,
    ) -> bool;
}
extern "C" {
    #[doc = " Return true if the specified attribute is set for at least one\n parameter or for the return value. If Index is not nullptr, the index\n of a parameter with the specified attribute is provided."]
    #[link_name = "\u{1}_ZNK4llvm13AttributeList16hasAttrSomewhereENS_9Attribute8AttrKindEPj"]
    pub fn llvm_AttributeList_hasAttrSomewhere(
        this: *const llvm_AttributeList,
        Kind: llvm_Attribute_AttrKind,
        Index: *mut ::std::os::raw::c_uint,
    ) -> bool;
}
extern "C" {
    #[doc = " Return the attribute object that exists at the given index."]
    #[link_name = "\u{1}_ZNK4llvm13AttributeList19getAttributeAtIndexEjNS_9Attribute8AttrKindE"]
    pub fn llvm_AttributeList_getAttributeAtIndex(
        this: *const llvm_AttributeList,
        Index: ::std::os::raw::c_uint,
        Kind: llvm_Attribute_AttrKind,
    ) -> llvm_Attribute;
}
extern "C" {
    #[doc = " Return the attribute object that exists at the given index."]
    #[link_name = "\u{1}_ZNK4llvm13AttributeList19getAttributeAtIndexEjNS_9StringRefE"]
    pub fn llvm_AttributeList_getAttributeAtIndex1(
        this: *const llvm_AttributeList,
        Index: ::std::os::raw::c_uint,
        Kind: llvm_StringRef,
    ) -> llvm_Attribute;
}
extern "C" {
    #[doc = " Return the alignment of the return value."]
    #[link_name = "\u{1}_ZNK4llvm13AttributeList15getRetAlignmentEv"]
    pub fn llvm_AttributeList_getRetAlignment(this: *const llvm_AttributeList) -> llvm_MaybeAlign;
}
extern "C" {
    #[doc = " Return the alignment for the specified function parameter."]
    #[link_name = "\u{1}_ZNK4llvm13AttributeList17getParamAlignmentEj"]
    pub fn llvm_AttributeList_getParamAlignment(
        this: *const llvm_AttributeList,
        ArgNo: ::std::os::raw::c_uint,
    ) -> llvm_MaybeAlign;
}
extern "C" {
    #[doc = " Return the stack alignment for the specified function parameter."]
    #[link_name = "\u{1}_ZNK4llvm13AttributeList22getParamStackAlignmentEj"]
    pub fn llvm_AttributeList_getParamStackAlignment(
        this: *const llvm_AttributeList,
        ArgNo: ::std::os::raw::c_uint,
    ) -> llvm_MaybeAlign;
}
extern "C" {
    #[doc = " Return the byval type for the specified function parameter."]
    #[link_name = "\u{1}_ZNK4llvm13AttributeList17getParamByValTypeEj"]
    pub fn llvm_AttributeList_getParamByValType(
        this: *const llvm_AttributeList,
        ArgNo: ::std::os::raw::c_uint,
    ) -> *mut llvm_Type;
}
extern "C" {
    #[doc = " Return the sret type for the specified function parameter."]
    #[link_name = "\u{1}_ZNK4llvm13AttributeList21getParamStructRetTypeEj"]
    pub fn llvm_AttributeList_getParamStructRetType(
        this: *const llvm_AttributeList,
        ArgNo: ::std::os::raw::c_uint,
    ) -> *mut llvm_Type;
}
extern "C" {
    #[doc = " Return the byref type for the specified function parameter."]
    #[link_name = "\u{1}_ZNK4llvm13AttributeList17getParamByRefTypeEj"]
    pub fn llvm_AttributeList_getParamByRefType(
        this: *const llvm_AttributeList,
        ArgNo: ::std::os::raw::c_uint,
    ) -> *mut llvm_Type;
}
extern "C" {
    #[doc = " Return the preallocated type for the specified function parameter."]
    #[link_name = "\u{1}_ZNK4llvm13AttributeList24getParamPreallocatedTypeEj"]
    pub fn llvm_AttributeList_getParamPreallocatedType(
        this: *const llvm_AttributeList,
        ArgNo: ::std::os::raw::c_uint,
    ) -> *mut llvm_Type;
}
extern "C" {
    #[doc = " Return the inalloca type for the specified function parameter."]
    #[link_name = "\u{1}_ZNK4llvm13AttributeList20getParamInAllocaTypeEj"]
    pub fn llvm_AttributeList_getParamInAllocaType(
        this: *const llvm_AttributeList,
        ArgNo: ::std::os::raw::c_uint,
    ) -> *mut llvm_Type;
}
extern "C" {
    #[doc = " Return the elementtype type for the specified function parameter."]
    #[link_name = "\u{1}_ZNK4llvm13AttributeList19getParamElementTypeEj"]
    pub fn llvm_AttributeList_getParamElementType(
        this: *const llvm_AttributeList,
        ArgNo: ::std::os::raw::c_uint,
    ) -> *mut llvm_Type;
}
extern "C" {
    #[doc = " Get the stack alignment of the function."]
    #[link_name = "\u{1}_ZNK4llvm13AttributeList19getFnStackAlignmentEv"]
    pub fn llvm_AttributeList_getFnStackAlignment(
        this: *const llvm_AttributeList,
    ) -> llvm_MaybeAlign;
}
extern "C" {
    #[doc = " Get the stack alignment of the return value."]
    #[link_name = "\u{1}_ZNK4llvm13AttributeList20getRetStackAlignmentEv"]
    pub fn llvm_AttributeList_getRetStackAlignment(
        this: *const llvm_AttributeList,
    ) -> llvm_MaybeAlign;
}
extern "C" {
    #[doc = " Get the number of dereferenceable bytes (or zero if unknown) of the return\n value."]
    #[link_name = "\u{1}_ZNK4llvm13AttributeList26getRetDereferenceableBytesEv"]
    pub fn llvm_AttributeList_getRetDereferenceableBytes(this: *const llvm_AttributeList) -> u64;
}
extern "C" {
    #[doc = " Get the number of dereferenceable bytes (or zero if unknown) of an arg."]
    #[link_name = "\u{1}_ZNK4llvm13AttributeList28getParamDereferenceableBytesEj"]
    pub fn llvm_AttributeList_getParamDereferenceableBytes(
        this: *const llvm_AttributeList,
        Index: ::std::os::raw::c_uint,
    ) -> u64;
}
extern "C" {
    #[doc = " Get the number of dereferenceable_or_null bytes (or zero if unknown) of\n the return value."]
    #[link_name = "\u{1}_ZNK4llvm13AttributeList32getRetDereferenceableOrNullBytesEv"]
    pub fn llvm_AttributeList_getRetDereferenceableOrNullBytes(
        this: *const llvm_AttributeList,
    ) -> u64;
}
extern "C" {
    #[doc = " Get the number of dereferenceable_or_null bytes (or zero if unknown) of an\n arg."]
    #[link_name = "\u{1}_ZNK4llvm13AttributeList34getParamDereferenceableOrNullBytesEj"]
    pub fn llvm_AttributeList_getParamDereferenceableOrNullBytes(
        this: *const llvm_AttributeList,
        ArgNo: ::std::os::raw::c_uint,
    ) -> u64;
}
extern "C" {
    #[doc = " Get the disallowed floating-point classes of the return value."]
    #[link_name = "\u{1}_ZNK4llvm13AttributeList15getRetNoFPClassEv"]
    pub fn llvm_AttributeList_getRetNoFPClass(this: *const llvm_AttributeList) -> llvm_FPClassTest;
}
extern "C" {
    #[doc = " Get the disallowed floating-point classes of the argument value."]
    #[link_name = "\u{1}_ZNK4llvm13AttributeList17getParamNoFPClassEj"]
    pub fn llvm_AttributeList_getParamNoFPClass(
        this: *const llvm_AttributeList,
        ArgNo: ::std::os::raw::c_uint,
    ) -> llvm_FPClassTest;
}
extern "C" {
    #[doc = " Get the unwind table kind requested for the function."]
    #[link_name = "\u{1}_ZNK4llvm13AttributeList14getUWTableKindEv"]
    pub fn llvm_AttributeList_getUWTableKind(this: *const llvm_AttributeList) -> llvm_UWTableKind;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4llvm13AttributeList12getAllocKindEv"]
    pub fn llvm_AttributeList_getAllocKind(this: *const llvm_AttributeList) -> llvm_AllocFnKind;
}
extern "C" {
    #[doc = " Returns memory effects of the function."]
    #[link_name = "\u{1}_ZNK4llvm13AttributeList16getMemoryEffectsEv"]
    pub fn llvm_AttributeList_getMemoryEffects(
        this: *const llvm_AttributeList,
    ) -> llvm_MemoryEffects;
}
extern "C" {
    #[doc = " Return the attributes at the index as a string."]
    #[link_name = "\u{1}_ZNK4llvm13AttributeList11getAsStringB5cxx11Ejb"]
    pub fn llvm_AttributeList_getAsString(
        this: *const llvm_AttributeList,
        Index: ::std::os::raw::c_uint,
        InAttrGrp: bool,
    ) -> std_string;
}
extern "C" {
    #[doc = " Return true if this attribute list belongs to the LLVMContext."]
    #[link_name = "\u{1}_ZNK4llvm13AttributeList16hasParentContextERNS_11LLVMContextE"]
    pub fn llvm_AttributeList_hasParentContext(
        this: *const llvm_AttributeList,
        C: *mut llvm_LLVMContext,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4llvm13AttributeList5beginEv"]
    pub fn llvm_AttributeList_begin(this: *const llvm_AttributeList)
        -> llvm_AttributeList_iterator;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4llvm13AttributeList3endEv"]
    pub fn llvm_AttributeList_end(this: *const llvm_AttributeList) -> llvm_AttributeList_iterator;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4llvm13AttributeList14getNumAttrSetsEv"]
    pub fn llvm_AttributeList_getNumAttrSets(
        this: *const llvm_AttributeList,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4llvm13AttributeList5printERNS_11raw_ostreamE"]
    pub fn llvm_AttributeList_print(this: *const llvm_AttributeList, O: *mut llvm_raw_ostream);
}
extern "C" {
    #[link_name = "\u{1}_ZNK4llvm13AttributeList4dumpEv"]
    pub fn llvm_AttributeList_dump(this: *const llvm_AttributeList);
}
impl llvm_AttributeList {
    #[inline]
    pub unsafe fn get(
        C: *mut llvm_LLVMContext,
        Attrs: llvm_ArrayRef<std_pair<::std::os::raw::c_uint, llvm_Attribute>>,
    ) -> llvm_AttributeList {
        llvm_AttributeList_get(C, Attrs)
    }
    #[inline]
    pub unsafe fn get1(
        C: *mut llvm_LLVMContext,
        Attrs: llvm_ArrayRef<std_pair<::std::os::raw::c_uint, llvm_AttributeSet>>,
    ) -> llvm_AttributeList {
        llvm_AttributeList_get1(C, Attrs)
    }
    #[inline]
    pub unsafe fn get2(
        C: *mut llvm_LLVMContext,
        FnAttrs: llvm_AttributeSet,
        RetAttrs: llvm_AttributeSet,
        ArgAttrs: llvm_ArrayRef<llvm_AttributeSet>,
    ) -> llvm_AttributeList {
        llvm_AttributeList_get2(C, FnAttrs, RetAttrs, ArgAttrs)
    }
    #[inline]
    pub unsafe fn get3(
        C: *mut llvm_LLVMContext,
        Attrs: llvm_ArrayRef<llvm_AttributeList>,
    ) -> llvm_AttributeList {
        llvm_AttributeList_get3(C, Attrs)
    }
    #[inline]
    pub unsafe fn get4(
        C: *mut llvm_LLVMContext,
        Index: ::std::os::raw::c_uint,
        Kinds: llvm_ArrayRef<llvm_Attribute_AttrKind>,
    ) -> llvm_AttributeList {
        llvm_AttributeList_get4(C, Index, Kinds)
    }
    #[inline]
    pub unsafe fn get5(
        C: *mut llvm_LLVMContext,
        Index: ::std::os::raw::c_uint,
        Kinds: llvm_ArrayRef<llvm_Attribute_AttrKind>,
        Values: llvm_ArrayRef<u64>,
    ) -> llvm_AttributeList {
        llvm_AttributeList_get5(C, Index, Kinds, Values)
    }
    #[inline]
    pub unsafe fn get6(
        C: *mut llvm_LLVMContext,
        Index: ::std::os::raw::c_uint,
        Kind: llvm_ArrayRef<llvm_StringRef>,
    ) -> llvm_AttributeList {
        llvm_AttributeList_get6(C, Index, Kind)
    }
    #[inline]
    pub unsafe fn get7(
        C: *mut llvm_LLVMContext,
        Index: ::std::os::raw::c_uint,
        Attrs: llvm_AttributeSet,
    ) -> llvm_AttributeList {
        llvm_AttributeList_get7(C, Index, Attrs)
    }
    #[inline]
    pub unsafe fn get8(
        C: *mut llvm_LLVMContext,
        Index: ::std::os::raw::c_uint,
        B: *const llvm_AttrBuilder,
    ) -> llvm_AttributeList {
        llvm_AttributeList_get8(C, Index, B)
    }
    #[inline]
    pub unsafe fn addAttributeAtIndex(
        &self,
        C: *mut llvm_LLVMContext,
        Index: ::std::os::raw::c_uint,
        Kind: llvm_Attribute_AttrKind,
    ) -> llvm_AttributeList {
        llvm_AttributeList_addAttributeAtIndex(self, C, Index, Kind)
    }
    #[inline]
    pub unsafe fn addAttributeAtIndex1(
        &self,
        C: *mut llvm_LLVMContext,
        Index: ::std::os::raw::c_uint,
        Kind: llvm_StringRef,
        Value: llvm_StringRef,
    ) -> llvm_AttributeList {
        llvm_AttributeList_addAttributeAtIndex1(self, C, Index, Kind, Value)
    }
    #[inline]
    pub unsafe fn addAttributeAtIndex2(
        &self,
        C: *mut llvm_LLVMContext,
        Index: ::std::os::raw::c_uint,
        A: llvm_Attribute,
    ) -> llvm_AttributeList {
        llvm_AttributeList_addAttributeAtIndex2(self, C, Index, A)
    }
    #[inline]
    pub unsafe fn addAttributesAtIndex(
        &self,
        C: *mut llvm_LLVMContext,
        Index: ::std::os::raw::c_uint,
        B: *const llvm_AttrBuilder,
    ) -> llvm_AttributeList {
        llvm_AttributeList_addAttributesAtIndex(self, C, Index, B)
    }
    #[inline]
    pub unsafe fn addParamAttribute(
        &self,
        C: *mut llvm_LLVMContext,
        ArgNos: llvm_ArrayRef<::std::os::raw::c_uint>,
        A: llvm_Attribute,
    ) -> llvm_AttributeList {
        llvm_AttributeList_addParamAttribute(self, C, ArgNos, A)
    }
    #[inline]
    pub unsafe fn removeAttributeAtIndex(
        &self,
        C: *mut llvm_LLVMContext,
        Index: ::std::os::raw::c_uint,
        Kind: llvm_Attribute_AttrKind,
    ) -> llvm_AttributeList {
        llvm_AttributeList_removeAttributeAtIndex(self, C, Index, Kind)
    }
    #[inline]
    pub unsafe fn removeAttributeAtIndex1(
        &self,
        C: *mut llvm_LLVMContext,
        Index: ::std::os::raw::c_uint,
        Kind: llvm_StringRef,
    ) -> llvm_AttributeList {
        llvm_AttributeList_removeAttributeAtIndex1(self, C, Index, Kind)
    }
    #[inline]
    pub unsafe fn removeAttributesAtIndex(
        &self,
        C: *mut llvm_LLVMContext,
        Index: ::std::os::raw::c_uint,
        AttrsToRemove: *const llvm_AttributeMask,
    ) -> llvm_AttributeList {
        llvm_AttributeList_removeAttributesAtIndex(self, C, Index, AttrsToRemove)
    }
    #[inline]
    pub unsafe fn removeAttributesAtIndex1(
        &self,
        C: *mut llvm_LLVMContext,
        Index: ::std::os::raw::c_uint,
    ) -> llvm_AttributeList {
        llvm_AttributeList_removeAttributesAtIndex1(self, C, Index)
    }
    #[inline]
    pub unsafe fn addDereferenceableRetAttr(
        &self,
        C: *mut llvm_LLVMContext,
        Bytes: u64,
    ) -> llvm_AttributeList {
        llvm_AttributeList_addDereferenceableRetAttr(self, C, Bytes)
    }
    #[inline]
    pub unsafe fn addDereferenceableParamAttr(
        &self,
        C: *mut llvm_LLVMContext,
        ArgNo: ::std::os::raw::c_uint,
        Bytes: u64,
    ) -> llvm_AttributeList {
        llvm_AttributeList_addDereferenceableParamAttr(self, C, ArgNo, Bytes)
    }
    #[inline]
    pub unsafe fn addDereferenceableOrNullParamAttr(
        &self,
        C: *mut llvm_LLVMContext,
        ArgNo: ::std::os::raw::c_uint,
        Bytes: u64,
    ) -> llvm_AttributeList {
        llvm_AttributeList_addDereferenceableOrNullParamAttr(self, C, ArgNo, Bytes)
    }
    #[inline]
    pub unsafe fn addRangeRetAttr(
        &self,
        C: *mut llvm_LLVMContext,
        CR: *const llvm_ConstantRange,
    ) -> llvm_AttributeList {
        llvm_AttributeList_addRangeRetAttr(self, C, CR)
    }
    #[inline]
    pub unsafe fn addAllocSizeParamAttr(
        &mut self,
        C: *mut llvm_LLVMContext,
        ArgNo: ::std::os::raw::c_uint,
        ElemSizeArg: ::std::os::raw::c_uint,
        NumElemsArg: *const std_optional,
    ) -> llvm_AttributeList {
        llvm_AttributeList_addAllocSizeParamAttr(self, C, ArgNo, ElemSizeArg, NumElemsArg)
    }
    #[inline]
    pub unsafe fn getAttributes(&self, Index: ::std::os::raw::c_uint) -> llvm_AttributeSet {
        llvm_AttributeList_getAttributes(self, Index)
    }
    #[inline]
    pub unsafe fn getParamAttrs(&self, ArgNo: ::std::os::raw::c_uint) -> llvm_AttributeSet {
        llvm_AttributeList_getParamAttrs(self, ArgNo)
    }
    #[inline]
    pub unsafe fn getRetAttrs(&self) -> llvm_AttributeSet {
        llvm_AttributeList_getRetAttrs(self)
    }
    #[inline]
    pub unsafe fn getFnAttrs(&self) -> llvm_AttributeSet {
        llvm_AttributeList_getFnAttrs(self)
    }
    #[inline]
    pub unsafe fn hasAttributeAtIndex(
        &self,
        Index: ::std::os::raw::c_uint,
        Kind: llvm_Attribute_AttrKind,
    ) -> bool {
        llvm_AttributeList_hasAttributeAtIndex(self, Index, Kind)
    }
    #[inline]
    pub unsafe fn hasAttributeAtIndex1(
        &self,
        Index: ::std::os::raw::c_uint,
        Kind: llvm_StringRef,
    ) -> bool {
        llvm_AttributeList_hasAttributeAtIndex1(self, Index, Kind)
    }
    #[inline]
    pub unsafe fn hasAttributesAtIndex(&self, Index: ::std::os::raw::c_uint) -> bool {
        llvm_AttributeList_hasAttributesAtIndex(self, Index)
    }
    #[inline]
    pub unsafe fn hasFnAttr(&self, Kind: llvm_Attribute_AttrKind) -> bool {
        llvm_AttributeList_hasFnAttr(self, Kind)
    }
    #[inline]
    pub unsafe fn hasFnAttr1(&self, Kind: llvm_StringRef) -> bool {
        llvm_AttributeList_hasFnAttr1(self, Kind)
    }
    #[inline]
    pub unsafe fn hasAttrSomewhere(
        &self,
        Kind: llvm_Attribute_AttrKind,
        Index: *mut ::std::os::raw::c_uint,
    ) -> bool {
        llvm_AttributeList_hasAttrSomewhere(self, Kind, Index)
    }
    #[inline]
    pub unsafe fn getAttributeAtIndex(
        &self,
        Index: ::std::os::raw::c_uint,
        Kind: llvm_Attribute_AttrKind,
    ) -> llvm_Attribute {
        llvm_AttributeList_getAttributeAtIndex(self, Index, Kind)
    }
    #[inline]
    pub unsafe fn getAttributeAtIndex1(
        &self,
        Index: ::std::os::raw::c_uint,
        Kind: llvm_StringRef,
    ) -> llvm_Attribute {
        llvm_AttributeList_getAttributeAtIndex1(self, Index, Kind)
    }
    #[inline]
    pub unsafe fn getRetAlignment(&self) -> llvm_MaybeAlign {
        llvm_AttributeList_getRetAlignment(self)
    }
    #[inline]
    pub unsafe fn getParamAlignment(&self, ArgNo: ::std::os::raw::c_uint) -> llvm_MaybeAlign {
        llvm_AttributeList_getParamAlignment(self, ArgNo)
    }
    #[inline]
    pub unsafe fn getParamStackAlignment(&self, ArgNo: ::std::os::raw::c_uint) -> llvm_MaybeAlign {
        llvm_AttributeList_getParamStackAlignment(self, ArgNo)
    }
    #[inline]
    pub unsafe fn getParamByValType(&self, ArgNo: ::std::os::raw::c_uint) -> *mut llvm_Type {
        llvm_AttributeList_getParamByValType(self, ArgNo)
    }
    #[inline]
    pub unsafe fn getParamStructRetType(&self, ArgNo: ::std::os::raw::c_uint) -> *mut llvm_Type {
        llvm_AttributeList_getParamStructRetType(self, ArgNo)
    }
    #[inline]
    pub unsafe fn getParamByRefType(&self, ArgNo: ::std::os::raw::c_uint) -> *mut llvm_Type {
        llvm_AttributeList_getParamByRefType(self, ArgNo)
    }
    #[inline]
    pub unsafe fn getParamPreallocatedType(&self, ArgNo: ::std::os::raw::c_uint) -> *mut llvm_Type {
        llvm_AttributeList_getParamPreallocatedType(self, ArgNo)
    }
    #[inline]
    pub unsafe fn getParamInAllocaType(&self, ArgNo: ::std::os::raw::c_uint) -> *mut llvm_Type {
        llvm_AttributeList_getParamInAllocaType(self, ArgNo)
    }
    #[inline]
    pub unsafe fn getParamElementType(&self, ArgNo: ::std::os::raw::c_uint) -> *mut llvm_Type {
        llvm_AttributeList_getParamElementType(self, ArgNo)
    }
    #[inline]
    pub unsafe fn getFnStackAlignment(&self) -> llvm_MaybeAlign {
        llvm_AttributeList_getFnStackAlignment(self)
    }
    #[inline]
    pub unsafe fn getRetStackAlignment(&self) -> llvm_MaybeAlign {
        llvm_AttributeList_getRetStackAlignment(self)
    }
    #[inline]
    pub unsafe fn getRetDereferenceableBytes(&self) -> u64 {
        llvm_AttributeList_getRetDereferenceableBytes(self)
    }
    #[inline]
    pub unsafe fn getParamDereferenceableBytes(&self, Index: ::std::os::raw::c_uint) -> u64 {
        llvm_AttributeList_getParamDereferenceableBytes(self, Index)
    }
    #[inline]
    pub unsafe fn getRetDereferenceableOrNullBytes(&self) -> u64 {
        llvm_AttributeList_getRetDereferenceableOrNullBytes(self)
    }
    #[inline]
    pub unsafe fn getParamDereferenceableOrNullBytes(&self, ArgNo: ::std::os::raw::c_uint) -> u64 {
        llvm_AttributeList_getParamDereferenceableOrNullBytes(self, ArgNo)
    }
    #[inline]
    pub unsafe fn getRetNoFPClass(&self) -> llvm_FPClassTest {
        llvm_AttributeList_getRetNoFPClass(self)
    }
    #[inline]
    pub unsafe fn getParamNoFPClass(&self, ArgNo: ::std::os::raw::c_uint) -> llvm_FPClassTest {
        llvm_AttributeList_getParamNoFPClass(self, ArgNo)
    }
    #[inline]
    pub unsafe fn getUWTableKind(&self) -> llvm_UWTableKind {
        llvm_AttributeList_getUWTableKind(self)
    }
    #[inline]
    pub unsafe fn getAllocKind(&self) -> llvm_AllocFnKind {
        llvm_AttributeList_getAllocKind(self)
    }
    #[inline]
    pub unsafe fn getMemoryEffects(&self) -> llvm_MemoryEffects {
        llvm_AttributeList_getMemoryEffects(self)
    }
    #[inline]
    pub unsafe fn getAsString(&self, Index: ::std::os::raw::c_uint, InAttrGrp: bool) -> std_string {
        llvm_AttributeList_getAsString(self, Index, InAttrGrp)
    }
    #[inline]
    pub unsafe fn hasParentContext(&self, C: *mut llvm_LLVMContext) -> bool {
        llvm_AttributeList_hasParentContext(self, C)
    }
    #[inline]
    pub unsafe fn begin(&self) -> llvm_AttributeList_iterator {
        llvm_AttributeList_begin(self)
    }
    #[inline]
    pub unsafe fn end(&self) -> llvm_AttributeList_iterator {
        llvm_AttributeList_end(self)
    }
    #[inline]
    pub unsafe fn getNumAttrSets(&self) -> ::std::os::raw::c_uint {
        llvm_AttributeList_getNumAttrSets(self)
    }
    #[inline]
    pub unsafe fn print(&self, O: *mut llvm_raw_ostream) {
        llvm_AttributeList_print(self, O)
    }
    #[inline]
    pub unsafe fn dump(&self) {
        llvm_AttributeList_dump(self)
    }
}
#[test]
fn __bindgen_test_layout_llvm_DenseMapInfo_open0_llvm_AttributeList_void_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<llvm_DenseMapInfo>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_DenseMapInfo)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_DenseMapInfo>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_DenseMapInfo)
        )
    );
}
#[doc = " \\class\n This class is used in conjunction with the Attribute::get method to\n create an Attribute object. The object itself is uniquified. The Builder's\n value, however, is not. So this can be used as a quick way to test for\n equality, presence of attributes, etc."]
#[repr(C)]
#[derive(Debug)]
pub struct llvm_AttrBuilder {
    pub Ctx: *mut llvm_LLVMContext,
    pub Attrs: [u64; 10usize],
}
#[test]
fn bindgen_test_layout_llvm_AttrBuilder() {
    const UNINIT: ::std::mem::MaybeUninit<llvm_AttrBuilder> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<llvm_AttrBuilder>(),
        88usize,
        concat!("Size of: ", stringify!(llvm_AttrBuilder))
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_AttrBuilder>(),
        8usize,
        concat!("Alignment of ", stringify!(llvm_AttrBuilder))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Ctx) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_AttrBuilder),
            "::",
            stringify!(Ctx)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Attrs) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_AttrBuilder),
            "::",
            stringify!(Attrs)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm11AttrBuilder5clearEv"]
    pub fn llvm_AttrBuilder_clear(this: *mut llvm_AttrBuilder);
}
extern "C" {
    #[doc = " Add an attribute to the builder."]
    #[link_name = "\u{1}_ZN4llvm11AttrBuilder12addAttributeENS_9Attribute8AttrKindE"]
    pub fn llvm_AttrBuilder_addAttribute(
        this: *mut llvm_AttrBuilder,
        Val: llvm_Attribute_AttrKind,
    ) -> *mut llvm_AttrBuilder;
}
extern "C" {
    #[doc = " Add the Attribute object to the builder."]
    #[link_name = "\u{1}_ZN4llvm11AttrBuilder12addAttributeENS_9AttributeE"]
    pub fn llvm_AttrBuilder_addAttribute1(
        this: *mut llvm_AttrBuilder,
        A: llvm_Attribute,
    ) -> *mut llvm_AttrBuilder;
}
extern "C" {
    #[doc = " Add the target-dependent attribute to the builder."]
    #[link_name = "\u{1}_ZN4llvm11AttrBuilder12addAttributeENS_9StringRefES1_"]
    pub fn llvm_AttrBuilder_addAttribute2(
        this: *mut llvm_AttrBuilder,
        A: llvm_StringRef,
        V: llvm_StringRef,
    ) -> *mut llvm_AttrBuilder;
}
extern "C" {
    #[doc = " Remove an attribute from the builder."]
    #[link_name = "\u{1}_ZN4llvm11AttrBuilder15removeAttributeENS_9Attribute8AttrKindE"]
    pub fn llvm_AttrBuilder_removeAttribute(
        this: *mut llvm_AttrBuilder,
        Val: llvm_Attribute_AttrKind,
    ) -> *mut llvm_AttrBuilder;
}
extern "C" {
    #[doc = " Remove the target-dependent attribute from the builder."]
    #[link_name = "\u{1}_ZN4llvm11AttrBuilder15removeAttributeENS_9StringRefE"]
    pub fn llvm_AttrBuilder_removeAttribute1(
        this: *mut llvm_AttrBuilder,
        A: llvm_StringRef,
    ) -> *mut llvm_AttrBuilder;
}
extern "C" {
    #[doc = " Add the attributes from the builder. Attributes in the passed builder\n overwrite attributes in this builder if they have the same key."]
    #[link_name = "\u{1}_ZN4llvm11AttrBuilder5mergeERKS0_"]
    pub fn llvm_AttrBuilder_merge(
        this: *mut llvm_AttrBuilder,
        B: *const llvm_AttrBuilder,
    ) -> *mut llvm_AttrBuilder;
}
extern "C" {
    #[doc = " Remove the attributes from the builder."]
    #[link_name = "\u{1}_ZN4llvm11AttrBuilder6removeERKNS_13AttributeMaskE"]
    pub fn llvm_AttrBuilder_remove(
        this: *mut llvm_AttrBuilder,
        AM: *const llvm_AttributeMask,
    ) -> *mut llvm_AttrBuilder;
}
extern "C" {
    #[doc = " Return true if the builder has any attribute that's in the\n specified builder."]
    #[link_name = "\u{1}_ZNK4llvm11AttrBuilder8overlapsERKNS_13AttributeMaskE"]
    pub fn llvm_AttrBuilder_overlaps(
        this: *const llvm_AttrBuilder,
        AM: *const llvm_AttributeMask,
    ) -> bool;
}
extern "C" {
    #[doc = " Return true if the builder has the specified attribute."]
    #[link_name = "\u{1}_ZNK4llvm11AttrBuilder8containsENS_9Attribute8AttrKindE"]
    pub fn llvm_AttrBuilder_contains(
        this: *const llvm_AttrBuilder,
        A: llvm_Attribute_AttrKind,
    ) -> bool;
}
extern "C" {
    #[doc = " Return true if the builder has the specified target-dependent\n attribute."]
    #[link_name = "\u{1}_ZNK4llvm11AttrBuilder8containsENS_9StringRefE"]
    pub fn llvm_AttrBuilder_contains1(this: *const llvm_AttrBuilder, A: llvm_StringRef) -> bool;
}
extern "C" {
    #[doc = " Return Attribute with the given Kind. The returned attribute will be\n invalid if the Kind is not present in the builder."]
    #[link_name = "\u{1}_ZNK4llvm11AttrBuilder12getAttributeENS_9Attribute8AttrKindE"]
    pub fn llvm_AttrBuilder_getAttribute(
        this: *const llvm_AttrBuilder,
        Kind: llvm_Attribute_AttrKind,
    ) -> llvm_Attribute;
}
extern "C" {
    #[doc = " Return Attribute with the given Kind. The returned attribute will be\n invalid if the Kind is not present in the builder."]
    #[link_name = "\u{1}_ZNK4llvm11AttrBuilder12getAttributeENS_9StringRefE"]
    pub fn llvm_AttrBuilder_getAttribute1(
        this: *const llvm_AttrBuilder,
        Kind: llvm_StringRef,
    ) -> llvm_Attribute;
}
extern "C" {
    #[doc = " Return raw (possibly packed/encoded) value of integer attribute or\n std::nullopt if not set."]
    #[link_name = "\u{1}_ZNK4llvm11AttrBuilder13getRawIntAttrENS_9Attribute8AttrKindE"]
    pub fn llvm_AttrBuilder_getRawIntAttr(
        this: *const llvm_AttrBuilder,
        Kind: llvm_Attribute_AttrKind,
    ) -> std_optional;
}
extern "C" {
    #[doc = " Retrieve type for the given type attribute."]
    #[link_name = "\u{1}_ZNK4llvm11AttrBuilder11getTypeAttrENS_9Attribute8AttrKindE"]
    pub fn llvm_AttrBuilder_getTypeAttr(
        this: *const llvm_AttrBuilder,
        Kind: llvm_Attribute_AttrKind,
    ) -> *mut llvm_Type;
}
extern "C" {
    #[doc = " Retrieve the allocsize args, or std::nullopt if the attribute does not\n exist."]
    #[link_name = "\u{1}_ZNK4llvm11AttrBuilder16getAllocSizeArgsEv"]
    pub fn llvm_AttrBuilder_getAllocSizeArgs(this: *const llvm_AttrBuilder) -> std_optional;
}
extern "C" {
    #[doc = " Add integer attribute with raw value (packed/encoded if necessary)."]
    #[link_name = "\u{1}_ZN4llvm11AttrBuilder13addRawIntAttrENS_9Attribute8AttrKindEm"]
    pub fn llvm_AttrBuilder_addRawIntAttr(
        this: *mut llvm_AttrBuilder,
        Kind: llvm_Attribute_AttrKind,
        Value: u64,
    ) -> *mut llvm_AttrBuilder;
}
extern "C" {
    #[doc = " This turns an alignment into the form used internally in Attribute.\n This call has no effect if Align is not set."]
    #[link_name = "\u{1}_ZN4llvm11AttrBuilder16addAlignmentAttrENS_10MaybeAlignE"]
    pub fn llvm_AttrBuilder_addAlignmentAttr(
        this: *mut llvm_AttrBuilder,
        Align: llvm_MaybeAlign,
    ) -> *mut llvm_AttrBuilder;
}
extern "C" {
    #[doc = " This turns a stack alignment into the form used internally in Attribute.\n This call has no effect if Align is not set."]
    #[link_name = "\u{1}_ZN4llvm11AttrBuilder21addStackAlignmentAttrENS_10MaybeAlignE"]
    pub fn llvm_AttrBuilder_addStackAlignmentAttr(
        this: *mut llvm_AttrBuilder,
        Align: llvm_MaybeAlign,
    ) -> *mut llvm_AttrBuilder;
}
extern "C" {
    #[doc = " This turns the number of dereferenceable bytes into the form used\n internally in Attribute."]
    #[link_name = "\u{1}_ZN4llvm11AttrBuilder22addDereferenceableAttrEm"]
    pub fn llvm_AttrBuilder_addDereferenceableAttr(
        this: *mut llvm_AttrBuilder,
        Bytes: u64,
    ) -> *mut llvm_AttrBuilder;
}
extern "C" {
    #[doc = " This turns the number of dereferenceable_or_null bytes into the\n form used internally in Attribute."]
    #[link_name = "\u{1}_ZN4llvm11AttrBuilder28addDereferenceableOrNullAttrEm"]
    pub fn llvm_AttrBuilder_addDereferenceableOrNullAttr(
        this: *mut llvm_AttrBuilder,
        Bytes: u64,
    ) -> *mut llvm_AttrBuilder;
}
extern "C" {
    #[doc = " This turns one (or two) ints into the form used internally in Attribute."]
    #[link_name = "\u{1}_ZN4llvm11AttrBuilder16addAllocSizeAttrEjRKSt8optionalIjE"]
    pub fn llvm_AttrBuilder_addAllocSizeAttr(
        this: *mut llvm_AttrBuilder,
        ElemSizeArg: ::std::os::raw::c_uint,
        NumElemsArg: *const std_optional,
    ) -> *mut llvm_AttrBuilder;
}
extern "C" {
    #[doc = " This turns two ints into the form used internally in Attribute."]
    #[link_name = "\u{1}_ZN4llvm11AttrBuilder18addVScaleRangeAttrEjSt8optionalIjE"]
    pub fn llvm_AttrBuilder_addVScaleRangeAttr(
        this: *mut llvm_AttrBuilder,
        MinValue: ::std::os::raw::c_uint,
        MaxValue: std_optional,
    ) -> *mut llvm_AttrBuilder;
}
extern "C" {
    #[doc = " Add a type attribute with the given type."]
    #[link_name = "\u{1}_ZN4llvm11AttrBuilder11addTypeAttrENS_9Attribute8AttrKindEPNS_4TypeE"]
    pub fn llvm_AttrBuilder_addTypeAttr(
        this: *mut llvm_AttrBuilder,
        Kind: llvm_Attribute_AttrKind,
        Ty: *mut llvm_Type,
    ) -> *mut llvm_AttrBuilder;
}
extern "C" {
    #[doc = " This turns a byval type into the form used internally in Attribute."]
    #[link_name = "\u{1}_ZN4llvm11AttrBuilder12addByValAttrEPNS_4TypeE"]
    pub fn llvm_AttrBuilder_addByValAttr(
        this: *mut llvm_AttrBuilder,
        Ty: *mut llvm_Type,
    ) -> *mut llvm_AttrBuilder;
}
extern "C" {
    #[doc = " This turns a sret type into the form used internally in Attribute."]
    #[link_name = "\u{1}_ZN4llvm11AttrBuilder16addStructRetAttrEPNS_4TypeE"]
    pub fn llvm_AttrBuilder_addStructRetAttr(
        this: *mut llvm_AttrBuilder,
        Ty: *mut llvm_Type,
    ) -> *mut llvm_AttrBuilder;
}
extern "C" {
    #[doc = " This turns a byref type into the form used internally in Attribute."]
    #[link_name = "\u{1}_ZN4llvm11AttrBuilder12addByRefAttrEPNS_4TypeE"]
    pub fn llvm_AttrBuilder_addByRefAttr(
        this: *mut llvm_AttrBuilder,
        Ty: *mut llvm_Type,
    ) -> *mut llvm_AttrBuilder;
}
extern "C" {
    #[doc = " This turns a preallocated type into the form used internally in Attribute."]
    #[link_name = "\u{1}_ZN4llvm11AttrBuilder19addPreallocatedAttrEPNS_4TypeE"]
    pub fn llvm_AttrBuilder_addPreallocatedAttr(
        this: *mut llvm_AttrBuilder,
        Ty: *mut llvm_Type,
    ) -> *mut llvm_AttrBuilder;
}
extern "C" {
    #[doc = " This turns an inalloca type into the form used internally in Attribute."]
    #[link_name = "\u{1}_ZN4llvm11AttrBuilder15addInAllocaAttrEPNS_4TypeE"]
    pub fn llvm_AttrBuilder_addInAllocaAttr(
        this: *mut llvm_AttrBuilder,
        Ty: *mut llvm_Type,
    ) -> *mut llvm_AttrBuilder;
}
extern "C" {
    #[doc = " Add an allocsize attribute, using the representation returned by\n Attribute.getIntValue()."]
    #[link_name = "\u{1}_ZN4llvm11AttrBuilder27addAllocSizeAttrFromRawReprEm"]
    pub fn llvm_AttrBuilder_addAllocSizeAttrFromRawRepr(
        this: *mut llvm_AttrBuilder,
        RawAllocSizeRepr: u64,
    ) -> *mut llvm_AttrBuilder;
}
extern "C" {
    #[doc = " Add a vscale_range attribute, using the representation returned by\n Attribute.getIntValue()."]
    #[link_name = "\u{1}_ZN4llvm11AttrBuilder29addVScaleRangeAttrFromRawReprEm"]
    pub fn llvm_AttrBuilder_addVScaleRangeAttrFromRawRepr(
        this: *mut llvm_AttrBuilder,
        RawVScaleRangeRepr: u64,
    ) -> *mut llvm_AttrBuilder;
}
extern "C" {
    #[doc = " This turns the unwind table kind into the form used internally in\n Attribute."]
    #[link_name = "\u{1}_ZN4llvm11AttrBuilder14addUWTableAttrENS_11UWTableKindE"]
    pub fn llvm_AttrBuilder_addUWTableAttr(
        this: *mut llvm_AttrBuilder,
        Kind: llvm_UWTableKind,
    ) -> *mut llvm_AttrBuilder;
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm11AttrBuilder16addAllocKindAttrENS_11AllocFnKindE"]
    pub fn llvm_AttrBuilder_addAllocKindAttr(
        this: *mut llvm_AttrBuilder,
        Kind: llvm_AllocFnKind,
    ) -> *mut llvm_AttrBuilder;
}
extern "C" {
    #[doc = " Add memory effect attribute."]
    #[link_name = "\u{1}_ZN4llvm11AttrBuilder13addMemoryAttrENS_17MemoryEffectsBaseINS_13IRMemLocationEEE"]
    pub fn llvm_AttrBuilder_addMemoryAttr(
        this: *mut llvm_AttrBuilder,
        ME: llvm_MemoryEffects,
    ) -> *mut llvm_AttrBuilder;
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm11AttrBuilder16addNoFPClassAttrENS_11FPClassTestE"]
    pub fn llvm_AttrBuilder_addNoFPClassAttr(
        this: *mut llvm_AttrBuilder,
        NoFPClassMask: llvm_FPClassTest,
    ) -> *mut llvm_AttrBuilder;
}
extern "C" {
    #[doc = " Add a ConstantRange attribute with the given range."]
    #[link_name = "\u{1}_ZN4llvm11AttrBuilder20addConstantRangeAttrENS_9Attribute8AttrKindERKNS_13ConstantRangeE"]
    pub fn llvm_AttrBuilder_addConstantRangeAttr(
        this: *mut llvm_AttrBuilder,
        Kind: llvm_Attribute_AttrKind,
        CR: *const llvm_ConstantRange,
    ) -> *mut llvm_AttrBuilder;
}
extern "C" {
    #[doc = " Add range attribute."]
    #[link_name = "\u{1}_ZN4llvm11AttrBuilder12addRangeAttrERKNS_13ConstantRangeE"]
    pub fn llvm_AttrBuilder_addRangeAttr(
        this: *mut llvm_AttrBuilder,
        CR: *const llvm_ConstantRange,
    ) -> *mut llvm_AttrBuilder;
}
extern "C" {
    #[doc = " Add a ConstantRangeList attribute with the given ranges."]
    #[link_name = "\u{1}_ZN4llvm11AttrBuilder24addConstantRangeListAttrENS_9Attribute8AttrKindENS_8ArrayRefINS_13ConstantRangeEEE"]
    pub fn llvm_AttrBuilder_addConstantRangeListAttr(
        this: *mut llvm_AttrBuilder,
        Kind: llvm_Attribute_AttrKind,
        Val: llvm_ArrayRef<llvm_ConstantRange>,
    ) -> *mut llvm_AttrBuilder;
}
extern "C" {
    #[doc = " Add initializes attribute."]
    #[link_name = "\u{1}_ZN4llvm11AttrBuilder18addInitializesAttrERKNS_17ConstantRangeListE"]
    pub fn llvm_AttrBuilder_addInitializesAttr(
        this: *mut llvm_AttrBuilder,
        CRL: *const llvm_ConstantRangeList,
    ) -> *mut llvm_AttrBuilder;
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm11AttrBuilderC1ERNS_11LLVMContextENS_12AttributeSetE"]
    pub fn llvm_AttrBuilder_AttrBuilder(
        this: *mut llvm_AttrBuilder,
        Ctx: *mut llvm_LLVMContext,
        AS: llvm_AttributeSet,
    );
}
impl llvm_AttrBuilder {
    #[inline]
    pub unsafe fn clear(&mut self) {
        llvm_AttrBuilder_clear(self)
    }
    #[inline]
    pub unsafe fn addAttribute(&mut self, Val: llvm_Attribute_AttrKind) -> *mut llvm_AttrBuilder {
        llvm_AttrBuilder_addAttribute(self, Val)
    }
    #[inline]
    pub unsafe fn addAttribute1(&mut self, A: llvm_Attribute) -> *mut llvm_AttrBuilder {
        llvm_AttrBuilder_addAttribute1(self, A)
    }
    #[inline]
    pub unsafe fn addAttribute2(
        &mut self,
        A: llvm_StringRef,
        V: llvm_StringRef,
    ) -> *mut llvm_AttrBuilder {
        llvm_AttrBuilder_addAttribute2(self, A, V)
    }
    #[inline]
    pub unsafe fn removeAttribute(
        &mut self,
        Val: llvm_Attribute_AttrKind,
    ) -> *mut llvm_AttrBuilder {
        llvm_AttrBuilder_removeAttribute(self, Val)
    }
    #[inline]
    pub unsafe fn removeAttribute1(&mut self, A: llvm_StringRef) -> *mut llvm_AttrBuilder {
        llvm_AttrBuilder_removeAttribute1(self, A)
    }
    #[inline]
    pub unsafe fn merge(&mut self, B: *const llvm_AttrBuilder) -> *mut llvm_AttrBuilder {
        llvm_AttrBuilder_merge(self, B)
    }
    #[inline]
    pub unsafe fn remove(&mut self, AM: *const llvm_AttributeMask) -> *mut llvm_AttrBuilder {
        llvm_AttrBuilder_remove(self, AM)
    }
    #[inline]
    pub unsafe fn overlaps(&self, AM: *const llvm_AttributeMask) -> bool {
        llvm_AttrBuilder_overlaps(self, AM)
    }
    #[inline]
    pub unsafe fn contains(&self, A: llvm_Attribute_AttrKind) -> bool {
        llvm_AttrBuilder_contains(self, A)
    }
    #[inline]
    pub unsafe fn contains1(&self, A: llvm_StringRef) -> bool {
        llvm_AttrBuilder_contains1(self, A)
    }
    #[inline]
    pub unsafe fn getAttribute(&self, Kind: llvm_Attribute_AttrKind) -> llvm_Attribute {
        llvm_AttrBuilder_getAttribute(self, Kind)
    }
    #[inline]
    pub unsafe fn getAttribute1(&self, Kind: llvm_StringRef) -> llvm_Attribute {
        llvm_AttrBuilder_getAttribute1(self, Kind)
    }
    #[inline]
    pub unsafe fn getRawIntAttr(&self, Kind: llvm_Attribute_AttrKind) -> std_optional {
        llvm_AttrBuilder_getRawIntAttr(self, Kind)
    }
    #[inline]
    pub unsafe fn getTypeAttr(&self, Kind: llvm_Attribute_AttrKind) -> *mut llvm_Type {
        llvm_AttrBuilder_getTypeAttr(self, Kind)
    }
    #[inline]
    pub unsafe fn getAllocSizeArgs(&self) -> std_optional {
        llvm_AttrBuilder_getAllocSizeArgs(self)
    }
    #[inline]
    pub unsafe fn addRawIntAttr(
        &mut self,
        Kind: llvm_Attribute_AttrKind,
        Value: u64,
    ) -> *mut llvm_AttrBuilder {
        llvm_AttrBuilder_addRawIntAttr(self, Kind, Value)
    }
    #[inline]
    pub unsafe fn addAlignmentAttr(&mut self, Align: llvm_MaybeAlign) -> *mut llvm_AttrBuilder {
        llvm_AttrBuilder_addAlignmentAttr(self, Align)
    }
    #[inline]
    pub unsafe fn addStackAlignmentAttr(
        &mut self,
        Align: llvm_MaybeAlign,
    ) -> *mut llvm_AttrBuilder {
        llvm_AttrBuilder_addStackAlignmentAttr(self, Align)
    }
    #[inline]
    pub unsafe fn addDereferenceableAttr(&mut self, Bytes: u64) -> *mut llvm_AttrBuilder {
        llvm_AttrBuilder_addDereferenceableAttr(self, Bytes)
    }
    #[inline]
    pub unsafe fn addDereferenceableOrNullAttr(&mut self, Bytes: u64) -> *mut llvm_AttrBuilder {
        llvm_AttrBuilder_addDereferenceableOrNullAttr(self, Bytes)
    }
    #[inline]
    pub unsafe fn addAllocSizeAttr(
        &mut self,
        ElemSizeArg: ::std::os::raw::c_uint,
        NumElemsArg: *const std_optional,
    ) -> *mut llvm_AttrBuilder {
        llvm_AttrBuilder_addAllocSizeAttr(self, ElemSizeArg, NumElemsArg)
    }
    #[inline]
    pub unsafe fn addVScaleRangeAttr(
        &mut self,
        MinValue: ::std::os::raw::c_uint,
        MaxValue: std_optional,
    ) -> *mut llvm_AttrBuilder {
        llvm_AttrBuilder_addVScaleRangeAttr(self, MinValue, MaxValue)
    }
    #[inline]
    pub unsafe fn addTypeAttr(
        &mut self,
        Kind: llvm_Attribute_AttrKind,
        Ty: *mut llvm_Type,
    ) -> *mut llvm_AttrBuilder {
        llvm_AttrBuilder_addTypeAttr(self, Kind, Ty)
    }
    #[inline]
    pub unsafe fn addByValAttr(&mut self, Ty: *mut llvm_Type) -> *mut llvm_AttrBuilder {
        llvm_AttrBuilder_addByValAttr(self, Ty)
    }
    #[inline]
    pub unsafe fn addStructRetAttr(&mut self, Ty: *mut llvm_Type) -> *mut llvm_AttrBuilder {
        llvm_AttrBuilder_addStructRetAttr(self, Ty)
    }
    #[inline]
    pub unsafe fn addByRefAttr(&mut self, Ty: *mut llvm_Type) -> *mut llvm_AttrBuilder {
        llvm_AttrBuilder_addByRefAttr(self, Ty)
    }
    #[inline]
    pub unsafe fn addPreallocatedAttr(&mut self, Ty: *mut llvm_Type) -> *mut llvm_AttrBuilder {
        llvm_AttrBuilder_addPreallocatedAttr(self, Ty)
    }
    #[inline]
    pub unsafe fn addInAllocaAttr(&mut self, Ty: *mut llvm_Type) -> *mut llvm_AttrBuilder {
        llvm_AttrBuilder_addInAllocaAttr(self, Ty)
    }
    #[inline]
    pub unsafe fn addAllocSizeAttrFromRawRepr(
        &mut self,
        RawAllocSizeRepr: u64,
    ) -> *mut llvm_AttrBuilder {
        llvm_AttrBuilder_addAllocSizeAttrFromRawRepr(self, RawAllocSizeRepr)
    }
    #[inline]
    pub unsafe fn addVScaleRangeAttrFromRawRepr(
        &mut self,
        RawVScaleRangeRepr: u64,
    ) -> *mut llvm_AttrBuilder {
        llvm_AttrBuilder_addVScaleRangeAttrFromRawRepr(self, RawVScaleRangeRepr)
    }
    #[inline]
    pub unsafe fn addUWTableAttr(&mut self, Kind: llvm_UWTableKind) -> *mut llvm_AttrBuilder {
        llvm_AttrBuilder_addUWTableAttr(self, Kind)
    }
    #[inline]
    pub unsafe fn addAllocKindAttr(&mut self, Kind: llvm_AllocFnKind) -> *mut llvm_AttrBuilder {
        llvm_AttrBuilder_addAllocKindAttr(self, Kind)
    }
    #[inline]
    pub unsafe fn addMemoryAttr(&mut self, ME: llvm_MemoryEffects) -> *mut llvm_AttrBuilder {
        llvm_AttrBuilder_addMemoryAttr(self, ME)
    }
    #[inline]
    pub unsafe fn addNoFPClassAttr(
        &mut self,
        NoFPClassMask: llvm_FPClassTest,
    ) -> *mut llvm_AttrBuilder {
        llvm_AttrBuilder_addNoFPClassAttr(self, NoFPClassMask)
    }
    #[inline]
    pub unsafe fn addConstantRangeAttr(
        &mut self,
        Kind: llvm_Attribute_AttrKind,
        CR: *const llvm_ConstantRange,
    ) -> *mut llvm_AttrBuilder {
        llvm_AttrBuilder_addConstantRangeAttr(self, Kind, CR)
    }
    #[inline]
    pub unsafe fn addRangeAttr(&mut self, CR: *const llvm_ConstantRange) -> *mut llvm_AttrBuilder {
        llvm_AttrBuilder_addRangeAttr(self, CR)
    }
    #[inline]
    pub unsafe fn addConstantRangeListAttr(
        &mut self,
        Kind: llvm_Attribute_AttrKind,
        Val: llvm_ArrayRef<llvm_ConstantRange>,
    ) -> *mut llvm_AttrBuilder {
        llvm_AttrBuilder_addConstantRangeListAttr(self, Kind, Val)
    }
    #[inline]
    pub unsafe fn addInitializesAttr(
        &mut self,
        CRL: *const llvm_ConstantRangeList,
    ) -> *mut llvm_AttrBuilder {
        llvm_AttrBuilder_addInitializesAttr(self, CRL)
    }
    #[inline]
    pub unsafe fn new(Ctx: *mut llvm_LLVMContext, AS: llvm_AttributeSet) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        llvm_AttrBuilder_AttrBuilder(__bindgen_tmp.as_mut_ptr(), Ctx, AS);
        __bindgen_tmp.assume_init()
    }
}
pub const llvm_AttributeFuncs_AttributeSafetyKind_ASK_SAFE_TO_DROP:
    llvm_AttributeFuncs_AttributeSafetyKind = 1;
pub const llvm_AttributeFuncs_AttributeSafetyKind_ASK_UNSAFE_TO_DROP:
    llvm_AttributeFuncs_AttributeSafetyKind = 2;
pub const llvm_AttributeFuncs_AttributeSafetyKind_ASK_ALL: llvm_AttributeFuncs_AttributeSafetyKind =
    3;
pub type llvm_AttributeFuncs_AttributeSafetyKind = u8;
extern "C" {
    #[doc = " Returns true if this is a type legal for the 'nofpclass' attribute. This\n follows the same type rules as FPMathOperator."]
    #[link_name = "\u{1}_ZN4llvm14AttributeFuncs25isNoFPClassCompatibleTypeEPNS_4TypeE"]
    pub fn llvm_AttributeFuncs_isNoFPClassCompatibleType(Ty: *mut llvm_Type) -> bool;
}
extern "C" {
    #[doc = " Which attributes cannot be applied to a type. The argument \\p ASK indicates,\n if only attributes that are known to be safely droppable are contained in\n the mask; only attributes that might be unsafe to drop (e.g., ABI-related\n attributes) are in the mask; or both."]
    #[link_name = "\u{1}_ZN4llvm14AttributeFuncs16typeIncompatibleEPNS_4TypeENS0_19AttributeSafetyKindE"]
    pub fn llvm_AttributeFuncs_typeIncompatible(
        Ty: *mut llvm_Type,
        ASK: llvm_AttributeFuncs_AttributeSafetyKind,
    ) -> llvm_AttributeMask;
}
extern "C" {
    #[doc = " Get param/return attributes which imply immediate undefined behavior if an\n invalid value is passed. For example, this includes noundef (where undef\n implies UB), but not nonnull (where null implies poison). It also does not\n include attributes like nocapture, which constrain the function\n implementation rather than the passed value."]
    #[link_name = "\u{1}_ZN4llvm14AttributeFuncs23getUBImplyingAttributesEv"]
    pub fn llvm_AttributeFuncs_getUBImplyingAttributes() -> llvm_AttributeMask;
}
extern "C" {
    #[doc = " \\returns Return true if the two functions have compatible target-independent\n attributes for inlining purposes."]
    #[link_name = "\u{1}_ZN4llvm14AttributeFuncs19areInlineCompatibleERKNS_8FunctionES3_"]
    pub fn llvm_AttributeFuncs_areInlineCompatible(
        Caller: *const llvm_Function,
        Callee: *const llvm_Function,
    ) -> bool;
}
extern "C" {
    #[doc = " Checks  if there are any incompatible function attributes between\n \\p A and \\p B.\n\n \\param [in] A - The first function to be compared with.\n \\param [in] B - The second function to be compared with.\n \\returns true if the functions have compatible attributes."]
    #[link_name = "\u{1}_ZN4llvm14AttributeFuncs20areOutlineCompatibleERKNS_8FunctionES3_"]
    pub fn llvm_AttributeFuncs_areOutlineCompatible(
        A: *const llvm_Function,
        B: *const llvm_Function,
    ) -> bool;
}
extern "C" {
    #[doc = " Merge caller's and callee's attributes."]
    #[link_name = "\u{1}_ZN4llvm14AttributeFuncs26mergeAttributesForInliningERNS_8FunctionERKS1_"]
    pub fn llvm_AttributeFuncs_mergeAttributesForInlining(
        Caller: *mut llvm_Function,
        Callee: *const llvm_Function,
    );
}
extern "C" {
    #[doc = " Merges the functions attributes from \\p ToMerge into function \\p Base.\n\n \\param [in,out] Base - The function being merged into.\n \\param [in] ToMerge - The function to merge attributes from."]
    #[link_name = "\u{1}_ZN4llvm14AttributeFuncs27mergeAttributesForOutliningERNS_8FunctionERKS1_"]
    pub fn llvm_AttributeFuncs_mergeAttributesForOutlining(
        Base: *mut llvm_Function,
        ToMerge: *const llvm_Function,
    );
}
extern "C" {
    #[doc = " Update min-legal-vector-width if it is in Attribute and less than Width."]
    #[link_name = "\u{1}_ZN4llvm14AttributeFuncs29updateMinLegalVectorWidthAttrERNS_8FunctionEm"]
    pub fn llvm_AttributeFuncs_updateMinLegalVectorWidthAttr(Fn: *mut llvm_Function, Width: u64);
}
#[doc = " A base class for data structure classes wishing to make iterators\n (\"handles\") pointing into themselves fail-fast.  When building without\n asserts, this class is empty and does nothing.\n\n DebugEpochBase does not by itself track handles pointing into itself.  The\n expectation is that routines touching the handles will poll on\n isHandleInSync at appropriate points to assert that the handle they're using\n is still valid.\n"]
#[repr(C)]
#[derive(Debug)]
pub struct llvm_DebugEpochBase {
    pub Epoch: u64,
}
#[doc = " A base class for iterator classes (\"handles\") that wish to poll for\n iterator invalidating modifications in the underlying data structure.\n When LLVM is built without asserts, this class is empty and does nothing.\n\n HandleBase does not track the parent data structure by itself.  It expects\n the routines modifying the data structure to call incrementEpoch when they\n make an iterator-invalidating modification.\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_DebugEpochBase_HandleBase {
    pub EpochAddress: *const u64,
    pub EpochAtCreation: u64,
}
#[test]
fn bindgen_test_layout_llvm_DebugEpochBase_HandleBase() {
    const UNINIT: ::std::mem::MaybeUninit<llvm_DebugEpochBase_HandleBase> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<llvm_DebugEpochBase_HandleBase>(),
        16usize,
        concat!("Size of: ", stringify!(llvm_DebugEpochBase_HandleBase))
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_DebugEpochBase_HandleBase>(),
        8usize,
        concat!("Alignment of ", stringify!(llvm_DebugEpochBase_HandleBase))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).EpochAddress) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_DebugEpochBase_HandleBase),
            "::",
            stringify!(EpochAddress)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).EpochAtCreation) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_DebugEpochBase_HandleBase),
            "::",
            stringify!(EpochAtCreation)
        )
    );
}
#[test]
fn bindgen_test_layout_llvm_DebugEpochBase() {
    const UNINIT: ::std::mem::MaybeUninit<llvm_DebugEpochBase> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<llvm_DebugEpochBase>(),
        8usize,
        concat!("Size of: ", stringify!(llvm_DebugEpochBase))
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_DebugEpochBase>(),
        8usize,
        concat!("Alignment of ", stringify!(llvm_DebugEpochBase))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Epoch) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_DebugEpochBase),
            "::",
            stringify!(Epoch)
        )
    );
}
#[doc = " SmallPtrSetImplBase - This is the common code shared among all the\n SmallPtrSet<>'s, which is almost everything.  SmallPtrSet has two modes, one\n for small and one for large sets.\n\n Small sets use an array of pointers allocated in the SmallPtrSet object,\n which is treated as a simple array of pointers.  When a pointer is added to\n the set, the array is scanned to see if the element already exists, if not\n the element is 'pushed back' onto the array.  If we run out of space in the\n array, we grow into the 'large set' case.  SmallSet should be used when the\n sets are often small.  In this case, no memory allocation is used, and only\n light-weight and cache-efficient scanning is used.\n\n Large sets use a classic exponentially-probed hash table.  Empty buckets are\n represented with an illegal pointer value (-1) to allow null pointers to be\n inserted.  Tombstones are represented with another illegal pointer value\n (-2), to allow deletion.  The hash table is resized when the table is 3/4 or\n more.  When this happens, the table is doubled in size.\n"]
#[repr(C)]
#[derive(Debug)]
pub struct llvm_SmallPtrSetImplBase {
    pub _base: llvm_DebugEpochBase,
    #[doc = " SmallArray - Points to a fixed size set of buckets, used in 'small mode'."]
    pub SmallArray: *mut *const ::std::os::raw::c_void,
    #[doc = " CurArray - This is the current set of buckets.  If equal to SmallArray,\n then the set is in 'small mode'."]
    pub CurArray: *mut *const ::std::os::raw::c_void,
    #[doc = " CurArraySize - The allocated size of CurArray, always a power of two."]
    pub CurArraySize: ::std::os::raw::c_uint,
    #[doc = " Number of elements in CurArray that contain a value or are a tombstone.\n If small, all these elements are at the beginning of CurArray and the rest\n is uninitialized."]
    pub NumNonEmpty: ::std::os::raw::c_uint,
    #[doc = " Number of tombstones in CurArray."]
    pub NumTombstones: ::std::os::raw::c_uint,
}
pub type llvm_SmallPtrSetImplBase_size_type = ::std::os::raw::c_uint;
#[test]
fn bindgen_test_layout_llvm_SmallPtrSetImplBase() {
    const UNINIT: ::std::mem::MaybeUninit<llvm_SmallPtrSetImplBase> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<llvm_SmallPtrSetImplBase>(),
        40usize,
        concat!("Size of: ", stringify!(llvm_SmallPtrSetImplBase))
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_SmallPtrSetImplBase>(),
        8usize,
        concat!("Alignment of ", stringify!(llvm_SmallPtrSetImplBase))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).SmallArray) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_SmallPtrSetImplBase),
            "::",
            stringify!(SmallArray)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).CurArray) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_SmallPtrSetImplBase),
            "::",
            stringify!(CurArray)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).CurArraySize) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_SmallPtrSetImplBase),
            "::",
            stringify!(CurArraySize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).NumNonEmpty) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_SmallPtrSetImplBase),
            "::",
            stringify!(NumNonEmpty)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).NumTombstones) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_SmallPtrSetImplBase),
            "::",
            stringify!(NumTombstones)
        )
    );
}
extern "C" {
    #[doc = " swap - Swaps the elements of two sets.\n Note: This method assumes that both sets have the same small size."]
    #[link_name = "\u{1}_ZN4llvm19SmallPtrSetImplBase4swapERS0_"]
    pub fn llvm_SmallPtrSetImplBase_swap(
        this: *mut llvm_SmallPtrSetImplBase,
        RHS: *mut llvm_SmallPtrSetImplBase,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm19SmallPtrSetImplBase8CopyFromERKS0_"]
    pub fn llvm_SmallPtrSetImplBase_CopyFrom(
        this: *mut llvm_SmallPtrSetImplBase,
        RHS: *const llvm_SmallPtrSetImplBase,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm19SmallPtrSetImplBase8MoveFromEjOS0_"]
    pub fn llvm_SmallPtrSetImplBase_MoveFrom(
        this: *mut llvm_SmallPtrSetImplBase,
        SmallSize: ::std::os::raw::c_uint,
        RHS: *mut llvm_SmallPtrSetImplBase,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm19SmallPtrSetImplBaseC1EPPKvRKS0_"]
    pub fn llvm_SmallPtrSetImplBase_SmallPtrSetImplBase(
        this: *mut llvm_SmallPtrSetImplBase,
        SmallStorage: *mut *const ::std::os::raw::c_void,
        that: *const llvm_SmallPtrSetImplBase,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm19SmallPtrSetImplBaseC1EPPKvjOS0_"]
    pub fn llvm_SmallPtrSetImplBase_SmallPtrSetImplBase1(
        this: *mut llvm_SmallPtrSetImplBase,
        SmallStorage: *mut *const ::std::os::raw::c_void,
        SmallSize: ::std::os::raw::c_uint,
        that: *mut llvm_SmallPtrSetImplBase,
    );
}
impl llvm_SmallPtrSetImplBase {
    #[inline]
    pub unsafe fn swap(&mut self, RHS: *mut llvm_SmallPtrSetImplBase) {
        llvm_SmallPtrSetImplBase_swap(self, RHS)
    }
    #[inline]
    pub unsafe fn CopyFrom(&mut self, RHS: *const llvm_SmallPtrSetImplBase) {
        llvm_SmallPtrSetImplBase_CopyFrom(self, RHS)
    }
    #[inline]
    pub unsafe fn MoveFrom(
        &mut self,
        SmallSize: ::std::os::raw::c_uint,
        RHS: *mut llvm_SmallPtrSetImplBase,
    ) {
        llvm_SmallPtrSetImplBase_MoveFrom(self, SmallSize, RHS)
    }
    #[inline]
    pub unsafe fn new(
        SmallStorage: *mut *const ::std::os::raw::c_void,
        that: *const llvm_SmallPtrSetImplBase,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        llvm_SmallPtrSetImplBase_SmallPtrSetImplBase(
            __bindgen_tmp.as_mut_ptr(),
            SmallStorage,
            that,
        );
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(
        SmallStorage: *mut *const ::std::os::raw::c_void,
        SmallSize: ::std::os::raw::c_uint,
        that: *mut llvm_SmallPtrSetImplBase,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        llvm_SmallPtrSetImplBase_SmallPtrSetImplBase1(
            __bindgen_tmp.as_mut_ptr(),
            SmallStorage,
            SmallSize,
            that,
        );
        __bindgen_tmp.assume_init()
    }
}
#[doc = " SmallPtrSetIteratorImpl - This is the common base class shared between all\n instances of SmallPtrSetIterator."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_SmallPtrSetIteratorImpl {
    pub Bucket: *const *const ::std::os::raw::c_void,
    pub End: *const *const ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_llvm_SmallPtrSetIteratorImpl() {
    const UNINIT: ::std::mem::MaybeUninit<llvm_SmallPtrSetIteratorImpl> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<llvm_SmallPtrSetIteratorImpl>(),
        16usize,
        concat!("Size of: ", stringify!(llvm_SmallPtrSetIteratorImpl))
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_SmallPtrSetIteratorImpl>(),
        8usize,
        concat!("Alignment of ", stringify!(llvm_SmallPtrSetIteratorImpl))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Bucket) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_SmallPtrSetIteratorImpl),
            "::",
            stringify!(Bucket)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).End) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_SmallPtrSetIteratorImpl),
            "::",
            stringify!(End)
        )
    );
}
#[doc = " SmallPtrSetIterator - This implements a const_iterator for SmallPtrSet."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_SmallPtrSetIterator {
    pub _base: llvm_SmallPtrSetIteratorImpl,
    pub _base_1: llvm_DebugEpochBase_HandleBase,
}
pub type llvm_SmallPtrSetIterator_PtrTraits = llvm_PointerLikeTypeTraits;
pub type llvm_SmallPtrSetIterator_value_type<PtrTy> = PtrTy;
pub type llvm_SmallPtrSetIterator_reference<PtrTy> = PtrTy;
pub type llvm_SmallPtrSetIterator_pointer<PtrTy> = PtrTy;
pub type llvm_SmallPtrSetIterator_difference_type = isize;
pub type llvm_SmallPtrSetIterator_iterator_category = std_forward_iterator_tag;
#[doc = " A templated base class for \\c SmallPtrSet which provides the\n typesafe interface that is common across all small sizes.\n\n This is particularly useful for passing around between interface boundaries\n to avoid encoding a particular small size in the interface boundary."]
#[repr(C)]
#[derive(Debug)]
pub struct llvm_SmallPtrSetImpl {
    pub _base: llvm_SmallPtrSetImplBase,
}
pub type llvm_SmallPtrSetImpl_ConstPtrType = llvm_add_const_past_pointer;
pub type llvm_SmallPtrSetImpl_PtrTraits = llvm_PointerLikeTypeTraits;
pub type llvm_SmallPtrSetImpl_ConstPtrTraits = llvm_PointerLikeTypeTraits;
#[doc = " SmallPtrSetIterator - This implements a const_iterator for SmallPtrSet."]
pub type llvm_SmallPtrSetImpl_iterator = llvm_SmallPtrSetIterator;
#[doc = " SmallPtrSetIterator - This implements a const_iterator for SmallPtrSet."]
pub type llvm_SmallPtrSetImpl_const_iterator = llvm_SmallPtrSetIterator;
pub type llvm_SmallPtrSetImpl_key_type = llvm_SmallPtrSetImpl_ConstPtrType;
pub type llvm_SmallPtrSetImpl_value_type<PtrType> = PtrType;
#[doc = " A templated base class for \\c SmallPtrSet which provides the\n typesafe interface that is common across all small sizes.\n\n This is particularly useful for passing around between interface boundaries\n to avoid encoding a particular small size in the interface boundary."]
pub type llvm_SmallPtrSet_BaseT = llvm_SmallPtrSetImpl;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_Comdat {
    pub Name: *mut llvm_StringMapEntry<llvm_Comdat>,
    pub SK: llvm_Comdat_SelectionKind,
    pub Users: [u64; 7usize],
}
#[doc = "< The linker may choose any COMDAT."]
pub const llvm_Comdat_SelectionKind_Any: llvm_Comdat_SelectionKind = 0;
#[doc = "< The data referenced by the COMDAT must be the same."]
pub const llvm_Comdat_SelectionKind_ExactMatch: llvm_Comdat_SelectionKind = 1;
#[doc = "< The linker will choose the largest COMDAT."]
pub const llvm_Comdat_SelectionKind_Largest: llvm_Comdat_SelectionKind = 2;
#[doc = "< No deduplication is performed."]
pub const llvm_Comdat_SelectionKind_NoDeduplicate: llvm_Comdat_SelectionKind = 3;
#[doc = "< The data referenced by the COMDAT must be the same size."]
pub const llvm_Comdat_SelectionKind_SameSize: llvm_Comdat_SelectionKind = 4;
pub type llvm_Comdat_SelectionKind = ::std::os::raw::c_uint;
#[test]
fn bindgen_test_layout_llvm_Comdat() {
    const UNINIT: ::std::mem::MaybeUninit<llvm_Comdat> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<llvm_Comdat>(),
        72usize,
        concat!("Size of: ", stringify!(llvm_Comdat))
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_Comdat>(),
        8usize,
        concat!("Alignment of ", stringify!(llvm_Comdat))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_Comdat),
            "::",
            stringify!(Name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).SK) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_Comdat),
            "::",
            stringify!(SK)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Users) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_Comdat),
            "::",
            stringify!(Users)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK4llvm6Comdat7getNameEv"]
    pub fn llvm_Comdat_getName(this: *const llvm_Comdat) -> llvm_StringRef;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4llvm6Comdat5printERNS_11raw_ostreamEb"]
    pub fn llvm_Comdat_print(this: *const llvm_Comdat, OS: *mut llvm_raw_ostream, IsForDebug: bool);
}
extern "C" {
    #[link_name = "\u{1}_ZNK4llvm6Comdat4dumpEv"]
    pub fn llvm_Comdat_dump(this: *const llvm_Comdat);
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm6ComdatC1EOS0_"]
    pub fn llvm_Comdat_Comdat(this: *mut llvm_Comdat, C: *mut llvm_Comdat);
}
impl llvm_Comdat {
    #[inline]
    pub unsafe fn getName(&self) -> llvm_StringRef {
        llvm_Comdat_getName(self)
    }
    #[inline]
    pub unsafe fn print(&self, OS: *mut llvm_raw_ostream, IsForDebug: bool) {
        llvm_Comdat_print(self, OS, IsForDebug)
    }
    #[inline]
    pub unsafe fn dump(&self) {
        llvm_Comdat_dump(self)
    }
    #[inline]
    pub unsafe fn new(C: *mut llvm_Comdat) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        llvm_Comdat_Comdat(__bindgen_tmp.as_mut_ptr(), C);
        __bindgen_tmp.assume_init()
    }
}
pub type llvm_float128 = u128;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_DynamicAPInt {
    _unused: [u8; 0],
}
#[doc = " Class for arbitrary precision integers.\n\n APInt is a functional replacement for common case unsigned integer type like\n \"unsigned\", \"unsigned long\" or \"uint64_t\", but also allows non-byte-width\n integer sizes and large integer value types such as 3-bits, 15-bits, or more\n than 64-bits of precision. APInt provides a variety of arithmetic operators\n and methods to manipulate integer values of any bit-width. It supports both\n the typical integer arithmetic and comparison operations as well as bitwise\n manipulation.\n\n The class has several invariants worth noting:\n   * All bit, byte, and word positions are zero-based.\n   * Once the bit width is set, it doesn't change except by the Truncate,\n     SignExtend, or ZeroExtend operations.\n   * All binary operators must be on APInt instances of the same bit width.\n     Attempting to use these operators on instances with different bit\n     widths will yield an assertion.\n   * The value is stored canonically as an unsigned value. For operations\n     where it makes a difference, there are both signed and unsigned variants\n     of the operation. For example, sdiv and udiv. However, because the bit\n     widths must be the same, operations such as Mul and Add produce the same\n     results regardless of whether the values are interpreted as signed or\n     not.\n   * In general, the class tries to follow the style of computation that LLVM\n     uses in its IR. This simplifies its use for LLVM.\n   * APInt supports zero-bit-width values, but operations that require bits\n     are not defined on it (e.g. you cannot ask for the sign of a zero-bit\n     integer).  This means that operations like zero extension and logical\n     shifts are defined, but sign extension and ashr is not.  Zero bit values\n     compare and hash equal to themselves, and countLeadingZeros returns 0.\n"]
#[repr(C)]
pub struct llvm_APInt {
    pub U: llvm_APInt__bindgen_ty_1,
    #[doc = "< The number of bits in this APInt."]
    pub BitWidth: ::std::os::raw::c_uint,
}
pub type llvm_APInt_WordType = u64;
pub const llvm_APInt_Rounding_DOWN: llvm_APInt_Rounding = 0;
pub const llvm_APInt_Rounding_TOWARD_ZERO: llvm_APInt_Rounding = 1;
pub const llvm_APInt_Rounding_UP: llvm_APInt_Rounding = 2;
pub type llvm_APInt_Rounding = ::std::os::raw::c_int;
#[doc = " This union is used to store the integer value. When the\n integer bit-width <= 64, it uses VAL, otherwise it uses pVal."]
#[repr(C)]
#[derive(Copy, Clone)]
pub union llvm_APInt__bindgen_ty_1 {
    #[doc = "< Used to store the <= 64 bits integer value."]
    pub VAL: u64,
    #[doc = "< Used to store the >64 bits integer value."]
    pub pVal: *mut u64,
}
#[test]
fn bindgen_test_layout_llvm_APInt__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<llvm_APInt__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<llvm_APInt__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(llvm_APInt__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_APInt__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(llvm_APInt__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).VAL) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_APInt__bindgen_ty_1),
            "::",
            stringify!(VAL)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pVal) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_APInt__bindgen_ty_1),
            "::",
            stringify!(pVal)
        )
    );
}
#[doc = " Byte size of a word."]
pub const llvm_APInt_APINT_WORD_SIZE: ::std::os::raw::c_uint = 8;
#[doc = " Bits in a word."]
pub const llvm_APInt_APINT_BITS_PER_WORD: ::std::os::raw::c_uint = 64;
extern "C" {
    #[link_name = "\u{1}_ZN4llvm5APInt12WORDTYPE_MAXE"]
    pub static llvm_APInt_WORDTYPE_MAX: llvm_APInt_WordType;
}
#[test]
fn bindgen_test_layout_llvm_APInt() {
    const UNINIT: ::std::mem::MaybeUninit<llvm_APInt> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<llvm_APInt>(),
        16usize,
        concat!("Size of: ", stringify!(llvm_APInt))
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_APInt>(),
        8usize,
        concat!("Alignment of ", stringify!(llvm_APInt))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).U) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_APInt),
            "::",
            stringify!(U)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).BitWidth) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_APInt),
            "::",
            stringify!(BitWidth)
        )
    );
}
extern "C" {
    #[doc = " Return a value containing V broadcasted over NewLen bits."]
    #[link_name = "\u{1}_ZN4llvm5APInt8getSplatEjRKS0_"]
    pub fn llvm_APInt_getSplat(NewLen: ::std::os::raw::c_uint, V: *const llvm_APInt) -> llvm_APInt;
}
extern "C" {
    #[doc = " Checks if this APInt -interpreted as an address- is aligned to the\n provided value."]
    #[link_name = "\u{1}_ZNK4llvm5APInt9isAlignedENS_5AlignE"]
    pub fn llvm_APInt_isAligned(this: *const llvm_APInt, A: llvm_Align) -> bool;
}
extern "C" {
    #[doc = " Check if the APInt consists of a repeated bit pattern.\n\n e.g. 0x01010101 satisfies isSplat(8).\n \\param SplatSizeInBits The size of the pattern in bits. Must divide bit\n width without remainder."]
    #[link_name = "\u{1}_ZNK4llvm5APInt7isSplatEj"]
    pub fn llvm_APInt_isSplat(
        this: *const llvm_APInt,
        SplatSizeInBits: ::std::os::raw::c_uint,
    ) -> bool;
}
extern "C" {
    #[doc = " Compute an APInt containing numBits highbits from this APInt.\n\n Get an APInt with the same BitWidth as this APInt, just zero mask the low\n bits and right shift to the least significant bit.\n\n \\returns the high \"numBits\" bits of this APInt."]
    #[link_name = "\u{1}_ZNK4llvm5APInt9getHiBitsEj"]
    pub fn llvm_APInt_getHiBits(
        this: *const llvm_APInt,
        numBits: ::std::os::raw::c_uint,
    ) -> llvm_APInt;
}
extern "C" {
    #[doc = " Compute an APInt containing numBits lowbits from this APInt.\n\n Get an APInt with the same BitWidth as this APInt, just zero mask the high\n bits.\n\n \\returns the low \"numBits\" bits of this APInt."]
    #[link_name = "\u{1}_ZNK4llvm5APInt9getLoBitsEj"]
    pub fn llvm_APInt_getLoBits(
        this: *const llvm_APInt,
        numBits: ::std::os::raw::c_uint,
    ) -> llvm_APInt;
}
extern "C" {
    #[doc = " Rotate left by rotateAmt."]
    #[link_name = "\u{1}_ZNK4llvm5APInt4rotlEj"]
    pub fn llvm_APInt_rotl(
        this: *const llvm_APInt,
        rotateAmt: ::std::os::raw::c_uint,
    ) -> llvm_APInt;
}
extern "C" {
    #[doc = " Rotate right by rotateAmt."]
    #[link_name = "\u{1}_ZNK4llvm5APInt4rotrEj"]
    pub fn llvm_APInt_rotr(
        this: *const llvm_APInt,
        rotateAmt: ::std::os::raw::c_uint,
    ) -> llvm_APInt;
}
extern "C" {
    #[doc = " Arithmetic right-shift this APInt by shiftAmt in place."]
    #[link_name = "\u{1}_ZN4llvm5APInt11ashrInPlaceERKS0_"]
    pub fn llvm_APInt_ashrInPlace(this: *mut llvm_APInt, shiftAmt: *const llvm_APInt);
}
extern "C" {
    #[doc = " Logical right-shift this APInt by ShiftAmt in place."]
    #[link_name = "\u{1}_ZN4llvm5APInt11lshrInPlaceERKS0_"]
    pub fn llvm_APInt_lshrInPlace(this: *mut llvm_APInt, ShiftAmt: *const llvm_APInt);
}
extern "C" {
    #[doc = " Rotate left by rotateAmt."]
    #[link_name = "\u{1}_ZNK4llvm5APInt4rotlERKS0_"]
    pub fn llvm_APInt_rotl1(this: *const llvm_APInt, rotateAmt: *const llvm_APInt) -> llvm_APInt;
}
extern "C" {
    #[doc = " Rotate right by rotateAmt."]
    #[link_name = "\u{1}_ZNK4llvm5APInt4rotrERKS0_"]
    pub fn llvm_APInt_rotr1(this: *const llvm_APInt, rotateAmt: *const llvm_APInt) -> llvm_APInt;
}
extern "C" {
    #[doc = " Unsigned division operation.\n\n Perform an unsigned divide operation on this APInt by RHS. Both this and\n RHS are treated as unsigned quantities for purposes of this division.\n\n \\returns a new APInt value containing the division result, rounded towards\n zero."]
    #[link_name = "\u{1}_ZNK4llvm5APInt4udivERKS0_"]
    pub fn llvm_APInt_udiv(this: *const llvm_APInt, RHS: *const llvm_APInt) -> llvm_APInt;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4llvm5APInt4udivEm"]
    pub fn llvm_APInt_udiv1(this: *const llvm_APInt, RHS: u64) -> llvm_APInt;
}
extern "C" {
    #[doc = " Signed division function for APInt.\n\n Signed divide this APInt by APInt RHS.\n\n The result is rounded towards zero."]
    #[link_name = "\u{1}_ZNK4llvm5APInt4sdivERKS0_"]
    pub fn llvm_APInt_sdiv(this: *const llvm_APInt, RHS: *const llvm_APInt) -> llvm_APInt;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4llvm5APInt4sdivEl"]
    pub fn llvm_APInt_sdiv1(this: *const llvm_APInt, RHS: i64) -> llvm_APInt;
}
extern "C" {
    #[doc = " Unsigned remainder operation.\n\n Perform an unsigned remainder operation on this APInt with RHS being the\n divisor. Both this and RHS are treated as unsigned quantities for purposes\n of this operation.\n\n \\returns a new APInt value containing the remainder result"]
    #[link_name = "\u{1}_ZNK4llvm5APInt4uremERKS0_"]
    pub fn llvm_APInt_urem(this: *const llvm_APInt, RHS: *const llvm_APInt) -> llvm_APInt;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4llvm5APInt4uremEm"]
    pub fn llvm_APInt_urem1(this: *const llvm_APInt, RHS: u64) -> u64;
}
extern "C" {
    #[doc = " Function for signed remainder operation.\n\n Signed remainder operation on APInt.\n\n Note that this is a true remainder operation and not a modulo operation\n because the sign follows the sign of the dividend which is *this."]
    #[link_name = "\u{1}_ZNK4llvm5APInt4sremERKS0_"]
    pub fn llvm_APInt_srem(this: *const llvm_APInt, RHS: *const llvm_APInt) -> llvm_APInt;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4llvm5APInt4sremEl"]
    pub fn llvm_APInt_srem1(this: *const llvm_APInt, RHS: i64) -> i64;
}
extern "C" {
    #[doc = " Dual division/remainder interface.\n\n Sometimes it is convenient to divide two APInt values and obtain both the\n quotient and remainder. This function does both operations in the same\n computation making it a little more efficient. The pair of input arguments\n may overlap with the pair of output arguments. It is safe to call\n udivrem(X, Y, X, Y), for example."]
    #[link_name = "\u{1}_ZN4llvm5APInt7udivremERKS0_S2_RS0_S3_"]
    pub fn llvm_APInt_udivrem(
        LHS: *const llvm_APInt,
        RHS: *const llvm_APInt,
        Quotient: *mut llvm_APInt,
        Remainder: *mut llvm_APInt,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm5APInt7udivremERKS0_mRS0_Rm"]
    pub fn llvm_APInt_udivrem1(
        LHS: *const llvm_APInt,
        RHS: u64,
        Quotient: *mut llvm_APInt,
        Remainder: *mut u64,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm5APInt7sdivremERKS0_S2_RS0_S3_"]
    pub fn llvm_APInt_sdivrem(
        LHS: *const llvm_APInt,
        RHS: *const llvm_APInt,
        Quotient: *mut llvm_APInt,
        Remainder: *mut llvm_APInt,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm5APInt7sdivremERKS0_lRS0_Rl"]
    pub fn llvm_APInt_sdivrem1(
        LHS: *const llvm_APInt,
        RHS: i64,
        Quotient: *mut llvm_APInt,
        Remainder: *mut i64,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK4llvm5APInt7sadd_ovERKS0_Rb"]
    pub fn llvm_APInt_sadd_ov(
        this: *const llvm_APInt,
        RHS: *const llvm_APInt,
        Overflow: *mut bool,
    ) -> llvm_APInt;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4llvm5APInt7uadd_ovERKS0_Rb"]
    pub fn llvm_APInt_uadd_ov(
        this: *const llvm_APInt,
        RHS: *const llvm_APInt,
        Overflow: *mut bool,
    ) -> llvm_APInt;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4llvm5APInt7ssub_ovERKS0_Rb"]
    pub fn llvm_APInt_ssub_ov(
        this: *const llvm_APInt,
        RHS: *const llvm_APInt,
        Overflow: *mut bool,
    ) -> llvm_APInt;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4llvm5APInt7usub_ovERKS0_Rb"]
    pub fn llvm_APInt_usub_ov(
        this: *const llvm_APInt,
        RHS: *const llvm_APInt,
        Overflow: *mut bool,
    ) -> llvm_APInt;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4llvm5APInt7sdiv_ovERKS0_Rb"]
    pub fn llvm_APInt_sdiv_ov(
        this: *const llvm_APInt,
        RHS: *const llvm_APInt,
        Overflow: *mut bool,
    ) -> llvm_APInt;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4llvm5APInt7smul_ovERKS0_Rb"]
    pub fn llvm_APInt_smul_ov(
        this: *const llvm_APInt,
        RHS: *const llvm_APInt,
        Overflow: *mut bool,
    ) -> llvm_APInt;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4llvm5APInt7umul_ovERKS0_Rb"]
    pub fn llvm_APInt_umul_ov(
        this: *const llvm_APInt,
        RHS: *const llvm_APInt,
        Overflow: *mut bool,
    ) -> llvm_APInt;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4llvm5APInt7sshl_ovERKS0_Rb"]
    pub fn llvm_APInt_sshl_ov(
        this: *const llvm_APInt,
        Amt: *const llvm_APInt,
        Overflow: *mut bool,
    ) -> llvm_APInt;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4llvm5APInt7sshl_ovEjRb"]
    pub fn llvm_APInt_sshl_ov1(
        this: *const llvm_APInt,
        Amt: ::std::os::raw::c_uint,
        Overflow: *mut bool,
    ) -> llvm_APInt;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4llvm5APInt7ushl_ovERKS0_Rb"]
    pub fn llvm_APInt_ushl_ov(
        this: *const llvm_APInt,
        Amt: *const llvm_APInt,
        Overflow: *mut bool,
    ) -> llvm_APInt;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4llvm5APInt7ushl_ovEjRb"]
    pub fn llvm_APInt_ushl_ov1(
        this: *const llvm_APInt,
        Amt: ::std::os::raw::c_uint,
        Overflow: *mut bool,
    ) -> llvm_APInt;
}
extern "C" {
    #[doc = " Signed integer floor division operation.\n\n Rounds towards negative infinity, i.e. 5 / -2 = -3. Iff minimum value\n divided by -1 set Overflow to true."]
    #[link_name = "\u{1}_ZNK4llvm5APInt12sfloordiv_ovERKS0_Rb"]
    pub fn llvm_APInt_sfloordiv_ov(
        this: *const llvm_APInt,
        RHS: *const llvm_APInt,
        Overflow: *mut bool,
    ) -> llvm_APInt;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4llvm5APInt8sadd_satERKS0_"]
    pub fn llvm_APInt_sadd_sat(this: *const llvm_APInt, RHS: *const llvm_APInt) -> llvm_APInt;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4llvm5APInt8uadd_satERKS0_"]
    pub fn llvm_APInt_uadd_sat(this: *const llvm_APInt, RHS: *const llvm_APInt) -> llvm_APInt;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4llvm5APInt8ssub_satERKS0_"]
    pub fn llvm_APInt_ssub_sat(this: *const llvm_APInt, RHS: *const llvm_APInt) -> llvm_APInt;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4llvm5APInt8usub_satERKS0_"]
    pub fn llvm_APInt_usub_sat(this: *const llvm_APInt, RHS: *const llvm_APInt) -> llvm_APInt;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4llvm5APInt8smul_satERKS0_"]
    pub fn llvm_APInt_smul_sat(this: *const llvm_APInt, RHS: *const llvm_APInt) -> llvm_APInt;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4llvm5APInt8umul_satERKS0_"]
    pub fn llvm_APInt_umul_sat(this: *const llvm_APInt, RHS: *const llvm_APInt) -> llvm_APInt;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4llvm5APInt8sshl_satERKS0_"]
    pub fn llvm_APInt_sshl_sat(this: *const llvm_APInt, RHS: *const llvm_APInt) -> llvm_APInt;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4llvm5APInt8sshl_satEj"]
    pub fn llvm_APInt_sshl_sat1(this: *const llvm_APInt, RHS: ::std::os::raw::c_uint)
        -> llvm_APInt;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4llvm5APInt8ushl_satERKS0_"]
    pub fn llvm_APInt_ushl_sat(this: *const llvm_APInt, RHS: *const llvm_APInt) -> llvm_APInt;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4llvm5APInt8ushl_satEj"]
    pub fn llvm_APInt_ushl_sat1(this: *const llvm_APInt, RHS: ::std::os::raw::c_uint)
        -> llvm_APInt;
}
extern "C" {
    #[doc = " Truncate to new width.\n\n Truncate the APInt to a specified width. It is an error to specify a width\n that is greater than the current width."]
    #[link_name = "\u{1}_ZNK4llvm5APInt5truncEj"]
    pub fn llvm_APInt_trunc(this: *const llvm_APInt, width: ::std::os::raw::c_uint) -> llvm_APInt;
}
extern "C" {
    #[doc = " Truncate to new width with unsigned saturation.\n\n If the APInt, treated as unsigned integer, can be losslessly truncated to\n the new bitwidth, then return truncated APInt. Else, return max value."]
    #[link_name = "\u{1}_ZNK4llvm5APInt9truncUSatEj"]
    pub fn llvm_APInt_truncUSat(
        this: *const llvm_APInt,
        width: ::std::os::raw::c_uint,
    ) -> llvm_APInt;
}
extern "C" {
    #[doc = " Truncate to new width with signed saturation.\n\n If this APInt, treated as signed integer, can be losslessly truncated to\n the new bitwidth, then return truncated APInt. Else, return either\n signed min value if the APInt was negative, or signed max value."]
    #[link_name = "\u{1}_ZNK4llvm5APInt9truncSSatEj"]
    pub fn llvm_APInt_truncSSat(
        this: *const llvm_APInt,
        width: ::std::os::raw::c_uint,
    ) -> llvm_APInt;
}
extern "C" {
    #[doc = " Sign extend to a new width.\n\n This operation sign extends the APInt to a new width. If the high order\n bit is set, the fill on the left will be done with 1 bits, otherwise zero.\n It is an error to specify a width that is less than the\n current width."]
    #[link_name = "\u{1}_ZNK4llvm5APInt4sextEj"]
    pub fn llvm_APInt_sext(this: *const llvm_APInt, width: ::std::os::raw::c_uint) -> llvm_APInt;
}
extern "C" {
    #[doc = " Zero extend to a new width.\n\n This operation zero extends the APInt to a new width. The high order bits\n are filled with 0 bits.  It is an error to specify a width that is less\n than the current width."]
    #[link_name = "\u{1}_ZNK4llvm5APInt4zextEj"]
    pub fn llvm_APInt_zext(this: *const llvm_APInt, width: ::std::os::raw::c_uint) -> llvm_APInt;
}
extern "C" {
    #[doc = " Sign extend or truncate to width\n\n Make this APInt have the bit width given by \\p width. The value is sign\n extended, truncated, or left alone to make it that width."]
    #[link_name = "\u{1}_ZNK4llvm5APInt11sextOrTruncEj"]
    pub fn llvm_APInt_sextOrTrunc(
        this: *const llvm_APInt,
        width: ::std::os::raw::c_uint,
    ) -> llvm_APInt;
}
extern "C" {
    #[doc = " Zero extend or truncate to width\n\n Make this APInt have the bit width given by \\p width. The value is zero\n extended, truncated, or left alone to make it that width."]
    #[link_name = "\u{1}_ZNK4llvm5APInt11zextOrTruncEj"]
    pub fn llvm_APInt_zextOrTrunc(
        this: *const llvm_APInt,
        width: ::std::os::raw::c_uint,
    ) -> llvm_APInt;
}
extern "C" {
    #[doc = " Toggles a given bit to its opposite value.\n\n Toggle a given bit to its opposite value whose position is given\n as \"bitPosition\"."]
    #[link_name = "\u{1}_ZN4llvm5APInt7flipBitEj"]
    pub fn llvm_APInt_flipBit(this: *mut llvm_APInt, bitPosition: ::std::os::raw::c_uint);
}
extern "C" {
    #[doc = " Insert the bits from a smaller APInt starting at bitPosition."]
    #[link_name = "\u{1}_ZN4llvm5APInt10insertBitsERKS0_j"]
    pub fn llvm_APInt_insertBits(
        this: *mut llvm_APInt,
        SubBits: *const llvm_APInt,
        bitPosition: ::std::os::raw::c_uint,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm5APInt10insertBitsEmjj"]
    pub fn llvm_APInt_insertBits1(
        this: *mut llvm_APInt,
        SubBits: u64,
        bitPosition: ::std::os::raw::c_uint,
        numBits: ::std::os::raw::c_uint,
    );
}
extern "C" {
    #[doc = " Return an APInt with the extracted bits [bitPosition,bitPosition+numBits)."]
    #[link_name = "\u{1}_ZNK4llvm5APInt11extractBitsEjj"]
    pub fn llvm_APInt_extractBits(
        this: *const llvm_APInt,
        numBits: ::std::os::raw::c_uint,
        bitPosition: ::std::os::raw::c_uint,
    ) -> llvm_APInt;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4llvm5APInt22extractBitsAsZExtValueEjj"]
    pub fn llvm_APInt_extractBitsAsZExtValue(
        this: *const llvm_APInt,
        numBits: ::std::os::raw::c_uint,
        bitPosition: ::std::os::raw::c_uint,
    ) -> u64;
}
extern "C" {
    #[doc = " Get bits required for string value.\n\n This method determines how many bits are required to hold the APInt\n equivalent of the string given by \\p str."]
    #[link_name = "\u{1}_ZN4llvm5APInt13getBitsNeededENS_9StringRefEh"]
    pub fn llvm_APInt_getBitsNeeded(str_: llvm_StringRef, radix: u8) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " Get the bits that are sufficient to represent the string value. This may\n over estimate the amount of bits required, but it does not require\n parsing the value in the string."]
    #[link_name = "\u{1}_ZN4llvm5APInt23getSufficientBitsNeededENS_9StringRefEh"]
    pub fn llvm_APInt_getSufficientBitsNeeded(
        Str: llvm_StringRef,
        Radix: u8,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " @}\n \\name Conversion Functions\n @{"]
    #[link_name = "\u{1}_ZNK4llvm5APInt5printERNS_11raw_ostreamEb"]
    pub fn llvm_APInt_print(this: *const llvm_APInt, OS: *mut llvm_raw_ostream, isSigned: bool);
}
extern "C" {
    #[doc = " Converts an APInt to a string and append it to Str.  Str is commonly a\n SmallString. If Radix > 10, UpperCase determine the case of letter\n digits."]
    #[link_name = "\u{1}_ZNK4llvm5APInt8toStringERNS_15SmallVectorImplIcEEjbbbb"]
    pub fn llvm_APInt_toString(
        this: *const llvm_APInt,
        Str: *mut llvm_SmallVectorImpl,
        Radix: ::std::os::raw::c_uint,
        Signed: bool,
        formatAsCLiteral: bool,
        UpperCase: bool,
        InsertSeparators: bool,
    );
}
extern "C" {
    #[doc = " \\returns a byte-swapped representation of this APInt Value."]
    #[link_name = "\u{1}_ZNK4llvm5APInt8byteSwapEv"]
    pub fn llvm_APInt_byteSwap(this: *const llvm_APInt) -> llvm_APInt;
}
extern "C" {
    #[doc = " \\returns the value with the bit representation reversed of this APInt\n Value."]
    #[link_name = "\u{1}_ZNK4llvm5APInt11reverseBitsEv"]
    pub fn llvm_APInt_reverseBits(this: *const llvm_APInt) -> llvm_APInt;
}
extern "C" {
    #[doc = " Converts this APInt to a double value."]
    #[link_name = "\u{1}_ZNK4llvm5APInt13roundToDoubleEb"]
    pub fn llvm_APInt_roundToDouble(this: *const llvm_APInt, isSigned: bool) -> f64;
}
extern "C" {
    #[doc = " \\returns the nearest log base 2 of this APInt. Ties round up.\n\n NOTE: When we have a BitWidth of 1, we define:\n\n   log2(0) = UINT32_MAX\n   log2(1) = 0\n\n to get around any mathematical concerns resulting from\n referencing 2 in a space where 2 does no exist."]
    #[link_name = "\u{1}_ZNK4llvm5APInt15nearestLogBase2Ev"]
    pub fn llvm_APInt_nearestLogBase2(this: *const llvm_APInt) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " Compute the square root."]
    #[link_name = "\u{1}_ZNK4llvm5APInt4sqrtEv"]
    pub fn llvm_APInt_sqrt(this: *const llvm_APInt) -> llvm_APInt;
}
extern "C" {
    #[doc = " \\returns the multiplicative inverse of an odd APInt modulo 2^BitWidth."]
    #[link_name = "\u{1}_ZNK4llvm5APInt21multiplicativeInverseEv"]
    pub fn llvm_APInt_multiplicativeInverse(this: *const llvm_APInt) -> llvm_APInt;
}
extern "C" {
    #[doc = " Sets the least significant part of a bignum to the input value, and zeroes\n out higher parts."]
    #[link_name = "\u{1}_ZN4llvm5APInt5tcSetEPmmj"]
    pub fn llvm_APInt_tcSet(
        arg1: *mut llvm_APInt_WordType,
        arg2: llvm_APInt_WordType,
        arg3: ::std::os::raw::c_uint,
    );
}
extern "C" {
    #[doc = " Assign one bignum to another."]
    #[link_name = "\u{1}_ZN4llvm5APInt8tcAssignEPmPKmj"]
    pub fn llvm_APInt_tcAssign(
        arg1: *mut llvm_APInt_WordType,
        arg2: *const llvm_APInt_WordType,
        arg3: ::std::os::raw::c_uint,
    );
}
extern "C" {
    #[doc = " Returns true if a bignum is zero, false otherwise."]
    #[link_name = "\u{1}_ZN4llvm5APInt8tcIsZeroEPKmj"]
    pub fn llvm_APInt_tcIsZero(
        arg1: *const llvm_APInt_WordType,
        arg2: ::std::os::raw::c_uint,
    ) -> bool;
}
extern "C" {
    #[doc = " Extract the given bit of a bignum; returns 0 or 1.  Zero-based."]
    #[link_name = "\u{1}_ZN4llvm5APInt12tcExtractBitEPKmj"]
    pub fn llvm_APInt_tcExtractBit(
        arg1: *const llvm_APInt_WordType,
        bit: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Copy the bit vector of width srcBITS from SRC, starting at bit srcLSB, to\n DST, of dstCOUNT parts, such that the bit srcLSB becomes the least\n significant bit of DST.  All high bits above srcBITS in DST are\n zero-filled."]
    #[link_name = "\u{1}_ZN4llvm5APInt9tcExtractEPmjPKmjj"]
    pub fn llvm_APInt_tcExtract(
        arg1: *mut llvm_APInt_WordType,
        dstCount: ::std::os::raw::c_uint,
        arg2: *const llvm_APInt_WordType,
        srcBits: ::std::os::raw::c_uint,
        srcLSB: ::std::os::raw::c_uint,
    );
}
extern "C" {
    #[doc = " Set the given bit of a bignum.  Zero-based."]
    #[link_name = "\u{1}_ZN4llvm5APInt8tcSetBitEPmj"]
    pub fn llvm_APInt_tcSetBit(arg1: *mut llvm_APInt_WordType, bit: ::std::os::raw::c_uint);
}
extern "C" {
    #[doc = " Clear the given bit of a bignum.  Zero-based."]
    #[link_name = "\u{1}_ZN4llvm5APInt10tcClearBitEPmj"]
    pub fn llvm_APInt_tcClearBit(arg1: *mut llvm_APInt_WordType, bit: ::std::os::raw::c_uint);
}
extern "C" {
    #[doc = " Returns the bit number of the least or most significant set bit of a\n number.  If the input number has no bits set -1U is returned."]
    #[link_name = "\u{1}_ZN4llvm5APInt5tcLSBEPKmj"]
    pub fn llvm_APInt_tcLSB(
        arg1: *const llvm_APInt_WordType,
        n: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm5APInt5tcMSBEPKmj"]
    pub fn llvm_APInt_tcMSB(
        parts: *const llvm_APInt_WordType,
        n: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " Negate a bignum in-place."]
    #[link_name = "\u{1}_ZN4llvm5APInt8tcNegateEPmj"]
    pub fn llvm_APInt_tcNegate(arg1: *mut llvm_APInt_WordType, arg2: ::std::os::raw::c_uint);
}
extern "C" {
    #[doc = " DST += RHS + CARRY where CARRY is zero or one.  Returns the carry flag."]
    #[link_name = "\u{1}_ZN4llvm5APInt5tcAddEPmPKmmj"]
    pub fn llvm_APInt_tcAdd(
        arg1: *mut llvm_APInt_WordType,
        arg2: *const llvm_APInt_WordType,
        carry: llvm_APInt_WordType,
        arg3: ::std::os::raw::c_uint,
    ) -> llvm_APInt_WordType;
}
extern "C" {
    #[doc = " DST += RHS.  Returns the carry flag."]
    #[link_name = "\u{1}_ZN4llvm5APInt9tcAddPartEPmmj"]
    pub fn llvm_APInt_tcAddPart(
        arg1: *mut llvm_APInt_WordType,
        arg2: llvm_APInt_WordType,
        arg3: ::std::os::raw::c_uint,
    ) -> llvm_APInt_WordType;
}
extern "C" {
    #[doc = " DST -= RHS + CARRY where CARRY is zero or one. Returns the carry flag."]
    #[link_name = "\u{1}_ZN4llvm5APInt10tcSubtractEPmPKmmj"]
    pub fn llvm_APInt_tcSubtract(
        arg1: *mut llvm_APInt_WordType,
        arg2: *const llvm_APInt_WordType,
        carry: llvm_APInt_WordType,
        arg3: ::std::os::raw::c_uint,
    ) -> llvm_APInt_WordType;
}
extern "C" {
    #[doc = " DST -= RHS.  Returns the carry flag."]
    #[link_name = "\u{1}_ZN4llvm5APInt14tcSubtractPartEPmmj"]
    pub fn llvm_APInt_tcSubtractPart(
        arg1: *mut llvm_APInt_WordType,
        arg2: llvm_APInt_WordType,
        arg3: ::std::os::raw::c_uint,
    ) -> llvm_APInt_WordType;
}
extern "C" {
    #[doc = " DST += SRC * MULTIPLIER + PART   if add is true\n DST  = SRC * MULTIPLIER + PART   if add is false\n\n Requires 0 <= DSTPARTS <= SRCPARTS + 1.  If DST overlaps SRC they must\n start at the same point, i.e. DST == SRC.\n\n If DSTPARTS == SRC_PARTS + 1 no overflow occurs and zero is returned.\n Otherwise DST is filled with the least significant DSTPARTS parts of the\n result, and if all of the omitted higher parts were zero return zero,\n otherwise overflow occurred and return one."]
    #[link_name = "\u{1}_ZN4llvm5APInt14tcMultiplyPartEPmPKmmmjjb"]
    pub fn llvm_APInt_tcMultiplyPart(
        dst: *mut llvm_APInt_WordType,
        src: *const llvm_APInt_WordType,
        multiplier: llvm_APInt_WordType,
        carry: llvm_APInt_WordType,
        srcParts: ::std::os::raw::c_uint,
        dstParts: ::std::os::raw::c_uint,
        add: bool,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " DST = LHS * RHS, where DST has the same width as the operands and is\n filled with the least significant parts of the result.  Returns one if\n overflow occurred, otherwise zero.  DST must be disjoint from both\n operands."]
    #[link_name = "\u{1}_ZN4llvm5APInt10tcMultiplyEPmPKmS3_j"]
    pub fn llvm_APInt_tcMultiply(
        arg1: *mut llvm_APInt_WordType,
        arg2: *const llvm_APInt_WordType,
        arg3: *const llvm_APInt_WordType,
        arg4: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " DST = LHS * RHS, where DST has width the sum of the widths of the\n operands. No overflow occurs. DST must be disjoint from both operands."]
    #[link_name = "\u{1}_ZN4llvm5APInt14tcFullMultiplyEPmPKmS3_jj"]
    pub fn llvm_APInt_tcFullMultiply(
        arg1: *mut llvm_APInt_WordType,
        arg2: *const llvm_APInt_WordType,
        arg3: *const llvm_APInt_WordType,
        arg4: ::std::os::raw::c_uint,
        arg5: ::std::os::raw::c_uint,
    );
}
extern "C" {
    #[doc = " If RHS is zero LHS and REMAINDER are left unchanged, return one.\n Otherwise set LHS to LHS / RHS with the fractional part discarded, set\n REMAINDER to the remainder, return zero.  i.e.\n\n  OLD_LHS = RHS * LHS + REMAINDER\n\n SCRATCH is a bignum of the same size as the operands and result for use by\n the routine; its contents need not be initialized and are destroyed.  LHS,\n REMAINDER and SCRATCH must be distinct."]
    #[link_name = "\u{1}_ZN4llvm5APInt8tcDivideEPmPKmS1_S1_j"]
    pub fn llvm_APInt_tcDivide(
        lhs: *mut llvm_APInt_WordType,
        rhs: *const llvm_APInt_WordType,
        remainder: *mut llvm_APInt_WordType,
        scratch: *mut llvm_APInt_WordType,
        parts: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Shift a bignum left Count bits. Shifted in bits are zero. There are no\n restrictions on Count."]
    #[link_name = "\u{1}_ZN4llvm5APInt11tcShiftLeftEPmjj"]
    pub fn llvm_APInt_tcShiftLeft(
        arg1: *mut llvm_APInt_WordType,
        Words: ::std::os::raw::c_uint,
        Count: ::std::os::raw::c_uint,
    );
}
extern "C" {
    #[doc = " Shift a bignum right Count bits.  Shifted in bits are zero.  There are no\n restrictions on Count."]
    #[link_name = "\u{1}_ZN4llvm5APInt12tcShiftRightEPmjj"]
    pub fn llvm_APInt_tcShiftRight(
        arg1: *mut llvm_APInt_WordType,
        Words: ::std::os::raw::c_uint,
        Count: ::std::os::raw::c_uint,
    );
}
extern "C" {
    #[doc = " Comparison (unsigned) of two bignums."]
    #[link_name = "\u{1}_ZN4llvm5APInt9tcCompareEPKmS2_j"]
    pub fn llvm_APInt_tcCompare(
        arg1: *const llvm_APInt_WordType,
        arg2: *const llvm_APInt_WordType,
        arg3: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Used to insert APInt objects, or objects that contain APInt objects, into\n  FoldingSets."]
    #[link_name = "\u{1}_ZNK4llvm5APInt7ProfileERNS_16FoldingSetNodeIDE"]
    pub fn llvm_APInt_Profile(this: *const llvm_APInt, id: *mut llvm_FoldingSetNodeID);
}
extern "C" {
    #[doc = " debug method"]
    #[link_name = "\u{1}_ZNK4llvm5APInt4dumpEv"]
    pub fn llvm_APInt_dump(this: *const llvm_APInt);
}
extern "C" {
    #[doc = " Construct an APInt of numBits width, initialized as bigVal[].\n\n Note that bigVal.size() can be smaller or larger than the corresponding\n bit width but any extraneous bits will be dropped.\n\n \\param numBits the bit width of the constructed APInt\n \\param bigVal a sequence of words to form the initial value of the APInt"]
    #[link_name = "\u{1}_ZN4llvm5APIntC1EjNS_8ArrayRefImEE"]
    pub fn llvm_APInt_APInt(
        this: *mut llvm_APInt,
        numBits: ::std::os::raw::c_uint,
        bigVal: llvm_ArrayRef<u64>,
    );
}
extern "C" {
    #[doc = " Equivalent to APInt(numBits, ArrayRef<uint64_t>(bigVal, numWords)), but\n deprecated because this constructor is prone to ambiguity with the\n APInt(unsigned, uint64_t, bool) constructor.\n\n If this overload is ever deleted, care should be taken to prevent calls\n from being incorrectly captured by the APInt(unsigned, uint64_t, bool)\n constructor."]
    #[link_name = "\u{1}_ZN4llvm5APIntC1EjjPKm"]
    pub fn llvm_APInt_APInt1(
        this: *mut llvm_APInt,
        numBits: ::std::os::raw::c_uint,
        numWords: ::std::os::raw::c_uint,
        bigVal: *const u64,
    );
}
extern "C" {
    #[doc = " Construct an APInt from a string representation.\n\n This constructor interprets the string \\p str in the given radix. The\n interpretation stops when the first character that is not suitable for the\n radix is encountered, or the end of the string. Acceptable radix values\n are 2, 8, 10, 16, and 36. It is an error for the value implied by the\n string to require more bits than numBits.\n\n \\param numBits the bit width of the constructed APInt\n \\param str the string to be interpreted\n \\param radix the radix to use for the conversion"]
    #[link_name = "\u{1}_ZN4llvm5APIntC1EjNS_9StringRefEh"]
    pub fn llvm_APInt_APInt2(
        this: *mut llvm_APInt,
        numBits: ::std::os::raw::c_uint,
        str_: llvm_StringRef,
        radix: u8,
    );
}
impl llvm_APInt {
    #[inline]
    pub unsafe fn getSplat(NewLen: ::std::os::raw::c_uint, V: *const llvm_APInt) -> llvm_APInt {
        llvm_APInt_getSplat(NewLen, V)
    }
    #[inline]
    pub unsafe fn isAligned(&self, A: llvm_Align) -> bool {
        llvm_APInt_isAligned(self, A)
    }
    #[inline]
    pub unsafe fn isSplat(&self, SplatSizeInBits: ::std::os::raw::c_uint) -> bool {
        llvm_APInt_isSplat(self, SplatSizeInBits)
    }
    #[inline]
    pub unsafe fn getHiBits(&self, numBits: ::std::os::raw::c_uint) -> llvm_APInt {
        llvm_APInt_getHiBits(self, numBits)
    }
    #[inline]
    pub unsafe fn getLoBits(&self, numBits: ::std::os::raw::c_uint) -> llvm_APInt {
        llvm_APInt_getLoBits(self, numBits)
    }
    #[inline]
    pub unsafe fn rotl(&self, rotateAmt: ::std::os::raw::c_uint) -> llvm_APInt {
        llvm_APInt_rotl(self, rotateAmt)
    }
    #[inline]
    pub unsafe fn rotr(&self, rotateAmt: ::std::os::raw::c_uint) -> llvm_APInt {
        llvm_APInt_rotr(self, rotateAmt)
    }
    #[inline]
    pub unsafe fn ashrInPlace(&mut self, shiftAmt: *const llvm_APInt) {
        llvm_APInt_ashrInPlace(self, shiftAmt)
    }
    #[inline]
    pub unsafe fn lshrInPlace(&mut self, ShiftAmt: *const llvm_APInt) {
        llvm_APInt_lshrInPlace(self, ShiftAmt)
    }
    #[inline]
    pub unsafe fn rotl1(&self, rotateAmt: *const llvm_APInt) -> llvm_APInt {
        llvm_APInt_rotl1(self, rotateAmt)
    }
    #[inline]
    pub unsafe fn rotr1(&self, rotateAmt: *const llvm_APInt) -> llvm_APInt {
        llvm_APInt_rotr1(self, rotateAmt)
    }
    #[inline]
    pub unsafe fn udiv(&self, RHS: *const llvm_APInt) -> llvm_APInt {
        llvm_APInt_udiv(self, RHS)
    }
    #[inline]
    pub unsafe fn udiv1(&self, RHS: u64) -> llvm_APInt {
        llvm_APInt_udiv1(self, RHS)
    }
    #[inline]
    pub unsafe fn sdiv(&self, RHS: *const llvm_APInt) -> llvm_APInt {
        llvm_APInt_sdiv(self, RHS)
    }
    #[inline]
    pub unsafe fn sdiv1(&self, RHS: i64) -> llvm_APInt {
        llvm_APInt_sdiv1(self, RHS)
    }
    #[inline]
    pub unsafe fn urem(&self, RHS: *const llvm_APInt) -> llvm_APInt {
        llvm_APInt_urem(self, RHS)
    }
    #[inline]
    pub unsafe fn urem1(&self, RHS: u64) -> u64 {
        llvm_APInt_urem1(self, RHS)
    }
    #[inline]
    pub unsafe fn srem(&self, RHS: *const llvm_APInt) -> llvm_APInt {
        llvm_APInt_srem(self, RHS)
    }
    #[inline]
    pub unsafe fn srem1(&self, RHS: i64) -> i64 {
        llvm_APInt_srem1(self, RHS)
    }
    #[inline]
    pub unsafe fn udivrem(
        LHS: *const llvm_APInt,
        RHS: *const llvm_APInt,
        Quotient: *mut llvm_APInt,
        Remainder: *mut llvm_APInt,
    ) {
        llvm_APInt_udivrem(LHS, RHS, Quotient, Remainder)
    }
    #[inline]
    pub unsafe fn udivrem1(
        LHS: *const llvm_APInt,
        RHS: u64,
        Quotient: *mut llvm_APInt,
        Remainder: *mut u64,
    ) {
        llvm_APInt_udivrem1(LHS, RHS, Quotient, Remainder)
    }
    #[inline]
    pub unsafe fn sdivrem(
        LHS: *const llvm_APInt,
        RHS: *const llvm_APInt,
        Quotient: *mut llvm_APInt,
        Remainder: *mut llvm_APInt,
    ) {
        llvm_APInt_sdivrem(LHS, RHS, Quotient, Remainder)
    }
    #[inline]
    pub unsafe fn sdivrem1(
        LHS: *const llvm_APInt,
        RHS: i64,
        Quotient: *mut llvm_APInt,
        Remainder: *mut i64,
    ) {
        llvm_APInt_sdivrem1(LHS, RHS, Quotient, Remainder)
    }
    #[inline]
    pub unsafe fn sadd_ov(&self, RHS: *const llvm_APInt, Overflow: *mut bool) -> llvm_APInt {
        llvm_APInt_sadd_ov(self, RHS, Overflow)
    }
    #[inline]
    pub unsafe fn uadd_ov(&self, RHS: *const llvm_APInt, Overflow: *mut bool) -> llvm_APInt {
        llvm_APInt_uadd_ov(self, RHS, Overflow)
    }
    #[inline]
    pub unsafe fn ssub_ov(&self, RHS: *const llvm_APInt, Overflow: *mut bool) -> llvm_APInt {
        llvm_APInt_ssub_ov(self, RHS, Overflow)
    }
    #[inline]
    pub unsafe fn usub_ov(&self, RHS: *const llvm_APInt, Overflow: *mut bool) -> llvm_APInt {
        llvm_APInt_usub_ov(self, RHS, Overflow)
    }
    #[inline]
    pub unsafe fn sdiv_ov(&self, RHS: *const llvm_APInt, Overflow: *mut bool) -> llvm_APInt {
        llvm_APInt_sdiv_ov(self, RHS, Overflow)
    }
    #[inline]
    pub unsafe fn smul_ov(&self, RHS: *const llvm_APInt, Overflow: *mut bool) -> llvm_APInt {
        llvm_APInt_smul_ov(self, RHS, Overflow)
    }
    #[inline]
    pub unsafe fn umul_ov(&self, RHS: *const llvm_APInt, Overflow: *mut bool) -> llvm_APInt {
        llvm_APInt_umul_ov(self, RHS, Overflow)
    }
    #[inline]
    pub unsafe fn sshl_ov(&self, Amt: *const llvm_APInt, Overflow: *mut bool) -> llvm_APInt {
        llvm_APInt_sshl_ov(self, Amt, Overflow)
    }
    #[inline]
    pub unsafe fn sshl_ov1(&self, Amt: ::std::os::raw::c_uint, Overflow: *mut bool) -> llvm_APInt {
        llvm_APInt_sshl_ov1(self, Amt, Overflow)
    }
    #[inline]
    pub unsafe fn ushl_ov(&self, Amt: *const llvm_APInt, Overflow: *mut bool) -> llvm_APInt {
        llvm_APInt_ushl_ov(self, Amt, Overflow)
    }
    #[inline]
    pub unsafe fn ushl_ov1(&self, Amt: ::std::os::raw::c_uint, Overflow: *mut bool) -> llvm_APInt {
        llvm_APInt_ushl_ov1(self, Amt, Overflow)
    }
    #[inline]
    pub unsafe fn sfloordiv_ov(&self, RHS: *const llvm_APInt, Overflow: *mut bool) -> llvm_APInt {
        llvm_APInt_sfloordiv_ov(self, RHS, Overflow)
    }
    #[inline]
    pub unsafe fn sadd_sat(&self, RHS: *const llvm_APInt) -> llvm_APInt {
        llvm_APInt_sadd_sat(self, RHS)
    }
    #[inline]
    pub unsafe fn uadd_sat(&self, RHS: *const llvm_APInt) -> llvm_APInt {
        llvm_APInt_uadd_sat(self, RHS)
    }
    #[inline]
    pub unsafe fn ssub_sat(&self, RHS: *const llvm_APInt) -> llvm_APInt {
        llvm_APInt_ssub_sat(self, RHS)
    }
    #[inline]
    pub unsafe fn usub_sat(&self, RHS: *const llvm_APInt) -> llvm_APInt {
        llvm_APInt_usub_sat(self, RHS)
    }
    #[inline]
    pub unsafe fn smul_sat(&self, RHS: *const llvm_APInt) -> llvm_APInt {
        llvm_APInt_smul_sat(self, RHS)
    }
    #[inline]
    pub unsafe fn umul_sat(&self, RHS: *const llvm_APInt) -> llvm_APInt {
        llvm_APInt_umul_sat(self, RHS)
    }
    #[inline]
    pub unsafe fn sshl_sat(&self, RHS: *const llvm_APInt) -> llvm_APInt {
        llvm_APInt_sshl_sat(self, RHS)
    }
    #[inline]
    pub unsafe fn sshl_sat1(&self, RHS: ::std::os::raw::c_uint) -> llvm_APInt {
        llvm_APInt_sshl_sat1(self, RHS)
    }
    #[inline]
    pub unsafe fn ushl_sat(&self, RHS: *const llvm_APInt) -> llvm_APInt {
        llvm_APInt_ushl_sat(self, RHS)
    }
    #[inline]
    pub unsafe fn ushl_sat1(&self, RHS: ::std::os::raw::c_uint) -> llvm_APInt {
        llvm_APInt_ushl_sat1(self, RHS)
    }
    #[inline]
    pub unsafe fn trunc(&self, width: ::std::os::raw::c_uint) -> llvm_APInt {
        llvm_APInt_trunc(self, width)
    }
    #[inline]
    pub unsafe fn truncUSat(&self, width: ::std::os::raw::c_uint) -> llvm_APInt {
        llvm_APInt_truncUSat(self, width)
    }
    #[inline]
    pub unsafe fn truncSSat(&self, width: ::std::os::raw::c_uint) -> llvm_APInt {
        llvm_APInt_truncSSat(self, width)
    }
    #[inline]
    pub unsafe fn sext(&self, width: ::std::os::raw::c_uint) -> llvm_APInt {
        llvm_APInt_sext(self, width)
    }
    #[inline]
    pub unsafe fn zext(&self, width: ::std::os::raw::c_uint) -> llvm_APInt {
        llvm_APInt_zext(self, width)
    }
    #[inline]
    pub unsafe fn sextOrTrunc(&self, width: ::std::os::raw::c_uint) -> llvm_APInt {
        llvm_APInt_sextOrTrunc(self, width)
    }
    #[inline]
    pub unsafe fn zextOrTrunc(&self, width: ::std::os::raw::c_uint) -> llvm_APInt {
        llvm_APInt_zextOrTrunc(self, width)
    }
    #[inline]
    pub unsafe fn flipBit(&mut self, bitPosition: ::std::os::raw::c_uint) {
        llvm_APInt_flipBit(self, bitPosition)
    }
    #[inline]
    pub unsafe fn insertBits(
        &mut self,
        SubBits: *const llvm_APInt,
        bitPosition: ::std::os::raw::c_uint,
    ) {
        llvm_APInt_insertBits(self, SubBits, bitPosition)
    }
    #[inline]
    pub unsafe fn insertBits1(
        &mut self,
        SubBits: u64,
        bitPosition: ::std::os::raw::c_uint,
        numBits: ::std::os::raw::c_uint,
    ) {
        llvm_APInt_insertBits1(self, SubBits, bitPosition, numBits)
    }
    #[inline]
    pub unsafe fn extractBits(
        &self,
        numBits: ::std::os::raw::c_uint,
        bitPosition: ::std::os::raw::c_uint,
    ) -> llvm_APInt {
        llvm_APInt_extractBits(self, numBits, bitPosition)
    }
    #[inline]
    pub unsafe fn extractBitsAsZExtValue(
        &self,
        numBits: ::std::os::raw::c_uint,
        bitPosition: ::std::os::raw::c_uint,
    ) -> u64 {
        llvm_APInt_extractBitsAsZExtValue(self, numBits, bitPosition)
    }
    #[inline]
    pub unsafe fn getBitsNeeded(str_: llvm_StringRef, radix: u8) -> ::std::os::raw::c_uint {
        llvm_APInt_getBitsNeeded(str_, radix)
    }
    #[inline]
    pub unsafe fn getSufficientBitsNeeded(
        Str: llvm_StringRef,
        Radix: u8,
    ) -> ::std::os::raw::c_uint {
        llvm_APInt_getSufficientBitsNeeded(Str, Radix)
    }
    #[inline]
    pub unsafe fn print(&self, OS: *mut llvm_raw_ostream, isSigned: bool) {
        llvm_APInt_print(self, OS, isSigned)
    }
    #[inline]
    pub unsafe fn toString(
        &self,
        Str: *mut llvm_SmallVectorImpl,
        Radix: ::std::os::raw::c_uint,
        Signed: bool,
        formatAsCLiteral: bool,
        UpperCase: bool,
        InsertSeparators: bool,
    ) {
        llvm_APInt_toString(
            self,
            Str,
            Radix,
            Signed,
            formatAsCLiteral,
            UpperCase,
            InsertSeparators,
        )
    }
    #[inline]
    pub unsafe fn byteSwap(&self) -> llvm_APInt {
        llvm_APInt_byteSwap(self)
    }
    #[inline]
    pub unsafe fn reverseBits(&self) -> llvm_APInt {
        llvm_APInt_reverseBits(self)
    }
    #[inline]
    pub unsafe fn roundToDouble(&self, isSigned: bool) -> f64 {
        llvm_APInt_roundToDouble(self, isSigned)
    }
    #[inline]
    pub unsafe fn nearestLogBase2(&self) -> ::std::os::raw::c_uint {
        llvm_APInt_nearestLogBase2(self)
    }
    #[inline]
    pub unsafe fn sqrt(&self) -> llvm_APInt {
        llvm_APInt_sqrt(self)
    }
    #[inline]
    pub unsafe fn multiplicativeInverse(&self) -> llvm_APInt {
        llvm_APInt_multiplicativeInverse(self)
    }
    #[inline]
    pub unsafe fn tcSet(
        arg1: *mut llvm_APInt_WordType,
        arg2: llvm_APInt_WordType,
        arg3: ::std::os::raw::c_uint,
    ) {
        llvm_APInt_tcSet(arg1, arg2, arg3)
    }
    #[inline]
    pub unsafe fn tcAssign(
        arg1: *mut llvm_APInt_WordType,
        arg2: *const llvm_APInt_WordType,
        arg3: ::std::os::raw::c_uint,
    ) {
        llvm_APInt_tcAssign(arg1, arg2, arg3)
    }
    #[inline]
    pub unsafe fn tcIsZero(arg1: *const llvm_APInt_WordType, arg2: ::std::os::raw::c_uint) -> bool {
        llvm_APInt_tcIsZero(arg1, arg2)
    }
    #[inline]
    pub unsafe fn tcExtractBit(
        arg1: *const llvm_APInt_WordType,
        bit: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int {
        llvm_APInt_tcExtractBit(arg1, bit)
    }
    #[inline]
    pub unsafe fn tcExtract(
        arg1: *mut llvm_APInt_WordType,
        dstCount: ::std::os::raw::c_uint,
        arg2: *const llvm_APInt_WordType,
        srcBits: ::std::os::raw::c_uint,
        srcLSB: ::std::os::raw::c_uint,
    ) {
        llvm_APInt_tcExtract(arg1, dstCount, arg2, srcBits, srcLSB)
    }
    #[inline]
    pub unsafe fn tcSetBit(arg1: *mut llvm_APInt_WordType, bit: ::std::os::raw::c_uint) {
        llvm_APInt_tcSetBit(arg1, bit)
    }
    #[inline]
    pub unsafe fn tcClearBit(arg1: *mut llvm_APInt_WordType, bit: ::std::os::raw::c_uint) {
        llvm_APInt_tcClearBit(arg1, bit)
    }
    #[inline]
    pub unsafe fn tcLSB(
        arg1: *const llvm_APInt_WordType,
        n: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_uint {
        llvm_APInt_tcLSB(arg1, n)
    }
    #[inline]
    pub unsafe fn tcMSB(
        parts: *const llvm_APInt_WordType,
        n: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_uint {
        llvm_APInt_tcMSB(parts, n)
    }
    #[inline]
    pub unsafe fn tcNegate(arg1: *mut llvm_APInt_WordType, arg2: ::std::os::raw::c_uint) {
        llvm_APInt_tcNegate(arg1, arg2)
    }
    #[inline]
    pub unsafe fn tcAdd(
        arg1: *mut llvm_APInt_WordType,
        arg2: *const llvm_APInt_WordType,
        carry: llvm_APInt_WordType,
        arg3: ::std::os::raw::c_uint,
    ) -> llvm_APInt_WordType {
        llvm_APInt_tcAdd(arg1, arg2, carry, arg3)
    }
    #[inline]
    pub unsafe fn tcAddPart(
        arg1: *mut llvm_APInt_WordType,
        arg2: llvm_APInt_WordType,
        arg3: ::std::os::raw::c_uint,
    ) -> llvm_APInt_WordType {
        llvm_APInt_tcAddPart(arg1, arg2, arg3)
    }
    #[inline]
    pub unsafe fn tcSubtract(
        arg1: *mut llvm_APInt_WordType,
        arg2: *const llvm_APInt_WordType,
        carry: llvm_APInt_WordType,
        arg3: ::std::os::raw::c_uint,
    ) -> llvm_APInt_WordType {
        llvm_APInt_tcSubtract(arg1, arg2, carry, arg3)
    }
    #[inline]
    pub unsafe fn tcSubtractPart(
        arg1: *mut llvm_APInt_WordType,
        arg2: llvm_APInt_WordType,
        arg3: ::std::os::raw::c_uint,
    ) -> llvm_APInt_WordType {
        llvm_APInt_tcSubtractPart(arg1, arg2, arg3)
    }
    #[inline]
    pub unsafe fn tcMultiplyPart(
        dst: *mut llvm_APInt_WordType,
        src: *const llvm_APInt_WordType,
        multiplier: llvm_APInt_WordType,
        carry: llvm_APInt_WordType,
        srcParts: ::std::os::raw::c_uint,
        dstParts: ::std::os::raw::c_uint,
        add: bool,
    ) -> ::std::os::raw::c_int {
        llvm_APInt_tcMultiplyPart(dst, src, multiplier, carry, srcParts, dstParts, add)
    }
    #[inline]
    pub unsafe fn tcMultiply(
        arg1: *mut llvm_APInt_WordType,
        arg2: *const llvm_APInt_WordType,
        arg3: *const llvm_APInt_WordType,
        arg4: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int {
        llvm_APInt_tcMultiply(arg1, arg2, arg3, arg4)
    }
    #[inline]
    pub unsafe fn tcFullMultiply(
        arg1: *mut llvm_APInt_WordType,
        arg2: *const llvm_APInt_WordType,
        arg3: *const llvm_APInt_WordType,
        arg4: ::std::os::raw::c_uint,
        arg5: ::std::os::raw::c_uint,
    ) {
        llvm_APInt_tcFullMultiply(arg1, arg2, arg3, arg4, arg5)
    }
    #[inline]
    pub unsafe fn tcDivide(
        lhs: *mut llvm_APInt_WordType,
        rhs: *const llvm_APInt_WordType,
        remainder: *mut llvm_APInt_WordType,
        scratch: *mut llvm_APInt_WordType,
        parts: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int {
        llvm_APInt_tcDivide(lhs, rhs, remainder, scratch, parts)
    }
    #[inline]
    pub unsafe fn tcShiftLeft(
        arg1: *mut llvm_APInt_WordType,
        Words: ::std::os::raw::c_uint,
        Count: ::std::os::raw::c_uint,
    ) {
        llvm_APInt_tcShiftLeft(arg1, Words, Count)
    }
    #[inline]
    pub unsafe fn tcShiftRight(
        arg1: *mut llvm_APInt_WordType,
        Words: ::std::os::raw::c_uint,
        Count: ::std::os::raw::c_uint,
    ) {
        llvm_APInt_tcShiftRight(arg1, Words, Count)
    }
    #[inline]
    pub unsafe fn tcCompare(
        arg1: *const llvm_APInt_WordType,
        arg2: *const llvm_APInt_WordType,
        arg3: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int {
        llvm_APInt_tcCompare(arg1, arg2, arg3)
    }
    #[inline]
    pub unsafe fn Profile(&self, id: *mut llvm_FoldingSetNodeID) {
        llvm_APInt_Profile(self, id)
    }
    #[inline]
    pub unsafe fn dump(&self) {
        llvm_APInt_dump(self)
    }
    #[inline]
    pub unsafe fn new(numBits: ::std::os::raw::c_uint, bigVal: llvm_ArrayRef<u64>) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        llvm_APInt_APInt(__bindgen_tmp.as_mut_ptr(), numBits, bigVal);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(
        numBits: ::std::os::raw::c_uint,
        numWords: ::std::os::raw::c_uint,
        bigVal: *const u64,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        llvm_APInt_APInt1(__bindgen_tmp.as_mut_ptr(), numBits, numWords, bigVal);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new2(numBits: ::std::os::raw::c_uint, str_: llvm_StringRef, radix: u8) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        llvm_APInt_APInt2(__bindgen_tmp.as_mut_ptr(), numBits, str_, radix);
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[doc = " Compute the floor of the signed average of C1 and C2"]
    #[link_name = "\u{1}_ZN4llvm8APIntOps9avgFloorSERKNS_5APIntES3_"]
    pub fn llvm_APIntOps_avgFloorS(C1: *const llvm_APInt, C2: *const llvm_APInt) -> llvm_APInt;
}
extern "C" {
    #[doc = " Compute the floor of the unsigned average of C1 and C2"]
    #[link_name = "\u{1}_ZN4llvm8APIntOps9avgFloorUERKNS_5APIntES3_"]
    pub fn llvm_APIntOps_avgFloorU(C1: *const llvm_APInt, C2: *const llvm_APInt) -> llvm_APInt;
}
extern "C" {
    #[doc = " Compute the ceil of the signed average of C1 and C2"]
    #[link_name = "\u{1}_ZN4llvm8APIntOps8avgCeilSERKNS_5APIntES3_"]
    pub fn llvm_APIntOps_avgCeilS(C1: *const llvm_APInt, C2: *const llvm_APInt) -> llvm_APInt;
}
extern "C" {
    #[doc = " Compute the ceil of the unsigned average of C1 and C2"]
    #[link_name = "\u{1}_ZN4llvm8APIntOps8avgCeilUERKNS_5APIntES3_"]
    pub fn llvm_APIntOps_avgCeilU(C1: *const llvm_APInt, C2: *const llvm_APInt) -> llvm_APInt;
}
extern "C" {
    #[doc = " Performs (2*N)-bit multiplication on sign-extended operands.\n Returns the high N bits of the multiplication result."]
    #[link_name = "\u{1}_ZN4llvm8APIntOps5mulhsERKNS_5APIntES3_"]
    pub fn llvm_APIntOps_mulhs(C1: *const llvm_APInt, C2: *const llvm_APInt) -> llvm_APInt;
}
extern "C" {
    #[doc = " Performs (2*N)-bit multiplication on zero-extended operands.\n Returns the high N bits of the multiplication result."]
    #[link_name = "\u{1}_ZN4llvm8APIntOps5mulhuERKNS_5APIntES3_"]
    pub fn llvm_APIntOps_mulhu(C1: *const llvm_APInt, C2: *const llvm_APInt) -> llvm_APInt;
}
extern "C" {
    #[doc = " Compute GCD of two unsigned APInt values.\n\n This function returns the greatest common divisor of the two APInt values\n using Stein's algorithm.\n\n \\returns the greatest common divisor of A and B."]
    #[link_name = "\u{1}_ZN4llvm8APIntOps21GreatestCommonDivisorENS_5APIntES1_"]
    pub fn llvm_APIntOps_GreatestCommonDivisor(A: llvm_APInt, B: llvm_APInt) -> llvm_APInt;
}
extern "C" {
    #[doc = " Converts the given double value into a APInt.\n\n This function convert a double value to an APInt value."]
    #[link_name = "\u{1}_ZN4llvm8APIntOps18RoundDoubleToAPIntEdj"]
    pub fn llvm_APIntOps_RoundDoubleToAPInt(
        Double: f64,
        width: ::std::os::raw::c_uint,
    ) -> llvm_APInt;
}
extern "C" {
    #[doc = " Return A unsign-divided by B, rounded by the given rounding mode."]
    #[link_name = "\u{1}_ZN4llvm8APIntOps12RoundingUDivERKNS_5APIntES3_NS1_8RoundingE"]
    pub fn llvm_APIntOps_RoundingUDiv(
        A: *const llvm_APInt,
        B: *const llvm_APInt,
        RM: llvm_APInt_Rounding,
    ) -> llvm_APInt;
}
extern "C" {
    #[doc = " Return A sign-divided by B, rounded by the given rounding mode."]
    #[link_name = "\u{1}_ZN4llvm8APIntOps12RoundingSDivERKNS_5APIntES3_NS1_8RoundingE"]
    pub fn llvm_APIntOps_RoundingSDiv(
        A: *const llvm_APInt,
        B: *const llvm_APInt,
        RM: llvm_APInt_Rounding,
    ) -> llvm_APInt;
}
extern "C" {
    #[doc = " Let q(n) = An^2 + Bn + C, and BW = bit width of the value range\n (e.g. 32 for i32).\n This function finds the smallest number n, such that\n (a) n >= 0 and q(n) = 0, or\n (b) n >= 1 and q(n-1) and q(n), when evaluated in the set of all\n     integers, belong to two different intervals [Rk, Rk+R),\n     where R = 2^BW, and k is an integer.\n The idea here is to find when q(n) \"overflows\" 2^BW, while at the\n same time \"allowing\" subtraction. In unsigned modulo arithmetic a\n subtraction (treated as addition of negated numbers) would always\n count as an overflow, but here we want to allow values to decrease\n and increase as long as they are within the same interval.\n Specifically, adding of two negative numbers should not cause an\n overflow (as long as the magnitude does not exceed the bit width).\n On the other hand, given a positive number, adding a negative\n number to it can give a negative result, which would cause the\n value to go from [-2^BW, 0) to [0, 2^BW). In that sense, zero is\n treated as a special case of an overflow.\n\n This function returns std::nullopt if after finding k that minimizes the\n positive solution to q(n) = kR, both solutions are contained between\n two consecutive integers.\n\n There are cases where q(n) > T, and q(n+1) < T (assuming evaluation\n in arithmetic modulo 2^BW, and treating the values as signed) by the\n virtue of *signed* overflow. This function will *not* find such an n,\n however it may find a value of n satisfying the inequalities due to\n an *unsigned* overflow (if the values are treated as unsigned).\n To find a solution for a signed overflow, treat it as a problem of\n finding an unsigned overflow with a range with of BW-1.\n\n The returned value may have a different bit width from the input\n coefficients."]
    #[link_name = "\u{1}_ZN4llvm8APIntOps26SolveQuadraticEquationWrapENS_5APIntES1_S1_j"]
    pub fn llvm_APIntOps_SolveQuadraticEquationWrap(
        A: llvm_APInt,
        B: llvm_APInt,
        C: llvm_APInt,
        RangeWidth: ::std::os::raw::c_uint,
    ) -> std_optional;
}
extern "C" {
    #[doc = " Compare two values, and if they are different, return the position of the\n most significant bit that is different in the values."]
    #[link_name = "\u{1}_ZN4llvm8APIntOps30GetMostSignificantDifferentBitERKNS_5APIntES3_"]
    pub fn llvm_APIntOps_GetMostSignificantDifferentBit(
        A: *const llvm_APInt,
        B: *const llvm_APInt,
    ) -> std_optional;
}
extern "C" {
    #[doc = " Splat/Merge neighboring bits to widen/narrow the bitmask represented\n by \\param A to \\param NewBitWidth bits.\n\n MatchAnyBits: (Default)\n e.g. ScaleBitMask(0b0101, 8) -> 0b00110011\n e.g. ScaleBitMask(0b00011011, 4) -> 0b0111\n\n MatchAllBits:\n e.g. ScaleBitMask(0b0101, 8) -> 0b00110011\n e.g. ScaleBitMask(0b00011011, 4) -> 0b0001\n A.getBitwidth() or NewBitWidth must be a whole multiples of the other."]
    #[link_name = "\u{1}_ZN4llvm8APIntOps12ScaleBitMaskERKNS_5APIntEjb"]
    pub fn llvm_APIntOps_ScaleBitMask(
        A: *const llvm_APInt,
        NewBitWidth: ::std::os::raw::c_uint,
        MatchAllBits: bool,
    ) -> llvm_APInt;
}
extern "C" {
    #[doc = " Overload to compute a hash_code for an APInt value."]
    #[link_name = "\u{1}_ZN4llvm10hash_valueERKNS_5APIntE"]
    pub fn llvm_hash_value1(Arg: *const llvm_APInt) -> llvm_hash_code;
}
extern "C" {
    #[doc = " StoreIntToMemory - Fills the StoreBytes bytes of memory starting from Dst\n with the integer held in IntVal."]
    #[link_name = "\u{1}_ZN4llvm16StoreIntToMemoryERKNS_5APIntEPhj"]
    pub fn llvm_StoreIntToMemory(
        IntVal: *const llvm_APInt,
        Dst: *mut u8,
        StoreBytes: ::std::os::raw::c_uint,
    );
}
extern "C" {
    #[doc = " LoadIntFromMemory - Loads the integer stored in the LoadBytes bytes starting\n from Src into IntVal, which is assumed to be wide enough and to hold zero."]
    #[link_name = "\u{1}_ZN4llvm17LoadIntFromMemoryERNS_5APIntEPKhj"]
    pub fn llvm_LoadIntFromMemory(
        IntVal: *mut llvm_APInt,
        Src: *const u8,
        LoadBytes: ::std::os::raw::c_uint,
    );
}
#[test]
fn __bindgen_test_layout_llvm_DenseMapInfo_open0_llvm_APInt_void_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<llvm_DenseMapInfo>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_DenseMapInfo)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_DenseMapInfo>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_DenseMapInfo)
        )
    );
}
extern "C" {
    #[doc = " Reports a diagnostic message to indicate an invalid size request has been\n done on a scalable vector. This function may not return."]
    #[link_name = "\u{1}_ZN4llvm24reportInvalidSizeRequestEPKc"]
    pub fn llvm_reportInvalidSizeRequest(Msg: *const ::std::os::raw::c_char);
}
#[doc = " StackOffset holds a fixed and a scalable offset in bytes."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_StackOffset {
    pub Fixed: i64,
    pub Scalable: i64,
}
#[test]
fn bindgen_test_layout_llvm_StackOffset() {
    const UNINIT: ::std::mem::MaybeUninit<llvm_StackOffset> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<llvm_StackOffset>(),
        16usize,
        concat!("Size of: ", stringify!(llvm_StackOffset))
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_StackOffset>(),
        8usize,
        concat!("Alignment of ", stringify!(llvm_StackOffset))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Fixed) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_StackOffset),
            "::",
            stringify!(Fixed)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Scalable) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_StackOffset),
            "::",
            stringify!(Scalable)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_details_FixedOrScalableQuantity<ValueTy> {
    pub Quantity: llvm_details_FixedOrScalableQuantity_ScalarTy<ValueTy>,
    pub Scalable: bool,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<ValueTy>>,
}
pub type llvm_details_FixedOrScalableQuantity_ScalarTy<ValueTy> = ValueTy;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_ElementCount {
    pub _base: llvm_details_FixedOrScalableQuantity<::std::os::raw::c_uint>,
}
#[test]
fn bindgen_test_layout_llvm_ElementCount() {
    assert_eq!(
        ::std::mem::size_of::<llvm_ElementCount>(),
        8usize,
        concat!("Size of: ", stringify!(llvm_ElementCount))
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_ElementCount>(),
        4usize,
        concat!("Alignment of ", stringify!(llvm_ElementCount))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_TypeSize {
    pub _base: llvm_details_FixedOrScalableQuantity<u64>,
}
#[test]
fn bindgen_test_layout_llvm_TypeSize() {
    assert_eq!(
        ::std::mem::size_of::<llvm_TypeSize>(),
        16usize,
        concat!("Size of: ", stringify!(llvm_TypeSize))
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_TypeSize>(),
        8usize,
        concat!("Alignment of ", stringify!(llvm_TypeSize))
    );
}
#[test]
fn __bindgen_test_layout_llvm_DenseMapInfo_open0_llvm_ElementCount_void_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<llvm_DenseMapInfo>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_DenseMapInfo)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_DenseMapInfo>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_DenseMapInfo)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_fltSemantics {
    _unused: [u8; 0],
}
#[doc = " The instances of the Type class are immutable: once they are created,\n they are never changed.  Also note that only one instance of a particular\n type is ever created.  Thus seeing if two types are equal is a matter of\n doing a trivial pointer comparison. To enforce that no two equal instances\n are created, Type instances can only be created via static factory methods\n in class Type and in derived classes.  Once allocated, Types are never\n free'd.\n"]
#[repr(C)]
#[derive(Debug)]
pub struct llvm_Type {
    #[doc = " This refers to the LLVMContext in which this type was uniqued."]
    pub Context: *mut llvm_LLVMContext,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    #[doc = " Keeps track of how many Type*'s there are in the ContainedTys list."]
    pub NumContainedTys: ::std::os::raw::c_uint,
    #[doc = " A pointer to the array of Types contained by this Type. For example, this\n includes the arguments of a function type, the elements of a structure,\n the pointee of a pointer, the element type of an array, etc. This pointer\n may be 0 for types that don't contain other types (Integer, Double,\n Float)."]
    pub ContainedTys: *const *mut llvm_Type,
}
#[doc = "< 16-bit floating point type"]
pub const llvm_Type_TypeID_HalfTyID: llvm_Type_TypeID = 0;
#[doc = "< 16-bit floating point type (7-bit significand)"]
pub const llvm_Type_TypeID_BFloatTyID: llvm_Type_TypeID = 1;
#[doc = "< 32-bit floating point type"]
pub const llvm_Type_TypeID_FloatTyID: llvm_Type_TypeID = 2;
#[doc = "< 64-bit floating point type"]
pub const llvm_Type_TypeID_DoubleTyID: llvm_Type_TypeID = 3;
#[doc = "< 80-bit floating point type (X87)"]
pub const llvm_Type_TypeID_X86_FP80TyID: llvm_Type_TypeID = 4;
#[doc = "< 128-bit floating point type (112-bit significand)"]
pub const llvm_Type_TypeID_FP128TyID: llvm_Type_TypeID = 5;
#[doc = "< 128-bit floating point type (two 64-bits, PowerPC)"]
pub const llvm_Type_TypeID_PPC_FP128TyID: llvm_Type_TypeID = 6;
#[doc = "< type with no size"]
pub const llvm_Type_TypeID_VoidTyID: llvm_Type_TypeID = 7;
#[doc = "< Labels"]
pub const llvm_Type_TypeID_LabelTyID: llvm_Type_TypeID = 8;
#[doc = "< Metadata"]
pub const llvm_Type_TypeID_MetadataTyID: llvm_Type_TypeID = 9;
#[doc = "< AMX vectors (8192 bits, X86 specific)"]
pub const llvm_Type_TypeID_X86_AMXTyID: llvm_Type_TypeID = 10;
#[doc = "< Tokens"]
pub const llvm_Type_TypeID_TokenTyID: llvm_Type_TypeID = 11;
#[doc = "< Arbitrary bit width integers"]
pub const llvm_Type_TypeID_IntegerTyID: llvm_Type_TypeID = 12;
#[doc = "< Functions"]
pub const llvm_Type_TypeID_FunctionTyID: llvm_Type_TypeID = 13;
#[doc = "< Pointers"]
pub const llvm_Type_TypeID_PointerTyID: llvm_Type_TypeID = 14;
#[doc = "< Structures"]
pub const llvm_Type_TypeID_StructTyID: llvm_Type_TypeID = 15;
#[doc = "< Arrays"]
pub const llvm_Type_TypeID_ArrayTyID: llvm_Type_TypeID = 16;
#[doc = "< Fixed width SIMD vector type"]
pub const llvm_Type_TypeID_FixedVectorTyID: llvm_Type_TypeID = 17;
#[doc = "< Scalable SIMD vector type"]
pub const llvm_Type_TypeID_ScalableVectorTyID: llvm_Type_TypeID = 18;
#[doc = "< Typed pointer used by some GPU targets"]
pub const llvm_Type_TypeID_TypedPointerTyID: llvm_Type_TypeID = 19;
#[doc = "< Target extension type"]
pub const llvm_Type_TypeID_TargetExtTyID: llvm_Type_TypeID = 20;
#[doc = " Definitions of all of the base types for the Type system.  Based on this\n value, you can cast to a class defined in DerivedTypes.h.\n Note: If you add an element to this, you need to add an element to the\n Type::getPrimitiveType function, or else things will break!\n Also update LLVMTypeKind and LLVMGetTypeKind () in the C binding.\n"]
pub type llvm_Type_TypeID = ::std::os::raw::c_uint;
pub type llvm_Type_subtype_iterator = *const *mut llvm_Type;
pub type llvm_Type_subtype_reverse_iterator = std_reverse_iterator<llvm_Type_subtype_iterator>;
#[test]
fn bindgen_test_layout_llvm_Type() {
    const UNINIT: ::std::mem::MaybeUninit<llvm_Type> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<llvm_Type>(),
        24usize,
        concat!("Size of: ", stringify!(llvm_Type))
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_Type>(),
        8usize,
        concat!("Alignment of ", stringify!(llvm_Type))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Context) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_Type),
            "::",
            stringify!(Context)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).NumContainedTys) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_Type),
            "::",
            stringify!(NumContainedTys)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ContainedTys) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_Type),
            "::",
            stringify!(ContainedTys)
        )
    );
}
extern "C" {
    #[doc = " Print the current type.\n Omit the type details if \\p NoDetails == true.\n E.g., let %st = type { i32, i16 }\n When \\p NoDetails is true, we only print %st.\n Put differently, \\p NoDetails prints the type as if\n inlined with the operands when printing an instruction."]
    #[link_name = "\u{1}_ZNK4llvm4Type5printERNS_11raw_ostreamEbb"]
    pub fn llvm_Type_print(
        this: *const llvm_Type,
        O: *mut llvm_raw_ostream,
        IsForDebug: bool,
        NoDetails: bool,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK4llvm4Type4dumpEv"]
    pub fn llvm_Type_dump(this: *const llvm_Type);
}
extern "C" {
    #[link_name = "\u{1}_ZNK4llvm4Type15getFltSemanticsEv"]
    pub fn llvm_Type_getFltSemantics(this: *const llvm_Type) -> *const llvm_fltSemantics;
}
extern "C" {
    #[doc = " Return true if this is a target extension type with a scalable layout."]
    #[link_name = "\u{1}_ZNK4llvm4Type21isScalableTargetExtTyEv"]
    pub fn llvm_Type_isScalableTargetExtTy(this: *const llvm_Type) -> bool;
}
extern "C" {
    #[doc = " Return true if this is a type whose size is a known multiple of vscale."]
    #[link_name = "\u{1}_ZNK4llvm4Type12isScalableTyEv"]
    pub fn llvm_Type_isScalableTy(this: *const llvm_Type) -> bool;
}
extern "C" {
    #[doc = " Return true if this is an IntegerType of the given width."]
    #[link_name = "\u{1}_ZNK4llvm4Type11isIntegerTyEj"]
    pub fn llvm_Type_isIntegerTy(this: *const llvm_Type, Bitwidth: ::std::os::raw::c_uint) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4llvm4Type20isRISCVVectorTupleTyEv"]
    pub fn llvm_Type_isRISCVVectorTupleTy(this: *const llvm_Type) -> bool;
}
extern "C" {
    #[doc = " Return true if this type could be converted with a lossless BitCast to\n type 'Ty'. For example, i8* to i32*. BitCasts are valid for types of the\n same size only where no re-interpretation of the bits is done.\n Determine if this type could be losslessly bitcast to Ty"]
    #[link_name = "\u{1}_ZNK4llvm4Type22canLosslesslyBitCastToEPS0_"]
    pub fn llvm_Type_canLosslesslyBitCastTo(this: *const llvm_Type, Ty: *mut llvm_Type) -> bool;
}
extern "C" {
    #[doc = " Return true if this type is empty, that is, it has no elements or all of\n its elements are empty."]
    #[link_name = "\u{1}_ZNK4llvm4Type9isEmptyTyEv"]
    pub fn llvm_Type_isEmptyTy(this: *const llvm_Type) -> bool;
}
extern "C" {
    #[doc = " Return the basic size of this type if it is a primitive type. These are\n fixed by LLVM and are not target-dependent.\n This will return zero if the type does not have a size or is not a\n primitive type.\n\n If this is a scalable vector type, the scalable property will be set and\n the runtime size will be a positive integer multiple of the base size.\n\n Note that this may not reflect the size of memory allocated for an\n instance of the type or the number of bytes that are written when an\n instance of the type is stored to memory. The DataLayout class provides\n additional query functions to provide this information.\n"]
    #[link_name = "\u{1}_ZNK4llvm4Type22getPrimitiveSizeInBitsEv"]
    pub fn llvm_Type_getPrimitiveSizeInBits(this: *const llvm_Type) -> llvm_TypeSize;
}
extern "C" {
    #[doc = " If this is a vector type, return the getPrimitiveSizeInBits value for the\n element type. Otherwise return the getPrimitiveSizeInBits value for this\n type."]
    #[link_name = "\u{1}_ZNK4llvm4Type19getScalarSizeInBitsEv"]
    pub fn llvm_Type_getScalarSizeInBits(this: *const llvm_Type) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " Return the width of the mantissa of this type. This is only valid on\n floating-point types. If the FP type does not have a stable mantissa (e.g.\n ppc long double), this method returns -1."]
    #[link_name = "\u{1}_ZNK4llvm4Type18getFPMantissaWidthEv"]
    pub fn llvm_Type_getFPMantissaWidth(this: *const llvm_Type) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Return whether the type is IEEE compatible, as defined by the eponymous\n method in APFloat."]
    #[link_name = "\u{1}_ZNK4llvm4Type6isIEEEEv"]
    pub fn llvm_Type_isIEEE(this: *const llvm_Type) -> bool;
}
extern "C" {
    #[doc = " Return a type based on an identifier."]
    #[link_name = "\u{1}_ZN4llvm4Type16getPrimitiveTypeERNS_11LLVMContextENS0_6TypeIDE"]
    pub fn llvm_Type_getPrimitiveType(
        C: *mut llvm_LLVMContext,
        IDNumber: llvm_Type_TypeID,
    ) -> *mut llvm_Type;
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm4Type9getVoidTyERNS_11LLVMContextE"]
    pub fn llvm_Type_getVoidTy(C: *mut llvm_LLVMContext) -> *mut llvm_Type;
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm4Type10getLabelTyERNS_11LLVMContextE"]
    pub fn llvm_Type_getLabelTy(C: *mut llvm_LLVMContext) -> *mut llvm_Type;
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm4Type9getHalfTyERNS_11LLVMContextE"]
    pub fn llvm_Type_getHalfTy(C: *mut llvm_LLVMContext) -> *mut llvm_Type;
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm4Type11getBFloatTyERNS_11LLVMContextE"]
    pub fn llvm_Type_getBFloatTy(C: *mut llvm_LLVMContext) -> *mut llvm_Type;
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm4Type10getFloatTyERNS_11LLVMContextE"]
    pub fn llvm_Type_getFloatTy(C: *mut llvm_LLVMContext) -> *mut llvm_Type;
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm4Type11getDoubleTyERNS_11LLVMContextE"]
    pub fn llvm_Type_getDoubleTy(C: *mut llvm_LLVMContext) -> *mut llvm_Type;
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm4Type13getMetadataTyERNS_11LLVMContextE"]
    pub fn llvm_Type_getMetadataTy(C: *mut llvm_LLVMContext) -> *mut llvm_Type;
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm4Type13getX86_FP80TyERNS_11LLVMContextE"]
    pub fn llvm_Type_getX86_FP80Ty(C: *mut llvm_LLVMContext) -> *mut llvm_Type;
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm4Type10getFP128TyERNS_11LLVMContextE"]
    pub fn llvm_Type_getFP128Ty(C: *mut llvm_LLVMContext) -> *mut llvm_Type;
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm4Type14getPPC_FP128TyERNS_11LLVMContextE"]
    pub fn llvm_Type_getPPC_FP128Ty(C: *mut llvm_LLVMContext) -> *mut llvm_Type;
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm4Type12getX86_AMXTyERNS_11LLVMContextE"]
    pub fn llvm_Type_getX86_AMXTy(C: *mut llvm_LLVMContext) -> *mut llvm_Type;
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm4Type10getTokenTyERNS_11LLVMContextE"]
    pub fn llvm_Type_getTokenTy(C: *mut llvm_LLVMContext) -> *mut llvm_Type;
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm4Type9getIntNTyERNS_11LLVMContextEj"]
    pub fn llvm_Type_getIntNTy(
        C: *mut llvm_LLVMContext,
        N: ::std::os::raw::c_uint,
    ) -> *mut llvm_IntegerType;
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm4Type9getInt1TyERNS_11LLVMContextE"]
    pub fn llvm_Type_getInt1Ty(C: *mut llvm_LLVMContext) -> *mut llvm_IntegerType;
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm4Type9getInt8TyERNS_11LLVMContextE"]
    pub fn llvm_Type_getInt8Ty(C: *mut llvm_LLVMContext) -> *mut llvm_IntegerType;
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm4Type10getInt16TyERNS_11LLVMContextE"]
    pub fn llvm_Type_getInt16Ty(C: *mut llvm_LLVMContext) -> *mut llvm_IntegerType;
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm4Type10getInt32TyERNS_11LLVMContextE"]
    pub fn llvm_Type_getInt32Ty(C: *mut llvm_LLVMContext) -> *mut llvm_IntegerType;
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm4Type10getInt64TyERNS_11LLVMContextE"]
    pub fn llvm_Type_getInt64Ty(C: *mut llvm_LLVMContext) -> *mut llvm_IntegerType;
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm4Type11getInt128TyERNS_11LLVMContextE"]
    pub fn llvm_Type_getInt128Ty(C: *mut llvm_LLVMContext) -> *mut llvm_IntegerType;
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm4Type18getFloatingPointTyERNS_11LLVMContextERKNS_12fltSemanticsE"]
    pub fn llvm_Type_getFloatingPointTy(
        C: *mut llvm_LLVMContext,
        S: *const llvm_fltSemantics,
    ) -> *mut llvm_Type;
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm4Type19getWasm_ExternrefTyERNS_11LLVMContextE"]
    pub fn llvm_Type_getWasm_ExternrefTy(C: *mut llvm_LLVMContext) -> *mut llvm_Type;
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm4Type17getWasm_FuncrefTyERNS_11LLVMContextE"]
    pub fn llvm_Type_getWasm_FuncrefTy(C: *mut llvm_LLVMContext) -> *mut llvm_Type;
}
extern "C" {
    #[doc = " Return a pointer to the current type. This is equivalent to\n PointerType::get(Foo, AddrSpace).\n TODO: Remove this after opaque pointer transition is complete."]
    #[link_name = "\u{1}_ZNK4llvm4Type12getPointerToEj"]
    pub fn llvm_Type_getPointerTo(
        this: *const llvm_Type,
        AddrSpace: ::std::os::raw::c_uint,
    ) -> *mut llvm_PointerType;
}
impl llvm_Type {
    #[inline]
    pub fn ID(&self) -> llvm_Type_TypeID {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_ID(&mut self, val: llvm_Type_TypeID) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn SubclassData(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 24u8) as u32) }
    }
    #[inline]
    pub fn set_SubclassData(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        ID: llvm_Type_TypeID,
        SubclassData: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let ID: u32 = unsafe { ::std::mem::transmute(ID) };
            ID as u64
        });
        __bindgen_bitfield_unit.set(8usize, 24u8, {
            let SubclassData: u32 = unsafe { ::std::mem::transmute(SubclassData) };
            SubclassData as u64
        });
        __bindgen_bitfield_unit
    }
    #[inline]
    pub unsafe fn print(&self, O: *mut llvm_raw_ostream, IsForDebug: bool, NoDetails: bool) {
        llvm_Type_print(self, O, IsForDebug, NoDetails)
    }
    #[inline]
    pub unsafe fn dump(&self) {
        llvm_Type_dump(self)
    }
    #[inline]
    pub unsafe fn getFltSemantics(&self) -> *const llvm_fltSemantics {
        llvm_Type_getFltSemantics(self)
    }
    #[inline]
    pub unsafe fn isScalableTargetExtTy(&self) -> bool {
        llvm_Type_isScalableTargetExtTy(self)
    }
    #[inline]
    pub unsafe fn isScalableTy(&self) -> bool {
        llvm_Type_isScalableTy(self)
    }
    #[inline]
    pub unsafe fn isIntegerTy(&self, Bitwidth: ::std::os::raw::c_uint) -> bool {
        llvm_Type_isIntegerTy(self, Bitwidth)
    }
    #[inline]
    pub unsafe fn isRISCVVectorTupleTy(&self) -> bool {
        llvm_Type_isRISCVVectorTupleTy(self)
    }
    #[inline]
    pub unsafe fn canLosslesslyBitCastTo(&self, Ty: *mut llvm_Type) -> bool {
        llvm_Type_canLosslesslyBitCastTo(self, Ty)
    }
    #[inline]
    pub unsafe fn isEmptyTy(&self) -> bool {
        llvm_Type_isEmptyTy(self)
    }
    #[inline]
    pub unsafe fn getPrimitiveSizeInBits(&self) -> llvm_TypeSize {
        llvm_Type_getPrimitiveSizeInBits(self)
    }
    #[inline]
    pub unsafe fn getScalarSizeInBits(&self) -> ::std::os::raw::c_uint {
        llvm_Type_getScalarSizeInBits(self)
    }
    #[inline]
    pub unsafe fn getFPMantissaWidth(&self) -> ::std::os::raw::c_int {
        llvm_Type_getFPMantissaWidth(self)
    }
    #[inline]
    pub unsafe fn isIEEE(&self) -> bool {
        llvm_Type_isIEEE(self)
    }
    #[inline]
    pub unsafe fn getPrimitiveType(
        C: *mut llvm_LLVMContext,
        IDNumber: llvm_Type_TypeID,
    ) -> *mut llvm_Type {
        llvm_Type_getPrimitiveType(C, IDNumber)
    }
    #[inline]
    pub unsafe fn getVoidTy(C: *mut llvm_LLVMContext) -> *mut llvm_Type {
        llvm_Type_getVoidTy(C)
    }
    #[inline]
    pub unsafe fn getLabelTy(C: *mut llvm_LLVMContext) -> *mut llvm_Type {
        llvm_Type_getLabelTy(C)
    }
    #[inline]
    pub unsafe fn getHalfTy(C: *mut llvm_LLVMContext) -> *mut llvm_Type {
        llvm_Type_getHalfTy(C)
    }
    #[inline]
    pub unsafe fn getBFloatTy(C: *mut llvm_LLVMContext) -> *mut llvm_Type {
        llvm_Type_getBFloatTy(C)
    }
    #[inline]
    pub unsafe fn getFloatTy(C: *mut llvm_LLVMContext) -> *mut llvm_Type {
        llvm_Type_getFloatTy(C)
    }
    #[inline]
    pub unsafe fn getDoubleTy(C: *mut llvm_LLVMContext) -> *mut llvm_Type {
        llvm_Type_getDoubleTy(C)
    }
    #[inline]
    pub unsafe fn getMetadataTy(C: *mut llvm_LLVMContext) -> *mut llvm_Type {
        llvm_Type_getMetadataTy(C)
    }
    #[inline]
    pub unsafe fn getX86_FP80Ty(C: *mut llvm_LLVMContext) -> *mut llvm_Type {
        llvm_Type_getX86_FP80Ty(C)
    }
    #[inline]
    pub unsafe fn getFP128Ty(C: *mut llvm_LLVMContext) -> *mut llvm_Type {
        llvm_Type_getFP128Ty(C)
    }
    #[inline]
    pub unsafe fn getPPC_FP128Ty(C: *mut llvm_LLVMContext) -> *mut llvm_Type {
        llvm_Type_getPPC_FP128Ty(C)
    }
    #[inline]
    pub unsafe fn getX86_AMXTy(C: *mut llvm_LLVMContext) -> *mut llvm_Type {
        llvm_Type_getX86_AMXTy(C)
    }
    #[inline]
    pub unsafe fn getTokenTy(C: *mut llvm_LLVMContext) -> *mut llvm_Type {
        llvm_Type_getTokenTy(C)
    }
    #[inline]
    pub unsafe fn getIntNTy(
        C: *mut llvm_LLVMContext,
        N: ::std::os::raw::c_uint,
    ) -> *mut llvm_IntegerType {
        llvm_Type_getIntNTy(C, N)
    }
    #[inline]
    pub unsafe fn getInt1Ty(C: *mut llvm_LLVMContext) -> *mut llvm_IntegerType {
        llvm_Type_getInt1Ty(C)
    }
    #[inline]
    pub unsafe fn getInt8Ty(C: *mut llvm_LLVMContext) -> *mut llvm_IntegerType {
        llvm_Type_getInt8Ty(C)
    }
    #[inline]
    pub unsafe fn getInt16Ty(C: *mut llvm_LLVMContext) -> *mut llvm_IntegerType {
        llvm_Type_getInt16Ty(C)
    }
    #[inline]
    pub unsafe fn getInt32Ty(C: *mut llvm_LLVMContext) -> *mut llvm_IntegerType {
        llvm_Type_getInt32Ty(C)
    }
    #[inline]
    pub unsafe fn getInt64Ty(C: *mut llvm_LLVMContext) -> *mut llvm_IntegerType {
        llvm_Type_getInt64Ty(C)
    }
    #[inline]
    pub unsafe fn getInt128Ty(C: *mut llvm_LLVMContext) -> *mut llvm_IntegerType {
        llvm_Type_getInt128Ty(C)
    }
    #[inline]
    pub unsafe fn getFloatingPointTy(
        C: *mut llvm_LLVMContext,
        S: *const llvm_fltSemantics,
    ) -> *mut llvm_Type {
        llvm_Type_getFloatingPointTy(C, S)
    }
    #[inline]
    pub unsafe fn getWasm_ExternrefTy(C: *mut llvm_LLVMContext) -> *mut llvm_Type {
        llvm_Type_getWasm_ExternrefTy(C)
    }
    #[inline]
    pub unsafe fn getWasm_FuncrefTy(C: *mut llvm_LLVMContext) -> *mut llvm_Type {
        llvm_Type_getWasm_FuncrefTy(C)
    }
    #[inline]
    pub unsafe fn getPointerTo(&self, AddrSpace: ::std::os::raw::c_uint) -> *mut llvm_PointerType {
        llvm_Type_getPointerTo(self, AddrSpace)
    }
}
#[test]
fn __bindgen_test_layout_llvm_isa_impl_open0_llvm_PointerType_llvm_Type_void_close0_instantiation()
{
    assert_eq!(
        ::std::mem::size_of::<llvm_isa_impl>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_isa_impl)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_isa_impl>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_isa_impl)
        )
    );
}
#[doc = " Class to represent integer types. Note that this class is also used to\n represent the built-in integer types: Int1Ty, Int8Ty, Int16Ty, Int32Ty and\n Int64Ty.\n Integer representation type"]
#[repr(C)]
#[derive(Debug)]
pub struct llvm_IntegerType {
    pub _base: llvm_Type,
}
#[doc = "< Minimum number of bits that can be specified"]
pub const llvm_IntegerType_MIN_INT_BITS: llvm_IntegerType__bindgen_ty_1 = 1;
#[doc = "< Maximum number of bits that can be specified\n< Note that bit width is stored in the Type classes SubclassData field\n< which has 24 bits. SelectionDAG type legalization can require a\n< power of 2 IntegerType, so limit to the largest representable power\n< of 2, 8388608."]
pub const llvm_IntegerType_MAX_INT_BITS: llvm_IntegerType__bindgen_ty_1 = 8388608;
#[doc = " This enum is just used to hold constants we need for IntegerType."]
pub type llvm_IntegerType__bindgen_ty_1 = ::std::os::raw::c_uint;
#[test]
fn bindgen_test_layout_llvm_IntegerType() {
    assert_eq!(
        ::std::mem::size_of::<llvm_IntegerType>(),
        24usize,
        concat!("Size of: ", stringify!(llvm_IntegerType))
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_IntegerType>(),
        8usize,
        concat!("Alignment of ", stringify!(llvm_IntegerType))
    );
}
extern "C" {
    #[doc = " This static method is the primary way of constructing an IntegerType.\n If an IntegerType with the same NumBits value was previously instantiated,\n that instance will be returned. Otherwise a new one will be created. Only\n one instance with a given NumBits value is ever created.\n Get or create an IntegerType instance."]
    #[link_name = "\u{1}_ZN4llvm11IntegerType3getERNS_11LLVMContextEj"]
    pub fn llvm_IntegerType_get(
        C: *mut llvm_LLVMContext,
        NumBits: ::std::os::raw::c_uint,
    ) -> *mut llvm_IntegerType;
}
extern "C" {
    #[doc = " For example, this is 0xFF for an 8 bit integer, 0xFFFF for i16, etc.\n @returns a bit mask with ones set for all the bits of this type.\n Get a bit mask for this type."]
    #[link_name = "\u{1}_ZNK4llvm11IntegerType7getMaskEv"]
    pub fn llvm_IntegerType_getMask(this: *const llvm_IntegerType) -> llvm_APInt;
}
impl llvm_IntegerType {
    #[inline]
    pub unsafe fn get(
        C: *mut llvm_LLVMContext,
        NumBits: ::std::os::raw::c_uint,
    ) -> *mut llvm_IntegerType {
        llvm_IntegerType_get(C, NumBits)
    }
    #[inline]
    pub unsafe fn getMask(&self) -> llvm_APInt {
        llvm_IntegerType_getMask(self)
    }
}
#[doc = " Class to represent function types\n"]
#[repr(C)]
#[derive(Debug)]
pub struct llvm_FunctionType {
    pub _base: llvm_Type,
}
pub type llvm_FunctionType_param_iterator = llvm_Type_subtype_iterator;
#[test]
fn bindgen_test_layout_llvm_FunctionType() {
    assert_eq!(
        ::std::mem::size_of::<llvm_FunctionType>(),
        24usize,
        concat!("Size of: ", stringify!(llvm_FunctionType))
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_FunctionType>(),
        8usize,
        concat!("Alignment of ", stringify!(llvm_FunctionType))
    );
}
extern "C" {
    #[doc = " This static method is the primary way of constructing a FunctionType."]
    #[link_name = "\u{1}_ZN4llvm12FunctionType3getEPNS_4TypeENS_8ArrayRefIS2_EEb"]
    pub fn llvm_FunctionType_get(
        Result: *mut llvm_Type,
        Params: llvm_ArrayRef<*mut llvm_Type>,
        isVarArg: bool,
    ) -> *mut llvm_FunctionType;
}
extern "C" {
    #[doc = " Create a FunctionType taking no parameters."]
    #[link_name = "\u{1}_ZN4llvm12FunctionType3getEPNS_4TypeEb"]
    pub fn llvm_FunctionType_get1(Result: *mut llvm_Type, isVarArg: bool)
        -> *mut llvm_FunctionType;
}
extern "C" {
    #[doc = " Return true if the specified type is valid as a return type."]
    #[link_name = "\u{1}_ZN4llvm12FunctionType17isValidReturnTypeEPNS_4TypeE"]
    pub fn llvm_FunctionType_isValidReturnType(RetTy: *mut llvm_Type) -> bool;
}
extern "C" {
    #[doc = " Return true if the specified type is valid as an argument type."]
    #[link_name = "\u{1}_ZN4llvm12FunctionType19isValidArgumentTypeEPNS_4TypeE"]
    pub fn llvm_FunctionType_isValidArgumentType(ArgTy: *mut llvm_Type) -> bool;
}
impl llvm_FunctionType {
    #[inline]
    pub unsafe fn get(
        Result: *mut llvm_Type,
        Params: llvm_ArrayRef<*mut llvm_Type>,
        isVarArg: bool,
    ) -> *mut llvm_FunctionType {
        llvm_FunctionType_get(Result, Params, isVarArg)
    }
    #[inline]
    pub unsafe fn get1(Result: *mut llvm_Type, isVarArg: bool) -> *mut llvm_FunctionType {
        llvm_FunctionType_get1(Result, isVarArg)
    }
    #[inline]
    pub unsafe fn isValidReturnType(RetTy: *mut llvm_Type) -> bool {
        llvm_FunctionType_isValidReturnType(RetTy)
    }
    #[inline]
    pub unsafe fn isValidArgumentType(ArgTy: *mut llvm_Type) -> bool {
        llvm_FunctionType_isValidArgumentType(ArgTy)
    }
}
#[doc = " A handy container for a FunctionType+Callee-pointer pair, which can be\n passed around as a single entity. This assists in replacing the use of\n PointerType::getElementType() to access the function's type, since that's\n slated for removal as part of the [opaque pointer types] project."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_FunctionCallee {
    pub FnTy: *mut llvm_FunctionType,
    pub Callee: *mut llvm_Value,
}
#[test]
fn bindgen_test_layout_llvm_FunctionCallee() {
    const UNINIT: ::std::mem::MaybeUninit<llvm_FunctionCallee> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<llvm_FunctionCallee>(),
        16usize,
        concat!("Size of: ", stringify!(llvm_FunctionCallee))
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_FunctionCallee>(),
        8usize,
        concat!("Alignment of ", stringify!(llvm_FunctionCallee))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).FnTy) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_FunctionCallee),
            "::",
            stringify!(FnTy)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Callee) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_FunctionCallee),
            "::",
            stringify!(Callee)
        )
    );
}
#[doc = " Class to represent struct types. There are two different kinds of struct\n types: Literal structs and Identified structs.\n\n Literal struct types (e.g. { i32, i32 }) are uniqued structurally, and must\n always have a body when created.  You can get one of these by using one of\n the StructType::get() forms.\n\n Identified structs (e.g. %foo or %42) may optionally have a name and are not\n uniqued.  The names for identified structs are managed at the LLVMContext\n level, so there can only be a single identified struct with a given name in\n a particular LLVMContext.  Identified structs may also optionally be opaque\n (have no body specified).  You get one of these by using one of the\n StructType::create() forms.\n\n Independent of what kind of struct you have, the body of a struct type are\n laid out in memory consecutively with the elements directly one after the\n other (if the struct is packed) or (if not packed) with padding between the\n elements as defined by DataLayout (which is required to match what the code\n generator for a target expects).\n"]
#[repr(C)]
#[derive(Debug)]
pub struct llvm_StructType {
    pub _base: llvm_Type,
    #[doc = " For a named struct that actually has a name, this is a pointer to the\n symbol table entry (maintained by LLVMContext) for the struct.\n This is null if the type is an literal struct or if it is a identified\n type that has an empty name."]
    pub SymbolTableEntry: *mut ::std::os::raw::c_void,
}
#[doc = " This is the contents of the SubClassData field."]
pub const llvm_StructType_SCDB_HasBody: llvm_StructType__bindgen_ty_1 = 1;
#[doc = " This is the contents of the SubClassData field."]
pub const llvm_StructType_SCDB_Packed: llvm_StructType__bindgen_ty_1 = 2;
#[doc = " This is the contents of the SubClassData field."]
pub const llvm_StructType_SCDB_IsLiteral: llvm_StructType__bindgen_ty_1 = 4;
#[doc = " This is the contents of the SubClassData field."]
pub const llvm_StructType_SCDB_IsSized: llvm_StructType__bindgen_ty_1 = 8;
#[doc = " This is the contents of the SubClassData field."]
pub const llvm_StructType_SCDB_ContainsScalableVector: llvm_StructType__bindgen_ty_1 = 16;
#[doc = " This is the contents of the SubClassData field."]
pub const llvm_StructType_SCDB_NotContainsScalableVector: llvm_StructType__bindgen_ty_1 = 32;
pub type llvm_StructType__bindgen_ty_1 = ::std::os::raw::c_uint;
pub type llvm_StructType_element_iterator = llvm_Type_subtype_iterator;
#[test]
fn bindgen_test_layout_llvm_StructType() {
    const UNINIT: ::std::mem::MaybeUninit<llvm_StructType> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<llvm_StructType>(),
        32usize,
        concat!("Size of: ", stringify!(llvm_StructType))
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_StructType>(),
        8usize,
        concat!("Alignment of ", stringify!(llvm_StructType))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).SymbolTableEntry) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_StructType),
            "::",
            stringify!(SymbolTableEntry)
        )
    );
}
extern "C" {
    #[doc = " This creates an identified struct."]
    #[link_name = "\u{1}_ZN4llvm10StructType6createERNS_11LLVMContextENS_9StringRefE"]
    pub fn llvm_StructType_create(
        Context: *mut llvm_LLVMContext,
        Name: llvm_StringRef,
    ) -> *mut llvm_StructType;
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm10StructType6createERNS_11LLVMContextE"]
    pub fn llvm_StructType_create1(Context: *mut llvm_LLVMContext) -> *mut llvm_StructType;
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm10StructType6createENS_8ArrayRefIPNS_4TypeEEENS_9StringRefEb"]
    pub fn llvm_StructType_create2(
        Elements: llvm_ArrayRef<*mut llvm_Type>,
        Name: llvm_StringRef,
        isPacked: bool,
    ) -> *mut llvm_StructType;
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm10StructType6createENS_8ArrayRefIPNS_4TypeEEE"]
    pub fn llvm_StructType_create3(Elements: llvm_ArrayRef<*mut llvm_Type>)
        -> *mut llvm_StructType;
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm10StructType6createERNS_11LLVMContextENS_8ArrayRefIPNS_4TypeEEENS_9StringRefEb"]
    pub fn llvm_StructType_create4(
        Context: *mut llvm_LLVMContext,
        Elements: llvm_ArrayRef<*mut llvm_Type>,
        Name: llvm_StringRef,
        isPacked: bool,
    ) -> *mut llvm_StructType;
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm10StructType6createERNS_11LLVMContextENS_8ArrayRefIPNS_4TypeEEE"]
    pub fn llvm_StructType_create5(
        Context: *mut llvm_LLVMContext,
        Elements: llvm_ArrayRef<*mut llvm_Type>,
    ) -> *mut llvm_StructType;
}
extern "C" {
    #[doc = " This static method is the primary way to create a literal StructType."]
    #[link_name = "\u{1}_ZN4llvm10StructType3getERNS_11LLVMContextENS_8ArrayRefIPNS_4TypeEEEb"]
    pub fn llvm_StructType_get(
        Context: *mut llvm_LLVMContext,
        Elements: llvm_ArrayRef<*mut llvm_Type>,
        isPacked: bool,
    ) -> *mut llvm_StructType;
}
extern "C" {
    #[doc = " Create an empty structure type."]
    #[link_name = "\u{1}_ZN4llvm10StructType3getERNS_11LLVMContextEb"]
    pub fn llvm_StructType_get1(
        Context: *mut llvm_LLVMContext,
        isPacked: bool,
    ) -> *mut llvm_StructType;
}
extern "C" {
    #[doc = " Return the type with the specified name, or null if there is none by that\n name."]
    #[link_name = "\u{1}_ZN4llvm10StructType13getTypeByNameERNS_11LLVMContextENS_9StringRefE"]
    pub fn llvm_StructType_getTypeByName(
        C: *mut llvm_LLVMContext,
        Name: llvm_StringRef,
    ) -> *mut llvm_StructType;
}
extern "C" {
    #[doc = " isSized - Return true if this is a sized type."]
    #[link_name = "\u{1}_ZNK4llvm10StructType7isSizedEPNS_15SmallPtrSetImplIPNS_4TypeEEE"]
    pub fn llvm_StructType_isSized(
        this: *const llvm_StructType,
        Visited: *mut llvm_SmallPtrSetImpl,
    ) -> bool;
}
extern "C" {
    #[doc = " Returns true if this struct contains a scalable vector."]
    #[link_name = "\u{1}_ZNK4llvm10StructType26containsScalableVectorTypeEPNS_15SmallPtrSetImplIPNS_4TypeEEE"]
    pub fn llvm_StructType_containsScalableVectorType(
        this: *const llvm_StructType,
        Visited: *mut llvm_SmallPtrSetImpl,
    ) -> bool;
}
extern "C" {
    #[doc = " Returns true if this struct contains homogeneous scalable vector types.\n Note that the definition of homogeneous scalable vector type is not\n recursive here. That means the following structure will return false\n when calling this function.\n {{<vscale x 2 x i32>, <vscale x 4 x i64>},\n  {<vscale x 2 x i32>, <vscale x 4 x i64>}}"]
    #[link_name = "\u{1}_ZNK4llvm10StructType38containsHomogeneousScalableVectorTypesEv"]
    pub fn llvm_StructType_containsHomogeneousScalableVectorTypes(
        this: *const llvm_StructType,
    ) -> bool;
}
extern "C" {
    #[doc = " Return the name for this struct type if it has an identity.\n This may return an empty string for an unnamed struct type.  Do not call\n this on an literal type."]
    #[link_name = "\u{1}_ZNK4llvm10StructType7getNameEv"]
    pub fn llvm_StructType_getName(this: *const llvm_StructType) -> llvm_StringRef;
}
extern "C" {
    #[doc = " Change the name of this type to the specified name, or to a name with a\n suffix if there is a collision. Do not call this on an literal type."]
    #[link_name = "\u{1}_ZN4llvm10StructType7setNameENS_9StringRefE"]
    pub fn llvm_StructType_setName(this: *mut llvm_StructType, Name: llvm_StringRef);
}
extern "C" {
    #[doc = " Specify a body for an opaque identified type."]
    #[link_name = "\u{1}_ZN4llvm10StructType7setBodyENS_8ArrayRefIPNS_4TypeEEEb"]
    pub fn llvm_StructType_setBody(
        this: *mut llvm_StructType,
        Elements: llvm_ArrayRef<*mut llvm_Type>,
        isPacked: bool,
    );
}
extern "C" {
    #[doc = " Return true if the specified type is valid as a element type."]
    #[link_name = "\u{1}_ZN4llvm10StructType18isValidElementTypeEPNS_4TypeE"]
    pub fn llvm_StructType_isValidElementType(ElemTy: *mut llvm_Type) -> bool;
}
extern "C" {
    #[doc = " Return true if this is layout identical to the specified struct."]
    #[link_name = "\u{1}_ZNK4llvm10StructType17isLayoutIdenticalEPS0_"]
    pub fn llvm_StructType_isLayoutIdentical(
        this: *const llvm_StructType,
        Other: *mut llvm_StructType,
    ) -> bool;
}
extern "C" {
    #[doc = " Given an index value into the type, return the type of the element."]
    #[link_name = "\u{1}_ZNK4llvm10StructType14getTypeAtIndexEPKNS_5ValueE"]
    pub fn llvm_StructType_getTypeAtIndex(
        this: *const llvm_StructType,
        V: *const llvm_Value,
    ) -> *mut llvm_Type;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4llvm10StructType10indexValidEPKNS_5ValueE"]
    pub fn llvm_StructType_indexValid(this: *const llvm_StructType, V: *const llvm_Value) -> bool;
}
impl llvm_StructType {
    #[inline]
    pub unsafe fn create(
        Context: *mut llvm_LLVMContext,
        Name: llvm_StringRef,
    ) -> *mut llvm_StructType {
        llvm_StructType_create(Context, Name)
    }
    #[inline]
    pub unsafe fn create1(Context: *mut llvm_LLVMContext) -> *mut llvm_StructType {
        llvm_StructType_create1(Context)
    }
    #[inline]
    pub unsafe fn create2(
        Elements: llvm_ArrayRef<*mut llvm_Type>,
        Name: llvm_StringRef,
        isPacked: bool,
    ) -> *mut llvm_StructType {
        llvm_StructType_create2(Elements, Name, isPacked)
    }
    #[inline]
    pub unsafe fn create3(Elements: llvm_ArrayRef<*mut llvm_Type>) -> *mut llvm_StructType {
        llvm_StructType_create3(Elements)
    }
    #[inline]
    pub unsafe fn create4(
        Context: *mut llvm_LLVMContext,
        Elements: llvm_ArrayRef<*mut llvm_Type>,
        Name: llvm_StringRef,
        isPacked: bool,
    ) -> *mut llvm_StructType {
        llvm_StructType_create4(Context, Elements, Name, isPacked)
    }
    #[inline]
    pub unsafe fn create5(
        Context: *mut llvm_LLVMContext,
        Elements: llvm_ArrayRef<*mut llvm_Type>,
    ) -> *mut llvm_StructType {
        llvm_StructType_create5(Context, Elements)
    }
    #[inline]
    pub unsafe fn get(
        Context: *mut llvm_LLVMContext,
        Elements: llvm_ArrayRef<*mut llvm_Type>,
        isPacked: bool,
    ) -> *mut llvm_StructType {
        llvm_StructType_get(Context, Elements, isPacked)
    }
    #[inline]
    pub unsafe fn get1(Context: *mut llvm_LLVMContext, isPacked: bool) -> *mut llvm_StructType {
        llvm_StructType_get1(Context, isPacked)
    }
    #[inline]
    pub unsafe fn getTypeByName(
        C: *mut llvm_LLVMContext,
        Name: llvm_StringRef,
    ) -> *mut llvm_StructType {
        llvm_StructType_getTypeByName(C, Name)
    }
    #[inline]
    pub unsafe fn isSized(&self, Visited: *mut llvm_SmallPtrSetImpl) -> bool {
        llvm_StructType_isSized(self, Visited)
    }
    #[inline]
    pub unsafe fn containsScalableVectorType(&self, Visited: *mut llvm_SmallPtrSetImpl) -> bool {
        llvm_StructType_containsScalableVectorType(self, Visited)
    }
    #[inline]
    pub unsafe fn containsHomogeneousScalableVectorTypes(&self) -> bool {
        llvm_StructType_containsHomogeneousScalableVectorTypes(self)
    }
    #[inline]
    pub unsafe fn getName(&self) -> llvm_StringRef {
        llvm_StructType_getName(self)
    }
    #[inline]
    pub unsafe fn setName(&mut self, Name: llvm_StringRef) {
        llvm_StructType_setName(self, Name)
    }
    #[inline]
    pub unsafe fn setBody(&mut self, Elements: llvm_ArrayRef<*mut llvm_Type>, isPacked: bool) {
        llvm_StructType_setBody(self, Elements, isPacked)
    }
    #[inline]
    pub unsafe fn isValidElementType(ElemTy: *mut llvm_Type) -> bool {
        llvm_StructType_isValidElementType(ElemTy)
    }
    #[inline]
    pub unsafe fn isLayoutIdentical(&self, Other: *mut llvm_StructType) -> bool {
        llvm_StructType_isLayoutIdentical(self, Other)
    }
    #[inline]
    pub unsafe fn getTypeAtIndex(&self, V: *const llvm_Value) -> *mut llvm_Type {
        llvm_StructType_getTypeAtIndex(self, V)
    }
    #[inline]
    pub unsafe fn indexValid(&self, V: *const llvm_Value) -> bool {
        llvm_StructType_indexValid(self, V)
    }
}
#[doc = " Class to represent array types."]
#[repr(C)]
#[derive(Debug)]
pub struct llvm_ArrayType {
    pub _base: llvm_Type,
    #[doc = " The element type of the array."]
    pub ContainedType: *mut llvm_Type,
    #[doc = " Number of elements in the array."]
    pub NumElements: u64,
}
#[test]
fn bindgen_test_layout_llvm_ArrayType() {
    const UNINIT: ::std::mem::MaybeUninit<llvm_ArrayType> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<llvm_ArrayType>(),
        40usize,
        concat!("Size of: ", stringify!(llvm_ArrayType))
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_ArrayType>(),
        8usize,
        concat!("Alignment of ", stringify!(llvm_ArrayType))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ContainedType) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_ArrayType),
            "::",
            stringify!(ContainedType)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).NumElements) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_ArrayType),
            "::",
            stringify!(NumElements)
        )
    );
}
extern "C" {
    #[doc = " This static method is the primary way to construct an ArrayType"]
    #[link_name = "\u{1}_ZN4llvm9ArrayType3getEPNS_4TypeEm"]
    pub fn llvm_ArrayType_get(ElementType: *mut llvm_Type, NumElements: u64)
        -> *mut llvm_ArrayType;
}
extern "C" {
    #[doc = " Return true if the specified type is valid as a element type."]
    #[link_name = "\u{1}_ZN4llvm9ArrayType18isValidElementTypeEPNS_4TypeE"]
    pub fn llvm_ArrayType_isValidElementType(ElemTy: *mut llvm_Type) -> bool;
}
impl llvm_ArrayType {
    #[inline]
    pub unsafe fn get(ElementType: *mut llvm_Type, NumElements: u64) -> *mut llvm_ArrayType {
        llvm_ArrayType_get(ElementType, NumElements)
    }
    #[inline]
    pub unsafe fn isValidElementType(ElemTy: *mut llvm_Type) -> bool {
        llvm_ArrayType_isValidElementType(ElemTy)
    }
}
#[doc = " Base class of all SIMD vector types"]
#[repr(C)]
#[derive(Debug)]
pub struct llvm_VectorType {
    pub _base: llvm_Type,
    #[doc = " The element type of the vector."]
    pub ContainedType: *mut llvm_Type,
    #[doc = " The element quantity of this vector. The meaning of this value depends\n on the type of vector:\n - For FixedVectorType = <ElementQuantity x ty>, there are\n   exactly ElementQuantity elements in this vector.\n - For ScalableVectorType = <vscale x ElementQuantity x ty>,\n   there are vscale * ElementQuantity elements in this vector, where\n   vscale is a runtime-constant integer greater than 0."]
    pub ElementQuantity: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_llvm_VectorType() {
    const UNINIT: ::std::mem::MaybeUninit<llvm_VectorType> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<llvm_VectorType>(),
        40usize,
        concat!("Size of: ", stringify!(llvm_VectorType))
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_VectorType>(),
        8usize,
        concat!("Alignment of ", stringify!(llvm_VectorType))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ContainedType) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_VectorType),
            "::",
            stringify!(ContainedType)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ElementQuantity) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_VectorType),
            "::",
            stringify!(ElementQuantity)
        )
    );
}
extern "C" {
    #[doc = " This static method is the primary way to construct an VectorType."]
    #[link_name = "\u{1}_ZN4llvm10VectorType3getEPNS_4TypeENS_12ElementCountE"]
    pub fn llvm_VectorType_get(
        ElementType: *mut llvm_Type,
        EC: llvm_ElementCount,
    ) -> *mut llvm_VectorType;
}
extern "C" {
    #[doc = " Return true if the specified type is valid as a element type."]
    #[link_name = "\u{1}_ZN4llvm10VectorType18isValidElementTypeEPNS_4TypeE"]
    pub fn llvm_VectorType_isValidElementType(ElemTy: *mut llvm_Type) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm10VectorTypeC1EPNS_4TypeEjNS1_6TypeIDE"]
    pub fn llvm_VectorType_VectorType(
        this: *mut llvm_VectorType,
        ElType: *mut llvm_Type,
        EQ: ::std::os::raw::c_uint,
        TID: llvm_Type_TypeID,
    );
}
impl llvm_VectorType {
    #[inline]
    pub unsafe fn get(ElementType: *mut llvm_Type, EC: llvm_ElementCount) -> *mut llvm_VectorType {
        llvm_VectorType_get(ElementType, EC)
    }
    #[inline]
    pub unsafe fn isValidElementType(ElemTy: *mut llvm_Type) -> bool {
        llvm_VectorType_isValidElementType(ElemTy)
    }
    #[inline]
    pub unsafe fn new(
        ElType: *mut llvm_Type,
        EQ: ::std::os::raw::c_uint,
        TID: llvm_Type_TypeID,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        llvm_VectorType_VectorType(__bindgen_tmp.as_mut_ptr(), ElType, EQ, TID);
        __bindgen_tmp.assume_init()
    }
}
#[doc = " Class to represent fixed width SIMD vectors"]
#[repr(C)]
#[derive(Debug)]
pub struct llvm_FixedVectorType {
    pub _base: llvm_VectorType,
}
#[test]
fn bindgen_test_layout_llvm_FixedVectorType() {
    assert_eq!(
        ::std::mem::size_of::<llvm_FixedVectorType>(),
        40usize,
        concat!("Size of: ", stringify!(llvm_FixedVectorType))
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_FixedVectorType>(),
        8usize,
        concat!("Alignment of ", stringify!(llvm_FixedVectorType))
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm15FixedVectorType3getEPNS_4TypeEj"]
    pub fn llvm_FixedVectorType_get(
        ElementType: *mut llvm_Type,
        NumElts: ::std::os::raw::c_uint,
    ) -> *mut llvm_FixedVectorType;
}
impl llvm_FixedVectorType {
    #[inline]
    pub unsafe fn get(
        ElementType: *mut llvm_Type,
        NumElts: ::std::os::raw::c_uint,
    ) -> *mut llvm_FixedVectorType {
        llvm_FixedVectorType_get(ElementType, NumElts)
    }
}
#[doc = " Class to represent scalable SIMD vectors"]
#[repr(C)]
#[derive(Debug)]
pub struct llvm_ScalableVectorType {
    pub _base: llvm_VectorType,
}
#[test]
fn bindgen_test_layout_llvm_ScalableVectorType() {
    assert_eq!(
        ::std::mem::size_of::<llvm_ScalableVectorType>(),
        40usize,
        concat!("Size of: ", stringify!(llvm_ScalableVectorType))
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_ScalableVectorType>(),
        8usize,
        concat!("Alignment of ", stringify!(llvm_ScalableVectorType))
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm18ScalableVectorType3getEPNS_4TypeEj"]
    pub fn llvm_ScalableVectorType_get(
        ElementType: *mut llvm_Type,
        MinNumElts: ::std::os::raw::c_uint,
    ) -> *mut llvm_ScalableVectorType;
}
impl llvm_ScalableVectorType {
    #[inline]
    pub unsafe fn get(
        ElementType: *mut llvm_Type,
        MinNumElts: ::std::os::raw::c_uint,
    ) -> *mut llvm_ScalableVectorType {
        llvm_ScalableVectorType_get(ElementType, MinNumElts)
    }
}
#[doc = " Class to represent pointers."]
#[repr(C)]
#[derive(Debug)]
pub struct llvm_PointerType {
    pub _base: llvm_Type,
}
#[test]
fn bindgen_test_layout_llvm_PointerType() {
    assert_eq!(
        ::std::mem::size_of::<llvm_PointerType>(),
        24usize,
        concat!("Size of: ", stringify!(llvm_PointerType))
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_PointerType>(),
        8usize,
        concat!("Alignment of ", stringify!(llvm_PointerType))
    );
}
extern "C" {
    #[doc = " This constructs a pointer to an object of the specified type in a numbered\n address space."]
    #[link_name = "\u{1}_ZN4llvm11PointerType3getEPNS_4TypeEj"]
    pub fn llvm_PointerType_get(
        ElementType: *mut llvm_Type,
        AddressSpace: ::std::os::raw::c_uint,
    ) -> *mut llvm_PointerType;
}
extern "C" {
    #[doc = " This constructs an opaque pointer to an object in a numbered address\n space."]
    #[link_name = "\u{1}_ZN4llvm11PointerType3getERNS_11LLVMContextEj"]
    pub fn llvm_PointerType_get1(
        C: *mut llvm_LLVMContext,
        AddressSpace: ::std::os::raw::c_uint,
    ) -> *mut llvm_PointerType;
}
extern "C" {
    #[doc = " Return true if the specified type is valid as a element type."]
    #[link_name = "\u{1}_ZN4llvm11PointerType18isValidElementTypeEPNS_4TypeE"]
    pub fn llvm_PointerType_isValidElementType(ElemTy: *mut llvm_Type) -> bool;
}
extern "C" {
    #[doc = " Return true if we can load or store from a pointer to this type."]
    #[link_name = "\u{1}_ZN4llvm11PointerType24isLoadableOrStorableTypeEPNS_4TypeE"]
    pub fn llvm_PointerType_isLoadableOrStorableType(ElemTy: *mut llvm_Type) -> bool;
}
impl llvm_PointerType {
    #[inline]
    pub unsafe fn get(
        ElementType: *mut llvm_Type,
        AddressSpace: ::std::os::raw::c_uint,
    ) -> *mut llvm_PointerType {
        llvm_PointerType_get(ElementType, AddressSpace)
    }
    #[inline]
    pub unsafe fn get1(
        C: *mut llvm_LLVMContext,
        AddressSpace: ::std::os::raw::c_uint,
    ) -> *mut llvm_PointerType {
        llvm_PointerType_get1(C, AddressSpace)
    }
    #[inline]
    pub unsafe fn isValidElementType(ElemTy: *mut llvm_Type) -> bool {
        llvm_PointerType_isValidElementType(ElemTy)
    }
    #[inline]
    pub unsafe fn isLoadableOrStorableType(ElemTy: *mut llvm_Type) -> bool {
        llvm_PointerType_isLoadableOrStorableType(ElemTy)
    }
}
#[doc = " Class to represent target extensions types, which are generally\n unintrospectable from target-independent optimizations.\n\n Target extension types have a string name, and optionally have type and/or\n integer parameters. The exact meaning of any parameters is dependent on the\n target."]
#[repr(C)]
#[derive(Debug)]
pub struct llvm_TargetExtType {
    pub _base: llvm_Type,
    pub Name: llvm_StringRef,
    pub IntParams: *mut ::std::os::raw::c_uint,
}
pub type llvm_TargetExtType_type_param_iterator = llvm_Type_subtype_iterator;
#[doc = " zeroinitializer is valid for this target extension type."]
pub const llvm_TargetExtType_Property_HasZeroInit: llvm_TargetExtType_Property = 1;
#[doc = " This type may be used as the value type of a global variable."]
pub const llvm_TargetExtType_Property_CanBeGlobal: llvm_TargetExtType_Property = 2;
pub type llvm_TargetExtType_Property = ::std::os::raw::c_uint;
#[test]
fn bindgen_test_layout_llvm_TargetExtType() {
    const UNINIT: ::std::mem::MaybeUninit<llvm_TargetExtType> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<llvm_TargetExtType>(),
        48usize,
        concat!("Size of: ", stringify!(llvm_TargetExtType))
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_TargetExtType>(),
        8usize,
        concat!("Alignment of ", stringify!(llvm_TargetExtType))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Name) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_TargetExtType),
            "::",
            stringify!(Name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).IntParams) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_TargetExtType),
            "::",
            stringify!(IntParams)
        )
    );
}
extern "C" {
    #[doc = " Return a target extension type having the specified name and optional\n type and integer parameters."]
    #[link_name = "\u{1}_ZN4llvm13TargetExtType3getERNS_11LLVMContextENS_9StringRefENS_8ArrayRefIPNS_4TypeEEENS4_IjEE"]
    pub fn llvm_TargetExtType_get(
        Context: *mut llvm_LLVMContext,
        Name: llvm_StringRef,
        Types: llvm_ArrayRef<*mut llvm_Type>,
        Ints: llvm_ArrayRef<::std::os::raw::c_uint>,
    ) -> *mut llvm_TargetExtType;
}
extern "C" {
    #[doc = " Returns true if the target extension type contains the given property."]
    #[link_name = "\u{1}_ZNK4llvm13TargetExtType11hasPropertyENS0_8PropertyE"]
    pub fn llvm_TargetExtType_hasProperty(
        this: *const llvm_TargetExtType,
        Prop: llvm_TargetExtType_Property,
    ) -> bool;
}
extern "C" {
    #[doc = " Returns an underlying layout type for the target extension type. This\n type can be used to query size and alignment information, if it is\n appropriate (although note that the layout type may also be void). It is\n not legal to bitcast between this type and the layout type, however."]
    #[link_name = "\u{1}_ZNK4llvm13TargetExtType13getLayoutTypeEv"]
    pub fn llvm_TargetExtType_getLayoutType(this: *const llvm_TargetExtType) -> *mut llvm_Type;
}
impl llvm_TargetExtType {
    #[inline]
    pub unsafe fn get(
        Context: *mut llvm_LLVMContext,
        Name: llvm_StringRef,
        Types: llvm_ArrayRef<*mut llvm_Type>,
        Ints: llvm_ArrayRef<::std::os::raw::c_uint>,
    ) -> *mut llvm_TargetExtType {
        llvm_TargetExtType_get(Context, Name, Types, Ints)
    }
    #[inline]
    pub unsafe fn hasProperty(&self, Prop: llvm_TargetExtType_Property) -> bool {
        llvm_TargetExtType_hasProperty(self, Prop)
    }
    #[inline]
    pub unsafe fn getLayoutType(&self) -> *mut llvm_Type {
        llvm_TargetExtType_getLayoutType(self)
    }
}
#[doc = " Helper template to calculate the max alignment requirement for a set of\n objects."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_trailing_objects_internal_AlignmentCalcHelper {
    pub _address: u8,
}
pub const llvm_trailing_objects_internal_AlignmentCalcHelper_FirstAlignment:
    llvm_trailing_objects_internal_AlignmentCalcHelper__bindgen_ty_1 = 0;
pub const llvm_trailing_objects_internal_AlignmentCalcHelper_RestAlignment:
    llvm_trailing_objects_internal_AlignmentCalcHelper__bindgen_ty_1 = 0;
pub type llvm_trailing_objects_internal_AlignmentCalcHelper__bindgen_ty_1 = i32;
pub const llvm_trailing_objects_internal_AlignmentCalcHelper_Alignment:
    llvm_trailing_objects_internal_AlignmentCalcHelper__bindgen_ty_2 = 0;
pub type llvm_trailing_objects_internal_AlignmentCalcHelper__bindgen_ty_2 = i32;
#[doc = " The base class for TrailingObjects* classes."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_trailing_objects_internal_TrailingObjectsBase {
    pub _address: u8,
}
#[doc = " OverloadToken's purpose is to allow specifying function overloads\n for different types, without actually taking the types as\n parameters. (Necessary because member function templates cannot\n be specialized, so overloads must be used instead of\n specialization.)"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_trailing_objects_internal_TrailingObjectsBase_OverloadToken {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_llvm_trailing_objects_internal_TrailingObjectsBase() {
    assert_eq!(
        ::std::mem::size_of::<llvm_trailing_objects_internal_TrailingObjectsBase>(),
        1usize,
        concat!(
            "Size of: ",
            stringify!(llvm_trailing_objects_internal_TrailingObjectsBase)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_trailing_objects_internal_TrailingObjectsBase>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(llvm_trailing_objects_internal_TrailingObjectsBase)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_trailing_objects_internal_ExtractSecondType {
    pub _address: u8,
}
pub type llvm_trailing_objects_internal_ExtractSecondType_type<Ty2> = Ty2;
#[doc = " See the file comment for details on the usage of the\n TrailingObjects type."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_TrailingObjects {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_TrailingObjects_Foo {
    pub _address: u8,
}
pub type llvm_TrailingObjects_ParentType = u8;
#[doc = " The base class for TrailingObjects* classes."]
pub type llvm_TrailingObjects_TrailingObjectsBase =
    llvm_trailing_objects_internal_TrailingObjectsBase;
#[doc = " A type where its ::with_counts template member has a ::type member\n suitable for use as uninitialized storage for an object with the given\n trailing object counts. The template arguments are similar to those\n of additionalSizeToAlloc.\n\n Use with FixedSizeStorageOwner, e.g.:\n\n \\code{.cpp}\n\n MyObj::FixedSizeStorage<void *>::with_counts<1u>::type myStackObjStorage;\n MyObj::FixedSizeStorageOwner\n     myStackObjOwner(new ((void *)&myStackObjStorage) MyObj);\n MyObj *const myStackObjPtr = myStackObjOwner.get();\n\n \\endcode"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_TrailingObjects_FixedSizeStorage {
    pub _address: u8,
}
#[doc = " A type that acts as the owner for an object placed into fixed storage."]
#[repr(C)]
#[derive(Debug)]
pub struct llvm_TrailingObjects_FixedSizeStorageOwner<BaseTy> {
    pub p: *mut BaseTy,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<BaseTy>>,
}
pub const llvm_TrailingObjects_FixedSizeStorage_with_counts_Size:
    llvm_TrailingObjects_FixedSizeStorage_with_counts__bindgen_ty_1 = 0;
pub type llvm_TrailingObjects_FixedSizeStorage_with_counts__bindgen_ty_1 = i32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_TrailingObjects_FixedSizeStorage_with_counts_type {
    pub buffer: *mut ::std::os::raw::c_char,
}
#[doc = " A parsed version of the target data layout string in and methods for\n querying it.\n\n The target data layout string is specified *by the target* - a frontend\n generating LLVM IR is required to generate the right target data for the\n target being codegen'd to."]
#[repr(C)]
pub struct llvm_DataLayout {
    pub BigEndian: bool,
    pub AllocaAddrSpace: ::std::os::raw::c_uint,
    pub ProgramAddrSpace: ::std::os::raw::c_uint,
    pub DefaultGlobalsAddrSpace: ::std::os::raw::c_uint,
    pub StackNaturalAlign: llvm_MaybeAlign,
    pub FunctionPtrAlign: llvm_MaybeAlign,
    pub TheFunctionPtrAlignType: llvm_DataLayout_FunctionPtrAlignType,
    pub ManglingMode: llvm_DataLayout_ManglingModeT,
    pub LegalIntWidths: [u64; 4usize],
    #[doc = " Primitive type specifications. Sorted and uniqued by type bit width."]
    pub IntSpecs: [u64; 8usize],
    pub FloatSpecs: [u64; 6usize],
    pub VectorSpecs: [u64; 12usize],
    #[doc = " Pointer type specifications. Sorted and uniqued by address space number."]
    pub PointerSpecs: [u64; 18usize],
    #[doc = " The string representation used to create this DataLayout"]
    pub StringRepresentation: std_string,
    #[doc = " Struct type ABI and preferred alignments. The default spec is \"a:8:64\"."]
    pub StructABIAlignment: llvm_Align,
    pub StructPrefAlignment: llvm_Align,
    pub LayoutMap: *mut ::std::os::raw::c_void,
    #[doc = " Pointers in these address spaces are non-integral, and don't have a\n well-defined bitwise representation."]
    pub NonIntegralAddressSpaces: [u64; 6usize],
}
#[doc = " Primitive type specification."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_DataLayout_PrimitiveSpec {
    pub BitWidth: u32,
    pub ABIAlign: llvm_Align,
    pub PrefAlign: llvm_Align,
}
#[test]
fn bindgen_test_layout_llvm_DataLayout_PrimitiveSpec() {
    const UNINIT: ::std::mem::MaybeUninit<llvm_DataLayout_PrimitiveSpec> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<llvm_DataLayout_PrimitiveSpec>(),
        8usize,
        concat!("Size of: ", stringify!(llvm_DataLayout_PrimitiveSpec))
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_DataLayout_PrimitiveSpec>(),
        4usize,
        concat!("Alignment of ", stringify!(llvm_DataLayout_PrimitiveSpec))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).BitWidth) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_DataLayout_PrimitiveSpec),
            "::",
            stringify!(BitWidth)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ABIAlign) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_DataLayout_PrimitiveSpec),
            "::",
            stringify!(ABIAlign)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).PrefAlign) as usize - ptr as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_DataLayout_PrimitiveSpec),
            "::",
            stringify!(PrefAlign)
        )
    );
}
#[doc = " Pointer type specification."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_DataLayout_PointerSpec {
    pub AddrSpace: u32,
    pub BitWidth: u32,
    pub ABIAlign: llvm_Align,
    pub PrefAlign: llvm_Align,
    pub IndexBitWidth: u32,
}
#[test]
fn bindgen_test_layout_llvm_DataLayout_PointerSpec() {
    const UNINIT: ::std::mem::MaybeUninit<llvm_DataLayout_PointerSpec> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<llvm_DataLayout_PointerSpec>(),
        16usize,
        concat!("Size of: ", stringify!(llvm_DataLayout_PointerSpec))
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_DataLayout_PointerSpec>(),
        4usize,
        concat!("Alignment of ", stringify!(llvm_DataLayout_PointerSpec))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).AddrSpace) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_DataLayout_PointerSpec),
            "::",
            stringify!(AddrSpace)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).BitWidth) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_DataLayout_PointerSpec),
            "::",
            stringify!(BitWidth)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ABIAlign) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_DataLayout_PointerSpec),
            "::",
            stringify!(ABIAlign)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).PrefAlign) as usize - ptr as usize },
        9usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_DataLayout_PointerSpec),
            "::",
            stringify!(PrefAlign)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).IndexBitWidth) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_DataLayout_PointerSpec),
            "::",
            stringify!(IndexBitWidth)
        )
    );
}
#[doc = " The function pointer alignment is independent of the function alignment."]
pub const llvm_DataLayout_FunctionPtrAlignType_Independent: llvm_DataLayout_FunctionPtrAlignType =
    0;
#[doc = " The function pointer alignment is a multiple of the function alignment."]
pub const llvm_DataLayout_FunctionPtrAlignType_MultipleOfFunctionAlign:
    llvm_DataLayout_FunctionPtrAlignType = 1;
pub type llvm_DataLayout_FunctionPtrAlignType = ::std::os::raw::c_int;
pub const llvm_DataLayout_ManglingModeT_MM_None: llvm_DataLayout_ManglingModeT = 0;
pub const llvm_DataLayout_ManglingModeT_MM_ELF: llvm_DataLayout_ManglingModeT = 1;
pub const llvm_DataLayout_ManglingModeT_MM_MachO: llvm_DataLayout_ManglingModeT = 2;
pub const llvm_DataLayout_ManglingModeT_MM_WinCOFF: llvm_DataLayout_ManglingModeT = 3;
pub const llvm_DataLayout_ManglingModeT_MM_WinCOFFX86: llvm_DataLayout_ManglingModeT = 4;
pub const llvm_DataLayout_ManglingModeT_MM_GOFF: llvm_DataLayout_ManglingModeT = 5;
pub const llvm_DataLayout_ManglingModeT_MM_Mips: llvm_DataLayout_ManglingModeT = 6;
pub const llvm_DataLayout_ManglingModeT_MM_XCOFF: llvm_DataLayout_ManglingModeT = 7;
pub type llvm_DataLayout_ManglingModeT = ::std::os::raw::c_uint;
#[test]
fn bindgen_test_layout_llvm_DataLayout() {
    const UNINIT: ::std::mem::MaybeUninit<llvm_DataLayout> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<llvm_DataLayout>(),
        512usize,
        concat!("Size of: ", stringify!(llvm_DataLayout))
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_DataLayout>(),
        8usize,
        concat!("Alignment of ", stringify!(llvm_DataLayout))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).BigEndian) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_DataLayout),
            "::",
            stringify!(BigEndian)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).AllocaAddrSpace) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_DataLayout),
            "::",
            stringify!(AllocaAddrSpace)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ProgramAddrSpace) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_DataLayout),
            "::",
            stringify!(ProgramAddrSpace)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).DefaultGlobalsAddrSpace) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_DataLayout),
            "::",
            stringify!(DefaultGlobalsAddrSpace)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).StackNaturalAlign) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_DataLayout),
            "::",
            stringify!(StackNaturalAlign)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).FunctionPtrAlign) as usize - ptr as usize },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_DataLayout),
            "::",
            stringify!(FunctionPtrAlign)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).TheFunctionPtrAlignType) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_DataLayout),
            "::",
            stringify!(TheFunctionPtrAlignType)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ManglingMode) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_DataLayout),
            "::",
            stringify!(ManglingMode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LegalIntWidths) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_DataLayout),
            "::",
            stringify!(LegalIntWidths)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).IntSpecs) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_DataLayout),
            "::",
            stringify!(IntSpecs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).FloatSpecs) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_DataLayout),
            "::",
            stringify!(FloatSpecs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).VectorSpecs) as usize - ptr as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_DataLayout),
            "::",
            stringify!(VectorSpecs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).PointerSpecs) as usize - ptr as usize },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_DataLayout),
            "::",
            stringify!(PointerSpecs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).StringRepresentation) as usize - ptr as usize },
        416usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_DataLayout),
            "::",
            stringify!(StringRepresentation)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).StructABIAlignment) as usize - ptr as usize },
        448usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_DataLayout),
            "::",
            stringify!(StructABIAlignment)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).StructPrefAlignment) as usize - ptr as usize },
        449usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_DataLayout),
            "::",
            stringify!(StructPrefAlignment)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LayoutMap) as usize - ptr as usize },
        456usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_DataLayout),
            "::",
            stringify!(LayoutMap)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).NonIntegralAddressSpaces) as usize - ptr as usize },
        464usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_DataLayout),
            "::",
            stringify!(NonIntegralAddressSpaces)
        )
    );
}
extern "C" {
    #[doc = " Parse a data layout string and return the layout. Return an error\n description on failure."]
    #[link_name = "\u{1}_ZN4llvm10DataLayout5parseENS_9StringRefE"]
    pub fn llvm_DataLayout_parse(LayoutString: llvm_StringRef) -> llvm_Expected;
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm10DataLayout20getManglingComponentERKNS_6TripleE"]
    pub fn llvm_DataLayout_getManglingComponent(
        T: *const llvm_Triple,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Layout pointer alignment"]
    #[link_name = "\u{1}_ZNK4llvm10DataLayout22getPointerABIAlignmentEj"]
    pub fn llvm_DataLayout_getPointerABIAlignment(
        this: *const llvm_DataLayout,
        AS: ::std::os::raw::c_uint,
    ) -> llvm_Align;
}
extern "C" {
    #[doc = " Return target's alignment for stack-based pointers\n FIXME: The defaults need to be removed once all of\n the backends/clients are updated."]
    #[link_name = "\u{1}_ZNK4llvm10DataLayout23getPointerPrefAlignmentEj"]
    pub fn llvm_DataLayout_getPointerPrefAlignment(
        this: *const llvm_DataLayout,
        AS: ::std::os::raw::c_uint,
    ) -> llvm_Align;
}
extern "C" {
    #[doc = " Layout pointer size in bytes, rounded up to a whole\n number of bytes.\n FIXME: The defaults need to be removed once all of\n the backends/clients are updated."]
    #[link_name = "\u{1}_ZNK4llvm10DataLayout14getPointerSizeEj"]
    pub fn llvm_DataLayout_getPointerSize(
        this: *const llvm_DataLayout,
        AS: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " Returns the maximum index size over all address spaces."]
    #[link_name = "\u{1}_ZNK4llvm10DataLayout15getMaxIndexSizeEv"]
    pub fn llvm_DataLayout_getMaxIndexSize(this: *const llvm_DataLayout) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " rounded up to a whole number of bytes."]
    #[link_name = "\u{1}_ZNK4llvm10DataLayout12getIndexSizeEj"]
    pub fn llvm_DataLayout_getIndexSize(
        this: *const llvm_DataLayout,
        AS: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " Layout pointer size, in bits, based on the type.  If this function is\n called with a pointer type, then the type size of the pointer is returned.\n If this function is called with a vector of pointers, then the type size\n of the pointer is returned.  This should only be called with a pointer or\n vector of pointers."]
    #[link_name = "\u{1}_ZNK4llvm10DataLayout24getPointerTypeSizeInBitsEPNS_4TypeE"]
    pub fn llvm_DataLayout_getPointerTypeSizeInBits(
        this: *const llvm_DataLayout,
        arg1: *mut llvm_Type,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " Layout size of the index used in GEP calculation.\n The function should be called with pointer or vector of pointers type."]
    #[link_name = "\u{1}_ZNK4llvm10DataLayout22getIndexTypeSizeInBitsEPNS_4TypeE"]
    pub fn llvm_DataLayout_getIndexTypeSizeInBits(
        this: *const llvm_DataLayout,
        Ty: *mut llvm_Type,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " Returns the minimum ABI-required alignment for the specified type."]
    #[link_name = "\u{1}_ZNK4llvm10DataLayout15getABITypeAlignEPNS_4TypeE"]
    pub fn llvm_DataLayout_getABITypeAlign(
        this: *const llvm_DataLayout,
        Ty: *mut llvm_Type,
    ) -> llvm_Align;
}
extern "C" {
    #[doc = " Returns the preferred stack/global alignment for the specified\n type.\n\n This is always at least as good as the ABI alignment."]
    #[link_name = "\u{1}_ZNK4llvm10DataLayout16getPrefTypeAlignEPNS_4TypeE"]
    pub fn llvm_DataLayout_getPrefTypeAlign(
        this: *const llvm_DataLayout,
        Ty: *mut llvm_Type,
    ) -> llvm_Align;
}
extern "C" {
    #[doc = " Returns an integer type with size at least as big as that of a\n pointer in the given address space."]
    #[link_name = "\u{1}_ZNK4llvm10DataLayout13getIntPtrTypeERNS_11LLVMContextEj"]
    pub fn llvm_DataLayout_getIntPtrType(
        this: *const llvm_DataLayout,
        C: *mut llvm_LLVMContext,
        AddressSpace: ::std::os::raw::c_uint,
    ) -> *mut llvm_IntegerType;
}
extern "C" {
    #[doc = " Returns an integer (vector of integer) type with size at least as\n big as that of a pointer of the given pointer (vector of pointer) type."]
    #[link_name = "\u{1}_ZNK4llvm10DataLayout13getIntPtrTypeEPNS_4TypeE"]
    pub fn llvm_DataLayout_getIntPtrType1(
        this: *const llvm_DataLayout,
        arg1: *mut llvm_Type,
    ) -> *mut llvm_Type;
}
extern "C" {
    #[doc = " Returns the smallest integer type with size at least as big as\n Width bits."]
    #[link_name = "\u{1}_ZNK4llvm10DataLayout23getSmallestLegalIntTypeERNS_11LLVMContextEj"]
    pub fn llvm_DataLayout_getSmallestLegalIntType(
        this: *const llvm_DataLayout,
        C: *mut llvm_LLVMContext,
        Width: ::std::os::raw::c_uint,
    ) -> *mut llvm_Type;
}
extern "C" {
    #[doc = " Returns the size of largest legal integer type size, or 0 if none\n are set."]
    #[link_name = "\u{1}_ZNK4llvm10DataLayout32getLargestLegalIntTypeSizeInBitsEv"]
    pub fn llvm_DataLayout_getLargestLegalIntTypeSizeInBits(
        this: *const llvm_DataLayout,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " Returns the type of a GEP index in AddressSpace.\n If it was not specified explicitly, it will be the integer type of the\n pointer width - IntPtrType."]
    #[link_name = "\u{1}_ZNK4llvm10DataLayout12getIndexTypeERNS_11LLVMContextEj"]
    pub fn llvm_DataLayout_getIndexType(
        this: *const llvm_DataLayout,
        C: *mut llvm_LLVMContext,
        AddressSpace: ::std::os::raw::c_uint,
    ) -> *mut llvm_IntegerType;
}
extern "C" {
    #[doc = " Returns the type of a GEP index.\n If it was not specified explicitly, it will be the integer type of the\n pointer width - IntPtrType."]
    #[link_name = "\u{1}_ZNK4llvm10DataLayout12getIndexTypeEPNS_4TypeE"]
    pub fn llvm_DataLayout_getIndexType1(
        this: *const llvm_DataLayout,
        PtrTy: *mut llvm_Type,
    ) -> *mut llvm_Type;
}
extern "C" {
    #[doc = " Returns the offset from the beginning of the type for the specified\n indices.\n\n Note that this takes the element type, not the pointer type.\n This is used to implement getelementptr."]
    #[link_name = "\u{1}_ZNK4llvm10DataLayout22getIndexedOffsetInTypeEPNS_4TypeENS_8ArrayRefIPNS_5ValueEEE"]
    pub fn llvm_DataLayout_getIndexedOffsetInType(
        this: *const llvm_DataLayout,
        ElemTy: *mut llvm_Type,
        Indices: llvm_ArrayRef<*mut llvm_Value>,
    ) -> i64;
}
extern "C" {
    #[doc = " Get GEP indices to access Offset inside ElemTy. ElemTy is updated to be\n the result element type and Offset to be the residual offset."]
    #[link_name = "\u{1}_ZNK4llvm10DataLayout22getGEPIndicesForOffsetERPNS_4TypeERNS_5APIntE"]
    pub fn llvm_DataLayout_getGEPIndicesForOffset(
        this: *const llvm_DataLayout,
        ElemTy: *mut *mut llvm_Type,
        Offset: *mut llvm_APInt,
    ) -> u8;
}
extern "C" {
    #[doc = " Get single GEP index to access Offset inside ElemTy. Returns std::nullopt\n if index cannot be computed, e.g. because the type is not an aggregate.\n ElemTy is updated to be the result element type and Offset to be the\n residual offset."]
    #[link_name = "\u{1}_ZNK4llvm10DataLayout20getGEPIndexForOffsetERPNS_4TypeERNS_5APIntE"]
    pub fn llvm_DataLayout_getGEPIndexForOffset(
        this: *const llvm_DataLayout,
        ElemTy: *mut *mut llvm_Type,
        Offset: *mut llvm_APInt,
    ) -> std_optional;
}
extern "C" {
    #[doc = " Returns a StructLayout object, indicating the alignment of the\n struct, its size, and the offsets of its fields.\n\n Note that this information is lazily cached."]
    #[link_name = "\u{1}_ZNK4llvm10DataLayout15getStructLayoutEPNS_10StructTypeE"]
    pub fn llvm_DataLayout_getStructLayout(
        this: *const llvm_DataLayout,
        Ty: *mut llvm_StructType,
    ) -> *const llvm_StructLayout;
}
extern "C" {
    #[doc = " Returns the preferred alignment of the specified global.\n\n This includes an explicitly requested alignment (if the global has one)."]
    #[link_name = "\u{1}_ZNK4llvm10DataLayout17getPreferredAlignEPKNS_14GlobalVariableE"]
    pub fn llvm_DataLayout_getPreferredAlign(
        this: *const llvm_DataLayout,
        GV: *const llvm_GlobalVariable,
    ) -> llvm_Align;
}
extern "C" {
    #[doc = " Constructs a DataLayout with default values."]
    #[link_name = "\u{1}_ZN4llvm10DataLayoutC1Ev"]
    pub fn llvm_DataLayout_DataLayout(this: *mut llvm_DataLayout);
}
extern "C" {
    #[doc = " Constructs a DataLayout from a specification string.\n WARNING: Aborts execution if the string is malformed. Use parse() instead."]
    #[link_name = "\u{1}_ZN4llvm10DataLayoutC1ENS_9StringRefE"]
    pub fn llvm_DataLayout_DataLayout1(this: *mut llvm_DataLayout, LayoutString: llvm_StringRef);
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm10DataLayoutD1Ev"]
    pub fn llvm_DataLayout_DataLayout_destructor(this: *mut llvm_DataLayout);
}
impl llvm_DataLayout {
    #[inline]
    pub unsafe fn parse(LayoutString: llvm_StringRef) -> llvm_Expected {
        llvm_DataLayout_parse(LayoutString)
    }
    #[inline]
    pub unsafe fn getManglingComponent(T: *const llvm_Triple) -> *const ::std::os::raw::c_char {
        llvm_DataLayout_getManglingComponent(T)
    }
    #[inline]
    pub unsafe fn getPointerABIAlignment(&self, AS: ::std::os::raw::c_uint) -> llvm_Align {
        llvm_DataLayout_getPointerABIAlignment(self, AS)
    }
    #[inline]
    pub unsafe fn getPointerPrefAlignment(&self, AS: ::std::os::raw::c_uint) -> llvm_Align {
        llvm_DataLayout_getPointerPrefAlignment(self, AS)
    }
    #[inline]
    pub unsafe fn getPointerSize(&self, AS: ::std::os::raw::c_uint) -> ::std::os::raw::c_uint {
        llvm_DataLayout_getPointerSize(self, AS)
    }
    #[inline]
    pub unsafe fn getMaxIndexSize(&self) -> ::std::os::raw::c_uint {
        llvm_DataLayout_getMaxIndexSize(self)
    }
    #[inline]
    pub unsafe fn getIndexSize(&self, AS: ::std::os::raw::c_uint) -> ::std::os::raw::c_uint {
        llvm_DataLayout_getIndexSize(self, AS)
    }
    #[inline]
    pub unsafe fn getPointerTypeSizeInBits(&self, arg1: *mut llvm_Type) -> ::std::os::raw::c_uint {
        llvm_DataLayout_getPointerTypeSizeInBits(self, arg1)
    }
    #[inline]
    pub unsafe fn getIndexTypeSizeInBits(&self, Ty: *mut llvm_Type) -> ::std::os::raw::c_uint {
        llvm_DataLayout_getIndexTypeSizeInBits(self, Ty)
    }
    #[inline]
    pub unsafe fn getABITypeAlign(&self, Ty: *mut llvm_Type) -> llvm_Align {
        llvm_DataLayout_getABITypeAlign(self, Ty)
    }
    #[inline]
    pub unsafe fn getPrefTypeAlign(&self, Ty: *mut llvm_Type) -> llvm_Align {
        llvm_DataLayout_getPrefTypeAlign(self, Ty)
    }
    #[inline]
    pub unsafe fn getIntPtrType(
        &self,
        C: *mut llvm_LLVMContext,
        AddressSpace: ::std::os::raw::c_uint,
    ) -> *mut llvm_IntegerType {
        llvm_DataLayout_getIntPtrType(self, C, AddressSpace)
    }
    #[inline]
    pub unsafe fn getIntPtrType1(&self, arg1: *mut llvm_Type) -> *mut llvm_Type {
        llvm_DataLayout_getIntPtrType1(self, arg1)
    }
    #[inline]
    pub unsafe fn getSmallestLegalIntType(
        &self,
        C: *mut llvm_LLVMContext,
        Width: ::std::os::raw::c_uint,
    ) -> *mut llvm_Type {
        llvm_DataLayout_getSmallestLegalIntType(self, C, Width)
    }
    #[inline]
    pub unsafe fn getLargestLegalIntTypeSizeInBits(&self) -> ::std::os::raw::c_uint {
        llvm_DataLayout_getLargestLegalIntTypeSizeInBits(self)
    }
    #[inline]
    pub unsafe fn getIndexType(
        &self,
        C: *mut llvm_LLVMContext,
        AddressSpace: ::std::os::raw::c_uint,
    ) -> *mut llvm_IntegerType {
        llvm_DataLayout_getIndexType(self, C, AddressSpace)
    }
    #[inline]
    pub unsafe fn getIndexType1(&self, PtrTy: *mut llvm_Type) -> *mut llvm_Type {
        llvm_DataLayout_getIndexType1(self, PtrTy)
    }
    #[inline]
    pub unsafe fn getIndexedOffsetInType(
        &self,
        ElemTy: *mut llvm_Type,
        Indices: llvm_ArrayRef<*mut llvm_Value>,
    ) -> i64 {
        llvm_DataLayout_getIndexedOffsetInType(self, ElemTy, Indices)
    }
    #[inline]
    pub unsafe fn getGEPIndicesForOffset(
        &self,
        ElemTy: *mut *mut llvm_Type,
        Offset: *mut llvm_APInt,
    ) -> u8 {
        llvm_DataLayout_getGEPIndicesForOffset(self, ElemTy, Offset)
    }
    #[inline]
    pub unsafe fn getGEPIndexForOffset(
        &self,
        ElemTy: *mut *mut llvm_Type,
        Offset: *mut llvm_APInt,
    ) -> std_optional {
        llvm_DataLayout_getGEPIndexForOffset(self, ElemTy, Offset)
    }
    #[inline]
    pub unsafe fn getStructLayout(&self, Ty: *mut llvm_StructType) -> *const llvm_StructLayout {
        llvm_DataLayout_getStructLayout(self, Ty)
    }
    #[inline]
    pub unsafe fn getPreferredAlign(&self, GV: *const llvm_GlobalVariable) -> llvm_Align {
        llvm_DataLayout_getPreferredAlign(self, GV)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        llvm_DataLayout_DataLayout(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(LayoutString: llvm_StringRef) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        llvm_DataLayout_DataLayout1(__bindgen_tmp.as_mut_ptr(), LayoutString);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn destruct(&mut self) {
        llvm_DataLayout_DataLayout_destructor(self)
    }
}
#[doc = " Used to lazily calculate structure layout information for a target machine,\n based on the DataLayout structure."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_StructLayout {
    pub StructSize: llvm_TypeSize,
    pub StructAlignment: llvm_Align,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_llvm_StructLayout() {
    const UNINIT: ::std::mem::MaybeUninit<llvm_StructLayout> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<llvm_StructLayout>(),
        24usize,
        concat!("Size of: ", stringify!(llvm_StructLayout))
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_StructLayout>(),
        8usize,
        concat!("Alignment of ", stringify!(llvm_StructLayout))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).StructSize) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_StructLayout),
            "::",
            stringify!(StructSize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).StructAlignment) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_StructLayout),
            "::",
            stringify!(StructAlignment)
        )
    );
}
extern "C" {
    #[doc = " Given a valid byte offset into the structure, returns the structure\n index that contains it."]
    #[link_name = "\u{1}_ZNK4llvm12StructLayout26getElementContainingOffsetEm"]
    pub fn llvm_StructLayout_getElementContainingOffset(
        this: *const llvm_StructLayout,
        FixedOffset: u64,
    ) -> ::std::os::raw::c_uint;
}
impl llvm_StructLayout {
    #[inline]
    pub fn IsPadded(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_IsPadded(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn NumElements(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 31u8) as u32) }
    }
    #[inline]
    pub fn set_NumElements(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 31u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        IsPadded: ::std::os::raw::c_uint,
        NumElements: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let IsPadded: u32 = unsafe { ::std::mem::transmute(IsPadded) };
            IsPadded as u64
        });
        __bindgen_bitfield_unit.set(1usize, 31u8, {
            let NumElements: u32 = unsafe { ::std::mem::transmute(NumElements) };
            NumElements as u64
        });
        __bindgen_bitfield_unit
    }
    #[inline]
    pub unsafe fn getElementContainingOffset(&self, FixedOffset: u64) -> ::std::os::raw::c_uint {
        llvm_StructLayout_getElementContainingOffset(self, FixedOffset)
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct llvm_DenseMapBase {
    pub _base: llvm_DebugEpochBase,
}
pub type llvm_DenseMapBase_const_arg_type_t = llvm_const_pointer_or_const_ref;
pub type llvm_DenseMapBase_size_type = ::std::os::raw::c_uint;
pub type llvm_DenseMapBase_key_type<KeyT> = KeyT;
pub type llvm_DenseMapBase_mapped_type<ValueT> = ValueT;
pub type llvm_DenseMapBase_value_type<BucketT> = BucketT;
pub type llvm_DenseMapBase_iterator = u8;
pub type llvm_DenseMapBase_const_iterator = u8;
#[repr(C)]
#[derive(Debug)]
pub struct llvm_DenseMap<BucketT> {
    pub _base: llvm_DenseMapBase,
    pub Buckets: *mut BucketT,
    pub NumEntries: ::std::os::raw::c_uint,
    pub NumTombstones: ::std::os::raw::c_uint,
    pub NumBuckets: ::std::os::raw::c_uint,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<BucketT>>,
}
pub type llvm_DenseMap_BaseT = llvm_DenseMapBase;
pub type llvm_SmallDenseMap_BaseT = llvm_DenseMapBase;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_SmallDenseMap_LargeRep<BucketT> {
    pub Buckets: *mut BucketT,
    pub NumBuckets: ::std::os::raw::c_uint,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<BucketT>>,
}
pub type llvm_DenseMapIterator_difference_type = isize;
pub type llvm_DenseMapIterator_value_type = std_conditional_t;
pub type llvm_DenseMapIterator_pointer = *mut llvm_DenseMapIterator_value_type;
pub type llvm_DenseMapIterator_reference = *mut llvm_DenseMapIterator_value_type;
pub type llvm_DenseMapIterator_iterator_category = std_forward_iterator_tag;
#[doc = " Implements a dense probed hash-table based set."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_DenseSet {
    pub _base: llvm_detail_DenseSetImpl<MapTy>,
}
#[doc = " Base class for DenseSet and DenseSmallSet.\n\n MapTy should be either\n\n   DenseMap<ValueT, detail::DenseSetEmpty, ValueInfoT,\n            detail::DenseSetPair<ValueT>>\n\n or the equivalent SmallDenseMap type.  ValueInfoT must implement the\n DenseMapInfo \"concept\"."]
pub type llvm_DenseSet_BaseT = llvm_detail_DenseSetImpl<MapTy>;
#[doc = " Base class for DenseSet and DenseSmallSet.\n\n MapTy should be either\n\n   DenseMap<ValueT, detail::DenseSetEmpty, ValueInfoT,\n            detail::DenseSetPair<ValueT>>\n\n or the equivalent SmallDenseMap type.  ValueInfoT must implement the\n DenseMapInfo \"concept\"."]
pub type llvm_SmallDenseSet_BaseT = llvm_detail_DenseSetImpl<MapTy>;
pub type llvm_PointerIntPair_InfoTy<Info> = Info;
#[doc = " PointerBitMask - The bits that come from the pointer."]
pub const llvm_PointerIntPairInfo_MaskAndShiftConstants_PointerBitMask:
    llvm_PointerIntPairInfo_MaskAndShiftConstants = 0;
#[doc = " IntShift - The number of low bits that we reserve for other uses, and\n keep zero."]
pub const llvm_PointerIntPairInfo_MaskAndShiftConstants_IntShift:
    llvm_PointerIntPairInfo_MaskAndShiftConstants = 0;
#[doc = " IntMask - This is the unshifted mask for valid bits of the int type."]
pub const llvm_PointerIntPairInfo_MaskAndShiftConstants_IntMask:
    llvm_PointerIntPairInfo_MaskAndShiftConstants = 0;
#[doc = " IntMask - This is the unshifted mask for valid bits of the int type."]
pub const llvm_PointerIntPairInfo_MaskAndShiftConstants_ShiftedIntMask:
    llvm_PointerIntPairInfo_MaskAndShiftConstants = 0;
pub type llvm_PointerIntPairInfo_MaskAndShiftConstants = usize;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_ilist_detail_node_base_parent<ParentTy> {
    pub Parent: *mut ParentTy,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<ParentTy>>,
}
#[test]
fn __bindgen_test_layout_llvm_ilist_detail_node_base_parent_open0_void_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<llvm_ilist_detail_node_base_parent<::std::os::raw::c_void>>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_ilist_detail_node_base_parent<::std::os::raw::c_void>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_ilist_detail_node_base_parent<::std::os::raw::c_void>>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_ilist_detail_node_base_parent<::std::os::raw::c_void>)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}is_explicit"]
    pub static llvm_ilist_detail_explicitness_is_explicit: bool;
}
#[doc = " Helper trait for recording whether an option is specified explicitly."]
pub type llvm_ilist_detail_is_explicit = u8;
#[doc = " Helper trait for recording whether an option is specified explicitly."]
pub type llvm_ilist_detail_is_implicit = u8;
#[doc = " Check whether an option is valid.\n\n The steps for adding and enabling a new ilist option include:\n \\li define the option, ilist_foo<Bar>, above;\n \\li add new parameters for Bar to \\a ilist_detail::node_options;\n \\li add an extraction meta-function, ilist_detail::extract_foo;\n \\li call extract_foo from \\a ilist_detail::compute_node_options and pass it\n into \\a ilist_detail::node_options; and\n \\li specialize \\c is_valid_option<ilist_foo<Bar>> to inherit from \\c\n std::true_type to get static assertions passing in \\a simple_ilist and \\a\n ilist_node."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_ilist_detail_is_valid_option {
    pub _base: std_false_type,
}
#[doc = " Extract sentinel tracking option.\n\n Look through \\p Options for the \\a ilist_sentinel_tracking option, with the\n default depending on LLVM_ENABLE_ABI_BREAKING_CHECKS."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_ilist_detail_extract_sentinel_tracking {
    pub _address: u8,
}
#[test]
fn __bindgen_test_layout_llvm_ilist_detail_extract_sentinel_tracking_open0_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<llvm_ilist_detail_extract_sentinel_tracking>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_ilist_detail_extract_sentinel_tracking)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_ilist_detail_extract_sentinel_tracking>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_ilist_detail_extract_sentinel_tracking)
        )
    );
}
#[doc = " Extract custom tag option.\n\n Look through \\p Options for the \\a ilist_tag option, pulling out the\n custom tag type, using void as a default."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_ilist_detail_extract_tag {
    pub _address: u8,
}
#[test]
fn __bindgen_test_layout_llvm_ilist_detail_extract_tag_open0_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<llvm_ilist_detail_extract_tag>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_ilist_detail_extract_tag)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_ilist_detail_extract_tag>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_ilist_detail_extract_tag)
        )
    );
}
#[doc = " Extract iterator bits option.\n\n Look through \\p Options for the \\a ilist_iterator_bits option. Defaults\n to false."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_ilist_detail_extract_iterator_bits {
    pub _address: u8,
}
#[test]
fn __bindgen_test_layout_llvm_ilist_detail_extract_iterator_bits_open0_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<llvm_ilist_detail_extract_iterator_bits>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_ilist_detail_extract_iterator_bits)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_ilist_detail_extract_iterator_bits>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_ilist_detail_extract_iterator_bits)
        )
    );
}
#[doc = " Extract node parent option.\n\n Look through \\p Options for the \\a ilist_parent option, pulling out the\n custom parent type, using void as a default."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_ilist_detail_extract_parent {
    pub _address: u8,
}
#[test]
fn __bindgen_test_layout_llvm_ilist_detail_extract_parent_open0_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<llvm_ilist_detail_extract_parent>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_ilist_detail_extract_parent)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_ilist_detail_extract_parent>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_ilist_detail_extract_parent)
        )
    );
}
#[doc = " Check whether options are valid.\n\n The conjunction of \\a is_valid_option on each individual option."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_ilist_detail_check_options {
    pub _address: u8,
}
#[test]
fn __bindgen_test_layout_llvm_ilist_detail_check_options_open0_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<llvm_ilist_detail_check_options>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_ilist_detail_check_options)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_ilist_detail_check_options>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_ilist_detail_check_options)
        )
    );
}
pub type llvm_ilist_detail_node_options_value_type<T> = T;
pub type llvm_ilist_detail_node_options_pointer<T> = *mut T;
pub type llvm_ilist_detail_node_options_reference<T> = *mut T;
pub type llvm_ilist_detail_node_options_const_pointer<T> = *const T;
pub type llvm_ilist_detail_node_options_const_reference<T> = *const T;
pub type llvm_ilist_detail_node_options_tag<TagT> = TagT;
pub type llvm_ilist_detail_node_options_parent_ty<ParentTy> = ParentTy;
#[doc = " Base class for ilist nodes.\n\n Optionally tracks whether this node is the sentinel."]
pub type llvm_ilist_detail_node_options_node_base_type = u8;
#[doc = " Implementations of list algorithms using ilist_node_base."]
pub type llvm_ilist_detail_node_options_list_base_type = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_ilist_detail_compute_node_options {
    pub _address: u8,
}
#[doc = " Traits for options for \\a ilist_node.\n\n This is usually computed via \\a compute_node_options."]
pub type llvm_ilist_detail_compute_node_options_type = u8;
#[doc = " Mixin base class that is used to add \\a getParent() and\n \\a setParent(ParentTy*) methods to \\a ilist_node_impl iff \\a ilist_parent\n has been set in the list options."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_ilist_detail_node_parent_access {
    pub _address: u8,
}
#[doc = " An access class for ilist_node private API.\n\n This gives access to the private parts of ilist nodes.  Nodes for an ilist\n should friend this class if they inherit privately from ilist_node.\n\n Using this class outside of the ilist implementation is unsupported."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_ilist_detail_NodeAccess {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_llvm_ilist_detail_NodeAccess() {
    assert_eq!(
        ::std::mem::size_of::<llvm_ilist_detail_NodeAccess>(),
        1usize,
        concat!("Size of: ", stringify!(llvm_ilist_detail_NodeAccess))
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_ilist_detail_NodeAccess>(),
        1usize,
        concat!("Alignment of ", stringify!(llvm_ilist_detail_NodeAccess))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_ilist_detail_SpecificNodeAccess {
    pub _address: u8,
}
pub type llvm_ilist_detail_SpecificNodeAccess_pointer = [u8; 0usize];
pub type llvm_ilist_detail_SpecificNodeAccess_const_pointer = [u8; 0usize];
#[doc = " Implementation for an ilist node.\n\n Templated on an appropriate \\a ilist_detail::node_options, usually computed\n by \\a ilist_detail::compute_node_options.\n\n This is a wrapper around \\a ilist_node_base whose main purpose is to\n provide type safety: you can't insert nodes of \\a ilist_node_impl into the\n wrong \\a simple_ilist or \\a iplist."]
pub type llvm_ilist_detail_SpecificNodeAccess_node_type = llvm_ilist_node_impl;
#[doc = " Option to specify a tag for the node type.\n\n This option allows a single value type to be inserted in multiple lists\n simultaneously.  See \\a ilist_node for usage examples."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_ilist_tag {
    pub _address: u8,
}
#[doc = " Option to add a pointer to this list's owner in every node.\n\n This option causes the \\a ilist_base_node for this list to contain a pointer\n ParentTy *Parent, returned by \\a ilist_base_node::getNodeBaseParent() and\n set by \\a ilist_base_node::setNodeBaseParent(ParentTy *Parent). The parent\n value is not set automatically; the ilist owner should set itself as the\n parent of the list sentinel, and the parent should be set on each node\n inserted into the list. This value is also not used by\n \\a ilist_node_with_parent::getNodeParent(), but is used by \\a\n ilist_iterator::getNodeParent(), which allows the parent to be fetched from\n any valid (non-null) iterator to this list, including the sentinel."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_ilist_parent {
    pub _address: u8,
}
#[doc = " Iterator for intrusive lists  based on ilist_node."]
pub type llvm_ilist_select_iterator_type_type = u8;
#[doc = " Implementation for an ilist node.\n\n Templated on an appropriate \\a ilist_detail::node_options, usually computed\n by \\a ilist_detail::compute_node_options.\n\n This is a wrapper around \\a ilist_node_base whose main purpose is to\n provide type safety: you can't insert nodes of \\a ilist_node_impl into the\n wrong \\a simple_ilist or \\a iplist."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_ilist_node_impl {
    pub _address: u8,
}
pub type llvm_ilist_node_impl_value_type = [u8; 0usize];
pub type llvm_ilist_node_impl_node_base_type = [u8; 0usize];
pub type llvm_ilist_node_impl_list_base_type = [u8; 0usize];
pub type llvm_ilist_node_impl_self_iterator = u8;
pub type llvm_ilist_node_impl_const_self_iterator = u8;
pub type llvm_ilist_node_impl_reverse_self_iterator = u8;
pub type llvm_ilist_node_impl_const_reverse_self_iterator = u8;
#[doc = " An intrusive list node.\n\n A base class to enable membership in intrusive lists, including \\a\n simple_ilist, \\a iplist, and \\a ilist.  The first template parameter is the\n \\a value_type for the list.\n\n An ilist node can be configured with compile-time options to change\n behaviour and/or add API.\n\n By default, an \\a ilist_node knows whether it is the list sentinel (an\n instance of \\a ilist_sentinel) if and only if\n LLVM_ENABLE_ABI_BREAKING_CHECKS.  The function \\a isKnownSentinel() always\n returns \\c false tracking is off.  Sentinel tracking steals a bit from the\n \"prev\" link, which adds a mask operation when decrementing an iterator, but\n enables bug-finding assertions in \\a ilist_iterator.\n\n To turn sentinel tracking on all the time, pass in the\n ilist_sentinel_tracking<true> template parameter.  This also enables the \\a\n isSentinel() function.  The same option must be passed to the intrusive\n list.  (ilist_sentinel_tracking<false> turns sentinel tracking off all the\n time.)\n\n A type can inherit from ilist_node multiple times by passing in different\n \\a ilist_tag options.  This allows a single instance to be inserted into\n multiple lists simultaneously, where each list is given the same tag.\n\n \\example\n struct A {};\n struct B {};\n struct N : ilist_node<N, ilist_tag<A>>, ilist_node<N, ilist_tag<B>> {};\n\n void foo() {\n   simple_ilist<N, ilist_tag<A>> ListA;\n   simple_ilist<N, ilist_tag<B>> ListB;\n   N N1;\n   ListA.push_back(N1);\n   ListB.push_back(N1);\n }\n \\endexample\n\n When the \\a ilist_parent<ParentTy> option is passed to an ilist_node and the\n owning ilist, each node contains a pointer to the ilist's owner. This adds\n \\a getParent() and \\a setParent(ParentTy*) methods to the ilist_node, which\n will be used for node access by the ilist if the node class publicly\n inherits from \\a ilist_node_with_parent. By default, setParent() is not\n automatically called by the ilist; a SymbolTableList will call setParent()\n on inserted nodes, but the sentinel must still be manually set after the\n list is created (e.g. SymTabList.end()->setParent(Parent)).\n\n The primary benefit of using ilist_parent is that a parent\n pointer will be stored in the sentinel, meaning that you can safely use \\a\n ilist_iterator::getNodeParent() to get the node parent from any valid (i.e.\n non-null) iterator, even one that points to a sentinel value.\n\n See \\a is_valid_option for steps on adding a new option."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_ilist_node {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_ilist_sentinel {
    pub _address: u8,
}
#[doc = " An ilist node that can access its parent list.\n\n Requires \\c NodeTy to have \\a getParent() to find the parent node, and the\n \\c ParentTy to have \\a getSublistAccess() to get a reference to the list."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_ilist_node_with_parent {
    pub _address: u8,
}
#[doc = " A Use represents the edge between a Value definition and its users.\n\n This is notionally a two-dimensional linked list. It supports traversing\n all of the uses for a particular value definition. It also supports jumping\n directly to the used value when we arrive from the User's operands, and\n jumping directly to the User when we arrive from the Value's uses."]
#[repr(C)]
#[derive(Debug)]
pub struct llvm_Use {
    pub Val: *mut llvm_Value,
    pub Next: *mut llvm_Use,
    pub Prev: *mut *mut llvm_Use,
    pub Parent: *mut llvm_User,
}
#[test]
fn bindgen_test_layout_llvm_Use() {
    const UNINIT: ::std::mem::MaybeUninit<llvm_Use> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<llvm_Use>(),
        32usize,
        concat!("Size of: ", stringify!(llvm_Use))
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_Use>(),
        8usize,
        concat!("Alignment of ", stringify!(llvm_Use))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Val) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_Use),
            "::",
            stringify!(Val)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Next) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_Use),
            "::",
            stringify!(Next)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Prev) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_Use),
            "::",
            stringify!(Prev)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Parent) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_Use),
            "::",
            stringify!(Parent)
        )
    );
}
extern "C" {
    #[doc = " Provide a fast substitute to std::swap<Use>\n that also works with less standard-compliant compilers"]
    #[link_name = "\u{1}_ZN4llvm3Use4swapERS0_"]
    pub fn llvm_Use_swap(this: *mut llvm_Use, RHS: *mut llvm_Use);
}
extern "C" {
    #[doc = " Return the operand # of this use in its User."]
    #[link_name = "\u{1}_ZNK4llvm3Use12getOperandNoEv"]
    pub fn llvm_Use_getOperandNo(this: *const llvm_Use) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " Destroys Use operands when the number of operands of\n a User changes."]
    #[link_name = "\u{1}_ZN4llvm3Use3zapEPS0_PKS0_b"]
    pub fn llvm_Use_zap(Start: *mut llvm_Use, Stop: *const llvm_Use, del: bool);
}
impl llvm_Use {
    #[inline]
    pub unsafe fn swap(&mut self, RHS: *mut llvm_Use) {
        llvm_Use_swap(self, RHS)
    }
    #[inline]
    pub unsafe fn getOperandNo(&self) -> ::std::os::raw::c_uint {
        llvm_Use_getOperandNo(self)
    }
    #[inline]
    pub unsafe fn zap(Start: *mut llvm_Use, Stop: *const llvm_Use, del: bool) {
        llvm_Use_zap(Start, Stop, del)
    }
}
#[test]
fn __bindgen_test_layout_llvm_simplify_type_open0_llvm_Use_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<llvm_simplify_type>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_simplify_type)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_simplify_type>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_simplify_type)
        )
    );
}
#[test]
fn __bindgen_test_layout_llvm_simplify_type_open0_llvm_Use_close0_instantiation_1() {
    assert_eq!(
        ::std::mem::size_of::<llvm_simplify_type>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_simplify_type)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_simplify_type>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_simplify_type)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_ConstantData {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_ConstantAggregate {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_InlineAsm {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_ModuleSlotTracker {
    _unused: [u8; 0],
}
pub type llvm_ValueName = llvm_StringMapEntry<*mut llvm_Value>;
#[doc = " LLVM Value Representation\n\n This is a very important LLVM class. It is the base class of all values\n computed by a program that may be used as operands to other values. Value is\n the super class of other important classes such as Instruction and Function.\n All Values have a Type. Type is not a subclass of Value. Some values can\n have a name and they belong to some Module.  Setting the name on the Value\n automatically updates the module's symbol table.\n\n Every value has a \"use list\" that keeps track of which other Values are\n using this Value.  A Value can also have an arbitrary number of ValueHandle\n objects that watch it and listen to RAUW and Destroy events.  See\n llvm/IR/ValueHandle.h for details."]
#[repr(C)]
#[derive(Debug)]
pub struct llvm_Value {
    pub SubclassID: ::std::os::raw::c_uchar,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    #[doc = " Hold arbitrary subclass data.\n\n This member is defined by this class, but is not used for anything.\n Subclasses can use it to hold whatever state they find useful.  This\n field is initialized to zero by the ctor."]
    pub SubclassData: ::std::os::raw::c_ushort,
    pub _bitfield_align_2: [u32; 0],
    pub _bitfield_2: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub VTy: *mut llvm_Type,
    pub UseList: *mut llvm_Use,
}
pub const llvm_Value_NumUserOperandsBits: llvm_Value__bindgen_ty_1 = 27;
#[doc = " The number of operands in the subclass.\n\n This member is defined by this class, but not used for anything.\n Subclasses can use it to store their number of operands, if they have\n any.\n\n This is stored here to save space in User on 64-bit hosts.  Since most\n instances of Value have operands, 32-bit hosts aren't significantly\n affected.\n\n Note, this should *NOT* be used directly by any class other than User.\n User uses this value to find the Use list."]
pub type llvm_Value__bindgen_ty_1 = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_Value_use_iterator_impl<UseT> {
    pub U: *mut UseT,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<UseT>>,
}
pub type llvm_Value_use_iterator_impl_iterator_category = std_forward_iterator_tag;
pub type llvm_Value_use_iterator_impl_value_type<UseT> = *mut UseT;
pub type llvm_Value_use_iterator_impl_difference_type = isize;
pub type llvm_Value_use_iterator_impl_pointer<UseT> =
    *mut llvm_Value_use_iterator_impl_value_type<UseT>;
pub type llvm_Value_use_iterator_impl_reference<UseT> =
    *mut llvm_Value_use_iterator_impl_value_type<UseT>;
#[repr(C)]
#[derive(Debug)]
pub struct llvm_Value_user_iterator_impl {
    pub UI: llvm_Value_use_iterator_impl<llvm_Use>,
}
pub type llvm_Value_user_iterator_impl_iterator_category = std_forward_iterator_tag;
pub type llvm_Value_user_iterator_impl_value_type<UserTy> = *mut UserTy;
pub type llvm_Value_user_iterator_impl_difference_type = isize;
pub type llvm_Value_user_iterator_impl_pointer<UserTy> =
    *mut llvm_Value_user_iterator_impl_value_type<UserTy>;
pub type llvm_Value_user_iterator_impl_reference<UserTy> =
    *mut llvm_Value_user_iterator_impl_value_type<UserTy>;
pub const llvm_Value_ReplaceMetadataUses_No: llvm_Value_ReplaceMetadataUses = 0;
pub const llvm_Value_ReplaceMetadataUses_Yes: llvm_Value_ReplaceMetadataUses = 1;
pub type llvm_Value_ReplaceMetadataUses = ::std::os::raw::c_int;
pub type llvm_Value_use_iterator = llvm_Value_use_iterator_impl<llvm_Use>;
pub type llvm_Value_const_use_iterator = llvm_Value_use_iterator_impl<llvm_Use>;
pub type llvm_Value_user_iterator = llvm_Value_user_iterator_impl;
pub type llvm_Value_const_user_iterator = llvm_Value_user_iterator_impl;
pub const llvm_Value_ValueTy_FunctionVal: llvm_Value_ValueTy = 0;
pub const llvm_Value_ValueTy_GlobalAliasVal: llvm_Value_ValueTy = 1;
pub const llvm_Value_ValueTy_GlobalIFuncVal: llvm_Value_ValueTy = 2;
pub const llvm_Value_ValueTy_GlobalVariableVal: llvm_Value_ValueTy = 3;
pub const llvm_Value_ValueTy_BlockAddressVal: llvm_Value_ValueTy = 4;
pub const llvm_Value_ValueTy_ConstantExprVal: llvm_Value_ValueTy = 5;
pub const llvm_Value_ValueTy_DSOLocalEquivalentVal: llvm_Value_ValueTy = 6;
pub const llvm_Value_ValueTy_NoCFIValueVal: llvm_Value_ValueTy = 7;
pub const llvm_Value_ValueTy_ConstantPtrAuthVal: llvm_Value_ValueTy = 8;
pub const llvm_Value_ValueTy_ConstantArrayVal: llvm_Value_ValueTy = 9;
pub const llvm_Value_ValueTy_ConstantStructVal: llvm_Value_ValueTy = 10;
pub const llvm_Value_ValueTy_ConstantVectorVal: llvm_Value_ValueTy = 11;
pub const llvm_Value_ValueTy_UndefValueVal: llvm_Value_ValueTy = 12;
pub const llvm_Value_ValueTy_PoisonValueVal: llvm_Value_ValueTy = 13;
pub const llvm_Value_ValueTy_ConstantAggregateZeroVal: llvm_Value_ValueTy = 14;
pub const llvm_Value_ValueTy_ConstantDataArrayVal: llvm_Value_ValueTy = 15;
pub const llvm_Value_ValueTy_ConstantDataVectorVal: llvm_Value_ValueTy = 16;
pub const llvm_Value_ValueTy_ConstantIntVal: llvm_Value_ValueTy = 17;
pub const llvm_Value_ValueTy_ConstantFPVal: llvm_Value_ValueTy = 18;
pub const llvm_Value_ValueTy_ConstantTargetNoneVal: llvm_Value_ValueTy = 19;
pub const llvm_Value_ValueTy_ConstantPointerNullVal: llvm_Value_ValueTy = 20;
pub const llvm_Value_ValueTy_ConstantTokenNoneVal: llvm_Value_ValueTy = 21;
pub const llvm_Value_ValueTy_ArgumentVal: llvm_Value_ValueTy = 22;
pub const llvm_Value_ValueTy_BasicBlockVal: llvm_Value_ValueTy = 23;
pub const llvm_Value_ValueTy_MetadataAsValueVal: llvm_Value_ValueTy = 24;
pub const llvm_Value_ValueTy_InlineAsmVal: llvm_Value_ValueTy = 25;
pub const llvm_Value_ValueTy_MemoryUseVal: llvm_Value_ValueTy = 26;
pub const llvm_Value_ValueTy_MemoryDefVal: llvm_Value_ValueTy = 27;
pub const llvm_Value_ValueTy_MemoryPhiVal: llvm_Value_ValueTy = 28;
pub const llvm_Value_ValueTy_InstructionVal: llvm_Value_ValueTy = 29;
pub const llvm_Value_ValueTy_ConstantFirstVal: llvm_Value_ValueTy = 0;
pub const llvm_Value_ValueTy_ConstantLastVal: llvm_Value_ValueTy = 21;
pub const llvm_Value_ValueTy_ConstantDataFirstVal: llvm_Value_ValueTy = 12;
pub const llvm_Value_ValueTy_ConstantDataLastVal: llvm_Value_ValueTy = 21;
pub const llvm_Value_ValueTy_ConstantAggregateFirstVal: llvm_Value_ValueTy = 9;
pub const llvm_Value_ValueTy_ConstantAggregateLastVal: llvm_Value_ValueTy = 11;
#[doc = " Concrete subclass of this.\n\n An enumeration for keeping track of the concrete subclass of Value that\n is actually instantiated. Values of this enumeration are kept in the\n Value classes SubclassID field. They are used for concrete type\n identification."]
pub type llvm_Value_ValueTy = ::std::os::raw::c_uint;
#[doc = " The maximum alignment for instructions.\n\n This is the greatest alignment value supported by load, store, and alloca\n instructions, and global values."]
pub const llvm_Value_MaxAlignmentExponent: ::std::os::raw::c_uint = 32;
extern "C" {
    #[link_name = "\u{1}_ZN4llvm5Value16MaximumAlignmentE"]
    pub static llvm_Value_MaximumAlignment: u64;
}
#[test]
fn bindgen_test_layout_llvm_Value() {
    const UNINIT: ::std::mem::MaybeUninit<llvm_Value> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<llvm_Value>(),
        24usize,
        concat!("Size of: ", stringify!(llvm_Value))
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_Value>(),
        8usize,
        concat!("Alignment of ", stringify!(llvm_Value))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).SubclassID) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_Value),
            "::",
            stringify!(SubclassID)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).SubclassData) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_Value),
            "::",
            stringify!(SubclassData)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).VTy) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_Value),
            "::",
            stringify!(VTy)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).UseList) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_Value),
            "::",
            stringify!(UseList)
        )
    );
}
extern "C" {
    #[doc = " Delete a pointer to a generic Value."]
    #[link_name = "\u{1}_ZN4llvm5Value11deleteValueEv"]
    pub fn llvm_Value_deleteValue(this: *mut llvm_Value);
}
extern "C" {
    #[doc = " Support for debugging, callable in GDB: V->dump()"]
    #[link_name = "\u{1}_ZNK4llvm5Value4dumpEv"]
    pub fn llvm_Value_dump(this: *const llvm_Value);
}
extern "C" {
    #[doc = " Implement operator<< on Value.\n @{"]
    #[link_name = "\u{1}_ZNK4llvm5Value5printERNS_11raw_ostreamEb"]
    pub fn llvm_Value_print(this: *const llvm_Value, O: *mut llvm_raw_ostream, IsForDebug: bool);
}
extern "C" {
    #[link_name = "\u{1}_ZNK4llvm5Value5printERNS_11raw_ostreamERNS_17ModuleSlotTrackerEb"]
    pub fn llvm_Value_print1(
        this: *const llvm_Value,
        O: *mut llvm_raw_ostream,
        MST: *mut llvm_ModuleSlotTracker,
        IsForDebug: bool,
    );
}
extern "C" {
    #[doc = " Print the name of this Value out to the specified raw_ostream.\n\n This is useful when you just want to print 'int %reg126', not the\n instruction that generated it. If you specify a Module for context, then\n even constants get pretty-printed; for example, the type of a null\n pointer is printed symbolically.\n @{"]
    #[link_name = "\u{1}_ZNK4llvm5Value14printAsOperandERNS_11raw_ostreamEbPKNS_6ModuleE"]
    pub fn llvm_Value_printAsOperand(
        this: *const llvm_Value,
        O: *mut llvm_raw_ostream,
        PrintType: bool,
        M: *const llvm_Module,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK4llvm5Value14printAsOperandERNS_11raw_ostreamEbRNS_17ModuleSlotTrackerE"]
    pub fn llvm_Value_printAsOperand1(
        this: *const llvm_Value,
        O: *mut llvm_raw_ostream,
        PrintType: bool,
        MST: *mut llvm_ModuleSlotTracker,
    );
}
extern "C" {
    #[doc = " All values hold a context through their type."]
    #[link_name = "\u{1}_ZNK4llvm5Value10getContextEv"]
    pub fn llvm_Value_getContext(this: *const llvm_Value) -> *mut llvm_LLVMContext;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4llvm5Value12getValueNameEv"]
    pub fn llvm_Value_getValueName(this: *const llvm_Value) -> *mut llvm_ValueName;
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm5Value12setValueNameEPNS_14StringMapEntryIPS0_EE"]
    pub fn llvm_Value_setValueName(this: *mut llvm_Value, VN: *mut llvm_ValueName);
}
extern "C" {
    #[doc = " Return a constant reference to the value's name.\n\n This guaranteed to return the same reference as long as the value is not\n modified.  If the value has a name, this does a hashtable lookup, so it's\n not free."]
    #[link_name = "\u{1}_ZNK4llvm5Value7getNameEv"]
    pub fn llvm_Value_getName(this: *const llvm_Value) -> llvm_StringRef;
}
extern "C" {
    #[doc = " Change the name of the value.\n\n Choose a new unique name if the provided name is taken.\n\n \\param Name The new name; or \"\" if the value's name should be removed."]
    #[link_name = "\u{1}_ZN4llvm5Value7setNameERKNS_5TwineE"]
    pub fn llvm_Value_setName(this: *mut llvm_Value, Name: *const llvm_Twine);
}
extern "C" {
    #[doc = " Transfer the name from V to this value.\n\n After taking V's name, sets V's name to empty.\n\n \\note It is an error to call V->takeName(V)."]
    #[link_name = "\u{1}_ZN4llvm5Value8takeNameEPS0_"]
    pub fn llvm_Value_takeName(this: *mut llvm_Value, V: *mut llvm_Value);
}
extern "C" {
    #[link_name = "\u{1}_ZNK4llvm5Value18getNameOrAsOperandB5cxx11Ev"]
    pub fn llvm_Value_getNameOrAsOperand(this: *const llvm_Value) -> std_string;
}
extern "C" {
    #[doc = " Change all uses of this to point to a new Value.\n\n Go through the uses list for this definition and make each use point to\n \"V\" instead of \"this\".  After this completes, 'this's use list is\n guaranteed to be empty."]
    #[link_name = "\u{1}_ZN4llvm5Value18replaceAllUsesWithEPS0_"]
    pub fn llvm_Value_replaceAllUsesWith(this: *mut llvm_Value, V: *mut llvm_Value);
}
extern "C" {
    #[doc = " Change non-metadata uses of this to point to a new Value.\n\n Go through the uses list for this definition and make each use point to\n \"V\" instead of \"this\". This function skips metadata entries in the list."]
    #[link_name = "\u{1}_ZN4llvm5Value26replaceNonMetadataUsesWithEPS0_"]
    pub fn llvm_Value_replaceNonMetadataUsesWith(this: *mut llvm_Value, V: *mut llvm_Value);
}
extern "C" {
    #[doc = " Go through the uses list for this definition and make each use point\n to \"V\" if the callback ShouldReplace returns true for the given Use.\n Unlike replaceAllUsesWith() this function does not support basic block\n values."]
    #[link_name = "\u{1}_ZN4llvm5Value17replaceUsesWithIfEPS0_NS_12function_refIFbRNS_3UseEEEE"]
    pub fn llvm_Value_replaceUsesWithIf(
        this: *mut llvm_Value,
        New: *mut llvm_Value,
        ShouldReplace: llvm_function_ref,
    );
}
extern "C" {
    #[doc = " replaceUsesOutsideBlock - Go through the uses list for this definition and\n make each use point to \"V\" instead of \"this\" when the use is outside the\n block. 'This's use list is expected to have at least one element.\n Unlike replaceAllUsesWith() this function does not support basic block\n values."]
    #[link_name = "\u{1}_ZN4llvm5Value23replaceUsesOutsideBlockEPS0_PNS_10BasicBlockE"]
    pub fn llvm_Value_replaceUsesOutsideBlock(
        this: *mut llvm_Value,
        V: *mut llvm_Value,
        BB: *mut llvm_BasicBlock,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK4llvm5Value30assertModuleIsMaterializedImplEv"]
    pub fn llvm_Value_assertModuleIsMaterializedImpl(this: *const llvm_Value);
}
extern "C" {
    #[doc = " Return true if this Value has exactly N uses."]
    #[link_name = "\u{1}_ZNK4llvm5Value8hasNUsesEj"]
    pub fn llvm_Value_hasNUses(this: *const llvm_Value, N: ::std::os::raw::c_uint) -> bool;
}
extern "C" {
    #[doc = " Return true if this value has N uses or more.\n\n This is logically equivalent to getNumUses() >= N."]
    #[link_name = "\u{1}_ZNK4llvm5Value14hasNUsesOrMoreEj"]
    pub fn llvm_Value_hasNUsesOrMore(this: *const llvm_Value, N: ::std::os::raw::c_uint) -> bool;
}
extern "C" {
    #[doc = " Return true if there is exactly one user of this value.\n\n Note that this is not the same as \"has one use\". If a value has one use,\n then there certainly is a single user. But if value has several uses,\n it is possible that all uses are in a single user, or not.\n\n This check is potentially costly, since it requires traversing,\n in the worst case, the whole use list of a value."]
    #[link_name = "\u{1}_ZNK4llvm5Value10hasOneUserEv"]
    pub fn llvm_Value_hasOneUser(this: *const llvm_Value) -> bool;
}
extern "C" {
    #[doc = " Return true if there is exactly one use of this value that cannot be\n dropped."]
    #[link_name = "\u{1}_ZN4llvm5Value23getSingleUndroppableUseEv"]
    pub fn llvm_Value_getSingleUndroppableUse(this: *mut llvm_Value) -> *mut llvm_Use;
}
extern "C" {
    #[doc = " Return true if there is exactly one unique user of this value that cannot be\n dropped (that user can have multiple uses of this value)."]
    #[link_name = "\u{1}_ZN4llvm5Value24getUniqueUndroppableUserEv"]
    pub fn llvm_Value_getUniqueUndroppableUser(this: *mut llvm_Value) -> *mut llvm_User;
}
extern "C" {
    #[doc = " Return true if there this value.\n\n This is specialized because it is a common request and does not require\n traversing the whole use list."]
    #[link_name = "\u{1}_ZNK4llvm5Value19hasNUndroppableUsesEj"]
    pub fn llvm_Value_hasNUndroppableUses(
        this: *const llvm_Value,
        N: ::std::os::raw::c_uint,
    ) -> bool;
}
extern "C" {
    #[doc = " Return true if this value has N uses or more.\n\n This is logically equivalent to getNumUses() >= N."]
    #[link_name = "\u{1}_ZNK4llvm5Value25hasNUndroppableUsesOrMoreEj"]
    pub fn llvm_Value_hasNUndroppableUsesOrMore(
        this: *const llvm_Value,
        N: ::std::os::raw::c_uint,
    ) -> bool;
}
extern "C" {
    #[doc = " Remove every uses that can safely be removed.\n\n This will remove for example uses in llvm.assume.\n This should be used when performing want to perform a tranformation but\n some Droppable uses pervent it.\n This function optionally takes a filter to only remove some droppable\n uses."]
    #[link_name = "\u{1}_ZN4llvm5Value17dropDroppableUsesENS_12function_refIFbPKNS_3UseEEEE"]
    pub fn llvm_Value_dropDroppableUses(this: *mut llvm_Value, ShouldDrop: [u64; 2usize]);
}
extern "C" {
    #[doc = " Remove every use of this value in \\p User that can safely be removed."]
    #[link_name = "\u{1}_ZN4llvm5Value19dropDroppableUsesInERNS_4UserE"]
    pub fn llvm_Value_dropDroppableUsesIn(this: *mut llvm_Value, Usr: *mut llvm_User);
}
extern "C" {
    #[doc = " Remove the droppable use \\p U."]
    #[link_name = "\u{1}_ZN4llvm5Value16dropDroppableUseERNS_3UseE"]
    pub fn llvm_Value_dropDroppableUse(U: *mut llvm_Use);
}
extern "C" {
    #[doc = " Check if this value is used in the specified basic block."]
    #[link_name = "\u{1}_ZNK4llvm5Value18isUsedInBasicBlockEPKNS_10BasicBlockE"]
    pub fn llvm_Value_isUsedInBasicBlock(
        this: *const llvm_Value,
        BB: *const llvm_BasicBlock,
    ) -> bool;
}
extern "C" {
    #[doc = " This method computes the number of uses of this Value.\n\n This is a linear time operation.  Use hasOneUse, hasNUses, or\n hasNUsesOrMore to check for specific values."]
    #[link_name = "\u{1}_ZNK4llvm5Value10getNumUsesEv"]
    pub fn llvm_Value_getNumUses(this: *const llvm_Value) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4llvm5Value11getMetadataENS_9StringRefE"]
    pub fn llvm_Value_getMetadata(
        this: *const llvm_Value,
        Kind: llvm_StringRef,
    ) -> *mut llvm_MDNode;
}
extern "C" {
    #[doc = " Appends all attachments with the given ID to \\c MDs in insertion order.\n If the Value has no attachments with the given ID, or if ID is invalid,\n leaves MDs unchanged.\n @{"]
    #[link_name = "\u{1}_ZNK4llvm5Value11getMetadataEjRNS_15SmallVectorImplIPNS_6MDNodeEEE"]
    pub fn llvm_Value_getMetadata1(
        this: *const llvm_Value,
        KindID: ::std::os::raw::c_uint,
        MDs: *mut llvm_SmallVectorImpl,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK4llvm5Value11getMetadataENS_9StringRefERNS_15SmallVectorImplIPNS_6MDNodeEEE"]
    pub fn llvm_Value_getMetadata2(
        this: *const llvm_Value,
        Kind: llvm_StringRef,
        MDs: *mut llvm_SmallVectorImpl,
    );
}
extern "C" {
    #[doc = " Appends all metadata attached to this value to \\c MDs, sorting by\n KindID. The first element of each pair returned is the KindID, the second\n element is the metadata value. Attachments with the same ID appear in\n insertion order."]
    #[link_name = "\u{1}_ZNK4llvm5Value14getAllMetadataERNS_15SmallVectorImplISt4pairIjPNS_6MDNodeEEEE"]
    pub fn llvm_Value_getAllMetadata(this: *const llvm_Value, MDs: *mut llvm_SmallVectorImpl);
}
extern "C" {
    #[doc = " Set a particular kind of metadata attachment.\n\n Sets the given attachment to \\c MD, erasing it if \\c MD is \\c nullptr or\n replacing it if it already exists.\n @{"]
    #[link_name = "\u{1}_ZN4llvm5Value11setMetadataEjPNS_6MDNodeE"]
    pub fn llvm_Value_setMetadata(
        this: *mut llvm_Value,
        KindID: ::std::os::raw::c_uint,
        Node: *mut llvm_MDNode,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm5Value11setMetadataENS_9StringRefEPNS_6MDNodeE"]
    pub fn llvm_Value_setMetadata1(
        this: *mut llvm_Value,
        Kind: llvm_StringRef,
        Node: *mut llvm_MDNode,
    );
}
extern "C" {
    #[doc = " Add a metadata attachment.\n @{"]
    #[link_name = "\u{1}_ZN4llvm5Value11addMetadataEjRNS_6MDNodeE"]
    pub fn llvm_Value_addMetadata(
        this: *mut llvm_Value,
        KindID: ::std::os::raw::c_uint,
        MD: *mut llvm_MDNode,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm5Value11addMetadataENS_9StringRefERNS_6MDNodeE"]
    pub fn llvm_Value_addMetadata1(
        this: *mut llvm_Value,
        Kind: llvm_StringRef,
        MD: *mut llvm_MDNode,
    );
}
extern "C" {
    #[doc = " Erase all metadata attachments with the given kind.\n\n \\returns true if any metadata was removed."]
    #[link_name = "\u{1}_ZN4llvm5Value13eraseMetadataEj"]
    pub fn llvm_Value_eraseMetadata(this: *mut llvm_Value, KindID: ::std::os::raw::c_uint) -> bool;
}
extern "C" {
    #[doc = " Erase all metadata attachments matching the given predicate."]
    #[link_name = "\u{1}_ZN4llvm5Value15eraseMetadataIfENS_12function_refIFbjPNS_6MDNodeEEEE"]
    pub fn llvm_Value_eraseMetadataIf(this: *mut llvm_Value, Pred: llvm_function_ref);
}
extern "C" {
    #[doc = " Erase all metadata attached to this Value."]
    #[link_name = "\u{1}_ZN4llvm5Value13clearMetadataEv"]
    pub fn llvm_Value_clearMetadata(this: *mut llvm_Value);
}
extern "C" {
    #[doc = " Get metadata for the given kind, if any.\n This is an internal function that must only be called after\n checking that `hasMetadata()` returns true."]
    #[link_name = "\u{1}_ZNK4llvm5Value15getMetadataImplEj"]
    pub fn llvm_Value_getMetadataImpl(
        this: *const llvm_Value,
        KindID: ::std::os::raw::c_uint,
    ) -> *mut llvm_MDNode;
}
extern "C" {
    #[doc = " Return true if this value is a swifterror value.\n\n swifterror values can be either a function argument or an alloca with a\n swifterror attribute."]
    #[link_name = "\u{1}_ZNK4llvm5Value12isSwiftErrorEv"]
    pub fn llvm_Value_isSwiftError(this: *const llvm_Value) -> bool;
}
extern "C" {
    #[doc = " Strip off pointer casts, all-zero GEPs and address space casts.\n\n Returns the original uncasted value.  If this is called on a non-pointer\n value, it returns 'this'."]
    #[link_name = "\u{1}_ZNK4llvm5Value17stripPointerCastsEv"]
    pub fn llvm_Value_stripPointerCasts(this: *const llvm_Value) -> *const llvm_Value;
}
extern "C" {
    #[doc = " Strip off pointer casts, all-zero GEPs, address space casts, and aliases.\n\n Returns the original uncasted value.  If this is called on a non-pointer\n value, it returns 'this'."]
    #[link_name = "\u{1}_ZNK4llvm5Value27stripPointerCastsAndAliasesEv"]
    pub fn llvm_Value_stripPointerCastsAndAliases(this: *const llvm_Value) -> *const llvm_Value;
}
extern "C" {
    #[doc = " Strip off pointer casts, all-zero GEPs and address space casts\n but ensures the representation of the result stays the same.\n\n Returns the original uncasted value with the same representation. If this\n is called on a non-pointer value, it returns 'this'."]
    #[link_name = "\u{1}_ZNK4llvm5Value35stripPointerCastsSameRepresentationEv"]
    pub fn llvm_Value_stripPointerCastsSameRepresentation(
        this: *const llvm_Value,
    ) -> *const llvm_Value;
}
extern "C" {
    #[doc = " Strip off pointer casts, all-zero GEPs, single-argument phi nodes and\n invariant group info.\n\n Returns the original uncasted value.  If this is called on a non-pointer\n value, it returns 'this'. This function should be used only in\n Alias analysis."]
    #[link_name = "\u{1}_ZNK4llvm5Value33stripPointerCastsForAliasAnalysisEv"]
    pub fn llvm_Value_stripPointerCastsForAliasAnalysis(
        this: *const llvm_Value,
    ) -> *const llvm_Value;
}
extern "C" {
    #[doc = " Strip off pointer casts and all-constant inbounds GEPs.\n\n Returns the original pointer value.  If this is called on a non-pointer\n value, it returns 'this'."]
    #[link_name = "\u{1}_ZNK4llvm5Value28stripInBoundsConstantOffsetsEv"]
    pub fn llvm_Value_stripInBoundsConstantOffsets(this: *const llvm_Value) -> *const llvm_Value;
}
extern "C" {
    #[doc = " Accumulate the constant offset this value has compared to a base pointer.\n Only 'getelementptr' instructions (GEPs) are accumulated but other\n instructions, e.g., casts, are stripped away as well.\n The accumulated constant offset is added to \\p Offset and the base\n pointer is returned.\n\n The APInt \\p Offset has to have a bit-width equal to the IntPtr type for\n the address space of 'this' pointer value, e.g., use\n DataLayout::getIndexTypeSizeInBits(Ty).\n\n If \\p AllowNonInbounds is true, offsets in GEPs are stripped and\n accumulated even if the GEP is not \"inbounds\".\n\n If \\p AllowInvariantGroup is true then this method also looks through\n strip.invariant.group and launder.invariant.group intrinsics.\n\n If \\p ExternalAnalysis is provided it will be used to calculate a offset\n when a operand of GEP is not constant.\n For example, for a value \\p ExternalAnalysis might try to calculate a\n lower bound. If \\p ExternalAnalysis is successful, it should return true.\n\n If this is called on a non-pointer value, it returns 'this' and the\n \\p Offset is not modified.\n\n Note that this function will never return a nullptr. It will also never\n manipulate the \\p Offset in a way that would not match the difference\n between the underlying value and the returned one. Thus, if no constant\n offset was found, the returned value is the underlying one and \\p Offset\n is unchanged."]
    #[link_name = "\u{1}_ZNK4llvm5Value33stripAndAccumulateConstantOffsetsERKNS_10DataLayoutERNS_5APIntEbbNS_12function_refIFbRS0_S5_EEE"]
    pub fn llvm_Value_stripAndAccumulateConstantOffsets(
        this: *const llvm_Value,
        DL: *const llvm_DataLayout,
        Offset: *mut llvm_APInt,
        AllowNonInbounds: bool,
        AllowInvariantGroup: bool,
        ExternalAnalysis: [u64; 2usize],
    ) -> *const llvm_Value;
}
extern "C" {
    #[doc = " Strip off pointer casts and inbounds GEPs.\n\n Returns the original pointer value.  If this is called on a non-pointer\n value, it returns 'this'."]
    #[link_name = "\u{1}_ZNK4llvm5Value20stripInBoundsOffsetsENS_12function_refIFvPKS0_EEE"]
    pub fn llvm_Value_stripInBoundsOffsets(
        this: *const llvm_Value,
        Func: [u64; 2usize],
    ) -> *const llvm_Value;
}
extern "C" {
    #[doc = " If this ptr is provably equal to \\p Other plus a constant offset, return\n that offset in bytes. Essentially `ptr this` subtract `ptr Other`."]
    #[link_name = "\u{1}_ZNK4llvm5Value20getPointerOffsetFromEPKS0_RKNS_10DataLayoutE"]
    pub fn llvm_Value_getPointerOffsetFrom(
        this: *const llvm_Value,
        Other: *const llvm_Value,
        DL: *const llvm_DataLayout,
    ) -> std_optional;
}
extern "C" {
    #[doc = " Return true if the memory object referred to by V can by freed in the\n scope for which the SSA value defining the allocation is statically\n defined.  E.g.  deallocation after the static scope of a value does not\n count, but a deallocation before that does."]
    #[link_name = "\u{1}_ZNK4llvm5Value10canBeFreedEv"]
    pub fn llvm_Value_canBeFreed(this: *const llvm_Value) -> bool;
}
extern "C" {
    #[doc = " Returns the number of bytes known to be dereferenceable for the\n pointer value.\n\n If CanBeNull is set by this function the pointer can either be null or be\n dereferenceable up to the returned number of bytes.\n\n IF CanBeFreed is true, the pointer is known to be dereferenceable at\n point of definition only.  Caller must prove that allocation is not\n deallocated between point of definition and use."]
    #[link_name = "\u{1}_ZNK4llvm5Value30getPointerDereferenceableBytesERKNS_10DataLayoutERbS4_"]
    pub fn llvm_Value_getPointerDereferenceableBytes(
        this: *const llvm_Value,
        DL: *const llvm_DataLayout,
        CanBeNull: *mut bool,
        CanBeFreed: *mut bool,
    ) -> u64;
}
extern "C" {
    #[doc = " Returns an alignment of the pointer value.\n\n Returns an alignment which is either specified explicitly, e.g. via\n align attribute of a function argument, or guaranteed by DataLayout."]
    #[link_name = "\u{1}_ZNK4llvm5Value19getPointerAlignmentERKNS_10DataLayoutE"]
    pub fn llvm_Value_getPointerAlignment(
        this: *const llvm_Value,
        DL: *const llvm_DataLayout,
    ) -> llvm_Align;
}
extern "C" {
    #[doc = " Translate PHI node to its predecessor from the given basic block.\n\n If this value is a PHI node with CurBB as its parent, return the value in\n the PHI node corresponding to PredBB.  If not, return ourself.  This is\n useful if you want to know the value something has in a predecessor\n block."]
    #[link_name = "\u{1}_ZNK4llvm5Value16DoPHITranslationEPKNS_10BasicBlockES3_"]
    pub fn llvm_Value_DoPHITranslation(
        this: *const llvm_Value,
        CurBB: *const llvm_BasicBlock,
        PredBB: *const llvm_BasicBlock,
    ) -> *const llvm_Value;
}
extern "C" {
    #[doc = " Reverse the use-list."]
    #[link_name = "\u{1}_ZN4llvm5Value14reverseUseListEv"]
    pub fn llvm_Value_reverseUseList(this: *mut llvm_Value);
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm5ValueC1EPNS_4TypeEj"]
    pub fn llvm_Value_Value(
        this: *mut llvm_Value,
        Ty: *mut llvm_Type,
        scid: ::std::os::raw::c_uint,
    );
}
extern "C" {
    #[doc = " Value's destructor should be virtual by design, but that would require\n that Value and all of its subclasses have a vtable that effectively\n duplicates the information in the value ID. As a size optimization, the\n destructor has been protected, and the caller should manually call\n deleteValue."]
    #[link_name = "\u{1}_ZN4llvm5ValueD1Ev"]
    pub fn llvm_Value_Value_destructor(this: *mut llvm_Value);
}
impl llvm_Value {
    #[inline]
    pub fn HasValueHandle(&self) -> ::std::os::raw::c_uchar {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_HasValueHandle(&mut self, val: ::std::os::raw::c_uchar) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SubclassOptionalData(&self) -> ::std::os::raw::c_uchar {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 7u8) as u8) }
    }
    #[inline]
    pub fn set_SubclassOptionalData(&mut self, val: ::std::os::raw::c_uchar) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 7u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        HasValueHandle: ::std::os::raw::c_uchar,
        SubclassOptionalData: ::std::os::raw::c_uchar,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let HasValueHandle: u8 = unsafe { ::std::mem::transmute(HasValueHandle) };
            HasValueHandle as u64
        });
        __bindgen_bitfield_unit.set(1usize, 7u8, {
            let SubclassOptionalData: u8 = unsafe { ::std::mem::transmute(SubclassOptionalData) };
            SubclassOptionalData as u64
        });
        __bindgen_bitfield_unit
    }
    #[inline]
    pub fn NumUserOperands(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_2.get(0usize, 27u8) as u32) }
    }
    #[inline]
    pub fn set_NumUserOperands(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_2.set(0usize, 27u8, val as u64)
        }
    }
    #[inline]
    pub fn IsUsedByMD(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_2.get(27usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_IsUsedByMD(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_2.set(27usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn HasName(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_2.get(28usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_HasName(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_2.set(28usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn HasMetadata(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_2.get(29usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_HasMetadata(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_2.set(29usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn HasHungOffUses(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_2.get(30usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_HasHungOffUses(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_2.set(30usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn HasDescriptor(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_2.get(31usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_HasDescriptor(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_2.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_2(
        NumUserOperands: ::std::os::raw::c_uint,
        IsUsedByMD: ::std::os::raw::c_uint,
        HasName: ::std::os::raw::c_uint,
        HasMetadata: ::std::os::raw::c_uint,
        HasHungOffUses: ::std::os::raw::c_uint,
        HasDescriptor: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 27u8, {
            let NumUserOperands: u32 = unsafe { ::std::mem::transmute(NumUserOperands) };
            NumUserOperands as u64
        });
        __bindgen_bitfield_unit.set(27usize, 1u8, {
            let IsUsedByMD: u32 = unsafe { ::std::mem::transmute(IsUsedByMD) };
            IsUsedByMD as u64
        });
        __bindgen_bitfield_unit.set(28usize, 1u8, {
            let HasName: u32 = unsafe { ::std::mem::transmute(HasName) };
            HasName as u64
        });
        __bindgen_bitfield_unit.set(29usize, 1u8, {
            let HasMetadata: u32 = unsafe { ::std::mem::transmute(HasMetadata) };
            HasMetadata as u64
        });
        __bindgen_bitfield_unit.set(30usize, 1u8, {
            let HasHungOffUses: u32 = unsafe { ::std::mem::transmute(HasHungOffUses) };
            HasHungOffUses as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let HasDescriptor: u32 = unsafe { ::std::mem::transmute(HasDescriptor) };
            HasDescriptor as u64
        });
        __bindgen_bitfield_unit
    }
    #[inline]
    pub unsafe fn deleteValue(&mut self) {
        llvm_Value_deleteValue(self)
    }
    #[inline]
    pub unsafe fn dump(&self) {
        llvm_Value_dump(self)
    }
    #[inline]
    pub unsafe fn print(&self, O: *mut llvm_raw_ostream, IsForDebug: bool) {
        llvm_Value_print(self, O, IsForDebug)
    }
    #[inline]
    pub unsafe fn print1(
        &self,
        O: *mut llvm_raw_ostream,
        MST: *mut llvm_ModuleSlotTracker,
        IsForDebug: bool,
    ) {
        llvm_Value_print1(self, O, MST, IsForDebug)
    }
    #[inline]
    pub unsafe fn printAsOperand(
        &self,
        O: *mut llvm_raw_ostream,
        PrintType: bool,
        M: *const llvm_Module,
    ) {
        llvm_Value_printAsOperand(self, O, PrintType, M)
    }
    #[inline]
    pub unsafe fn printAsOperand1(
        &self,
        O: *mut llvm_raw_ostream,
        PrintType: bool,
        MST: *mut llvm_ModuleSlotTracker,
    ) {
        llvm_Value_printAsOperand1(self, O, PrintType, MST)
    }
    #[inline]
    pub unsafe fn getContext(&self) -> *mut llvm_LLVMContext {
        llvm_Value_getContext(self)
    }
    #[inline]
    pub unsafe fn getValueName(&self) -> *mut llvm_ValueName {
        llvm_Value_getValueName(self)
    }
    #[inline]
    pub unsafe fn setValueName(&mut self, VN: *mut llvm_ValueName) {
        llvm_Value_setValueName(self, VN)
    }
    #[inline]
    pub unsafe fn getName(&self) -> llvm_StringRef {
        llvm_Value_getName(self)
    }
    #[inline]
    pub unsafe fn setName(&mut self, Name: *const llvm_Twine) {
        llvm_Value_setName(self, Name)
    }
    #[inline]
    pub unsafe fn takeName(&mut self, V: *mut llvm_Value) {
        llvm_Value_takeName(self, V)
    }
    #[inline]
    pub unsafe fn getNameOrAsOperand(&self) -> std_string {
        llvm_Value_getNameOrAsOperand(self)
    }
    #[inline]
    pub unsafe fn replaceAllUsesWith(&mut self, V: *mut llvm_Value) {
        llvm_Value_replaceAllUsesWith(self, V)
    }
    #[inline]
    pub unsafe fn replaceNonMetadataUsesWith(&mut self, V: *mut llvm_Value) {
        llvm_Value_replaceNonMetadataUsesWith(self, V)
    }
    #[inline]
    pub unsafe fn replaceUsesWithIf(
        &mut self,
        New: *mut llvm_Value,
        ShouldReplace: llvm_function_ref,
    ) {
        llvm_Value_replaceUsesWithIf(self, New, ShouldReplace)
    }
    #[inline]
    pub unsafe fn replaceUsesOutsideBlock(&mut self, V: *mut llvm_Value, BB: *mut llvm_BasicBlock) {
        llvm_Value_replaceUsesOutsideBlock(self, V, BB)
    }
    #[inline]
    pub unsafe fn assertModuleIsMaterializedImpl(&self) {
        llvm_Value_assertModuleIsMaterializedImpl(self)
    }
    #[inline]
    pub unsafe fn hasNUses(&self, N: ::std::os::raw::c_uint) -> bool {
        llvm_Value_hasNUses(self, N)
    }
    #[inline]
    pub unsafe fn hasNUsesOrMore(&self, N: ::std::os::raw::c_uint) -> bool {
        llvm_Value_hasNUsesOrMore(self, N)
    }
    #[inline]
    pub unsafe fn hasOneUser(&self) -> bool {
        llvm_Value_hasOneUser(self)
    }
    #[inline]
    pub unsafe fn getSingleUndroppableUse(&mut self) -> *mut llvm_Use {
        llvm_Value_getSingleUndroppableUse(self)
    }
    #[inline]
    pub unsafe fn getUniqueUndroppableUser(&mut self) -> *mut llvm_User {
        llvm_Value_getUniqueUndroppableUser(self)
    }
    #[inline]
    pub unsafe fn hasNUndroppableUses(&self, N: ::std::os::raw::c_uint) -> bool {
        llvm_Value_hasNUndroppableUses(self, N)
    }
    #[inline]
    pub unsafe fn hasNUndroppableUsesOrMore(&self, N: ::std::os::raw::c_uint) -> bool {
        llvm_Value_hasNUndroppableUsesOrMore(self, N)
    }
    #[inline]
    pub unsafe fn dropDroppableUses(&mut self, ShouldDrop: [u64; 2usize]) {
        llvm_Value_dropDroppableUses(self, ShouldDrop)
    }
    #[inline]
    pub unsafe fn dropDroppableUsesIn(&mut self, Usr: *mut llvm_User) {
        llvm_Value_dropDroppableUsesIn(self, Usr)
    }
    #[inline]
    pub unsafe fn dropDroppableUse(U: *mut llvm_Use) {
        llvm_Value_dropDroppableUse(U)
    }
    #[inline]
    pub unsafe fn isUsedInBasicBlock(&self, BB: *const llvm_BasicBlock) -> bool {
        llvm_Value_isUsedInBasicBlock(self, BB)
    }
    #[inline]
    pub unsafe fn getNumUses(&self) -> ::std::os::raw::c_uint {
        llvm_Value_getNumUses(self)
    }
    #[inline]
    pub unsafe fn getMetadata(&self, Kind: llvm_StringRef) -> *mut llvm_MDNode {
        llvm_Value_getMetadata(self, Kind)
    }
    #[inline]
    pub unsafe fn getMetadata1(
        &self,
        KindID: ::std::os::raw::c_uint,
        MDs: *mut llvm_SmallVectorImpl,
    ) {
        llvm_Value_getMetadata1(self, KindID, MDs)
    }
    #[inline]
    pub unsafe fn getMetadata2(&self, Kind: llvm_StringRef, MDs: *mut llvm_SmallVectorImpl) {
        llvm_Value_getMetadata2(self, Kind, MDs)
    }
    #[inline]
    pub unsafe fn getAllMetadata(&self, MDs: *mut llvm_SmallVectorImpl) {
        llvm_Value_getAllMetadata(self, MDs)
    }
    #[inline]
    pub unsafe fn setMetadata(&mut self, KindID: ::std::os::raw::c_uint, Node: *mut llvm_MDNode) {
        llvm_Value_setMetadata(self, KindID, Node)
    }
    #[inline]
    pub unsafe fn setMetadata1(&mut self, Kind: llvm_StringRef, Node: *mut llvm_MDNode) {
        llvm_Value_setMetadata1(self, Kind, Node)
    }
    #[inline]
    pub unsafe fn addMetadata(&mut self, KindID: ::std::os::raw::c_uint, MD: *mut llvm_MDNode) {
        llvm_Value_addMetadata(self, KindID, MD)
    }
    #[inline]
    pub unsafe fn addMetadata1(&mut self, Kind: llvm_StringRef, MD: *mut llvm_MDNode) {
        llvm_Value_addMetadata1(self, Kind, MD)
    }
    #[inline]
    pub unsafe fn eraseMetadata(&mut self, KindID: ::std::os::raw::c_uint) -> bool {
        llvm_Value_eraseMetadata(self, KindID)
    }
    #[inline]
    pub unsafe fn eraseMetadataIf(&mut self, Pred: llvm_function_ref) {
        llvm_Value_eraseMetadataIf(self, Pred)
    }
    #[inline]
    pub unsafe fn clearMetadata(&mut self) {
        llvm_Value_clearMetadata(self)
    }
    #[inline]
    pub unsafe fn getMetadataImpl(&self, KindID: ::std::os::raw::c_uint) -> *mut llvm_MDNode {
        llvm_Value_getMetadataImpl(self, KindID)
    }
    #[inline]
    pub unsafe fn isSwiftError(&self) -> bool {
        llvm_Value_isSwiftError(self)
    }
    #[inline]
    pub unsafe fn stripPointerCasts(&self) -> *const llvm_Value {
        llvm_Value_stripPointerCasts(self)
    }
    #[inline]
    pub unsafe fn stripPointerCastsAndAliases(&self) -> *const llvm_Value {
        llvm_Value_stripPointerCastsAndAliases(self)
    }
    #[inline]
    pub unsafe fn stripPointerCastsSameRepresentation(&self) -> *const llvm_Value {
        llvm_Value_stripPointerCastsSameRepresentation(self)
    }
    #[inline]
    pub unsafe fn stripPointerCastsForAliasAnalysis(&self) -> *const llvm_Value {
        llvm_Value_stripPointerCastsForAliasAnalysis(self)
    }
    #[inline]
    pub unsafe fn stripInBoundsConstantOffsets(&self) -> *const llvm_Value {
        llvm_Value_stripInBoundsConstantOffsets(self)
    }
    #[inline]
    pub unsafe fn stripAndAccumulateConstantOffsets(
        &self,
        DL: *const llvm_DataLayout,
        Offset: *mut llvm_APInt,
        AllowNonInbounds: bool,
        AllowInvariantGroup: bool,
        ExternalAnalysis: [u64; 2usize],
    ) -> *const llvm_Value {
        llvm_Value_stripAndAccumulateConstantOffsets(
            self,
            DL,
            Offset,
            AllowNonInbounds,
            AllowInvariantGroup,
            ExternalAnalysis,
        )
    }
    #[inline]
    pub unsafe fn stripInBoundsOffsets(&self, Func: [u64; 2usize]) -> *const llvm_Value {
        llvm_Value_stripInBoundsOffsets(self, Func)
    }
    #[inline]
    pub unsafe fn getPointerOffsetFrom(
        &self,
        Other: *const llvm_Value,
        DL: *const llvm_DataLayout,
    ) -> std_optional {
        llvm_Value_getPointerOffsetFrom(self, Other, DL)
    }
    #[inline]
    pub unsafe fn canBeFreed(&self) -> bool {
        llvm_Value_canBeFreed(self)
    }
    #[inline]
    pub unsafe fn getPointerDereferenceableBytes(
        &self,
        DL: *const llvm_DataLayout,
        CanBeNull: *mut bool,
        CanBeFreed: *mut bool,
    ) -> u64 {
        llvm_Value_getPointerDereferenceableBytes(self, DL, CanBeNull, CanBeFreed)
    }
    #[inline]
    pub unsafe fn getPointerAlignment(&self, DL: *const llvm_DataLayout) -> llvm_Align {
        llvm_Value_getPointerAlignment(self, DL)
    }
    #[inline]
    pub unsafe fn DoPHITranslation(
        &self,
        CurBB: *const llvm_BasicBlock,
        PredBB: *const llvm_BasicBlock,
    ) -> *const llvm_Value {
        llvm_Value_DoPHITranslation(self, CurBB, PredBB)
    }
    #[inline]
    pub unsafe fn reverseUseList(&mut self) {
        llvm_Value_reverseUseList(self)
    }
    #[inline]
    pub unsafe fn new(Ty: *mut llvm_Type, scid: ::std::os::raw::c_uint) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        llvm_Value_Value(__bindgen_tmp.as_mut_ptr(), Ty, scid);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn destruct(&mut self) {
        llvm_Value_Value_destructor(self)
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_ValueDeleter {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_llvm_ValueDeleter() {
    assert_eq!(
        ::std::mem::size_of::<llvm_ValueDeleter>(),
        1usize,
        concat!("Size of: ", stringify!(llvm_ValueDeleter))
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_ValueDeleter>(),
        1usize,
        concat!("Alignment of ", stringify!(llvm_ValueDeleter))
    );
}
#[doc = " Use this instead of std::unique_ptr<Value> or std::unique_ptr<Instruction>.\n Those don't work because Value and Instruction's destructors are protected,\n aren't virtual, and won't destroy the complete object."]
pub type llvm_unique_value = std_unique_ptr;
#[test]
fn __bindgen_test_layout_llvm_isa_impl_open0_llvm_Constant_llvm_Value_void_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<llvm_isa_impl>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_isa_impl)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_isa_impl>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_isa_impl)
        )
    );
}
#[test]
fn __bindgen_test_layout_llvm_isa_impl_open0_llvm_ConstantData_llvm_Value_void_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<llvm_isa_impl>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_isa_impl)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_isa_impl>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_isa_impl)
        )
    );
}
#[test]
fn __bindgen_test_layout_llvm_isa_impl_open0_llvm_ConstantAggregate_llvm_Value_void_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<llvm_isa_impl>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_isa_impl)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_isa_impl>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_isa_impl)
        )
    );
}
#[test]
fn __bindgen_test_layout_llvm_isa_impl_open0_llvm_Argument_llvm_Value_void_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<llvm_isa_impl>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_isa_impl)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_isa_impl>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_isa_impl)
        )
    );
}
#[test]
fn __bindgen_test_layout_llvm_isa_impl_open0_llvm_InlineAsm_llvm_Value_void_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<llvm_isa_impl>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_isa_impl)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_isa_impl>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_isa_impl)
        )
    );
}
#[test]
fn __bindgen_test_layout_llvm_isa_impl_open0_llvm_Instruction_llvm_Value_void_close0_instantiation()
{
    assert_eq!(
        ::std::mem::size_of::<llvm_isa_impl>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_isa_impl)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_isa_impl>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_isa_impl)
        )
    );
}
#[test]
fn __bindgen_test_layout_llvm_isa_impl_open0_llvm_BasicBlock_llvm_Value_void_close0_instantiation()
{
    assert_eq!(
        ::std::mem::size_of::<llvm_isa_impl>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_isa_impl)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_isa_impl>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_isa_impl)
        )
    );
}
#[test]
fn __bindgen_test_layout_llvm_isa_impl_open0_llvm_Function_llvm_Value_void_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<llvm_isa_impl>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_isa_impl)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_isa_impl>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_isa_impl)
        )
    );
}
#[test]
fn __bindgen_test_layout_llvm_isa_impl_open0_llvm_GlobalVariable_llvm_Value_void_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<llvm_isa_impl>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_isa_impl)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_isa_impl>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_isa_impl)
        )
    );
}
#[test]
fn __bindgen_test_layout_llvm_isa_impl_open0_llvm_GlobalAlias_llvm_Value_void_close0_instantiation()
{
    assert_eq!(
        ::std::mem::size_of::<llvm_isa_impl>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_isa_impl)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_isa_impl>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_isa_impl)
        )
    );
}
#[test]
fn __bindgen_test_layout_llvm_isa_impl_open0_llvm_GlobalIFunc_llvm_Value_void_close0_instantiation()
{
    assert_eq!(
        ::std::mem::size_of::<llvm_isa_impl>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_isa_impl)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_isa_impl>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_isa_impl)
        )
    );
}
#[test]
fn __bindgen_test_layout_llvm_isa_impl_open0_llvm_GlobalValue_llvm_Value_void_close0_instantiation()
{
    assert_eq!(
        ::std::mem::size_of::<llvm_isa_impl>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_isa_impl)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_isa_impl>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_isa_impl)
        )
    );
}
#[test]
fn __bindgen_test_layout_llvm_isa_impl_open0_llvm_GlobalObject_llvm_Value_void_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<llvm_isa_impl>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_isa_impl)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_isa_impl>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_isa_impl)
        )
    );
}
#[doc = " This class represents an incoming formal argument to a Function. A formal\n argument, since it is ``formal'', does not contain an actual value but\n instead represents the type, argument number, and attributes of an argument\n for a specific function. When used in the body of said function, the\n argument of course represents the value of the actual argument that the\n function was called with."]
#[repr(C)]
#[derive(Debug)]
pub struct llvm_Argument {
    pub _base: llvm_Value,
    pub Parent: *mut llvm_Function,
    pub ArgNo: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_llvm_Argument() {
    const UNINIT: ::std::mem::MaybeUninit<llvm_Argument> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<llvm_Argument>(),
        40usize,
        concat!("Size of: ", stringify!(llvm_Argument))
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_Argument>(),
        8usize,
        concat!("Alignment of ", stringify!(llvm_Argument))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Parent) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_Argument),
            "::",
            stringify!(Parent)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ArgNo) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_Argument),
            "::",
            stringify!(ArgNo)
        )
    );
}
extern "C" {
    #[doc = " Return true if this argument has the nonnull attribute. Also returns true\n if at least one byte is known to be dereferenceable and the pointer is in\n addrspace(0).\n If AllowUndefOrPoison is true, respect the semantics of nonnull attribute\n and return true even if the argument can be undef or poison."]
    #[link_name = "\u{1}_ZNK4llvm8Argument14hasNonNullAttrEb"]
    pub fn llvm_Argument_hasNonNullAttr(
        this: *const llvm_Argument,
        AllowUndefOrPoison: bool,
    ) -> bool;
}
extern "C" {
    #[doc = " If this argument has the dereferenceable attribute, return the number of\n bytes known to be dereferenceable. Otherwise, zero is returned."]
    #[link_name = "\u{1}_ZNK4llvm8Argument23getDereferenceableBytesEv"]
    pub fn llvm_Argument_getDereferenceableBytes(this: *const llvm_Argument) -> u64;
}
extern "C" {
    #[doc = " If this argument has the dereferenceable_or_null attribute, return the\n number of bytes known to be dereferenceable. Otherwise, zero is returned."]
    #[link_name = "\u{1}_ZNK4llvm8Argument29getDereferenceableOrNullBytesEv"]
    pub fn llvm_Argument_getDereferenceableOrNullBytes(this: *const llvm_Argument) -> u64;
}
extern "C" {
    #[doc = " If this argument has nofpclass attribute, return the mask representing\n disallowed floating-point values. Otherwise, fcNone is returned."]
    #[link_name = "\u{1}_ZNK4llvm8Argument12getNoFPClassEv"]
    pub fn llvm_Argument_getNoFPClass(this: *const llvm_Argument) -> llvm_FPClassTest;
}
extern "C" {
    #[doc = " If this argument has a range attribute, return the value range of the\n argument. Otherwise, std::nullopt is returned."]
    #[link_name = "\u{1}_ZNK4llvm8Argument8getRangeEv"]
    pub fn llvm_Argument_getRange(this: *const llvm_Argument) -> std_optional;
}
extern "C" {
    #[doc = " Return true if this argument has the byval attribute."]
    #[link_name = "\u{1}_ZNK4llvm8Argument12hasByValAttrEv"]
    pub fn llvm_Argument_hasByValAttr(this: *const llvm_Argument) -> bool;
}
extern "C" {
    #[doc = " Return true if this argument has the byref attribute."]
    #[link_name = "\u{1}_ZNK4llvm8Argument12hasByRefAttrEv"]
    pub fn llvm_Argument_hasByRefAttr(this: *const llvm_Argument) -> bool;
}
extern "C" {
    #[doc = " Return true if this argument has the swiftself attribute."]
    #[link_name = "\u{1}_ZNK4llvm8Argument16hasSwiftSelfAttrEv"]
    pub fn llvm_Argument_hasSwiftSelfAttr(this: *const llvm_Argument) -> bool;
}
extern "C" {
    #[doc = " Return true if this argument has the swifterror attribute."]
    #[link_name = "\u{1}_ZNK4llvm8Argument17hasSwiftErrorAttrEv"]
    pub fn llvm_Argument_hasSwiftErrorAttr(this: *const llvm_Argument) -> bool;
}
extern "C" {
    #[doc = " Return true if this argument has the byval, inalloca, or preallocated\n attribute. These attributes represent arguments being passed by value,\n with an associated copy between the caller and callee"]
    #[link_name = "\u{1}_ZNK4llvm8Argument29hasPassPointeeByValueCopyAttrEv"]
    pub fn llvm_Argument_hasPassPointeeByValueCopyAttr(this: *const llvm_Argument) -> bool;
}
extern "C" {
    #[doc = " If this argument satisfies has hasPassPointeeByValueAttr, return the\n in-memory ABI size copied to the stack for the call. Otherwise, return 0."]
    #[link_name = "\u{1}_ZNK4llvm8Argument29getPassPointeeByValueCopySizeERKNS_10DataLayoutE"]
    pub fn llvm_Argument_getPassPointeeByValueCopySize(
        this: *const llvm_Argument,
        DL: *const llvm_DataLayout,
    ) -> u64;
}
extern "C" {
    #[doc = " Return true if this argument has the byval, sret, inalloca, preallocated,\n or byref attribute. These attributes represent arguments being passed by\n value (which may or may not involve a stack copy)"]
    #[link_name = "\u{1}_ZNK4llvm8Argument27hasPointeeInMemoryValueAttrEv"]
    pub fn llvm_Argument_hasPointeeInMemoryValueAttr(this: *const llvm_Argument) -> bool;
}
extern "C" {
    #[doc = " If hasPointeeInMemoryValueAttr returns true, the in-memory ABI type is\n returned. Otherwise, nullptr."]
    #[link_name = "\u{1}_ZNK4llvm8Argument27getPointeeInMemoryValueTypeEv"]
    pub fn llvm_Argument_getPointeeInMemoryValueType(this: *const llvm_Argument) -> *mut llvm_Type;
}
extern "C" {
    #[doc = " If this is a byval or inalloca argument, return its alignment.\n FIXME: Remove this function once transition to Align is over.\n Use getParamAlign() instead."]
    #[link_name = "\u{1}_ZNK4llvm8Argument17getParamAlignmentEv"]
    pub fn llvm_Argument_getParamAlignment(this: *const llvm_Argument) -> u64;
}
extern "C" {
    #[doc = " If this is a byval or inalloca argument, return its alignment."]
    #[link_name = "\u{1}_ZNK4llvm8Argument13getParamAlignEv"]
    pub fn llvm_Argument_getParamAlign(this: *const llvm_Argument) -> llvm_MaybeAlign;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4llvm8Argument18getParamStackAlignEv"]
    pub fn llvm_Argument_getParamStackAlign(this: *const llvm_Argument) -> llvm_MaybeAlign;
}
extern "C" {
    #[doc = " If this is a byval argument, return its type."]
    #[link_name = "\u{1}_ZNK4llvm8Argument17getParamByValTypeEv"]
    pub fn llvm_Argument_getParamByValType(this: *const llvm_Argument) -> *mut llvm_Type;
}
extern "C" {
    #[doc = " If this is an sret argument, return its type."]
    #[link_name = "\u{1}_ZNK4llvm8Argument21getParamStructRetTypeEv"]
    pub fn llvm_Argument_getParamStructRetType(this: *const llvm_Argument) -> *mut llvm_Type;
}
extern "C" {
    #[doc = " If this is a byref argument, return its type."]
    #[link_name = "\u{1}_ZNK4llvm8Argument17getParamByRefTypeEv"]
    pub fn llvm_Argument_getParamByRefType(this: *const llvm_Argument) -> *mut llvm_Type;
}
extern "C" {
    #[doc = " If this is an inalloca argument, return its type."]
    #[link_name = "\u{1}_ZNK4llvm8Argument20getParamInAllocaTypeEv"]
    pub fn llvm_Argument_getParamInAllocaType(this: *const llvm_Argument) -> *mut llvm_Type;
}
extern "C" {
    #[doc = " Return true if this argument has the nest attribute."]
    #[link_name = "\u{1}_ZNK4llvm8Argument11hasNestAttrEv"]
    pub fn llvm_Argument_hasNestAttr(this: *const llvm_Argument) -> bool;
}
extern "C" {
    #[doc = " Return true if this argument has the noalias attribute."]
    #[link_name = "\u{1}_ZNK4llvm8Argument14hasNoAliasAttrEv"]
    pub fn llvm_Argument_hasNoAliasAttr(this: *const llvm_Argument) -> bool;
}
extern "C" {
    #[doc = " Return true if this argument has the nocapture attribute."]
    #[link_name = "\u{1}_ZNK4llvm8Argument16hasNoCaptureAttrEv"]
    pub fn llvm_Argument_hasNoCaptureAttr(this: *const llvm_Argument) -> bool;
}
extern "C" {
    #[doc = " Return true if this argument has the nofree attribute."]
    #[link_name = "\u{1}_ZNK4llvm8Argument13hasNoFreeAttrEv"]
    pub fn llvm_Argument_hasNoFreeAttr(this: *const llvm_Argument) -> bool;
}
extern "C" {
    #[doc = " Return true if this argument has the sret attribute."]
    #[link_name = "\u{1}_ZNK4llvm8Argument16hasStructRetAttrEv"]
    pub fn llvm_Argument_hasStructRetAttr(this: *const llvm_Argument) -> bool;
}
extern "C" {
    #[doc = " Return true if this argument has the inreg attribute."]
    #[link_name = "\u{1}_ZNK4llvm8Argument12hasInRegAttrEv"]
    pub fn llvm_Argument_hasInRegAttr(this: *const llvm_Argument) -> bool;
}
extern "C" {
    #[doc = " Return true if this argument has the returned attribute."]
    #[link_name = "\u{1}_ZNK4llvm8Argument15hasReturnedAttrEv"]
    pub fn llvm_Argument_hasReturnedAttr(this: *const llvm_Argument) -> bool;
}
extern "C" {
    #[doc = " Return true if this argument has the readonly or readnone attribute."]
    #[link_name = "\u{1}_ZNK4llvm8Argument15onlyReadsMemoryEv"]
    pub fn llvm_Argument_onlyReadsMemory(this: *const llvm_Argument) -> bool;
}
extern "C" {
    #[doc = " Return true if this argument has the inalloca attribute."]
    #[link_name = "\u{1}_ZNK4llvm8Argument15hasInAllocaAttrEv"]
    pub fn llvm_Argument_hasInAllocaAttr(this: *const llvm_Argument) -> bool;
}
extern "C" {
    #[doc = " Return true if this argument has the preallocated attribute."]
    #[link_name = "\u{1}_ZNK4llvm8Argument19hasPreallocatedAttrEv"]
    pub fn llvm_Argument_hasPreallocatedAttr(this: *const llvm_Argument) -> bool;
}
extern "C" {
    #[doc = " Return true if this argument has the zext attribute."]
    #[link_name = "\u{1}_ZNK4llvm8Argument11hasZExtAttrEv"]
    pub fn llvm_Argument_hasZExtAttr(this: *const llvm_Argument) -> bool;
}
extern "C" {
    #[doc = " Return true if this argument has the sext attribute."]
    #[link_name = "\u{1}_ZNK4llvm8Argument11hasSExtAttrEv"]
    pub fn llvm_Argument_hasSExtAttr(this: *const llvm_Argument) -> bool;
}
extern "C" {
    #[doc = " Add attributes to an argument."]
    #[link_name = "\u{1}_ZN4llvm8Argument8addAttrsERNS_11AttrBuilderE"]
    pub fn llvm_Argument_addAttrs(this: *mut llvm_Argument, B: *mut llvm_AttrBuilder);
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm8Argument7addAttrENS_9Attribute8AttrKindE"]
    pub fn llvm_Argument_addAttr(this: *mut llvm_Argument, Kind: llvm_Attribute_AttrKind);
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm8Argument7addAttrENS_9AttributeE"]
    pub fn llvm_Argument_addAttr1(this: *mut llvm_Argument, Attr: llvm_Attribute);
}
extern "C" {
    #[doc = " Remove attributes from an argument."]
    #[link_name = "\u{1}_ZN4llvm8Argument10removeAttrENS_9Attribute8AttrKindE"]
    pub fn llvm_Argument_removeAttr(this: *mut llvm_Argument, Kind: llvm_Attribute_AttrKind);
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm8Argument11removeAttrsERKNS_13AttributeMaskE"]
    pub fn llvm_Argument_removeAttrs(this: *mut llvm_Argument, AM: *const llvm_AttributeMask);
}
extern "C" {
    #[doc = " Check if an argument has a given attribute."]
    #[link_name = "\u{1}_ZNK4llvm8Argument12hasAttributeENS_9Attribute8AttrKindE"]
    pub fn llvm_Argument_hasAttribute(
        this: *const llvm_Argument,
        Kind: llvm_Attribute_AttrKind,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4llvm8Argument12getAttributeENS_9Attribute8AttrKindE"]
    pub fn llvm_Argument_getAttribute(
        this: *const llvm_Argument,
        Kind: llvm_Attribute_AttrKind,
    ) -> llvm_Attribute;
}
extern "C" {
    #[doc = " Argument constructor."]
    #[link_name = "\u{1}_ZN4llvm8ArgumentC1EPNS_4TypeERKNS_5TwineEPNS_8FunctionEj"]
    pub fn llvm_Argument_Argument(
        this: *mut llvm_Argument,
        Ty: *mut llvm_Type,
        Name: *const llvm_Twine,
        F: *mut llvm_Function,
        ArgNo: ::std::os::raw::c_uint,
    );
}
impl llvm_Argument {
    #[inline]
    pub unsafe fn hasNonNullAttr(&self, AllowUndefOrPoison: bool) -> bool {
        llvm_Argument_hasNonNullAttr(self, AllowUndefOrPoison)
    }
    #[inline]
    pub unsafe fn getDereferenceableBytes(&self) -> u64 {
        llvm_Argument_getDereferenceableBytes(self)
    }
    #[inline]
    pub unsafe fn getDereferenceableOrNullBytes(&self) -> u64 {
        llvm_Argument_getDereferenceableOrNullBytes(self)
    }
    #[inline]
    pub unsafe fn getNoFPClass(&self) -> llvm_FPClassTest {
        llvm_Argument_getNoFPClass(self)
    }
    #[inline]
    pub unsafe fn getRange(&self) -> std_optional {
        llvm_Argument_getRange(self)
    }
    #[inline]
    pub unsafe fn hasByValAttr(&self) -> bool {
        llvm_Argument_hasByValAttr(self)
    }
    #[inline]
    pub unsafe fn hasByRefAttr(&self) -> bool {
        llvm_Argument_hasByRefAttr(self)
    }
    #[inline]
    pub unsafe fn hasSwiftSelfAttr(&self) -> bool {
        llvm_Argument_hasSwiftSelfAttr(self)
    }
    #[inline]
    pub unsafe fn hasSwiftErrorAttr(&self) -> bool {
        llvm_Argument_hasSwiftErrorAttr(self)
    }
    #[inline]
    pub unsafe fn hasPassPointeeByValueCopyAttr(&self) -> bool {
        llvm_Argument_hasPassPointeeByValueCopyAttr(self)
    }
    #[inline]
    pub unsafe fn getPassPointeeByValueCopySize(&self, DL: *const llvm_DataLayout) -> u64 {
        llvm_Argument_getPassPointeeByValueCopySize(self, DL)
    }
    #[inline]
    pub unsafe fn hasPointeeInMemoryValueAttr(&self) -> bool {
        llvm_Argument_hasPointeeInMemoryValueAttr(self)
    }
    #[inline]
    pub unsafe fn getPointeeInMemoryValueType(&self) -> *mut llvm_Type {
        llvm_Argument_getPointeeInMemoryValueType(self)
    }
    #[inline]
    pub unsafe fn getParamAlignment(&self) -> u64 {
        llvm_Argument_getParamAlignment(self)
    }
    #[inline]
    pub unsafe fn getParamAlign(&self) -> llvm_MaybeAlign {
        llvm_Argument_getParamAlign(self)
    }
    #[inline]
    pub unsafe fn getParamStackAlign(&self) -> llvm_MaybeAlign {
        llvm_Argument_getParamStackAlign(self)
    }
    #[inline]
    pub unsafe fn getParamByValType(&self) -> *mut llvm_Type {
        llvm_Argument_getParamByValType(self)
    }
    #[inline]
    pub unsafe fn getParamStructRetType(&self) -> *mut llvm_Type {
        llvm_Argument_getParamStructRetType(self)
    }
    #[inline]
    pub unsafe fn getParamByRefType(&self) -> *mut llvm_Type {
        llvm_Argument_getParamByRefType(self)
    }
    #[inline]
    pub unsafe fn getParamInAllocaType(&self) -> *mut llvm_Type {
        llvm_Argument_getParamInAllocaType(self)
    }
    #[inline]
    pub unsafe fn hasNestAttr(&self) -> bool {
        llvm_Argument_hasNestAttr(self)
    }
    #[inline]
    pub unsafe fn hasNoAliasAttr(&self) -> bool {
        llvm_Argument_hasNoAliasAttr(self)
    }
    #[inline]
    pub unsafe fn hasNoCaptureAttr(&self) -> bool {
        llvm_Argument_hasNoCaptureAttr(self)
    }
    #[inline]
    pub unsafe fn hasNoFreeAttr(&self) -> bool {
        llvm_Argument_hasNoFreeAttr(self)
    }
    #[inline]
    pub unsafe fn hasStructRetAttr(&self) -> bool {
        llvm_Argument_hasStructRetAttr(self)
    }
    #[inline]
    pub unsafe fn hasInRegAttr(&self) -> bool {
        llvm_Argument_hasInRegAttr(self)
    }
    #[inline]
    pub unsafe fn hasReturnedAttr(&self) -> bool {
        llvm_Argument_hasReturnedAttr(self)
    }
    #[inline]
    pub unsafe fn onlyReadsMemory(&self) -> bool {
        llvm_Argument_onlyReadsMemory(self)
    }
    #[inline]
    pub unsafe fn hasInAllocaAttr(&self) -> bool {
        llvm_Argument_hasInAllocaAttr(self)
    }
    #[inline]
    pub unsafe fn hasPreallocatedAttr(&self) -> bool {
        llvm_Argument_hasPreallocatedAttr(self)
    }
    #[inline]
    pub unsafe fn hasZExtAttr(&self) -> bool {
        llvm_Argument_hasZExtAttr(self)
    }
    #[inline]
    pub unsafe fn hasSExtAttr(&self) -> bool {
        llvm_Argument_hasSExtAttr(self)
    }
    #[inline]
    pub unsafe fn addAttrs(&mut self, B: *mut llvm_AttrBuilder) {
        llvm_Argument_addAttrs(self, B)
    }
    #[inline]
    pub unsafe fn addAttr(&mut self, Kind: llvm_Attribute_AttrKind) {
        llvm_Argument_addAttr(self, Kind)
    }
    #[inline]
    pub unsafe fn addAttr1(&mut self, Attr: llvm_Attribute) {
        llvm_Argument_addAttr1(self, Attr)
    }
    #[inline]
    pub unsafe fn removeAttr(&mut self, Kind: llvm_Attribute_AttrKind) {
        llvm_Argument_removeAttr(self, Kind)
    }
    #[inline]
    pub unsafe fn removeAttrs(&mut self, AM: *const llvm_AttributeMask) {
        llvm_Argument_removeAttrs(self, AM)
    }
    #[inline]
    pub unsafe fn hasAttribute(&self, Kind: llvm_Attribute_AttrKind) -> bool {
        llvm_Argument_hasAttribute(self, Kind)
    }
    #[inline]
    pub unsafe fn getAttribute(&self, Kind: llvm_Attribute_AttrKind) -> llvm_Attribute {
        llvm_Argument_getAttribute(self, Kind)
    }
    #[inline]
    pub unsafe fn new(
        Ty: *mut llvm_Type,
        Name: *const llvm_Twine,
        F: *mut llvm_Function,
        ArgNo: ::std::os::raw::c_uint,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        llvm_Argument_Argument(__bindgen_tmp.as_mut_ptr(), Ty, Name, F, ArgNo);
        __bindgen_tmp.assume_init()
    }
}
#[doc = " Base class for ilist nodes.\n\n Optionally tracks whether this node is the sentinel."]
pub type llvm_ilist_base_node_base_type = u8;
pub type llvm_ilist_iterator_Traits = u8;
pub type llvm_ilist_iterator_Access = llvm_ilist_detail_SpecificNodeAccess;
pub type llvm_ilist_iterator_value_type = llvm_ilist_iterator_Traits;
pub type llvm_ilist_iterator_pointer = llvm_ilist_iterator_Traits;
pub type llvm_ilist_iterator_reference = llvm_ilist_iterator_Traits;
pub type llvm_ilist_iterator_difference_type = isize;
pub type llvm_ilist_iterator_iterator_category = std_bidirectional_iterator_tag;
pub type llvm_ilist_iterator_const_pointer = [u8; 0usize];
pub type llvm_ilist_iterator_const_reference = [u8; 0usize];
pub type llvm_ilist_iterator_node_pointer = llvm_ilist_iterator_Traits;
pub type llvm_ilist_iterator_node_reference = llvm_ilist_iterator_Traits;
pub type llvm_ilist_iterator_w_bits_Traits = u8;
pub type llvm_ilist_iterator_w_bits_Access = llvm_ilist_detail_SpecificNodeAccess;
pub type llvm_ilist_iterator_w_bits_value_type = llvm_ilist_iterator_w_bits_Traits;
pub type llvm_ilist_iterator_w_bits_pointer = llvm_ilist_iterator_w_bits_Traits;
pub type llvm_ilist_iterator_w_bits_reference = llvm_ilist_iterator_w_bits_Traits;
pub type llvm_ilist_iterator_w_bits_difference_type = isize;
pub type llvm_ilist_iterator_w_bits_iterator_category = std_bidirectional_iterator_tag;
pub type llvm_ilist_iterator_w_bits_const_pointer = [u8; 0usize];
pub type llvm_ilist_iterator_w_bits_const_reference = [u8; 0usize];
pub type llvm_ilist_iterator_w_bits_node_pointer = llvm_ilist_iterator_w_bits_Traits;
pub type llvm_ilist_iterator_w_bits_node_reference = llvm_ilist_iterator_w_bits_Traits;
#[doc = " A simple intrusive list implementation.\n\n This is a simple intrusive list for a \\c T that inherits from \\c\n ilist_node<T>.  The list never takes ownership of anything inserted in it.\n\n Unlike \\a iplist<T> and \\a ilist<T>, \\a simple_ilist<T> never deletes\n values, and has no callback traits.\n\n The API for adding nodes include \\a push_front(), \\a push_back(), and \\a\n insert().  These all take values by reference (not by pointer), except for\n the range version of \\a insert().\n\n There are three sets of API for discarding nodes from the list: \\a\n remove(), which takes a reference to the node to remove, \\a erase(), which\n takes an iterator or iterator range and returns the next one, and \\a\n clear(), which empties out the container.  All three are constant time\n operations.  None of these deletes any nodes; in particular, if there is a\n single node in the list, then these have identical semantics:\n \\li \\c L.remove(L.front());\n \\li \\c L.erase(L.begin());\n \\li \\c L.clear();\n\n As a convenience for callers, there are parallel APIs that take a \\c\n Disposer (such as \\c std::default_delete<T>): \\a removeAndDispose(), \\a\n eraseAndDispose(), and \\a clearAndDispose().  These have different names\n because the extra semantic is otherwise non-obvious.  They are equivalent\n to calling \\a std::for_each() on the range to be discarded.\n\n The currently available \\p Options customize the nodes in the list.  The\n same options must be specified in the \\a ilist_node instantiation for\n compatibility (although the order is irrelevant).\n \\li Use \\a ilist_tag to designate which ilist_node for a given \\p T this\n list should use.  This is useful if a type \\p T is part of multiple,\n independent lists simultaneously.\n \\li Use \\a ilist_sentinel_tracking to always (or never) track whether a\n node is a sentinel.  Specifying \\c true enables the \\a\n ilist_node::isSentinel() API.  Unlike \\a ilist_node::isKnownSentinel(),\n which is only appropriate for assertions, \\a ilist_node::isSentinel() is\n appropriate for real logic.\n\n Here are examples of \\p Options usage:\n \\li \\c simple_ilist<T> gives the defaults.  \\li \\c\n simple_ilist<T,ilist_sentinel_tracking<true>> enables the \\a\n ilist_node::isSentinel() API.\n \\li \\c simple_ilist<T,ilist_tag<A>,ilist_sentinel_tracking<false>>\n specifies a tag of A and that tracking should be off (even when\n LLVM_ENABLE_ABI_BREAKING_CHECKS are enabled).\n \\li \\c simple_ilist<T,ilist_sentinel_tracking<false>,ilist_tag<A>> is\n equivalent to the last.\n\n See \\a is_valid_option for steps on adding a new option."]
#[repr(C)]
#[derive(Debug)]
pub struct llvm_simple_ilist {
    pub Sentinel: llvm_ilist_sentinel,
}
pub type llvm_simple_ilist_OptionsT = llvm_ilist_detail_compute_node_options;
pub type llvm_simple_ilist_list_base_type = llvm_simple_ilist_OptionsT;
pub type llvm_simple_ilist_value_type = llvm_simple_ilist_OptionsT;
pub type llvm_simple_ilist_pointer = llvm_simple_ilist_OptionsT;
pub type llvm_simple_ilist_reference = llvm_simple_ilist_OptionsT;
pub type llvm_simple_ilist_const_pointer = llvm_simple_ilist_OptionsT;
pub type llvm_simple_ilist_const_reference = llvm_simple_ilist_OptionsT;
pub type llvm_simple_ilist_iterator = u8;
pub type llvm_simple_ilist_const_iterator = u8;
pub type llvm_simple_ilist_reverse_iterator = u8;
pub type llvm_simple_ilist_const_reverse_iterator = u8;
pub type llvm_simple_ilist_size_type = usize;
pub type llvm_simple_ilist_difference_type = isize;
#[doc = " Use delete by default for iplist and ilist.\n\n Specialize this to get different behaviour for ownership-related API.  (If\n you really want ownership semantics, consider using std::list or building\n something like \\a BumpPtrList.)\n\n \\see ilist_noalloc_traits"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_ilist_alloc_traits {
    pub _address: u8,
}
#[doc = " Custom traits to do nothing on deletion.\n\n Specialize ilist_alloc_traits to inherit from this to disable the\n non-intrusive deletion in iplist (which implies ownership).\n\n If you want purely intrusive semantics with no callbacks, consider using \\a\n simple_ilist instead.\n\n \\code\n template <>\n struct ilist_alloc_traits<MyType> : ilist_noalloc_traits<MyType> {};\n \\endcode"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_ilist_noalloc_traits {
    pub _address: u8,
}
#[doc = " Callbacks do nothing by default in iplist and ilist.\n\n Specialize this for to use callbacks for when nodes change their list\n membership."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_ilist_callback_traits {
    pub _address: u8,
}
#[doc = " A fragment for template traits for intrusive list that provides default\n node related operations.\n\n TODO: Remove this layer of indirection.  It's not necessary."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_ilist_node_traits {
    pub _address: u8,
}
#[doc = " Template traits for intrusive list.\n\n Customize callbacks and allocation semantics."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_ilist_traits {
    pub _address: u8,
}
#[doc = " A wrapper around an intrusive list with callbacks and non-intrusive\n ownership.\n\n This wraps a purely intrusive list (like simple_ilist) with a configurable\n traits class.  The traits can implement callbacks and customize the\n ownership semantics.\n\n This is a subset of ilist functionality that can safely be used on nodes of\n polymorphic types, i.e. a heterogeneous list with a common base class that\n holds the next/prev pointers.  The only state of the list itself is an\n ilist_sentinel, which holds pointers to the first and last nodes in the\n list."]
#[repr(C)]
#[derive(Debug)]
pub struct llvm_iplist_impl<IntrusiveListT, TraitsT> {
    pub _base: TraitsT,
    pub _base_1: IntrusiveListT,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<IntrusiveListT>>,
    pub _phantom_1: ::std::marker::PhantomData<::std::cell::UnsafeCell<TraitsT>>,
}
pub type llvm_iplist_impl_base_list_type<IntrusiveListT> = IntrusiveListT;
pub type llvm_iplist_impl_pointer = [u8; 0usize];
pub type llvm_iplist_impl_const_pointer = [u8; 0usize];
pub type llvm_iplist_impl_reference = [u8; 0usize];
pub type llvm_iplist_impl_const_reference = [u8; 0usize];
pub type llvm_iplist_impl_value_type = [u8; 0usize];
pub type llvm_iplist_impl_size_type = [u8; 0usize];
pub type llvm_iplist_impl_difference_type = [u8; 0usize];
pub type llvm_iplist_impl_iterator = [u8; 0usize];
pub type llvm_iplist_impl_const_iterator = [u8; 0usize];
pub type llvm_iplist_impl_reverse_iterator = [u8; 0usize];
pub type llvm_iplist_impl_const_reverse_iterator = [u8; 0usize];
#[doc = " An intrusive list with ownership and callbacks specified/controlled by\n ilist_traits, only with API safe for polymorphic types.\n\n The \\p Options parameters are the same as those for \\a simple_ilist.  See\n there for a description of what's available."]
#[repr(C)]
#[derive(Debug)]
pub struct llvm_iplist {
    pub _base: llvm_iplist_impl<llvm_simple_ilist, llvm_ilist_traits>,
}
pub type llvm_iplist_iplist_impl_type = llvm_iplist;
pub type llvm_ilist = llvm_iplist;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_DbgVariableFragmentInfo {
    pub SizeInBits: u64,
    pub OffsetInBits: u64,
}
#[test]
fn bindgen_test_layout_llvm_DbgVariableFragmentInfo() {
    const UNINIT: ::std::mem::MaybeUninit<llvm_DbgVariableFragmentInfo> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<llvm_DbgVariableFragmentInfo>(),
        16usize,
        concat!("Size of: ", stringify!(llvm_DbgVariableFragmentInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_DbgVariableFragmentInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(llvm_DbgVariableFragmentInfo))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).SizeInBits) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_DbgVariableFragmentInfo),
            "::",
            stringify!(SizeInBits)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).OffsetInBits) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_DbgVariableFragmentInfo),
            "::",
            stringify!(OffsetInBits)
        )
    );
}
#[doc = " Find the first type in a list of types."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_pointer_union_detail_GetFirstType {
    pub _address: u8,
}
pub type llvm_pointer_union_detail_GetFirstType_type<T> = T;
#[doc = " Provide PointerLikeTypeTraits for void* that is used by PointerUnion\n for the template arguments."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_pointer_union_detail_PointerUnionUIntTraits {
    pub _address: u8,
}
#[doc = " A discriminated union of two or more pointer types, with the discriminator\n in the low bit of the pointer.\n\n This implementation is extremely efficient in space due to leveraging the\n low bits of the pointer, while exposing a natural and type-safe API.\n\n Common use patterns would be something like this:\n    PointerUnion<int*, float*> P;\n    P = (int*)0;\n    printf(\"%d %d\", P.is<int*>(), P.is<float*>());  // prints \"1 0\"\n    X = P.get<int*>();     // ok.\n    Y = P.get<float*>();   // runtime assertion failure.\n    Z = P.get<double*>();  // compile time failure.\n    P = (float*)0;\n    Y = P.get<float*>();   // ok.\n    X = P.get<int*>();     // runtime assertion failure.\n    PointerUnion<int*, int*> Q; // compile time failure."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_PointerUnion {
    pub _address: u8,
}
pub type llvm_PointerUnion_First = llvm_TypeAtIndex;
pub type llvm_PointerUnion_Base = llvm_PointerUnion;
#[doc = " We can't (at least, at this moment with C++14) declare CastInfo\n as a friend of PointerUnion like this:\n ```\n   template<typename To>\n   friend struct CastInfo<To, PointerUnion<PTs...>>;\n ```\n The compiler complains 'Partial specialization cannot be declared as a\n friend'.\n So we define this struct to be a bridge between CastInfo and\n PointerUnion."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_CastInfoPointerUnionImpl {
    pub _address: u8,
}
#[doc = " A discriminated union of two or more pointer types, with the discriminator\n in the low bit of the pointer.\n\n This implementation is extremely efficient in space due to leveraging the\n low bits of the pointer, while exposing a natural and type-safe API.\n\n Common use patterns would be something like this:\n    PointerUnion<int*, float*> P;\n    P = (int*)0;\n    printf(\"%d %d\", P.is<int*>(), P.is<float*>());  // prints \"1 0\"\n    X = P.get<int*>();     // ok.\n    Y = P.get<float*>();   // runtime assertion failure.\n    Z = P.get<double*>();  // compile time failure.\n    P = (float*)0;\n    Y = P.get<float*>();   // ok.\n    X = P.get<int*>();     // runtime assertion failure.\n    PointerUnion<int*, int*> Q; // compile time failure."]
pub type llvm_CastInfoPointerUnionImpl_From = llvm_PointerUnion;
#[doc = " Compile-time customization of User operands.\n\n Customizes operand-related allocators and accessors."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_OperandTraits {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug)]
pub struct llvm_User {
    pub _base: llvm_Value,
}
pub type llvm_User_op_iterator = *mut llvm_Use;
pub type llvm_User_const_op_iterator = *const llvm_Use;
#[doc = " A range adaptor for a pair of iterators.\n\n This just wraps two iterators into a range-compatible interface. Nothing\n fancy at all."]
pub type llvm_User_op_range = llvm_iterator_range<llvm_User_op_iterator>;
#[doc = " A range adaptor for a pair of iterators.\n\n This just wraps two iterators into a range-compatible interface. Nothing\n fancy at all."]
pub type llvm_User_const_op_range = llvm_iterator_range<llvm_User_const_op_iterator>;
#[doc = " Iterator for directly iterating over the operand Values."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_User_value_op_iterator {
    pub _base: llvm_iterator_adaptor_base<llvm_User_op_iterator>,
}
#[test]
fn bindgen_test_layout_llvm_User_value_op_iterator() {
    assert_eq!(
        ::std::mem::size_of::<llvm_User_value_op_iterator>(),
        8usize,
        concat!("Size of: ", stringify!(llvm_User_value_op_iterator))
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_User_value_op_iterator>(),
        8usize,
        concat!("Alignment of ", stringify!(llvm_User_value_op_iterator))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_User_const_value_op_iterator {
    pub _base: llvm_iterator_adaptor_base<llvm_User_const_op_iterator>,
}
#[test]
fn bindgen_test_layout_llvm_User_const_value_op_iterator() {
    assert_eq!(
        ::std::mem::size_of::<llvm_User_const_value_op_iterator>(),
        8usize,
        concat!("Size of: ", stringify!(llvm_User_const_value_op_iterator))
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_User_const_value_op_iterator>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(llvm_User_const_value_op_iterator)
        )
    );
}
#[test]
fn bindgen_test_layout_llvm_User() {
    assert_eq!(
        ::std::mem::size_of::<llvm_User>(),
        24usize,
        concat!("Size of: ", stringify!(llvm_User))
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_User>(),
        8usize,
        concat!("Alignment of ", stringify!(llvm_User))
    );
}
extern "C" {
    #[doc = " Allocate the array of Uses, followed by a pointer\n (with bottom bit set) to the User.\n \\param IsPhi identifies callers which are phi nodes and which need\n N BasicBlock* allocated along with N"]
    #[link_name = "\u{1}_ZN4llvm4User16allocHungoffUsesEjb"]
    pub fn llvm_User_allocHungoffUses(this: *mut llvm_User, N: ::std::os::raw::c_uint, IsPhi: bool);
}
extern "C" {
    #[doc = " Grow the number of hung off uses.  Note that allocHungoffUses\n should be called if there are no uses."]
    #[link_name = "\u{1}_ZN4llvm4User15growHungoffUsesEjb"]
    pub fn llvm_User_growHungoffUses(this: *mut llvm_User, N: ::std::os::raw::c_uint, IsPhi: bool);
}
extern "C" {
    #[doc = " Returns the descriptor co-allocated with this User instance."]
    #[link_name = "\u{1}_ZNK4llvm4User13getDescriptorEv"]
    pub fn llvm_User_getDescriptor(this: *const llvm_User) -> llvm_ArrayRef<u8>;
}
extern "C" {
    #[doc = " Returns the descriptor co-allocated with this User instance."]
    #[link_name = "\u{1}_ZN4llvm4User13getDescriptorEv"]
    pub fn llvm_User_getDescriptor1(this: *mut llvm_User) -> llvm_MutableArrayRef<u8>;
}
extern "C" {
    #[doc = " A droppable user is a user for which uses can be dropped without affecting\n correctness and should be dropped rather than preventing a transformation\n from happening."]
    #[link_name = "\u{1}_ZNK4llvm4User11isDroppableEv"]
    pub fn llvm_User_isDroppable(this: *const llvm_User) -> bool;
}
extern "C" {
    #[doc = " Replace uses of one Value with another.\n\n Replaces all references to the \"From\" definition with references to the\n \"To\" definition. Returns whether any uses were replaced."]
    #[link_name = "\u{1}_ZN4llvm4User17replaceUsesOfWithEPNS_5ValueES2_"]
    pub fn llvm_User_replaceUsesOfWith(
        this: *mut llvm_User,
        From: *mut llvm_Value,
        To: *mut llvm_Value,
    ) -> bool;
}
impl llvm_User {
    #[inline]
    pub unsafe fn allocHungoffUses(&mut self, N: ::std::os::raw::c_uint, IsPhi: bool) {
        llvm_User_allocHungoffUses(self, N, IsPhi)
    }
    #[inline]
    pub unsafe fn growHungoffUses(&mut self, N: ::std::os::raw::c_uint, IsPhi: bool) {
        llvm_User_growHungoffUses(self, N, IsPhi)
    }
    #[inline]
    pub unsafe fn getDescriptor(&self) -> llvm_ArrayRef<u8> {
        llvm_User_getDescriptor(self)
    }
    #[inline]
    pub unsafe fn getDescriptor1(&mut self) -> llvm_MutableArrayRef<u8> {
        llvm_User_getDescriptor1(self)
    }
    #[inline]
    pub unsafe fn isDroppable(&self) -> bool {
        llvm_User_isDroppable(self)
    }
    #[inline]
    pub unsafe fn replaceUsesOfWith(&mut self, From: *mut llvm_Value, To: *mut llvm_Value) -> bool {
        llvm_User_replaceUsesOfWith(self, From, To)
    }
}
#[test]
fn __bindgen_test_layout_llvm_simplify_type_open0_ptr_Use_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<llvm_simplify_type>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_simplify_type)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_simplify_type>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_simplify_type)
        )
    );
}
#[test]
fn __bindgen_test_layout_llvm_simplify_type_open0_ptr_const_llvm__Use_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<llvm_simplify_type>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_simplify_type)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_simplify_type>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_simplify_type)
        )
    );
}
#[doc = " This is an important base class in LLVM. It provides the common facilities\n of all constant values in an LLVM program. A constant is a value that is\n immutable at runtime. Functions are constants because their address is\n immutable. Same with global variables.\n\n All constants share the capabilities provided in this class. All constants\n can have a null value. They can have an operand list. Constants can be\n simple (integer and floating point values), complex (arrays and structures),\n or expression based (computations yielding a constant value composed of\n only certain operators and other constant values).\n\n Note that Constants are immutable (once created they never change)\n and are fully shared by structural equivalence.  This means that two\n structurally equivalent constants will always have the same address.\n Constants are created on demand as needed and never deleted: thus clients\n don't have to worry about the lifetime of the objects.\n LLVM Constant Representation"]
#[repr(C)]
#[derive(Debug)]
pub struct llvm_Constant {
    pub _base: llvm_User,
}
#[doc = " This constant requires no relocations. That is, it holds simple\n constants (like integrals)."]
pub const llvm_Constant_PossibleRelocationsTy_NoRelocation: llvm_Constant_PossibleRelocationsTy = 0;
#[doc = " This constant holds static relocations that can be resolved by the\n static linker."]
pub const llvm_Constant_PossibleRelocationsTy_LocalRelocation: llvm_Constant_PossibleRelocationsTy =
    1;
#[doc = " This constant holds dynamic relocations that the dynamic linker will\n need to resolve."]
pub const llvm_Constant_PossibleRelocationsTy_GlobalRelocation:
    llvm_Constant_PossibleRelocationsTy = 2;
pub type llvm_Constant_PossibleRelocationsTy = ::std::os::raw::c_uint;
#[test]
fn bindgen_test_layout_llvm_Constant() {
    assert_eq!(
        ::std::mem::size_of::<llvm_Constant>(),
        24usize,
        concat!("Size of: ", stringify!(llvm_Constant))
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_Constant>(),
        8usize,
        concat!("Alignment of ", stringify!(llvm_Constant))
    );
}
extern "C" {
    #[doc = " Return true if this is the value that would be returned by getNullValue."]
    #[link_name = "\u{1}_ZNK4llvm8Constant11isNullValueEv"]
    pub fn llvm_Constant_isNullValue(this: *const llvm_Constant) -> bool;
}
extern "C" {
    #[doc = " Returns true if the value is one."]
    #[link_name = "\u{1}_ZNK4llvm8Constant10isOneValueEv"]
    pub fn llvm_Constant_isOneValue(this: *const llvm_Constant) -> bool;
}
extern "C" {
    #[doc = " Return true if the value is not the one value, or,\n for vectors, does not contain one value elements."]
    #[link_name = "\u{1}_ZNK4llvm8Constant13isNotOneValueEv"]
    pub fn llvm_Constant_isNotOneValue(this: *const llvm_Constant) -> bool;
}
extern "C" {
    #[doc = " Return true if this is the value that would be returned by\n getAllOnesValue."]
    #[link_name = "\u{1}_ZNK4llvm8Constant14isAllOnesValueEv"]
    pub fn llvm_Constant_isAllOnesValue(this: *const llvm_Constant) -> bool;
}
extern "C" {
    #[doc = " Return true if the value is what would be returned by\n getZeroValueForNegation."]
    #[link_name = "\u{1}_ZNK4llvm8Constant19isNegativeZeroValueEv"]
    pub fn llvm_Constant_isNegativeZeroValue(this: *const llvm_Constant) -> bool;
}
extern "C" {
    #[doc = " Return true if the value is negative zero or null value."]
    #[link_name = "\u{1}_ZNK4llvm8Constant11isZeroValueEv"]
    pub fn llvm_Constant_isZeroValue(this: *const llvm_Constant) -> bool;
}
extern "C" {
    #[doc = " Return true if the value is not the smallest signed value, or,\n for vectors, does not contain smallest signed value elements."]
    #[link_name = "\u{1}_ZNK4llvm8Constant19isNotMinSignedValueEv"]
    pub fn llvm_Constant_isNotMinSignedValue(this: *const llvm_Constant) -> bool;
}
extern "C" {
    #[doc = " Return true if the value is the smallest signed value."]
    #[link_name = "\u{1}_ZNK4llvm8Constant16isMinSignedValueEv"]
    pub fn llvm_Constant_isMinSignedValue(this: *const llvm_Constant) -> bool;
}
extern "C" {
    #[doc = " Return true if this is a finite and non-zero floating-point scalar\n constant or a fixed width vector constant with all finite and non-zero\n elements."]
    #[link_name = "\u{1}_ZNK4llvm8Constant17isFiniteNonZeroFPEv"]
    pub fn llvm_Constant_isFiniteNonZeroFP(this: *const llvm_Constant) -> bool;
}
extern "C" {
    #[doc = " Return true if this is a normal (as opposed to denormal, infinity, nan,\n or zero) floating-point scalar constant or a vector constant with all\n normal elements. See APFloat::isNormal."]
    #[link_name = "\u{1}_ZNK4llvm8Constant10isNormalFPEv"]
    pub fn llvm_Constant_isNormalFP(this: *const llvm_Constant) -> bool;
}
extern "C" {
    #[doc = " Return true if this scalar has an exact multiplicative inverse or this\n vector has an exact multiplicative inverse for each element in the vector."]
    #[link_name = "\u{1}_ZNK4llvm8Constant17hasExactInverseFPEv"]
    pub fn llvm_Constant_hasExactInverseFP(this: *const llvm_Constant) -> bool;
}
extern "C" {
    #[doc = " Return true if this is a floating-point NaN constant or a vector\n floating-point constant with all NaN elements."]
    #[link_name = "\u{1}_ZNK4llvm8Constant5isNaNEv"]
    pub fn llvm_Constant_isNaN(this: *const llvm_Constant) -> bool;
}
extern "C" {
    #[doc = " Return true if this constant and a constant 'Y' are element-wise equal.\n This is identical to just comparing the pointers, with the exception that\n for vectors, if only one of the constants has an `undef` element in some\n lane, the constants still match."]
    #[link_name = "\u{1}_ZNK4llvm8Constant18isElementWiseEqualEPNS_5ValueE"]
    pub fn llvm_Constant_isElementWiseEqual(this: *const llvm_Constant, Y: *mut llvm_Value)
        -> bool;
}
extern "C" {
    #[doc = " Return true if this is a vector constant that includes any undef or\n poison elements. Since it is impossible to inspect a scalable vector\n element- wise at compile time, this function returns true only if the\n entire vector is undef or poison."]
    #[link_name = "\u{1}_ZNK4llvm8Constant28containsUndefOrPoisonElementEv"]
    pub fn llvm_Constant_containsUndefOrPoisonElement(this: *const llvm_Constant) -> bool;
}
extern "C" {
    #[doc = " Return true if this is a vector constant that includes any poison\n elements."]
    #[link_name = "\u{1}_ZNK4llvm8Constant21containsPoisonElementEv"]
    pub fn llvm_Constant_containsPoisonElement(this: *const llvm_Constant) -> bool;
}
extern "C" {
    #[doc = " Return true if this is a vector constant that includes any strictly undef\n (not poison) elements."]
    #[link_name = "\u{1}_ZNK4llvm8Constant20containsUndefElementEv"]
    pub fn llvm_Constant_containsUndefElement(this: *const llvm_Constant) -> bool;
}
extern "C" {
    #[doc = " Return true if this is a fixed width vector constant that includes\n any constant expressions."]
    #[link_name = "\u{1}_ZNK4llvm8Constant26containsConstantExpressionEv"]
    pub fn llvm_Constant_containsConstantExpression(this: *const llvm_Constant) -> bool;
}
extern "C" {
    #[doc = " Return true if the value can vary between threads."]
    #[link_name = "\u{1}_ZNK4llvm8Constant17isThreadDependentEv"]
    pub fn llvm_Constant_isThreadDependent(this: *const llvm_Constant) -> bool;
}
extern "C" {
    #[doc = " Return true if the value is dependent on a dllimport variable."]
    #[link_name = "\u{1}_ZNK4llvm8Constant20isDLLImportDependentEv"]
    pub fn llvm_Constant_isDLLImportDependent(this: *const llvm_Constant) -> bool;
}
extern "C" {
    #[doc = " Return true if the constant has users other than constant expressions and\n other dangling things."]
    #[link_name = "\u{1}_ZNK4llvm8Constant14isConstantUsedEv"]
    pub fn llvm_Constant_isConstantUsed(this: *const llvm_Constant) -> bool;
}
extern "C" {
    #[doc = " This method classifies the entry according to whether or not it may\n generate a relocation entry (either static or dynamic). This must be\n conservative, so if it might codegen to a relocatable entry, it should say\n so.\n\n FIXME: This really should not be in IR."]
    #[link_name = "\u{1}_ZNK4llvm8Constant15needsRelocationEv"]
    pub fn llvm_Constant_needsRelocation(this: *const llvm_Constant) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4llvm8Constant22needsDynamicRelocationEv"]
    pub fn llvm_Constant_needsDynamicRelocation(this: *const llvm_Constant) -> bool;
}
extern "C" {
    #[doc = " For aggregates (struct/array/vector) return the constant that corresponds\n to the specified element if possible, or null if not. This can return null\n if the element index is a ConstantExpr, if 'this' is a constant expr or\n if the constant does not fit into an uint64_t."]
    #[link_name = "\u{1}_ZNK4llvm8Constant19getAggregateElementEj"]
    pub fn llvm_Constant_getAggregateElement(
        this: *const llvm_Constant,
        Elt: ::std::os::raw::c_uint,
    ) -> *mut llvm_Constant;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4llvm8Constant19getAggregateElementEPS0_"]
    pub fn llvm_Constant_getAggregateElement1(
        this: *const llvm_Constant,
        Elt: *mut llvm_Constant,
    ) -> *mut llvm_Constant;
}
extern "C" {
    #[doc = " If all elements of the vector constant have the same value, return that\n value. Otherwise, return nullptr. Ignore poison elements by setting\n AllowPoison to true."]
    #[link_name = "\u{1}_ZNK4llvm8Constant13getSplatValueEb"]
    pub fn llvm_Constant_getSplatValue(
        this: *const llvm_Constant,
        AllowPoison: bool,
    ) -> *mut llvm_Constant;
}
extern "C" {
    #[doc = " If C is a constant integer then return its value, otherwise C must be a\n vector of constant integers, all equal, and the common value is returned."]
    #[link_name = "\u{1}_ZNK4llvm8Constant16getUniqueIntegerEv"]
    pub fn llvm_Constant_getUniqueInteger(this: *const llvm_Constant) -> *const llvm_APInt;
}
extern "C" {
    #[doc = " Convert constant to an approximate constant range. For vectors, the\n range is the union over the element ranges. Poison elements are ignored."]
    #[link_name = "\u{1}_ZNK4llvm8Constant15toConstantRangeEv"]
    pub fn llvm_Constant_toConstantRange(this: *const llvm_Constant) -> llvm_ConstantRange;
}
extern "C" {
    #[doc = " Called if some element of this constant is no longer valid.\n At this point only other constants may be on the use_list for this\n constant.  Any constants on our Use list must also be destroy'd.  The\n implementation must be sure to remove the constant from the list of\n available cached constants.  Implementations should implement\n destroyConstantImpl to remove constants from any pools/maps they are\n contained it."]
    #[link_name = "\u{1}_ZN4llvm8Constant15destroyConstantEv"]
    pub fn llvm_Constant_destroyConstant(this: *mut llvm_Constant);
}
extern "C" {
    #[doc = " This method is a special form of User::replaceUsesOfWith\n (which does not work on constants) that does work\n on constants.  Basically this method goes through the trouble of building\n a new constant that is equivalent to the current one, with all uses of\n From replaced with uses of To.  After this construction is completed, all\n of the users of 'this' are replaced to use the new constant, and then\n 'this' is deleted.  In general, you should not call this method, instead,\n use Value::replaceAllUsesWith, which automatically dispatches to this\n method as needed.\n"]
    #[link_name = "\u{1}_ZN4llvm8Constant19handleOperandChangeEPNS_5ValueES2_"]
    pub fn llvm_Constant_handleOperandChange(
        this: *mut llvm_Constant,
        arg1: *mut llvm_Value,
        arg2: *mut llvm_Value,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm8Constant12getNullValueEPNS_4TypeE"]
    pub fn llvm_Constant_getNullValue(Ty: *mut llvm_Type) -> *mut llvm_Constant;
}
extern "C" {
    #[doc = " @returns the value for an integer or vector of integer constant of the\n given type that has all its bits set to true.\n Get the all ones value"]
    #[link_name = "\u{1}_ZN4llvm8Constant15getAllOnesValueEPNS_4TypeE"]
    pub fn llvm_Constant_getAllOnesValue(Ty: *mut llvm_Type) -> *mut llvm_Constant;
}
extern "C" {
    #[doc = " Return the value for an integer or pointer constant, or a vector thereof,\n with the given scalar value."]
    #[link_name = "\u{1}_ZN4llvm8Constant15getIntegerValueEPNS_4TypeERKNS_5APIntE"]
    pub fn llvm_Constant_getIntegerValue(
        Ty: *mut llvm_Type,
        V: *const llvm_APInt,
    ) -> *mut llvm_Constant;
}
extern "C" {
    #[doc = " If there are any dead constant users dangling off of this constant, remove\n them. This method is useful for clients that want to check to see if a\n global is unused, but don't want to deal with potentially dead constants\n hanging off of the globals."]
    #[link_name = "\u{1}_ZNK4llvm8Constant23removeDeadConstantUsersEv"]
    pub fn llvm_Constant_removeDeadConstantUsers(this: *const llvm_Constant);
}
extern "C" {
    #[doc = " Return true if the constant has exactly one live use.\n\n This returns the same result as calling Value::hasOneUse after\n Constant::removeDeadConstantUsers, but doesn't remove dead constants."]
    #[link_name = "\u{1}_ZNK4llvm8Constant13hasOneLiveUseEv"]
    pub fn llvm_Constant_hasOneLiveUse(this: *const llvm_Constant) -> bool;
}
extern "C" {
    #[doc = " Return true if the constant has no live uses.\n\n This returns the same result as calling Value::use_empty after\n Constant::removeDeadConstantUsers, but doesn't remove dead constants."]
    #[link_name = "\u{1}_ZNK4llvm8Constant15hasZeroLiveUsesEv"]
    pub fn llvm_Constant_hasZeroLiveUses(this: *const llvm_Constant) -> bool;
}
extern "C" {
    #[doc = " Try to replace undefined constant C or undefined elements in C with\n Replacement. If no changes are made, the constant C is returned."]
    #[link_name = "\u{1}_ZN4llvm8Constant17replaceUndefsWithEPS0_S1_"]
    pub fn llvm_Constant_replaceUndefsWith(
        C: *mut llvm_Constant,
        Replacement: *mut llvm_Constant,
    ) -> *mut llvm_Constant;
}
extern "C" {
    #[doc = " Merges undefs of a Constant with another Constant, along with the\n undefs already present. Other doesn't have to be the same type as C, but\n both must either be scalars or vectors with the same element count. If no\n changes are made, the constant C is returned."]
    #[link_name = "\u{1}_ZN4llvm8Constant15mergeUndefsWithEPS0_S1_"]
    pub fn llvm_Constant_mergeUndefsWith(
        C: *mut llvm_Constant,
        Other: *mut llvm_Constant,
    ) -> *mut llvm_Constant;
}
extern "C" {
    #[doc = " Return true if a constant is ConstantData or a ConstantAggregate or\n ConstantExpr that contain only ConstantData."]
    #[link_name = "\u{1}_ZNK4llvm8Constant18isManifestConstantEv"]
    pub fn llvm_Constant_isManifestConstant(this: *const llvm_Constant) -> bool;
}
impl llvm_Constant {
    #[inline]
    pub unsafe fn isNullValue(&self) -> bool {
        llvm_Constant_isNullValue(self)
    }
    #[inline]
    pub unsafe fn isOneValue(&self) -> bool {
        llvm_Constant_isOneValue(self)
    }
    #[inline]
    pub unsafe fn isNotOneValue(&self) -> bool {
        llvm_Constant_isNotOneValue(self)
    }
    #[inline]
    pub unsafe fn isAllOnesValue(&self) -> bool {
        llvm_Constant_isAllOnesValue(self)
    }
    #[inline]
    pub unsafe fn isNegativeZeroValue(&self) -> bool {
        llvm_Constant_isNegativeZeroValue(self)
    }
    #[inline]
    pub unsafe fn isZeroValue(&self) -> bool {
        llvm_Constant_isZeroValue(self)
    }
    #[inline]
    pub unsafe fn isNotMinSignedValue(&self) -> bool {
        llvm_Constant_isNotMinSignedValue(self)
    }
    #[inline]
    pub unsafe fn isMinSignedValue(&self) -> bool {
        llvm_Constant_isMinSignedValue(self)
    }
    #[inline]
    pub unsafe fn isFiniteNonZeroFP(&self) -> bool {
        llvm_Constant_isFiniteNonZeroFP(self)
    }
    #[inline]
    pub unsafe fn isNormalFP(&self) -> bool {
        llvm_Constant_isNormalFP(self)
    }
    #[inline]
    pub unsafe fn hasExactInverseFP(&self) -> bool {
        llvm_Constant_hasExactInverseFP(self)
    }
    #[inline]
    pub unsafe fn isNaN(&self) -> bool {
        llvm_Constant_isNaN(self)
    }
    #[inline]
    pub unsafe fn isElementWiseEqual(&self, Y: *mut llvm_Value) -> bool {
        llvm_Constant_isElementWiseEqual(self, Y)
    }
    #[inline]
    pub unsafe fn containsUndefOrPoisonElement(&self) -> bool {
        llvm_Constant_containsUndefOrPoisonElement(self)
    }
    #[inline]
    pub unsafe fn containsPoisonElement(&self) -> bool {
        llvm_Constant_containsPoisonElement(self)
    }
    #[inline]
    pub unsafe fn containsUndefElement(&self) -> bool {
        llvm_Constant_containsUndefElement(self)
    }
    #[inline]
    pub unsafe fn containsConstantExpression(&self) -> bool {
        llvm_Constant_containsConstantExpression(self)
    }
    #[inline]
    pub unsafe fn isThreadDependent(&self) -> bool {
        llvm_Constant_isThreadDependent(self)
    }
    #[inline]
    pub unsafe fn isDLLImportDependent(&self) -> bool {
        llvm_Constant_isDLLImportDependent(self)
    }
    #[inline]
    pub unsafe fn isConstantUsed(&self) -> bool {
        llvm_Constant_isConstantUsed(self)
    }
    #[inline]
    pub unsafe fn needsRelocation(&self) -> bool {
        llvm_Constant_needsRelocation(self)
    }
    #[inline]
    pub unsafe fn needsDynamicRelocation(&self) -> bool {
        llvm_Constant_needsDynamicRelocation(self)
    }
    #[inline]
    pub unsafe fn getAggregateElement(&self, Elt: ::std::os::raw::c_uint) -> *mut llvm_Constant {
        llvm_Constant_getAggregateElement(self, Elt)
    }
    #[inline]
    pub unsafe fn getAggregateElement1(&self, Elt: *mut llvm_Constant) -> *mut llvm_Constant {
        llvm_Constant_getAggregateElement1(self, Elt)
    }
    #[inline]
    pub unsafe fn getSplatValue(&self, AllowPoison: bool) -> *mut llvm_Constant {
        llvm_Constant_getSplatValue(self, AllowPoison)
    }
    #[inline]
    pub unsafe fn getUniqueInteger(&self) -> *const llvm_APInt {
        llvm_Constant_getUniqueInteger(self)
    }
    #[inline]
    pub unsafe fn toConstantRange(&self) -> llvm_ConstantRange {
        llvm_Constant_toConstantRange(self)
    }
    #[inline]
    pub unsafe fn destroyConstant(&mut self) {
        llvm_Constant_destroyConstant(self)
    }
    #[inline]
    pub unsafe fn handleOperandChange(&mut self, arg1: *mut llvm_Value, arg2: *mut llvm_Value) {
        llvm_Constant_handleOperandChange(self, arg1, arg2)
    }
    #[inline]
    pub unsafe fn getNullValue(Ty: *mut llvm_Type) -> *mut llvm_Constant {
        llvm_Constant_getNullValue(Ty)
    }
    #[inline]
    pub unsafe fn getAllOnesValue(Ty: *mut llvm_Type) -> *mut llvm_Constant {
        llvm_Constant_getAllOnesValue(Ty)
    }
    #[inline]
    pub unsafe fn getIntegerValue(Ty: *mut llvm_Type, V: *const llvm_APInt) -> *mut llvm_Constant {
        llvm_Constant_getIntegerValue(Ty, V)
    }
    #[inline]
    pub unsafe fn removeDeadConstantUsers(&self) {
        llvm_Constant_removeDeadConstantUsers(self)
    }
    #[inline]
    pub unsafe fn hasOneLiveUse(&self) -> bool {
        llvm_Constant_hasOneLiveUse(self)
    }
    #[inline]
    pub unsafe fn hasZeroLiveUses(&self) -> bool {
        llvm_Constant_hasZeroLiveUses(self)
    }
    #[inline]
    pub unsafe fn replaceUndefsWith(
        C: *mut llvm_Constant,
        Replacement: *mut llvm_Constant,
    ) -> *mut llvm_Constant {
        llvm_Constant_replaceUndefsWith(C, Replacement)
    }
    #[inline]
    pub unsafe fn mergeUndefsWith(
        C: *mut llvm_Constant,
        Other: *mut llvm_Constant,
    ) -> *mut llvm_Constant {
        llvm_Constant_mergeUndefsWith(C, Other)
    }
    #[inline]
    pub unsafe fn isManifestConstant(&self) -> bool {
        llvm_Constant_isManifestConstant(self)
    }
}
pub const llvm_LLVMConstants_DEBUG_METADATA_VERSION: llvm_LLVMConstants = 3;
pub type llvm_LLVMConstants = u32;
extern "C" {
    #[doc = " Magic number in the value profile metadata showing a target has been\n promoted for the instruction and shouldn't be promoted again."]
    #[link_name = "\u{1}_ZN4llvmL19NOMORE_ICP_MAGICNUME"]
    pub static llvm_NOMORE_ICP_MAGICNUM: u64;
}
#[doc = " Root of the metadata hierarchy.\n\n This is a root class for typeless data in the IR."]
#[repr(C)]
#[derive(Debug)]
pub struct llvm_Metadata {
    #[doc = " RTTI."]
    pub SubclassID: ::std::os::raw::c_uchar,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub SubclassData16: ::std::os::raw::c_ushort,
    pub SubclassData32: ::std::os::raw::c_uint,
}
pub const llvm_Metadata_StorageType_Uniqued: llvm_Metadata_StorageType = 0;
pub const llvm_Metadata_StorageType_Distinct: llvm_Metadata_StorageType = 1;
pub const llvm_Metadata_StorageType_Temporary: llvm_Metadata_StorageType = 2;
#[doc = " Active type of storage."]
pub type llvm_Metadata_StorageType = ::std::os::raw::c_uint;
pub const llvm_Metadata_MetadataKind_MDStringKind: llvm_Metadata_MetadataKind = 0;
pub const llvm_Metadata_MetadataKind_ConstantAsMetadataKind: llvm_Metadata_MetadataKind = 1;
pub const llvm_Metadata_MetadataKind_LocalAsMetadataKind: llvm_Metadata_MetadataKind = 2;
pub const llvm_Metadata_MetadataKind_DistinctMDOperandPlaceholderKind: llvm_Metadata_MetadataKind =
    3;
pub const llvm_Metadata_MetadataKind_DIArgListKind: llvm_Metadata_MetadataKind = 4;
pub const llvm_Metadata_MetadataKind_MDTupleKind: llvm_Metadata_MetadataKind = 5;
pub const llvm_Metadata_MetadataKind_DILocationKind: llvm_Metadata_MetadataKind = 6;
pub const llvm_Metadata_MetadataKind_DIExpressionKind: llvm_Metadata_MetadataKind = 7;
pub const llvm_Metadata_MetadataKind_DIGlobalVariableExpressionKind: llvm_Metadata_MetadataKind = 8;
pub const llvm_Metadata_MetadataKind_GenericDINodeKind: llvm_Metadata_MetadataKind = 9;
pub const llvm_Metadata_MetadataKind_DISubrangeKind: llvm_Metadata_MetadataKind = 10;
pub const llvm_Metadata_MetadataKind_DIEnumeratorKind: llvm_Metadata_MetadataKind = 11;
pub const llvm_Metadata_MetadataKind_DIBasicTypeKind: llvm_Metadata_MetadataKind = 12;
pub const llvm_Metadata_MetadataKind_DIDerivedTypeKind: llvm_Metadata_MetadataKind = 13;
pub const llvm_Metadata_MetadataKind_DICompositeTypeKind: llvm_Metadata_MetadataKind = 14;
pub const llvm_Metadata_MetadataKind_DISubroutineTypeKind: llvm_Metadata_MetadataKind = 15;
pub const llvm_Metadata_MetadataKind_DIFileKind: llvm_Metadata_MetadataKind = 16;
pub const llvm_Metadata_MetadataKind_DICompileUnitKind: llvm_Metadata_MetadataKind = 17;
pub const llvm_Metadata_MetadataKind_DISubprogramKind: llvm_Metadata_MetadataKind = 18;
pub const llvm_Metadata_MetadataKind_DILexicalBlockKind: llvm_Metadata_MetadataKind = 19;
pub const llvm_Metadata_MetadataKind_DILexicalBlockFileKind: llvm_Metadata_MetadataKind = 20;
pub const llvm_Metadata_MetadataKind_DINamespaceKind: llvm_Metadata_MetadataKind = 21;
pub const llvm_Metadata_MetadataKind_DIModuleKind: llvm_Metadata_MetadataKind = 22;
pub const llvm_Metadata_MetadataKind_DITemplateTypeParameterKind: llvm_Metadata_MetadataKind = 23;
pub const llvm_Metadata_MetadataKind_DITemplateValueParameterKind: llvm_Metadata_MetadataKind = 24;
pub const llvm_Metadata_MetadataKind_DIGlobalVariableKind: llvm_Metadata_MetadataKind = 25;
pub const llvm_Metadata_MetadataKind_DILocalVariableKind: llvm_Metadata_MetadataKind = 26;
pub const llvm_Metadata_MetadataKind_DILabelKind: llvm_Metadata_MetadataKind = 27;
pub const llvm_Metadata_MetadataKind_DIObjCPropertyKind: llvm_Metadata_MetadataKind = 28;
pub const llvm_Metadata_MetadataKind_DIImportedEntityKind: llvm_Metadata_MetadataKind = 29;
pub const llvm_Metadata_MetadataKind_DIAssignIDKind: llvm_Metadata_MetadataKind = 30;
pub const llvm_Metadata_MetadataKind_DIMacroKind: llvm_Metadata_MetadataKind = 31;
pub const llvm_Metadata_MetadataKind_DIMacroFileKind: llvm_Metadata_MetadataKind = 32;
pub const llvm_Metadata_MetadataKind_DICommonBlockKind: llvm_Metadata_MetadataKind = 33;
pub const llvm_Metadata_MetadataKind_DIStringTypeKind: llvm_Metadata_MetadataKind = 34;
pub const llvm_Metadata_MetadataKind_DIGenericSubrangeKind: llvm_Metadata_MetadataKind = 35;
pub type llvm_Metadata_MetadataKind = ::std::os::raw::c_uint;
#[test]
fn bindgen_test_layout_llvm_Metadata() {
    const UNINIT: ::std::mem::MaybeUninit<llvm_Metadata> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<llvm_Metadata>(),
        8usize,
        concat!("Size of: ", stringify!(llvm_Metadata))
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_Metadata>(),
        4usize,
        concat!("Alignment of ", stringify!(llvm_Metadata))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).SubclassID) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_Metadata),
            "::",
            stringify!(SubclassID)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).SubclassData16) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_Metadata),
            "::",
            stringify!(SubclassData16)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).SubclassData32) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_Metadata),
            "::",
            stringify!(SubclassData32)
        )
    );
}
extern "C" {
    #[doc = " User-friendly dump.\n\n If \\c M is provided, metadata nodes will be numbered canonically;\n otherwise, pointer addresses are substituted.\n\n Note: this uses an explicit overload instead of default arguments so that\n the nullptr version is easy to call from a debugger.\n\n @{"]
    #[link_name = "\u{1}_ZNK4llvm8Metadata4dumpEv"]
    pub fn llvm_Metadata_dump(this: *const llvm_Metadata);
}
extern "C" {
    #[link_name = "\u{1}_ZNK4llvm8Metadata4dumpEPKNS_6ModuleE"]
    pub fn llvm_Metadata_dump1(this: *const llvm_Metadata, M: *const llvm_Module);
}
extern "C" {
    #[doc = " Print.\n\n Prints definition of \\c this.\n\n If \\c M is provided, metadata nodes will be numbered canonically;\n otherwise, pointer addresses are substituted.\n @{"]
    #[link_name = "\u{1}_ZNK4llvm8Metadata5printERNS_11raw_ostreamEPKNS_6ModuleEb"]
    pub fn llvm_Metadata_print(
        this: *const llvm_Metadata,
        OS: *mut llvm_raw_ostream,
        M: *const llvm_Module,
        IsForDebug: bool,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK4llvm8Metadata5printERNS_11raw_ostreamERNS_17ModuleSlotTrackerEPKNS_6ModuleEb"]
    pub fn llvm_Metadata_print1(
        this: *const llvm_Metadata,
        OS: *mut llvm_raw_ostream,
        MST: *mut llvm_ModuleSlotTracker,
        M: *const llvm_Module,
        IsForDebug: bool,
    );
}
extern "C" {
    #[doc = " Print as operand.\n\n Prints reference of \\c this.\n\n If \\c M is provided, metadata nodes will be numbered canonically;\n otherwise, pointer addresses are substituted.\n @{"]
    #[link_name = "\u{1}_ZNK4llvm8Metadata14printAsOperandERNS_11raw_ostreamEPKNS_6ModuleE"]
    pub fn llvm_Metadata_printAsOperand(
        this: *const llvm_Metadata,
        OS: *mut llvm_raw_ostream,
        M: *const llvm_Module,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK4llvm8Metadata14printAsOperandERNS_11raw_ostreamERNS_17ModuleSlotTrackerEPKNS_6ModuleE"]
    pub fn llvm_Metadata_printAsOperand1(
        this: *const llvm_Metadata,
        OS: *mut llvm_raw_ostream,
        MST: *mut llvm_ModuleSlotTracker,
        M: *const llvm_Module,
    );
}
impl llvm_Metadata {
    #[inline]
    pub fn Storage(&self) -> ::std::os::raw::c_uchar {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 7u8) as u8) }
    }
    #[inline]
    pub fn set_Storage(&mut self, val: ::std::os::raw::c_uchar) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 7u8, val as u64)
        }
    }
    #[inline]
    pub fn SubclassData1(&self) -> ::std::os::raw::c_uchar {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_SubclassData1(&mut self, val: ::std::os::raw::c_uchar) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        Storage: ::std::os::raw::c_uchar,
        SubclassData1: ::std::os::raw::c_uchar,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 7u8, {
            let Storage: u8 = unsafe { ::std::mem::transmute(Storage) };
            Storage as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let SubclassData1: u8 = unsafe { ::std::mem::transmute(SubclassData1) };
            SubclassData1 as u64
        });
        __bindgen_bitfield_unit
    }
    #[inline]
    pub unsafe fn dump(&self) {
        llvm_Metadata_dump(self)
    }
    #[inline]
    pub unsafe fn dump1(&self, M: *const llvm_Module) {
        llvm_Metadata_dump1(self, M)
    }
    #[inline]
    pub unsafe fn print(&self, OS: *mut llvm_raw_ostream, M: *const llvm_Module, IsForDebug: bool) {
        llvm_Metadata_print(self, OS, M, IsForDebug)
    }
    #[inline]
    pub unsafe fn print1(
        &self,
        OS: *mut llvm_raw_ostream,
        MST: *mut llvm_ModuleSlotTracker,
        M: *const llvm_Module,
        IsForDebug: bool,
    ) {
        llvm_Metadata_print1(self, OS, MST, M, IsForDebug)
    }
    #[inline]
    pub unsafe fn printAsOperand(&self, OS: *mut llvm_raw_ostream, M: *const llvm_Module) {
        llvm_Metadata_printAsOperand(self, OS, M)
    }
    #[inline]
    pub unsafe fn printAsOperand1(
        &self,
        OS: *mut llvm_raw_ostream,
        MST: *mut llvm_ModuleSlotTracker,
        M: *const llvm_Module,
    ) {
        llvm_Metadata_printAsOperand1(self, OS, MST, M)
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_DIArgList {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_DILocation {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_DIExpression {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_DIGlobalVariableExpression {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_DINode {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_GenericDINode {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_DISubrange {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_DIEnumerator {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_DIScope {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_DIType {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_DIBasicType {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_DIDerivedType {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_DICompositeType {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_DISubroutineType {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_DIFile {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_DICompileUnit {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_DILocalScope {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_DISubprogram {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_DILexicalBlockBase {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_DILexicalBlock {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_DILexicalBlockFile {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_DINamespace {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_DIModule {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_DITemplateParameter {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_DITemplateTypeParameter {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_DITemplateValueParameter {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_DIVariable {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_DIGlobalVariable {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_DILocalVariable {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_DILabel {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_DIObjCProperty {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_DIImportedEntity {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_DIAssignID {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_DIMacroNode {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_DIMacro {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_DIMacroFile {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_DICommonBlock {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_DIStringType {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_DIGenericSubrange {
    _unused: [u8; 0],
}
#[test]
fn __bindgen_test_layout_llvm_isa_impl_open0_llvm_MDString_llvm_Metadata_void_close0_instantiation()
{
    assert_eq!(
        ::std::mem::size_of::<llvm_isa_impl>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_isa_impl)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_isa_impl>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_isa_impl)
        )
    );
}
#[test]
fn __bindgen_test_layout_llvm_isa_impl_open0_llvm_ConstantAsMetadata_llvm_Metadata_void_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<llvm_isa_impl>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_isa_impl)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_isa_impl>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_isa_impl)
        )
    );
}
#[test]
fn __bindgen_test_layout_llvm_isa_impl_open0_llvm_LocalAsMetadata_llvm_Metadata_void_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<llvm_isa_impl>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_isa_impl)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_isa_impl>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_isa_impl)
        )
    );
}
#[test]
fn __bindgen_test_layout_llvm_isa_impl_open0_llvm_DistinctMDOperandPlaceholder_llvm_Metadata_void_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<llvm_isa_impl>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_isa_impl)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_isa_impl>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_isa_impl)
        )
    );
}
#[test]
fn __bindgen_test_layout_llvm_isa_impl_open0_llvm_DIArgList_llvm_Metadata_void_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<llvm_isa_impl>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_isa_impl)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_isa_impl>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_isa_impl)
        )
    );
}
#[test]
fn __bindgen_test_layout_llvm_isa_impl_open0_llvm_MDTuple_llvm_Metadata_void_close0_instantiation()
{
    assert_eq!(
        ::std::mem::size_of::<llvm_isa_impl>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_isa_impl)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_isa_impl>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_isa_impl)
        )
    );
}
#[test]
fn __bindgen_test_layout_llvm_isa_impl_open0_llvm_DILocation_llvm_Metadata_void_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<llvm_isa_impl>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_isa_impl)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_isa_impl>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_isa_impl)
        )
    );
}
#[test]
fn __bindgen_test_layout_llvm_isa_impl_open0_llvm_DIExpression_llvm_Metadata_void_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<llvm_isa_impl>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_isa_impl)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_isa_impl>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_isa_impl)
        )
    );
}
#[test]
fn __bindgen_test_layout_llvm_isa_impl_open0_llvm_DIGlobalVariableExpression_llvm_Metadata_void_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<llvm_isa_impl>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_isa_impl)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_isa_impl>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_isa_impl)
        )
    );
}
#[test]
fn __bindgen_test_layout_llvm_isa_impl_open0_llvm_GenericDINode_llvm_Metadata_void_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<llvm_isa_impl>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_isa_impl)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_isa_impl>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_isa_impl)
        )
    );
}
#[test]
fn __bindgen_test_layout_llvm_isa_impl_open0_llvm_DISubrange_llvm_Metadata_void_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<llvm_isa_impl>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_isa_impl)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_isa_impl>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_isa_impl)
        )
    );
}
#[test]
fn __bindgen_test_layout_llvm_isa_impl_open0_llvm_DIEnumerator_llvm_Metadata_void_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<llvm_isa_impl>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_isa_impl)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_isa_impl>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_isa_impl)
        )
    );
}
#[test]
fn __bindgen_test_layout_llvm_isa_impl_open0_llvm_DIBasicType_llvm_Metadata_void_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<llvm_isa_impl>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_isa_impl)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_isa_impl>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_isa_impl)
        )
    );
}
#[test]
fn __bindgen_test_layout_llvm_isa_impl_open0_llvm_DIDerivedType_llvm_Metadata_void_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<llvm_isa_impl>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_isa_impl)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_isa_impl>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_isa_impl)
        )
    );
}
#[test]
fn __bindgen_test_layout_llvm_isa_impl_open0_llvm_DICompositeType_llvm_Metadata_void_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<llvm_isa_impl>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_isa_impl)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_isa_impl>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_isa_impl)
        )
    );
}
#[test]
fn __bindgen_test_layout_llvm_isa_impl_open0_llvm_DISubroutineType_llvm_Metadata_void_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<llvm_isa_impl>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_isa_impl)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_isa_impl>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_isa_impl)
        )
    );
}
#[test]
fn __bindgen_test_layout_llvm_isa_impl_open0_llvm_DIFile_llvm_Metadata_void_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<llvm_isa_impl>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_isa_impl)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_isa_impl>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_isa_impl)
        )
    );
}
#[test]
fn __bindgen_test_layout_llvm_isa_impl_open0_llvm_DICompileUnit_llvm_Metadata_void_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<llvm_isa_impl>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_isa_impl)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_isa_impl>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_isa_impl)
        )
    );
}
#[test]
fn __bindgen_test_layout_llvm_isa_impl_open0_llvm_DISubprogram_llvm_Metadata_void_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<llvm_isa_impl>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_isa_impl)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_isa_impl>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_isa_impl)
        )
    );
}
#[test]
fn __bindgen_test_layout_llvm_isa_impl_open0_llvm_DILexicalBlock_llvm_Metadata_void_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<llvm_isa_impl>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_isa_impl)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_isa_impl>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_isa_impl)
        )
    );
}
#[test]
fn __bindgen_test_layout_llvm_isa_impl_open0_llvm_DILexicalBlockFile_llvm_Metadata_void_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<llvm_isa_impl>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_isa_impl)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_isa_impl>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_isa_impl)
        )
    );
}
#[test]
fn __bindgen_test_layout_llvm_isa_impl_open0_llvm_DINamespace_llvm_Metadata_void_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<llvm_isa_impl>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_isa_impl)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_isa_impl>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_isa_impl)
        )
    );
}
#[test]
fn __bindgen_test_layout_llvm_isa_impl_open0_llvm_DIModule_llvm_Metadata_void_close0_instantiation()
{
    assert_eq!(
        ::std::mem::size_of::<llvm_isa_impl>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_isa_impl)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_isa_impl>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_isa_impl)
        )
    );
}
#[test]
fn __bindgen_test_layout_llvm_isa_impl_open0_llvm_DITemplateTypeParameter_llvm_Metadata_void_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<llvm_isa_impl>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_isa_impl)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_isa_impl>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_isa_impl)
        )
    );
}
#[test]
fn __bindgen_test_layout_llvm_isa_impl_open0_llvm_DITemplateValueParameter_llvm_Metadata_void_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<llvm_isa_impl>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_isa_impl)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_isa_impl>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_isa_impl)
        )
    );
}
#[test]
fn __bindgen_test_layout_llvm_isa_impl_open0_llvm_DIGlobalVariable_llvm_Metadata_void_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<llvm_isa_impl>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_isa_impl)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_isa_impl>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_isa_impl)
        )
    );
}
#[test]
fn __bindgen_test_layout_llvm_isa_impl_open0_llvm_DILocalVariable_llvm_Metadata_void_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<llvm_isa_impl>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_isa_impl)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_isa_impl>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_isa_impl)
        )
    );
}
#[test]
fn __bindgen_test_layout_llvm_isa_impl_open0_llvm_DILabel_llvm_Metadata_void_close0_instantiation()
{
    assert_eq!(
        ::std::mem::size_of::<llvm_isa_impl>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_isa_impl)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_isa_impl>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_isa_impl)
        )
    );
}
#[test]
fn __bindgen_test_layout_llvm_isa_impl_open0_llvm_DIObjCProperty_llvm_Metadata_void_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<llvm_isa_impl>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_isa_impl)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_isa_impl>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_isa_impl)
        )
    );
}
#[test]
fn __bindgen_test_layout_llvm_isa_impl_open0_llvm_DIImportedEntity_llvm_Metadata_void_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<llvm_isa_impl>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_isa_impl)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_isa_impl>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_isa_impl)
        )
    );
}
#[test]
fn __bindgen_test_layout_llvm_isa_impl_open0_llvm_DIAssignID_llvm_Metadata_void_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<llvm_isa_impl>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_isa_impl)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_isa_impl>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_isa_impl)
        )
    );
}
#[test]
fn __bindgen_test_layout_llvm_isa_impl_open0_llvm_DIMacro_llvm_Metadata_void_close0_instantiation()
{
    assert_eq!(
        ::std::mem::size_of::<llvm_isa_impl>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_isa_impl)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_isa_impl>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_isa_impl)
        )
    );
}
#[test]
fn __bindgen_test_layout_llvm_isa_impl_open0_llvm_DIMacroFile_llvm_Metadata_void_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<llvm_isa_impl>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_isa_impl)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_isa_impl>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_isa_impl)
        )
    );
}
#[test]
fn __bindgen_test_layout_llvm_isa_impl_open0_llvm_DICommonBlock_llvm_Metadata_void_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<llvm_isa_impl>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_isa_impl)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_isa_impl>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_isa_impl)
        )
    );
}
#[test]
fn __bindgen_test_layout_llvm_isa_impl_open0_llvm_DIStringType_llvm_Metadata_void_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<llvm_isa_impl>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_isa_impl)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_isa_impl>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_isa_impl)
        )
    );
}
#[test]
fn __bindgen_test_layout_llvm_isa_impl_open0_llvm_DIGenericSubrange_llvm_Metadata_void_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<llvm_isa_impl>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_isa_impl)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_isa_impl>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_isa_impl)
        )
    );
}
#[doc = " Metadata wrapper in the Value hierarchy.\n\n A member of the \\a Value hierarchy to represent a reference to metadata.\n This allows, e.g., intrinsics to have metadata as operands.\n\n Notably, this is the only thing in either hierarchy that is allowed to\n reference \\a LocalAsMetadata."]
#[repr(C)]
#[derive(Debug)]
pub struct llvm_MetadataAsValue {
    pub _base: llvm_Value,
    pub MD: *mut llvm_Metadata,
}
#[test]
fn bindgen_test_layout_llvm_MetadataAsValue() {
    const UNINIT: ::std::mem::MaybeUninit<llvm_MetadataAsValue> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<llvm_MetadataAsValue>(),
        32usize,
        concat!("Size of: ", stringify!(llvm_MetadataAsValue))
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_MetadataAsValue>(),
        8usize,
        concat!("Alignment of ", stringify!(llvm_MetadataAsValue))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).MD) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_MetadataAsValue),
            "::",
            stringify!(MD)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm15MetadataAsValue3getERNS_11LLVMContextEPNS_8MetadataE"]
    pub fn llvm_MetadataAsValue_get(
        Context: *mut llvm_LLVMContext,
        MD: *mut llvm_Metadata,
    ) -> *mut llvm_MetadataAsValue;
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm15MetadataAsValue11getIfExistsERNS_11LLVMContextEPNS_8MetadataE"]
    pub fn llvm_MetadataAsValue_getIfExists(
        Context: *mut llvm_LLVMContext,
        MD: *mut llvm_Metadata,
    ) -> *mut llvm_MetadataAsValue;
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm15MetadataAsValueD1Ev"]
    pub fn llvm_MetadataAsValue_MetadataAsValue_destructor(this: *mut llvm_MetadataAsValue);
}
impl llvm_MetadataAsValue {
    #[inline]
    pub unsafe fn get(
        Context: *mut llvm_LLVMContext,
        MD: *mut llvm_Metadata,
    ) -> *mut llvm_MetadataAsValue {
        llvm_MetadataAsValue_get(Context, MD)
    }
    #[inline]
    pub unsafe fn getIfExists(
        Context: *mut llvm_LLVMContext,
        MD: *mut llvm_Metadata,
    ) -> *mut llvm_MetadataAsValue {
        llvm_MetadataAsValue_getIfExists(Context, MD)
    }
    #[inline]
    pub unsafe fn destruct(&mut self) {
        llvm_MetadataAsValue_MetadataAsValue_destructor(self)
    }
}
#[doc = " Base class for tracking ValueAsMetadata/DIArgLists with user lookups and\n Owner callbacks outside of ValueAsMetadata.\n\n Currently only inherited by DbgVariableRecord; if other classes need to use\n it, then a SubclassID will need to be added (either as a new field or by\n making DebugValue into a PointerIntUnion) to discriminate between the\n subclasses in lookup and callback handling."]
#[repr(C)]
#[derive(Debug)]
pub struct llvm_DebugValueUser {
    pub DebugValues: [u64; 3usize],
}
#[test]
fn bindgen_test_layout_llvm_DebugValueUser() {
    const UNINIT: ::std::mem::MaybeUninit<llvm_DebugValueUser> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<llvm_DebugValueUser>(),
        24usize,
        concat!("Size of: ", stringify!(llvm_DebugValueUser))
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_DebugValueUser>(),
        8usize,
        concat!("Alignment of ", stringify!(llvm_DebugValueUser))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).DebugValues) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_DebugValueUser),
            "::",
            stringify!(DebugValues)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm14DebugValueUser7getUserEv"]
    pub fn llvm_DebugValueUser_getUser(
        this: *mut llvm_DebugValueUser,
    ) -> *mut llvm_DbgVariableRecord;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4llvm14DebugValueUser7getUserEv"]
    pub fn llvm_DebugValueUser_getUser1(
        this: *const llvm_DebugValueUser,
    ) -> *const llvm_DbgVariableRecord;
}
extern "C" {
    #[doc = " To be called by ReplaceableMetadataImpl::replaceAllUsesWith, where `Old`\n is a pointer to one of the pointers in `DebugValues` (so should be type\n Metadata**), and `NewDebugValue` is the new Metadata* that is replacing\n *Old.\n For manually replacing elements of DebugValues,\n `resetDebugValue(Idx, NewDebugValue)` should be used instead."]
    #[link_name = "\u{1}_ZN4llvm14DebugValueUser18handleChangedValueEPvPNS_8MetadataE"]
    pub fn llvm_DebugValueUser_handleChangedValue(
        this: *mut llvm_DebugValueUser,
        Old: *mut ::std::os::raw::c_void,
        NewDebugValue: *mut llvm_Metadata,
    );
}
impl llvm_DebugValueUser {
    #[inline]
    pub unsafe fn getUser(&mut self) -> *mut llvm_DbgVariableRecord {
        llvm_DebugValueUser_getUser(self)
    }
    #[inline]
    pub unsafe fn getUser1(&self) -> *const llvm_DbgVariableRecord {
        llvm_DebugValueUser_getUser1(self)
    }
    #[inline]
    pub unsafe fn handleChangedValue(
        &mut self,
        Old: *mut ::std::os::raw::c_void,
        NewDebugValue: *mut llvm_Metadata,
    ) {
        llvm_DebugValueUser_handleChangedValue(self, Old, NewDebugValue)
    }
}
#[doc = " API for tracking metadata references through RAUW and deletion.\n\n Shared API for updating \\a Metadata pointers in subclasses that support\n RAUW.\n\n This API is not meant to be used directly.  See \\a TrackingMDRef for a\n user-friendly tracking reference."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_MetadataTracking {
    pub _address: u8,
}
#[doc = " A discriminated union of two or more pointer types, with the discriminator\n in the low bit of the pointer.\n\n This implementation is extremely efficient in space due to leveraging the\n low bits of the pointer, while exposing a natural and type-safe API.\n\n Common use patterns would be something like this:\n    PointerUnion<int*, float*> P;\n    P = (int*)0;\n    printf(\"%d %d\", P.is<int*>(), P.is<float*>());  // prints \"1 0\"\n    X = P.get<int*>();     // ok.\n    Y = P.get<float*>();   // runtime assertion failure.\n    Z = P.get<double*>();  // compile time failure.\n    P = (float*)0;\n    Y = P.get<float*>();   // ok.\n    X = P.get<int*>();     // runtime assertion failure.\n    PointerUnion<int*, int*> Q; // compile time failure."]
pub type llvm_MetadataTracking_OwnerTy = llvm_PointerUnion;
#[test]
fn bindgen_test_layout_llvm_MetadataTracking() {
    assert_eq!(
        ::std::mem::size_of::<llvm_MetadataTracking>(),
        1usize,
        concat!("Size of: ", stringify!(llvm_MetadataTracking))
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_MetadataTracking>(),
        1usize,
        concat!("Alignment of ", stringify!(llvm_MetadataTracking))
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm16MetadataTracking7untrackEPvRNS_8MetadataE"]
    pub fn llvm_MetadataTracking_untrack(Ref: *mut ::std::os::raw::c_void, MD: *mut llvm_Metadata);
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm16MetadataTracking7retrackEPvRNS_8MetadataES1_"]
    pub fn llvm_MetadataTracking_retrack(
        Ref: *mut ::std::os::raw::c_void,
        MD: *mut llvm_Metadata,
        New: *mut ::std::os::raw::c_void,
    ) -> bool;
}
extern "C" {
    #[doc = " Check whether metadata is replaceable."]
    #[link_name = "\u{1}_ZN4llvm16MetadataTracking13isReplaceableERKNS_8MetadataE"]
    pub fn llvm_MetadataTracking_isReplaceable(MD: *const llvm_Metadata) -> bool;
}
impl llvm_MetadataTracking {
    #[inline]
    pub unsafe fn untrack(Ref: *mut ::std::os::raw::c_void, MD: *mut llvm_Metadata) {
        llvm_MetadataTracking_untrack(Ref, MD)
    }
    #[inline]
    pub unsafe fn retrack(
        Ref: *mut ::std::os::raw::c_void,
        MD: *mut llvm_Metadata,
        New: *mut ::std::os::raw::c_void,
    ) -> bool {
        llvm_MetadataTracking_retrack(Ref, MD, New)
    }
    #[inline]
    pub unsafe fn isReplaceable(MD: *const llvm_Metadata) -> bool {
        llvm_MetadataTracking_isReplaceable(MD)
    }
}
#[doc = " Shared implementation of use-lists for replaceable metadata.\n\n Most metadata cannot be RAUW'ed.  This is a shared implementation of\n use-lists and associated API for the three that support it (\n \\a ValueAsMetadata, \\a TempMDNode, and \\a DIArgList)."]
#[repr(C)]
#[derive(Debug)]
pub struct llvm_ReplaceableMetadataImpl {
    pub Context: *mut llvm_LLVMContext,
    pub NextIndex: u64,
    pub UseMap: [u64; 14usize],
}
#[doc = " A discriminated union of two or more pointer types, with the discriminator\n in the low bit of the pointer.\n\n This implementation is extremely efficient in space due to leveraging the\n low bits of the pointer, while exposing a natural and type-safe API.\n\n Common use patterns would be something like this:\n    PointerUnion<int*, float*> P;\n    P = (int*)0;\n    printf(\"%d %d\", P.is<int*>(), P.is<float*>());  // prints \"1 0\"\n    X = P.get<int*>();     // ok.\n    Y = P.get<float*>();   // runtime assertion failure.\n    Z = P.get<double*>();  // compile time failure.\n    P = (float*)0;\n    Y = P.get<float*>();   // ok.\n    X = P.get<int*>();     // runtime assertion failure.\n    PointerUnion<int*, int*> Q; // compile time failure."]
pub type llvm_ReplaceableMetadataImpl_OwnerTy = llvm_MetadataTracking_OwnerTy;
#[test]
fn bindgen_test_layout_llvm_ReplaceableMetadataImpl() {
    const UNINIT: ::std::mem::MaybeUninit<llvm_ReplaceableMetadataImpl> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<llvm_ReplaceableMetadataImpl>(),
        128usize,
        concat!("Size of: ", stringify!(llvm_ReplaceableMetadataImpl))
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_ReplaceableMetadataImpl>(),
        8usize,
        concat!("Alignment of ", stringify!(llvm_ReplaceableMetadataImpl))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Context) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_ReplaceableMetadataImpl),
            "::",
            stringify!(Context)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).NextIndex) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_ReplaceableMetadataImpl),
            "::",
            stringify!(NextIndex)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).UseMap) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_ReplaceableMetadataImpl),
            "::",
            stringify!(UseMap)
        )
    );
}
extern "C" {
    #[doc = " Replace all uses of this with MD.\n\n Replace all uses of this with \\c MD, which is allowed to be null."]
    #[link_name = "\u{1}_ZN4llvm23ReplaceableMetadataImpl18replaceAllUsesWithEPNS_8MetadataE"]
    pub fn llvm_ReplaceableMetadataImpl_replaceAllUsesWith(
        this: *mut llvm_ReplaceableMetadataImpl,
        MD: *mut llvm_Metadata,
    );
}
extern "C" {
    #[doc = " Replace all uses of the constant with Undef in debug info metadata"]
    #[link_name = "\u{1}_ZN4llvm23ReplaceableMetadataImpl16SalvageDebugInfoERKNS_8ConstantE"]
    pub fn llvm_ReplaceableMetadataImpl_SalvageDebugInfo(C: *const llvm_Constant);
}
extern "C" {
    #[doc = " Returns the list of all DIArgList users of this."]
    #[link_name = "\u{1}_ZN4llvm23ReplaceableMetadataImpl18getAllArgListUsersEv"]
    pub fn llvm_ReplaceableMetadataImpl_getAllArgListUsers(
        this: *mut llvm_ReplaceableMetadataImpl,
    ) -> [u64; 8usize];
}
extern "C" {
    #[doc = " Returns the list of all DbgVariableRecord users of this."]
    #[link_name = "\u{1}_ZN4llvm23ReplaceableMetadataImpl28getAllDbgVariableRecordUsersEv"]
    pub fn llvm_ReplaceableMetadataImpl_getAllDbgVariableRecordUsers(
        this: *mut llvm_ReplaceableMetadataImpl,
    ) -> [u64; 8usize];
}
extern "C" {
    #[doc = " Resolve all uses of this.\n\n Resolve all uses of this, turning off RAUW permanently.  If \\c\n ResolveUsers, call \\a MDNode::resolve() on any users whose last operand\n is resolved."]
    #[link_name = "\u{1}_ZN4llvm23ReplaceableMetadataImpl14resolveAllUsesEb"]
    pub fn llvm_ReplaceableMetadataImpl_resolveAllUses(
        this: *mut llvm_ReplaceableMetadataImpl,
        ResolveUsers: bool,
    );
}
impl llvm_ReplaceableMetadataImpl {
    #[inline]
    pub unsafe fn replaceAllUsesWith(&mut self, MD: *mut llvm_Metadata) {
        llvm_ReplaceableMetadataImpl_replaceAllUsesWith(self, MD)
    }
    #[inline]
    pub unsafe fn SalvageDebugInfo(C: *const llvm_Constant) {
        llvm_ReplaceableMetadataImpl_SalvageDebugInfo(C)
    }
    #[inline]
    pub unsafe fn getAllArgListUsers(&mut self) -> [u64; 8usize] {
        llvm_ReplaceableMetadataImpl_getAllArgListUsers(self)
    }
    #[inline]
    pub unsafe fn getAllDbgVariableRecordUsers(&mut self) -> [u64; 8usize] {
        llvm_ReplaceableMetadataImpl_getAllDbgVariableRecordUsers(self)
    }
    #[inline]
    pub unsafe fn resolveAllUses(&mut self, ResolveUsers: bool) {
        llvm_ReplaceableMetadataImpl_resolveAllUses(self, ResolveUsers)
    }
}
#[doc = " Value wrapper in the Metadata hierarchy.\n\n This is a custom value handle that allows other metadata to refer to\n classes in the Value hierarchy.\n\n Because of full uniquing support, each value is only wrapped by a single \\a\n ValueAsMetadata object, so the lookup maps are far more efficient than\n those using ValueHandleBase."]
#[repr(C)]
#[derive(Debug)]
pub struct llvm_ValueAsMetadata {
    pub _base: llvm_Metadata,
    pub _base_1: llvm_ReplaceableMetadataImpl,
    pub V: *mut llvm_Value,
}
#[test]
fn bindgen_test_layout_llvm_ValueAsMetadata() {
    const UNINIT: ::std::mem::MaybeUninit<llvm_ValueAsMetadata> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<llvm_ValueAsMetadata>(),
        144usize,
        concat!("Size of: ", stringify!(llvm_ValueAsMetadata))
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_ValueAsMetadata>(),
        8usize,
        concat!("Alignment of ", stringify!(llvm_ValueAsMetadata))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).V) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_ValueAsMetadata),
            "::",
            stringify!(V)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm15ValueAsMetadata3getEPNS_5ValueE"]
    pub fn llvm_ValueAsMetadata_get(V: *mut llvm_Value) -> *mut llvm_ValueAsMetadata;
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm15ValueAsMetadata11getIfExistsEPNS_5ValueE"]
    pub fn llvm_ValueAsMetadata_getIfExists(V: *mut llvm_Value) -> *mut llvm_ValueAsMetadata;
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm15ValueAsMetadata14handleDeletionEPNS_5ValueE"]
    pub fn llvm_ValueAsMetadata_handleDeletion(V: *mut llvm_Value);
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm15ValueAsMetadata10handleRAUWEPNS_5ValueES2_"]
    pub fn llvm_ValueAsMetadata_handleRAUW(From: *mut llvm_Value, To: *mut llvm_Value);
}
impl llvm_ValueAsMetadata {
    #[inline]
    pub unsafe fn get(V: *mut llvm_Value) -> *mut llvm_ValueAsMetadata {
        llvm_ValueAsMetadata_get(V)
    }
    #[inline]
    pub unsafe fn getIfExists(V: *mut llvm_Value) -> *mut llvm_ValueAsMetadata {
        llvm_ValueAsMetadata_getIfExists(V)
    }
    #[inline]
    pub unsafe fn handleDeletion(V: *mut llvm_Value) {
        llvm_ValueAsMetadata_handleDeletion(V)
    }
    #[inline]
    pub unsafe fn handleRAUW(From: *mut llvm_Value, To: *mut llvm_Value) {
        llvm_ValueAsMetadata_handleRAUW(From, To)
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct llvm_ConstantAsMetadata {
    pub _base: llvm_ValueAsMetadata,
}
#[test]
fn bindgen_test_layout_llvm_ConstantAsMetadata() {
    assert_eq!(
        ::std::mem::size_of::<llvm_ConstantAsMetadata>(),
        144usize,
        concat!("Size of: ", stringify!(llvm_ConstantAsMetadata))
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_ConstantAsMetadata>(),
        8usize,
        concat!("Alignment of ", stringify!(llvm_ConstantAsMetadata))
    );
}
#[repr(C)]
#[derive(Debug)]
pub struct llvm_LocalAsMetadata {
    pub _base: llvm_ValueAsMetadata,
}
#[test]
fn bindgen_test_layout_llvm_LocalAsMetadata() {
    assert_eq!(
        ::std::mem::size_of::<llvm_LocalAsMetadata>(),
        144usize,
        concat!("Size of: ", stringify!(llvm_LocalAsMetadata))
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_LocalAsMetadata>(),
        8usize,
        concat!("Alignment of ", stringify!(llvm_LocalAsMetadata))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_mdconst_detail_HasDereference {
    pub _address: u8,
}
pub type llvm_mdconst_detail_HasDereference_Yes = [::std::os::raw::c_char; 1usize];
pub type llvm_mdconst_detail_HasDereference_No = [::std::os::raw::c_char; 2usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_mdconst_detail_IsValidPointer {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_mdconst_detail_IsValidReference {
    pub _address: u8,
}
#[doc = " A single uniqued string.\n\n These are used to efficiently contain a byte sequence for metadata.\n MDString is always unnamed."]
#[repr(C)]
#[derive(Debug)]
pub struct llvm_MDString {
    pub _base: llvm_Metadata,
    pub Entry: *mut llvm_StringMapEntry<llvm_MDString>,
}
pub type llvm_MDString_iterator = llvm_StringRef_iterator;
#[test]
fn bindgen_test_layout_llvm_MDString() {
    const UNINIT: ::std::mem::MaybeUninit<llvm_MDString> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<llvm_MDString>(),
        16usize,
        concat!("Size of: ", stringify!(llvm_MDString))
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_MDString>(),
        8usize,
        concat!("Alignment of ", stringify!(llvm_MDString))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Entry) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_MDString),
            "::",
            stringify!(Entry)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm8MDString3getERNS_11LLVMContextENS_9StringRefE"]
    pub fn llvm_MDString_get(
        Context: *mut llvm_LLVMContext,
        Str: llvm_StringRef,
    ) -> *mut llvm_MDString;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4llvm8MDString9getStringEv"]
    pub fn llvm_MDString_getString(this: *const llvm_MDString) -> llvm_StringRef;
}
impl llvm_MDString {
    #[inline]
    pub unsafe fn get(Context: *mut llvm_LLVMContext, Str: llvm_StringRef) -> *mut llvm_MDString {
        llvm_MDString_get(Context, Str)
    }
    #[inline]
    pub unsafe fn getString(&self) -> llvm_StringRef {
        llvm_MDString_getString(self)
    }
}
#[doc = " A collection of metadata nodes that might be associated with a\n memory access used by the alias-analysis infrastructure."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_AAMDNodes {
    #[doc = " The tag for type-based alias analysis."]
    pub TBAA: *mut llvm_MDNode,
    #[doc = " The tag for type-based alias analysis (tbaa struct)."]
    pub TBAAStruct: *mut llvm_MDNode,
    #[doc = " The tag for alias scope specification (used with noalias)."]
    pub Scope: *mut llvm_MDNode,
    #[doc = " The tag specifying the noalias scope."]
    pub NoAlias: *mut llvm_MDNode,
}
#[test]
fn bindgen_test_layout_llvm_AAMDNodes() {
    const UNINIT: ::std::mem::MaybeUninit<llvm_AAMDNodes> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<llvm_AAMDNodes>(),
        32usize,
        concat!("Size of: ", stringify!(llvm_AAMDNodes))
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_AAMDNodes>(),
        8usize,
        concat!("Alignment of ", stringify!(llvm_AAMDNodes))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).TBAA) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_AAMDNodes),
            "::",
            stringify!(TBAA)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).TBAAStruct) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_AAMDNodes),
            "::",
            stringify!(TBAAStruct)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Scope) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_AAMDNodes),
            "::",
            stringify!(Scope)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).NoAlias) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_AAMDNodes),
            "::",
            stringify!(NoAlias)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm9AAMDNodes9shiftTBAAEPNS_6MDNodeEm"]
    pub fn llvm_AAMDNodes_shiftTBAA(M: *mut llvm_MDNode, off: usize) -> *mut llvm_MDNode;
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm9AAMDNodes15shiftTBAAStructEPNS_6MDNodeEm"]
    pub fn llvm_AAMDNodes_shiftTBAAStruct(M: *mut llvm_MDNode, off: usize) -> *mut llvm_MDNode;
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm9AAMDNodes12extendToTBAAEPNS_6MDNodeEl"]
    pub fn llvm_AAMDNodes_extendToTBAA(TBAA: *mut llvm_MDNode, len: isize) -> *mut llvm_MDNode;
}
extern "C" {
    #[doc = " Given two sets of AAMDNodes applying to potentially different locations,\n determine the best AAMDNodes that apply to both."]
    #[link_name = "\u{1}_ZNK4llvm9AAMDNodes5mergeERKS0_"]
    pub fn llvm_AAMDNodes_merge(
        this: *const llvm_AAMDNodes,
        Other: *const llvm_AAMDNodes,
    ) -> llvm_AAMDNodes;
}
extern "C" {
    #[doc = " Determine the best AAMDNodes after concatenating two different locations\n together. Different from `merge`, where different locations should\n overlap each other, `concat` puts non-overlapping locations together."]
    #[link_name = "\u{1}_ZNK4llvm9AAMDNodes6concatERKS0_"]
    pub fn llvm_AAMDNodes_concat(
        this: *const llvm_AAMDNodes,
        Other: *const llvm_AAMDNodes,
    ) -> llvm_AAMDNodes;
}
extern "C" {
    #[doc = " Create a new AAMDNode for accessing \\p AccessSize bytes of this AAMDNode.\n If this AAMDNode has !tbaa.struct and \\p AccessSize matches the size of\n the field at offset 0, get the TBAA tag describing the accessed field.\n If such an AAMDNode already embeds !tbaa, the existing one is retrieved.\n Finally, !tbaa.struct is zeroed out."]
    #[link_name = "\u{1}_ZN4llvm9AAMDNodes15adjustForAccessEj"]
    pub fn llvm_AAMDNodes_adjustForAccess(
        this: *mut llvm_AAMDNodes,
        AccessSize: ::std::os::raw::c_uint,
    ) -> llvm_AAMDNodes;
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm9AAMDNodes15adjustForAccessEmPNS_4TypeERKNS_10DataLayoutE"]
    pub fn llvm_AAMDNodes_adjustForAccess1(
        this: *mut llvm_AAMDNodes,
        Offset: usize,
        AccessTy: *mut llvm_Type,
        DL: *const llvm_DataLayout,
    ) -> llvm_AAMDNodes;
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm9AAMDNodes15adjustForAccessEmj"]
    pub fn llvm_AAMDNodes_adjustForAccess2(
        this: *mut llvm_AAMDNodes,
        Offset: usize,
        AccessSize: ::std::os::raw::c_uint,
    ) -> llvm_AAMDNodes;
}
impl llvm_AAMDNodes {
    #[inline]
    pub unsafe fn shiftTBAA(M: *mut llvm_MDNode, off: usize) -> *mut llvm_MDNode {
        llvm_AAMDNodes_shiftTBAA(M, off)
    }
    #[inline]
    pub unsafe fn shiftTBAAStruct(M: *mut llvm_MDNode, off: usize) -> *mut llvm_MDNode {
        llvm_AAMDNodes_shiftTBAAStruct(M, off)
    }
    #[inline]
    pub unsafe fn extendToTBAA(TBAA: *mut llvm_MDNode, len: isize) -> *mut llvm_MDNode {
        llvm_AAMDNodes_extendToTBAA(TBAA, len)
    }
    #[inline]
    pub unsafe fn merge(&self, Other: *const llvm_AAMDNodes) -> llvm_AAMDNodes {
        llvm_AAMDNodes_merge(self, Other)
    }
    #[inline]
    pub unsafe fn concat(&self, Other: *const llvm_AAMDNodes) -> llvm_AAMDNodes {
        llvm_AAMDNodes_concat(self, Other)
    }
    #[inline]
    pub unsafe fn adjustForAccess(&mut self, AccessSize: ::std::os::raw::c_uint) -> llvm_AAMDNodes {
        llvm_AAMDNodes_adjustForAccess(self, AccessSize)
    }
    #[inline]
    pub unsafe fn adjustForAccess1(
        &mut self,
        Offset: usize,
        AccessTy: *mut llvm_Type,
        DL: *const llvm_DataLayout,
    ) -> llvm_AAMDNodes {
        llvm_AAMDNodes_adjustForAccess1(self, Offset, AccessTy, DL)
    }
    #[inline]
    pub unsafe fn adjustForAccess2(
        &mut self,
        Offset: usize,
        AccessSize: ::std::os::raw::c_uint,
    ) -> llvm_AAMDNodes {
        llvm_AAMDNodes_adjustForAccess2(self, Offset, AccessSize)
    }
}
#[test]
fn __bindgen_test_layout_llvm_DenseMapInfo_open0_llvm_AAMDNodes_void_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<llvm_DenseMapInfo>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_DenseMapInfo)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_DenseMapInfo>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_DenseMapInfo)
        )
    );
}
#[doc = " Tracking metadata reference owned by Metadata.\n\n Similar to \\a TrackingMDRef, but it's expected to be owned by an instance\n of \\a Metadata, which has the option of registering itself for callbacks to\n re-unique itself.\n\n In particular, this is used by \\a MDNode."]
#[repr(C)]
#[derive(Debug)]
pub struct llvm_MDOperand {
    pub MD: *mut llvm_Metadata,
}
#[test]
fn bindgen_test_layout_llvm_MDOperand() {
    const UNINIT: ::std::mem::MaybeUninit<llvm_MDOperand> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<llvm_MDOperand>(),
        8usize,
        concat!("Size of: ", stringify!(llvm_MDOperand))
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_MDOperand>(),
        8usize,
        concat!("Alignment of ", stringify!(llvm_MDOperand))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).MD) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_MDOperand),
            "::",
            stringify!(MD)
        )
    );
}
#[test]
fn __bindgen_test_layout_llvm_simplify_type_open0_llvm_MDOperand_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<llvm_simplify_type>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_simplify_type)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_simplify_type>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_simplify_type)
        )
    );
}
#[test]
fn __bindgen_test_layout_llvm_simplify_type_open0_llvm_MDOperand_close0_instantiation_1() {
    assert_eq!(
        ::std::mem::size_of::<llvm_simplify_type>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_simplify_type)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_simplify_type>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_simplify_type)
        )
    );
}
#[doc = " Pointer to the context, with optional RAUW support.\n\n Either a raw (non-null) pointer to the \\a LLVMContext, or an owned pointer\n to \\a ReplaceableMetadataImpl (which has a reference to \\a LLVMContext)."]
#[repr(C)]
#[derive(Debug)]
pub struct llvm_ContextAndReplaceableUses {
    pub Ptr: llvm_PointerUnion,
}
#[test]
fn bindgen_test_layout_llvm_ContextAndReplaceableUses() {
    const UNINIT: ::std::mem::MaybeUninit<llvm_ContextAndReplaceableUses> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<llvm_ContextAndReplaceableUses>(),
        8usize,
        concat!("Size of: ", stringify!(llvm_ContextAndReplaceableUses))
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_ContextAndReplaceableUses>(),
        8usize,
        concat!("Alignment of ", stringify!(llvm_ContextAndReplaceableUses))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Ptr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_ContextAndReplaceableUses),
            "::",
            stringify!(Ptr)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_TempMDNodeDeleter {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_llvm_TempMDNodeDeleter() {
    assert_eq!(
        ::std::mem::size_of::<llvm_TempMDNodeDeleter>(),
        1usize,
        concat!("Size of: ", stringify!(llvm_TempMDNodeDeleter))
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_TempMDNodeDeleter>(),
        1usize,
        concat!("Alignment of ", stringify!(llvm_TempMDNodeDeleter))
    );
}
pub type llvm_TempMDNode = std_unique_ptr;
pub type llvm_TempMDTuple = std_unique_ptr;
pub type llvm_TempDILocation = std_unique_ptr;
pub type llvm_TempDIExpression = std_unique_ptr;
pub type llvm_TempDIGlobalVariableExpression = std_unique_ptr;
pub type llvm_TempDINode = std_unique_ptr;
pub type llvm_TempGenericDINode = std_unique_ptr;
pub type llvm_TempDISubrange = std_unique_ptr;
pub type llvm_TempDIEnumerator = std_unique_ptr;
pub type llvm_TempDIScope = std_unique_ptr;
pub type llvm_TempDIType = std_unique_ptr;
pub type llvm_TempDIBasicType = std_unique_ptr;
pub type llvm_TempDIDerivedType = std_unique_ptr;
pub type llvm_TempDICompositeType = std_unique_ptr;
pub type llvm_TempDISubroutineType = std_unique_ptr;
pub type llvm_TempDIFile = std_unique_ptr;
pub type llvm_TempDICompileUnit = std_unique_ptr;
pub type llvm_TempDILocalScope = std_unique_ptr;
pub type llvm_TempDISubprogram = std_unique_ptr;
pub type llvm_TempDILexicalBlockBase = std_unique_ptr;
pub type llvm_TempDILexicalBlock = std_unique_ptr;
pub type llvm_TempDILexicalBlockFile = std_unique_ptr;
pub type llvm_TempDINamespace = std_unique_ptr;
pub type llvm_TempDIModule = std_unique_ptr;
pub type llvm_TempDITemplateParameter = std_unique_ptr;
pub type llvm_TempDITemplateTypeParameter = std_unique_ptr;
pub type llvm_TempDITemplateValueParameter = std_unique_ptr;
pub type llvm_TempDIVariable = std_unique_ptr;
pub type llvm_TempDIGlobalVariable = std_unique_ptr;
pub type llvm_TempDILocalVariable = std_unique_ptr;
pub type llvm_TempDILabel = std_unique_ptr;
pub type llvm_TempDIObjCProperty = std_unique_ptr;
pub type llvm_TempDIImportedEntity = std_unique_ptr;
pub type llvm_TempDIAssignID = std_unique_ptr;
pub type llvm_TempDIMacroNode = std_unique_ptr;
pub type llvm_TempDIMacro = std_unique_ptr;
pub type llvm_TempDIMacroFile = std_unique_ptr;
pub type llvm_TempDICommonBlock = std_unique_ptr;
pub type llvm_TempDIStringType = std_unique_ptr;
pub type llvm_TempDIGenericSubrange = std_unique_ptr;
#[doc = " Metadata node.\n\n Metadata nodes can be uniqued, like constants, or distinct.  Temporary\n metadata nodes (with full support for RAUW) can be used to delay uniquing\n until forward references are known.  The basic metadata node is an \\a\n MDTuple.\n\n There is limited support for RAUW at construction time.  At construction\n time, if any operand is a temporary node (or an unresolved uniqued node,\n which indicates a transitive temporary operand), the node itself will be\n unresolved.  As soon as all operands become resolved, it will drop RAUW\n support permanently.\n\n If an unresolved node is part of a cycle, \\a resolveCycles() needs\n to be called on some member of the cycle once all temporary nodes have been\n replaced.\n\n MDNodes can be large or small, as well as resizable or non-resizable.\n Large MDNodes' operands are allocated in a separate storage vector,\n whereas small MDNodes' operands are co-allocated. Distinct and temporary\n MDnodes are resizable, but only MDTuples support this capability.\n\n Clients can add operands to resizable MDNodes using push_back()."]
#[repr(C)]
#[derive(Debug)]
pub struct llvm_MDNode {
    pub _base: llvm_Metadata,
    pub Context: llvm_ContextAndReplaceableUses,
}
#[doc = " The header that is coallocated with an MDNode along with its \"small\"\n operands. It is located immediately before the main body of the node.\n The operands are in turn located immediately before the header.\n For resizable MDNodes, the space for the storage vector is also allocated\n immediately before the header, overlapping with the operands.\n Explicity set alignment because bitfields by default have an\n alignment of 1 on z/OS."]
#[repr(C)]
#[repr(align(8))]
#[derive(Debug)]
pub struct llvm_MDNode_Header {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
    pub NumUnresolved: ::std::os::raw::c_uint,
}
#[doc = " Forward declaration of SmallVector so that\n calculateSmallVectorDefaultInlinedElements can reference\n `sizeof(SmallVector<T, 0>)`."]
pub type llvm_MDNode_Header_LargeStorageVector = [u64; 2usize];
pub const llvm_MDNode_Header_NumOpsFitInVector: usize = 2;
pub const llvm_MDNode_Header_MaxSmallSize: usize = 15;
#[test]
fn bindgen_test_layout_llvm_MDNode_Header() {
    const UNINIT: ::std::mem::MaybeUninit<llvm_MDNode_Header> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<llvm_MDNode_Header>(),
        16usize,
        concat!("Size of: ", stringify!(llvm_MDNode_Header))
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_MDNode_Header>(),
        8usize,
        concat!("Alignment of ", stringify!(llvm_MDNode_Header))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).NumUnresolved) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_MDNode_Header),
            "::",
            stringify!(NumUnresolved)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm6MDNode6Header11getSmallPtrEv"]
    pub fn llvm_MDNode_Header_getSmallPtr(
        this: *mut llvm_MDNode_Header,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm6MDNode6Header11resizeSmallEm"]
    pub fn llvm_MDNode_Header_resizeSmall(this: *mut llvm_MDNode_Header, NumOps: usize);
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm6MDNode6Header18resizeSmallToLargeEm"]
    pub fn llvm_MDNode_Header_resizeSmallToLarge(this: *mut llvm_MDNode_Header, NumOps: usize);
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm6MDNode6Header6resizeEm"]
    pub fn llvm_MDNode_Header_resize(this: *mut llvm_MDNode_Header, NumOps: usize);
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm6MDNode6HeaderC1EmNS_8Metadata11StorageTypeE"]
    pub fn llvm_MDNode_Header_Header(
        this: *mut llvm_MDNode_Header,
        NumOps: usize,
        Storage: llvm_Metadata_StorageType,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm6MDNode6HeaderD1Ev"]
    pub fn llvm_MDNode_Header_Header_destructor(this: *mut llvm_MDNode_Header);
}
impl llvm_MDNode_Header {
    #[inline]
    pub fn IsResizable(&self) -> bool {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_IsResizable(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn IsLarge(&self) -> bool {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_IsLarge(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SmallSize(&self) -> usize {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 4u8) as u64) }
    }
    #[inline]
    pub fn set_SmallSize(&mut self, val: usize) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn SmallNumOps(&self) -> usize {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 4u8) as u64) }
    }
    #[inline]
    pub fn set_SmallNumOps(&mut self, val: usize) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        IsResizable: bool,
        IsLarge: bool,
        SmallSize: usize,
        SmallNumOps: usize,
    ) -> __BindgenBitfieldUnit<[u8; 8usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let IsResizable: u8 = unsafe { ::std::mem::transmute(IsResizable) };
            IsResizable as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let IsLarge: u8 = unsafe { ::std::mem::transmute(IsLarge) };
            IsLarge as u64
        });
        __bindgen_bitfield_unit.set(2usize, 4u8, {
            let SmallSize: u64 = unsafe { ::std::mem::transmute(SmallSize) };
            SmallSize as u64
        });
        __bindgen_bitfield_unit.set(6usize, 4u8, {
            let SmallNumOps: u64 = unsafe { ::std::mem::transmute(SmallNumOps) };
            SmallNumOps as u64
        });
        __bindgen_bitfield_unit
    }
    #[inline]
    pub unsafe fn getSmallPtr(&mut self) -> *mut ::std::os::raw::c_void {
        llvm_MDNode_Header_getSmallPtr(self)
    }
    #[inline]
    pub unsafe fn resizeSmall(&mut self, NumOps: usize) {
        llvm_MDNode_Header_resizeSmall(self, NumOps)
    }
    #[inline]
    pub unsafe fn resizeSmallToLarge(&mut self, NumOps: usize) {
        llvm_MDNode_Header_resizeSmallToLarge(self, NumOps)
    }
    #[inline]
    pub unsafe fn resize(&mut self, NumOps: usize) {
        llvm_MDNode_Header_resize(self, NumOps)
    }
    #[inline]
    pub unsafe fn new(NumOps: usize, Storage: llvm_Metadata_StorageType) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        llvm_MDNode_Header_Header(__bindgen_tmp.as_mut_ptr(), NumOps, Storage);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn destruct(&mut self) {
        llvm_MDNode_Header_Header_destructor(self)
    }
}
#[doc = " A range adaptor for a pair of iterators.\n\n This just wraps two iterators into a range-compatible interface. Nothing\n fancy at all."]
pub type llvm_MDNode_mutable_op_range = llvm_iterator_range<*mut llvm_MDOperand>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_MDNode_HasCachedHash {
    pub _address: u8,
}
pub type llvm_MDNode_op_iterator = *const llvm_MDOperand;
pub type llvm_MDNode_op_range = llvm_iterator_range<llvm_MDNode_op_iterator>;
#[test]
fn bindgen_test_layout_llvm_MDNode() {
    const UNINIT: ::std::mem::MaybeUninit<llvm_MDNode> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<llvm_MDNode>(),
        16usize,
        concat!("Size of: ", stringify!(llvm_MDNode))
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_MDNode>(),
        8usize,
        concat!("Alignment of ", stringify!(llvm_MDNode))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Context) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_MDNode),
            "::",
            stringify!(Context)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm6MDNode17dropAllReferencesEv"]
    pub fn llvm_MDNode_dropAllReferences(this: *mut llvm_MDNode);
}
extern "C" {
    #[doc = " Create a (temporary) clone of this."]
    #[link_name = "\u{1}_ZNK4llvm6MDNode5cloneEv"]
    pub fn llvm_MDNode_clone(this: *const llvm_MDNode) -> llvm_TempMDNode;
}
extern "C" {
    #[doc = " Deallocate a node created by getTemporary.\n\n Calls \\c replaceAllUsesWith(nullptr) before deleting, so any remaining\n references will be reset."]
    #[link_name = "\u{1}_ZN4llvm6MDNode15deleteTemporaryEPS0_"]
    pub fn llvm_MDNode_deleteTemporary(N: *mut llvm_MDNode);
}
extern "C" {
    #[doc = " Replace a specific operand."]
    #[link_name = "\u{1}_ZN4llvm6MDNode18replaceOperandWithEjPNS_8MetadataE"]
    pub fn llvm_MDNode_replaceOperandWith(
        this: *mut llvm_MDNode,
        I: ::std::os::raw::c_uint,
        New: *mut llvm_Metadata,
    );
}
extern "C" {
    #[doc = " Resolve cycles.\n\n Once all forward declarations have been resolved, force cycles to be\n resolved.\n\n \\pre No operands (or operands' operands, etc.) have \\a isTemporary()."]
    #[link_name = "\u{1}_ZN4llvm6MDNode13resolveCyclesEv"]
    pub fn llvm_MDNode_resolveCycles(this: *mut llvm_MDNode);
}
extern "C" {
    #[doc = " Resolve a unique, unresolved node."]
    #[link_name = "\u{1}_ZN4llvm6MDNode7resolveEv"]
    pub fn llvm_MDNode_resolve(this: *mut llvm_MDNode);
}
extern "C" {
    #[doc = " Print in tree shape.\n\n Prints definition of \\c this in tree shape.\n\n If \\c M is provided, metadata nodes will be numbered canonically;\n otherwise, pointer addresses are substituted.\n @{"]
    #[link_name = "\u{1}_ZNK4llvm6MDNode9printTreeERNS_11raw_ostreamEPKNS_6ModuleE"]
    pub fn llvm_MDNode_printTree(
        this: *const llvm_MDNode,
        OS: *mut llvm_raw_ostream,
        M: *const llvm_Module,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK4llvm6MDNode9printTreeERNS_11raw_ostreamERNS_17ModuleSlotTrackerEPKNS_6ModuleE"]
    pub fn llvm_MDNode_printTree1(
        this: *const llvm_MDNode,
        OS: *mut llvm_raw_ostream,
        MST: *mut llvm_ModuleSlotTracker,
        M: *const llvm_Module,
    );
}
extern "C" {
    #[doc = " User-friendly dump in tree shape.\n\n If \\c M is provided, metadata nodes will be numbered canonically;\n otherwise, pointer addresses are substituted.\n\n Note: this uses an explicit overload instead of default arguments so that\n the nullptr version is easy to call from a debugger.\n\n @{"]
    #[link_name = "\u{1}_ZNK4llvm6MDNode8dumpTreeEv"]
    pub fn llvm_MDNode_dumpTree(this: *const llvm_MDNode);
}
extern "C" {
    #[link_name = "\u{1}_ZNK4llvm6MDNode8dumpTreeEPKNS_6ModuleE"]
    pub fn llvm_MDNode_dumpTree1(this: *const llvm_MDNode, M: *const llvm_Module);
}
extern "C" {
    #[doc = " Set an operand.\n\n Sets the operand directly, without worrying about uniquing."]
    #[link_name = "\u{1}_ZN4llvm6MDNode10setOperandEjPNS_8MetadataE"]
    pub fn llvm_MDNode_setOperand(
        this: *mut llvm_MDNode,
        I: ::std::os::raw::c_uint,
        New: *mut llvm_Metadata,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm6MDNode22storeDistinctInContextEv"]
    pub fn llvm_MDNode_storeDistinctInContext(this: *mut llvm_MDNode);
}
extern "C" {
    #[doc = " Check whether MDNode is a vtable access."]
    #[link_name = "\u{1}_ZNK4llvm6MDNode18isTBAAVtableAccessEv"]
    pub fn llvm_MDNode_isTBAAVtableAccess(this: *const llvm_MDNode) -> bool;
}
extern "C" {
    #[doc = " Methods for metadata merging."]
    #[link_name = "\u{1}_ZN4llvm6MDNode11concatenateEPS0_S1_"]
    pub fn llvm_MDNode_concatenate(A: *mut llvm_MDNode, B: *mut llvm_MDNode) -> *mut llvm_MDNode;
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm6MDNode9intersectEPS0_S1_"]
    pub fn llvm_MDNode_intersect(A: *mut llvm_MDNode, B: *mut llvm_MDNode) -> *mut llvm_MDNode;
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm6MDNode18getMostGenericTBAAEPS0_S1_"]
    pub fn llvm_MDNode_getMostGenericTBAA(
        A: *mut llvm_MDNode,
        B: *mut llvm_MDNode,
    ) -> *mut llvm_MDNode;
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm6MDNode20getMostGenericFPMathEPS0_S1_"]
    pub fn llvm_MDNode_getMostGenericFPMath(
        A: *mut llvm_MDNode,
        B: *mut llvm_MDNode,
    ) -> *mut llvm_MDNode;
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm6MDNode19getMostGenericRangeEPS0_S1_"]
    pub fn llvm_MDNode_getMostGenericRange(
        A: *mut llvm_MDNode,
        B: *mut llvm_MDNode,
    ) -> *mut llvm_MDNode;
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm6MDNode24getMostGenericAliasScopeEPS0_S1_"]
    pub fn llvm_MDNode_getMostGenericAliasScope(
        A: *mut llvm_MDNode,
        B: *mut llvm_MDNode,
    ) -> *mut llvm_MDNode;
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm6MDNode40getMostGenericAlignmentOrDereferenceableEPS0_S1_"]
    pub fn llvm_MDNode_getMostGenericAlignmentOrDereferenceable(
        A: *mut llvm_MDNode,
        B: *mut llvm_MDNode,
    ) -> *mut llvm_MDNode;
}
extern "C" {
    #[doc = " Merge !prof metadata from two instructions.\n Currently only implemented with direct callsites with branch weights."]
    #[link_name = "\u{1}_ZN4llvm6MDNode21getMergedProfMetadataEPS0_S1_PKNS_11InstructionES4_"]
    pub fn llvm_MDNode_getMergedProfMetadata(
        A: *mut llvm_MDNode,
        B: *mut llvm_MDNode,
        AInstr: *const llvm_Instruction,
        BInstr: *const llvm_Instruction,
    ) -> *mut llvm_MDNode;
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm6MDNodeC1ERNS_11LLVMContextEjNS_8Metadata11StorageTypeENS_8ArrayRefIPS3_EES7_"]
    pub fn llvm_MDNode_MDNode(
        this: *mut llvm_MDNode,
        Context: *mut llvm_LLVMContext,
        ID: ::std::os::raw::c_uint,
        Storage: llvm_Metadata_StorageType,
        Ops1: llvm_ArrayRef<*mut llvm_Metadata>,
        Ops2: llvm_ArrayRef<*mut llvm_Metadata>,
    );
}
impl llvm_MDNode {
    #[inline]
    pub unsafe fn dropAllReferences(&mut self) {
        llvm_MDNode_dropAllReferences(self)
    }
    #[inline]
    pub unsafe fn clone(&self) -> llvm_TempMDNode {
        llvm_MDNode_clone(self)
    }
    #[inline]
    pub unsafe fn deleteTemporary(N: *mut llvm_MDNode) {
        llvm_MDNode_deleteTemporary(N)
    }
    #[inline]
    pub unsafe fn replaceOperandWith(
        &mut self,
        I: ::std::os::raw::c_uint,
        New: *mut llvm_Metadata,
    ) {
        llvm_MDNode_replaceOperandWith(self, I, New)
    }
    #[inline]
    pub unsafe fn resolveCycles(&mut self) {
        llvm_MDNode_resolveCycles(self)
    }
    #[inline]
    pub unsafe fn resolve(&mut self) {
        llvm_MDNode_resolve(self)
    }
    #[inline]
    pub unsafe fn printTree(&self, OS: *mut llvm_raw_ostream, M: *const llvm_Module) {
        llvm_MDNode_printTree(self, OS, M)
    }
    #[inline]
    pub unsafe fn printTree1(
        &self,
        OS: *mut llvm_raw_ostream,
        MST: *mut llvm_ModuleSlotTracker,
        M: *const llvm_Module,
    ) {
        llvm_MDNode_printTree1(self, OS, MST, M)
    }
    #[inline]
    pub unsafe fn dumpTree(&self) {
        llvm_MDNode_dumpTree(self)
    }
    #[inline]
    pub unsafe fn dumpTree1(&self, M: *const llvm_Module) {
        llvm_MDNode_dumpTree1(self, M)
    }
    #[inline]
    pub unsafe fn setOperand(&mut self, I: ::std::os::raw::c_uint, New: *mut llvm_Metadata) {
        llvm_MDNode_setOperand(self, I, New)
    }
    #[inline]
    pub unsafe fn storeDistinctInContext(&mut self) {
        llvm_MDNode_storeDistinctInContext(self)
    }
    #[inline]
    pub unsafe fn isTBAAVtableAccess(&self) -> bool {
        llvm_MDNode_isTBAAVtableAccess(self)
    }
    #[inline]
    pub unsafe fn concatenate(A: *mut llvm_MDNode, B: *mut llvm_MDNode) -> *mut llvm_MDNode {
        llvm_MDNode_concatenate(A, B)
    }
    #[inline]
    pub unsafe fn intersect(A: *mut llvm_MDNode, B: *mut llvm_MDNode) -> *mut llvm_MDNode {
        llvm_MDNode_intersect(A, B)
    }
    #[inline]
    pub unsafe fn getMostGenericTBAA(A: *mut llvm_MDNode, B: *mut llvm_MDNode) -> *mut llvm_MDNode {
        llvm_MDNode_getMostGenericTBAA(A, B)
    }
    #[inline]
    pub unsafe fn getMostGenericFPMath(
        A: *mut llvm_MDNode,
        B: *mut llvm_MDNode,
    ) -> *mut llvm_MDNode {
        llvm_MDNode_getMostGenericFPMath(A, B)
    }
    #[inline]
    pub unsafe fn getMostGenericRange(
        A: *mut llvm_MDNode,
        B: *mut llvm_MDNode,
    ) -> *mut llvm_MDNode {
        llvm_MDNode_getMostGenericRange(A, B)
    }
    #[inline]
    pub unsafe fn getMostGenericAliasScope(
        A: *mut llvm_MDNode,
        B: *mut llvm_MDNode,
    ) -> *mut llvm_MDNode {
        llvm_MDNode_getMostGenericAliasScope(A, B)
    }
    #[inline]
    pub unsafe fn getMostGenericAlignmentOrDereferenceable(
        A: *mut llvm_MDNode,
        B: *mut llvm_MDNode,
    ) -> *mut llvm_MDNode {
        llvm_MDNode_getMostGenericAlignmentOrDereferenceable(A, B)
    }
    #[inline]
    pub unsafe fn getMergedProfMetadata(
        A: *mut llvm_MDNode,
        B: *mut llvm_MDNode,
        AInstr: *const llvm_Instruction,
        BInstr: *const llvm_Instruction,
    ) -> *mut llvm_MDNode {
        llvm_MDNode_getMergedProfMetadata(A, B, AInstr, BInstr)
    }
    #[inline]
    pub unsafe fn new(
        Context: *mut llvm_LLVMContext,
        ID: ::std::os::raw::c_uint,
        Storage: llvm_Metadata_StorageType,
        Ops1: llvm_ArrayRef<*mut llvm_Metadata>,
        Ops2: llvm_ArrayRef<*mut llvm_Metadata>,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        llvm_MDNode_MDNode(__bindgen_tmp.as_mut_ptr(), Context, ID, Storage, Ops1, Ops2);
        __bindgen_tmp.assume_init()
    }
}
#[doc = " Tuple of metadata.\n\n This is the simple \\a MDNode arbitrary tuple.  Nodes are uniqued by\n default based on their operands."]
#[repr(C)]
#[derive(Debug)]
pub struct llvm_MDTuple {
    pub _base: llvm_MDNode,
}
#[test]
fn bindgen_test_layout_llvm_MDTuple() {
    assert_eq!(
        ::std::mem::size_of::<llvm_MDTuple>(),
        16usize,
        concat!("Size of: ", stringify!(llvm_MDTuple))
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_MDTuple>(),
        8usize,
        concat!("Alignment of ", stringify!(llvm_MDTuple))
    );
}
#[doc = " This is a simple wrapper around an MDNode which provides a higher-level\n interface by hiding the details of how alias analysis information is encoded\n in its operands."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_AliasScopeNode {
    pub Node: *const llvm_MDNode,
}
#[test]
fn bindgen_test_layout_llvm_AliasScopeNode() {
    const UNINIT: ::std::mem::MaybeUninit<llvm_AliasScopeNode> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<llvm_AliasScopeNode>(),
        8usize,
        concat!("Size of: ", stringify!(llvm_AliasScopeNode))
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_AliasScopeNode>(),
        8usize,
        concat!("Alignment of ", stringify!(llvm_AliasScopeNode))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Node) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_AliasScopeNode),
            "::",
            stringify!(Node)
        )
    );
}
#[doc = " Typed iterator through MDNode operands.\n\n An iterator that transforms an \\a MDNode::iterator into an iterator over a\n particular Metadata subclass."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_TypedMDOperandIterator {
    pub I: llvm_MDNode_op_iterator,
}
pub type llvm_TypedMDOperandIterator_iterator_category = std_input_iterator_tag;
pub type llvm_TypedMDOperandIterator_value_type<T> = *mut T;
pub type llvm_TypedMDOperandIterator_difference_type = isize;
pub type llvm_TypedMDOperandIterator_pointer = ::std::os::raw::c_void;
pub type llvm_TypedMDOperandIterator_reference<T> = *mut T;
#[doc = " Typed, array-like tuple of metadata.\n\n This is a wrapper for \\a MDTuple that makes it act like an array holding a\n particular type of metadata."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_MDTupleTypedArrayWrapper {
    pub N: *const llvm_MDTuple,
}
#[doc = " Typed iterator through MDNode operands.\n\n An iterator that transforms an \\a MDNode::iterator into an iterator over a\n particular Metadata subclass."]
pub type llvm_MDTupleTypedArrayWrapper_iterator = llvm_TypedMDOperandIterator;
pub type llvm_MDStringArray = llvm_MDTupleTypedArrayWrapper;
pub type llvm_ValueAsMetadataArray = llvm_MDTupleTypedArrayWrapper;
pub type llvm_ConstantAsMetadataArray = llvm_MDTupleTypedArrayWrapper;
pub type llvm_LocalAsMetadataArray = llvm_MDTupleTypedArrayWrapper;
pub type llvm_DistinctMDOperandPlaceholderArray = llvm_MDTupleTypedArrayWrapper;
pub type llvm_DIArgListArray = llvm_MDTupleTypedArrayWrapper;
pub type llvm_MDNodeArray = llvm_MDTupleTypedArrayWrapper;
pub type llvm_MDTupleArray = llvm_MDTupleTypedArrayWrapper;
pub type llvm_DILocationArray = llvm_MDTupleTypedArrayWrapper;
pub type llvm_DIExpressionArray = llvm_MDTupleTypedArrayWrapper;
pub type llvm_DIGlobalVariableExpressionArray = llvm_MDTupleTypedArrayWrapper;
pub type llvm_DINodeArray = llvm_MDTupleTypedArrayWrapper;
pub type llvm_GenericDINodeArray = llvm_MDTupleTypedArrayWrapper;
pub type llvm_DISubrangeArray = llvm_MDTupleTypedArrayWrapper;
pub type llvm_DIEnumeratorArray = llvm_MDTupleTypedArrayWrapper;
pub type llvm_DIScopeArray = llvm_MDTupleTypedArrayWrapper;
pub type llvm_DITypeArray = llvm_MDTupleTypedArrayWrapper;
pub type llvm_DIBasicTypeArray = llvm_MDTupleTypedArrayWrapper;
pub type llvm_DIDerivedTypeArray = llvm_MDTupleTypedArrayWrapper;
pub type llvm_DICompositeTypeArray = llvm_MDTupleTypedArrayWrapper;
pub type llvm_DISubroutineTypeArray = llvm_MDTupleTypedArrayWrapper;
pub type llvm_DIFileArray = llvm_MDTupleTypedArrayWrapper;
pub type llvm_DICompileUnitArray = llvm_MDTupleTypedArrayWrapper;
pub type llvm_DILocalScopeArray = llvm_MDTupleTypedArrayWrapper;
pub type llvm_DISubprogramArray = llvm_MDTupleTypedArrayWrapper;
pub type llvm_DILexicalBlockBaseArray = llvm_MDTupleTypedArrayWrapper;
pub type llvm_DILexicalBlockArray = llvm_MDTupleTypedArrayWrapper;
pub type llvm_DILexicalBlockFileArray = llvm_MDTupleTypedArrayWrapper;
pub type llvm_DINamespaceArray = llvm_MDTupleTypedArrayWrapper;
pub type llvm_DIModuleArray = llvm_MDTupleTypedArrayWrapper;
pub type llvm_DITemplateParameterArray = llvm_MDTupleTypedArrayWrapper;
pub type llvm_DITemplateTypeParameterArray = llvm_MDTupleTypedArrayWrapper;
pub type llvm_DITemplateValueParameterArray = llvm_MDTupleTypedArrayWrapper;
pub type llvm_DIVariableArray = llvm_MDTupleTypedArrayWrapper;
pub type llvm_DIGlobalVariableArray = llvm_MDTupleTypedArrayWrapper;
pub type llvm_DILocalVariableArray = llvm_MDTupleTypedArrayWrapper;
pub type llvm_DILabelArray = llvm_MDTupleTypedArrayWrapper;
pub type llvm_DIObjCPropertyArray = llvm_MDTupleTypedArrayWrapper;
pub type llvm_DIImportedEntityArray = llvm_MDTupleTypedArrayWrapper;
pub type llvm_DIAssignIDArray = llvm_MDTupleTypedArrayWrapper;
pub type llvm_DIMacroNodeArray = llvm_MDTupleTypedArrayWrapper;
pub type llvm_DIMacroArray = llvm_MDTupleTypedArrayWrapper;
pub type llvm_DIMacroFileArray = llvm_MDTupleTypedArrayWrapper;
pub type llvm_DICommonBlockArray = llvm_MDTupleTypedArrayWrapper;
pub type llvm_DIStringTypeArray = llvm_MDTupleTypedArrayWrapper;
pub type llvm_DIGenericSubrangeArray = llvm_MDTupleTypedArrayWrapper;
#[doc = " Placeholder metadata for operands of distinct MDNodes.\n\n This is a lightweight placeholder for an operand of a distinct node.  It's\n purpose is to help track forward references when creating a distinct node.\n This allows distinct nodes involved in a cycle to be constructed before\n their operands without requiring a heavyweight temporary node with\n full-blown RAUW support.\n\n Each placeholder supports only a single MDNode user.  Clients should pass\n an ID, retrieved via \\a getID(), to indicate the \"real\" operand that this\n should be replaced with.\n\n While it would be possible to implement move operators, they would be\n fairly expensive.  Leave them unimplemented to discourage their use\n (clients can use std::deque, std::list, BumpPtrAllocator, etc.)."]
#[repr(C)]
#[derive(Debug)]
pub struct llvm_DistinctMDOperandPlaceholder {
    pub _base: llvm_Metadata,
    pub Use: *mut *mut llvm_Metadata,
}
#[test]
fn bindgen_test_layout_llvm_DistinctMDOperandPlaceholder() {
    const UNINIT: ::std::mem::MaybeUninit<llvm_DistinctMDOperandPlaceholder> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<llvm_DistinctMDOperandPlaceholder>(),
        16usize,
        concat!("Size of: ", stringify!(llvm_DistinctMDOperandPlaceholder))
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_DistinctMDOperandPlaceholder>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(llvm_DistinctMDOperandPlaceholder)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Use) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_DistinctMDOperandPlaceholder),
            "::",
            stringify!(Use)
        )
    );
}
#[doc = " A tuple of MDNodes.\n\n Despite its name, a NamedMDNode isn't itself an MDNode.\n\n NamedMDNodes are named module-level entities that contain lists of MDNodes.\n\n It is illegal for a NamedMDNode to appear as an operand of an MDNode."]
#[repr(C)]
pub struct llvm_NamedMDNode {
    pub __bindgen_padding_0: [u64; 2usize],
    pub Name: std_string,
    pub Parent: *mut llvm_Module,
    pub Operands: *mut ::std::os::raw::c_void,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_NamedMDNode_op_iterator_impl {
    pub Node: *const llvm_NamedMDNode,
    pub Idx: ::std::os::raw::c_uint,
}
pub type llvm_NamedMDNode_op_iterator_impl_iterator_category = std_bidirectional_iterator_tag;
pub type llvm_NamedMDNode_op_iterator_impl_value_type<T1> = T1;
pub type llvm_NamedMDNode_op_iterator_impl_difference_type = isize;
pub type llvm_NamedMDNode_op_iterator_impl_pointer<T1> =
    *mut llvm_NamedMDNode_op_iterator_impl_value_type<T1>;
pub type llvm_NamedMDNode_op_iterator_impl_reference<T1> =
    llvm_NamedMDNode_op_iterator_impl_value_type<T1>;
pub type llvm_NamedMDNode_op_iterator = llvm_NamedMDNode_op_iterator_impl;
pub type llvm_NamedMDNode_const_op_iterator = llvm_NamedMDNode_op_iterator_impl;
#[test]
fn bindgen_test_layout_llvm_NamedMDNode() {
    const UNINIT: ::std::mem::MaybeUninit<llvm_NamedMDNode> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<llvm_NamedMDNode>(),
        64usize,
        concat!("Size of: ", stringify!(llvm_NamedMDNode))
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_NamedMDNode>(),
        8usize,
        concat!("Alignment of ", stringify!(llvm_NamedMDNode))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Name) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_NamedMDNode),
            "::",
            stringify!(Name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Parent) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_NamedMDNode),
            "::",
            stringify!(Parent)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Operands) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_NamedMDNode),
            "::",
            stringify!(Operands)
        )
    );
}
extern "C" {
    #[doc = " Drop all references and remove the node from parent module."]
    #[link_name = "\u{1}_ZN4llvm11NamedMDNode15eraseFromParentEv"]
    pub fn llvm_NamedMDNode_eraseFromParent(this: *mut llvm_NamedMDNode);
}
extern "C" {
    #[doc = " Drop all references to this node's operands."]
    #[link_name = "\u{1}_ZN4llvm11NamedMDNode13clearOperandsEv"]
    pub fn llvm_NamedMDNode_clearOperands(this: *mut llvm_NamedMDNode);
}
extern "C" {
    #[link_name = "\u{1}_ZNK4llvm11NamedMDNode10getOperandEj"]
    pub fn llvm_NamedMDNode_getOperand(
        this: *const llvm_NamedMDNode,
        i: ::std::os::raw::c_uint,
    ) -> *mut llvm_MDNode;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4llvm11NamedMDNode14getNumOperandsEv"]
    pub fn llvm_NamedMDNode_getNumOperands(this: *const llvm_NamedMDNode)
        -> ::std::os::raw::c_uint;
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm11NamedMDNode10addOperandEPNS_6MDNodeE"]
    pub fn llvm_NamedMDNode_addOperand(this: *mut llvm_NamedMDNode, M: *mut llvm_MDNode);
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm11NamedMDNode10setOperandEjPNS_6MDNodeE"]
    pub fn llvm_NamedMDNode_setOperand(
        this: *mut llvm_NamedMDNode,
        I: ::std::os::raw::c_uint,
        New: *mut llvm_MDNode,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK4llvm11NamedMDNode7getNameEv"]
    pub fn llvm_NamedMDNode_getName(this: *const llvm_NamedMDNode) -> llvm_StringRef;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4llvm11NamedMDNode5printERNS_11raw_ostreamEb"]
    pub fn llvm_NamedMDNode_print(
        this: *const llvm_NamedMDNode,
        ROS: *mut llvm_raw_ostream,
        IsForDebug: bool,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK4llvm11NamedMDNode5printERNS_11raw_ostreamERNS_17ModuleSlotTrackerEb"]
    pub fn llvm_NamedMDNode_print1(
        this: *const llvm_NamedMDNode,
        ROS: *mut llvm_raw_ostream,
        MST: *mut llvm_ModuleSlotTracker,
        IsForDebug: bool,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK4llvm11NamedMDNode4dumpEv"]
    pub fn llvm_NamedMDNode_dump(this: *const llvm_NamedMDNode);
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm11NamedMDNodeD1Ev"]
    pub fn llvm_NamedMDNode_NamedMDNode_destructor(this: *mut llvm_NamedMDNode);
}
impl llvm_NamedMDNode {
    #[inline]
    pub unsafe fn eraseFromParent(&mut self) {
        llvm_NamedMDNode_eraseFromParent(self)
    }
    #[inline]
    pub unsafe fn clearOperands(&mut self) {
        llvm_NamedMDNode_clearOperands(self)
    }
    #[inline]
    pub unsafe fn getOperand(&self, i: ::std::os::raw::c_uint) -> *mut llvm_MDNode {
        llvm_NamedMDNode_getOperand(self, i)
    }
    #[inline]
    pub unsafe fn getNumOperands(&self) -> ::std::os::raw::c_uint {
        llvm_NamedMDNode_getNumOperands(self)
    }
    #[inline]
    pub unsafe fn addOperand(&mut self, M: *mut llvm_MDNode) {
        llvm_NamedMDNode_addOperand(self, M)
    }
    #[inline]
    pub unsafe fn setOperand(&mut self, I: ::std::os::raw::c_uint, New: *mut llvm_MDNode) {
        llvm_NamedMDNode_setOperand(self, I, New)
    }
    #[inline]
    pub unsafe fn getName(&self) -> llvm_StringRef {
        llvm_NamedMDNode_getName(self)
    }
    #[inline]
    pub unsafe fn print(&self, ROS: *mut llvm_raw_ostream, IsForDebug: bool) {
        llvm_NamedMDNode_print(self, ROS, IsForDebug)
    }
    #[inline]
    pub unsafe fn print1(
        &self,
        ROS: *mut llvm_raw_ostream,
        MST: *mut llvm_ModuleSlotTracker,
        IsForDebug: bool,
    ) {
        llvm_NamedMDNode_print1(self, ROS, MST, IsForDebug)
    }
    #[inline]
    pub unsafe fn dump(&self) {
        llvm_NamedMDNode_dump(self)
    }
    #[inline]
    pub unsafe fn destruct(&mut self) {
        llvm_NamedMDNode_NamedMDNode_destructor(self)
    }
}
#[doc = " Tracking metadata reference.\n\n This class behaves like \\a TrackingVH, but for metadata."]
#[repr(C)]
#[derive(Debug)]
pub struct llvm_TrackingMDRef {
    pub MD: *mut llvm_Metadata,
}
#[test]
fn bindgen_test_layout_llvm_TrackingMDRef() {
    const UNINIT: ::std::mem::MaybeUninit<llvm_TrackingMDRef> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<llvm_TrackingMDRef>(),
        8usize,
        concat!("Size of: ", stringify!(llvm_TrackingMDRef))
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_TrackingMDRef>(),
        8usize,
        concat!("Alignment of ", stringify!(llvm_TrackingMDRef))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).MD) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_TrackingMDRef),
            "::",
            stringify!(MD)
        )
    );
}
#[doc = " Typed tracking ref.\n\n Track refererences of a particular type.  It's useful to use this for \\a\n MDNode and \\a ValueAsMetadata."]
#[repr(C)]
#[derive(Debug)]
pub struct llvm_TypedTrackingMDRef {
    pub Ref: llvm_TrackingMDRef,
}
#[doc = " Typed tracking ref.\n\n Track refererences of a particular type.  It's useful to use this for \\a\n MDNode and \\a ValueAsMetadata."]
pub type llvm_TrackingMDNodeRef = llvm_TypedTrackingMDRef;
pub type llvm_TrackingValueAsMetadataRef = llvm_TypedTrackingMDRef;
#[test]
fn __bindgen_test_layout_llvm_simplify_type_open0_llvm_TrackingMDRef_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<llvm_simplify_type>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_simplify_type)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_simplify_type>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_simplify_type)
        )
    );
}
#[test]
fn __bindgen_test_layout_llvm_simplify_type_open0_llvm_TrackingMDRef_close0_instantiation_1() {
    assert_eq!(
        ::std::mem::size_of::<llvm_simplify_type>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_simplify_type)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_simplify_type>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_simplify_type)
        )
    );
}
#[doc = " A debug info location.\n\n This class is a wrapper around a tracking reference to an \\a DILocation\n pointer.\n\n To avoid extra includes, \\a DebugLoc doubles the \\a DILocation API with a\n one based on relatively opaque \\a MDNode pointers."]
#[repr(C)]
#[derive(Debug)]
pub struct llvm_DebugLoc {
    pub Loc: llvm_TrackingMDNodeRef,
}
pub const llvm_DebugLoc_ReplaceLastInlinedAt: llvm_DebugLoc__bindgen_ty_1 = 1;
pub type llvm_DebugLoc__bindgen_ty_1 = ::std::os::raw::c_uint;
#[test]
fn bindgen_test_layout_llvm_DebugLoc() {
    const UNINIT: ::std::mem::MaybeUninit<llvm_DebugLoc> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<llvm_DebugLoc>(),
        8usize,
        concat!("Size of: ", stringify!(llvm_DebugLoc))
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_DebugLoc>(),
        8usize,
        concat!("Alignment of ", stringify!(llvm_DebugLoc))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Loc) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_DebugLoc),
            "::",
            stringify!(Loc)
        )
    );
}
extern "C" {
    #[doc = " Get the underlying \\a DILocation.\n\n \\pre !*this or \\c isa<DILocation>(getAsMDNode()).\n @{"]
    #[link_name = "\u{1}_ZNK4llvm8DebugLoc3getEv"]
    pub fn llvm_DebugLoc_get(this: *const llvm_DebugLoc) -> *mut llvm_DILocation;
}
extern "C" {
    #[doc = " Rebuild the entire inlined-at chain for this instruction so that the top of\n the chain now is inlined-at the new call site.\n \\param   InlinedAt    The new outermost inlined-at in the chain."]
    #[link_name = "\u{1}_ZN4llvm8DebugLoc15appendInlinedAtERKS0_PNS_10DILocationERNS_11LLVMContextERNS_8DenseMapIPKNS_6MDNodeEPS8_NS_12DenseMapInfoISA_vEENS_6detail12DenseMapPairISA_SB_EEEE"]
    pub fn llvm_DebugLoc_appendInlinedAt(
        DL: *const llvm_DebugLoc,
        InlinedAt: *mut llvm_DILocation,
        Ctx: *mut llvm_LLVMContext,
        Cache: *mut llvm_DenseMap<llvm_detail_DenseMapPair<*const llvm_MDNode, *mut llvm_MDNode>>,
    ) -> llvm_DebugLoc;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4llvm8DebugLoc7getLineEv"]
    pub fn llvm_DebugLoc_getLine(this: *const llvm_DebugLoc) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4llvm8DebugLoc6getColEv"]
    pub fn llvm_DebugLoc_getCol(this: *const llvm_DebugLoc) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4llvm8DebugLoc8getScopeEv"]
    pub fn llvm_DebugLoc_getScope(this: *const llvm_DebugLoc) -> *mut llvm_MDNode;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4llvm8DebugLoc12getInlinedAtEv"]
    pub fn llvm_DebugLoc_getInlinedAt(this: *const llvm_DebugLoc) -> *mut llvm_DILocation;
}
extern "C" {
    #[doc = " Get the fully inlined-at scope for a DebugLoc.\n\n Gets the inlined-at scope for a DebugLoc."]
    #[link_name = "\u{1}_ZNK4llvm8DebugLoc17getInlinedAtScopeEv"]
    pub fn llvm_DebugLoc_getInlinedAtScope(this: *const llvm_DebugLoc) -> *mut llvm_MDNode;
}
extern "C" {
    #[doc = " Rebuild the entire inline-at chain by replacing the subprogram at the\n end of the chain with NewSP."]
    #[link_name = "\u{1}_ZN4llvm8DebugLoc26replaceInlinedAtSubprogramERKS0_RNS_12DISubprogramERNS_11LLVMContextERNS_8DenseMapIPKNS_6MDNodeEPS8_NS_12DenseMapInfoISA_vEENS_6detail12DenseMapPairISA_SB_EEEE"]
    pub fn llvm_DebugLoc_replaceInlinedAtSubprogram(
        DL: *const llvm_DebugLoc,
        NewSP: *mut llvm_DISubprogram,
        Ctx: *mut llvm_LLVMContext,
        Cache: *mut llvm_DenseMap<llvm_detail_DenseMapPair<*const llvm_MDNode, *mut llvm_MDNode>>,
    ) -> llvm_DebugLoc;
}
extern "C" {
    #[doc = " Find the debug info location for the start of the function.\n\n Walk up the scope chain of given debug loc and find line number info\n for the function.\n\n FIXME: Remove this.  Users should use DILocation/DILocalScope API to\n find the subprogram, and then DILocation::get()."]
    #[link_name = "\u{1}_ZNK4llvm8DebugLoc13getFnDebugLocEv"]
    pub fn llvm_DebugLoc_getFnDebugLoc(this: *const llvm_DebugLoc) -> llvm_DebugLoc;
}
extern "C" {
    #[doc = " Check if the DebugLoc corresponds to an implicit code."]
    #[link_name = "\u{1}_ZNK4llvm8DebugLoc14isImplicitCodeEv"]
    pub fn llvm_DebugLoc_isImplicitCode(this: *const llvm_DebugLoc) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm8DebugLoc15setImplicitCodeEb"]
    pub fn llvm_DebugLoc_setImplicitCode(this: *mut llvm_DebugLoc, ImplicitCode: bool);
}
extern "C" {
    #[link_name = "\u{1}_ZNK4llvm8DebugLoc4dumpEv"]
    pub fn llvm_DebugLoc_dump(this: *const llvm_DebugLoc);
}
extern "C" {
    #[doc = " prints source location /path/to/file.exe:line:col @[inlined at]"]
    #[link_name = "\u{1}_ZNK4llvm8DebugLoc5printERNS_11raw_ostreamE"]
    pub fn llvm_DebugLoc_print(this: *const llvm_DebugLoc, OS: *mut llvm_raw_ostream);
}
extern "C" {
    #[doc = " Construct from an \\a DILocation."]
    #[link_name = "\u{1}_ZN4llvm8DebugLocC1EPKNS_10DILocationE"]
    pub fn llvm_DebugLoc_DebugLoc(this: *mut llvm_DebugLoc, L: *const llvm_DILocation);
}
extern "C" {
    #[doc = " Construct from an \\a MDNode.\n\n Note: if \\c N is not an \\a DILocation, a verifier check will fail, and\n accessors will crash.  However, construction from other nodes is\n supported in order to handle forward references when reading textual\n IR."]
    #[link_name = "\u{1}_ZN4llvm8DebugLocC1EPKNS_6MDNodeE"]
    pub fn llvm_DebugLoc_DebugLoc1(this: *mut llvm_DebugLoc, N: *const llvm_MDNode);
}
impl llvm_DebugLoc {
    #[inline]
    pub unsafe fn get(&self) -> *mut llvm_DILocation {
        llvm_DebugLoc_get(self)
    }
    #[inline]
    pub unsafe fn appendInlinedAt(
        DL: *const llvm_DebugLoc,
        InlinedAt: *mut llvm_DILocation,
        Ctx: *mut llvm_LLVMContext,
        Cache: *mut llvm_DenseMap<llvm_detail_DenseMapPair<*const llvm_MDNode, *mut llvm_MDNode>>,
    ) -> llvm_DebugLoc {
        llvm_DebugLoc_appendInlinedAt(DL, InlinedAt, Ctx, Cache)
    }
    #[inline]
    pub unsafe fn getLine(&self) -> ::std::os::raw::c_uint {
        llvm_DebugLoc_getLine(self)
    }
    #[inline]
    pub unsafe fn getCol(&self) -> ::std::os::raw::c_uint {
        llvm_DebugLoc_getCol(self)
    }
    #[inline]
    pub unsafe fn getScope(&self) -> *mut llvm_MDNode {
        llvm_DebugLoc_getScope(self)
    }
    #[inline]
    pub unsafe fn getInlinedAt(&self) -> *mut llvm_DILocation {
        llvm_DebugLoc_getInlinedAt(self)
    }
    #[inline]
    pub unsafe fn getInlinedAtScope(&self) -> *mut llvm_MDNode {
        llvm_DebugLoc_getInlinedAtScope(self)
    }
    #[inline]
    pub unsafe fn replaceInlinedAtSubprogram(
        DL: *const llvm_DebugLoc,
        NewSP: *mut llvm_DISubprogram,
        Ctx: *mut llvm_LLVMContext,
        Cache: *mut llvm_DenseMap<llvm_detail_DenseMapPair<*const llvm_MDNode, *mut llvm_MDNode>>,
    ) -> llvm_DebugLoc {
        llvm_DebugLoc_replaceInlinedAtSubprogram(DL, NewSP, Ctx, Cache)
    }
    #[inline]
    pub unsafe fn getFnDebugLoc(&self) -> llvm_DebugLoc {
        llvm_DebugLoc_getFnDebugLoc(self)
    }
    #[inline]
    pub unsafe fn isImplicitCode(&self) -> bool {
        llvm_DebugLoc_isImplicitCode(self)
    }
    #[inline]
    pub unsafe fn setImplicitCode(&mut self, ImplicitCode: bool) {
        llvm_DebugLoc_setImplicitCode(self, ImplicitCode)
    }
    #[inline]
    pub unsafe fn dump(&self) {
        llvm_DebugLoc_dump(self)
    }
    #[inline]
    pub unsafe fn print(&self, OS: *mut llvm_raw_ostream) {
        llvm_DebugLoc_print(self, OS)
    }
    #[inline]
    pub unsafe fn new(L: *const llvm_DILocation) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        llvm_DebugLoc_DebugLoc(__bindgen_tmp.as_mut_ptr(), L);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(N: *const llvm_MDNode) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        llvm_DebugLoc_DebugLoc1(__bindgen_tmp.as_mut_ptr(), N);
        __bindgen_tmp.assume_init()
    }
}
#[doc = " Bit patterns are forged using the equivalent `Unsigned` type because of\n undefined operations over signed types (e.g. Bitwise shift operators).\n Moreover same size casting from unsigned to signed is well defined but not\n the other way around."]
pub type llvm_bitfields_details_BitPatterns_Unsigned = std_make_unsigned_t;
#[doc = " A struct defining useful bit patterns for n-bits integer types."]
pub type llvm_bitfields_details_Compressor_BP = u8;
#[doc = " Impl is where Bifield description and Storage are put together to interact\n with values."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_bitfields_details_Impl {
    pub _address: u8,
}
pub type llvm_bitfields_details_Impl_IntegerType = [u8; 0usize];
#[doc = " `Compressor` is used to manipulate the bits of a (possibly signed) integer\n type so it can be packed and unpacked into a `bits` sized integer,\n `Compressor` is specialized on signed-ness so no runtime cost is incurred.\n The `pack` method also checks that the passed in `UserValue` is valid."]
pub type llvm_bitfields_details_Impl_C = u8;
#[doc = " A struct defining useful bit patterns for n-bits integer types."]
pub type llvm_bitfields_details_Impl_BP = u8;
pub type llvm_bitfields_details_ResolveUnderlyingType_type = std_underlying_type_t;
#[doc = " Holds functions to get, set or test bitfields."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_Bitfield {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_llvm_Bitfield() {
    assert_eq!(
        ::std::mem::size_of::<llvm_Bitfield>(),
        1usize,
        concat!("Size of: ", stringify!(llvm_Bitfield))
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_Bitfield>(),
        1usize,
        concat!("Alignment of ", stringify!(llvm_Bitfield))
    );
}
pub type llvm_Bitfield_Element_Type<T> = T;
pub type llvm_Bitfield_Element_IntegerType = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_ValueSymbolTable {
    _unused: [u8; 0],
}
#[doc = " Template metafunction to get the parent type for a symbol table list.\n\n Implementations create a typedef called \\c type so that we only need a\n single template parameter for the list and traits."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_SymbolTableListParentType {
    pub _address: u8,
}
#[test]
fn __bindgen_test_layout_llvm_SymbolTableListParentType_open0_llvm_Instruction_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<llvm_SymbolTableListParentType>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_SymbolTableListParentType)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_SymbolTableListParentType>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_SymbolTableListParentType)
        )
    );
}
#[test]
fn __bindgen_test_layout_llvm_SymbolTableListParentType_open0_llvm_BasicBlock_close0_instantiation()
{
    assert_eq!(
        ::std::mem::size_of::<llvm_SymbolTableListParentType>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_SymbolTableListParentType)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_SymbolTableListParentType>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_SymbolTableListParentType)
        )
    );
}
#[test]
fn __bindgen_test_layout_llvm_SymbolTableListParentType_open0_llvm_Argument_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<llvm_SymbolTableListParentType>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_SymbolTableListParentType)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_SymbolTableListParentType>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_SymbolTableListParentType)
        )
    );
}
#[test]
fn __bindgen_test_layout_llvm_SymbolTableListParentType_open0_llvm_Function_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<llvm_SymbolTableListParentType>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_SymbolTableListParentType)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_SymbolTableListParentType>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_SymbolTableListParentType)
        )
    );
}
#[test]
fn __bindgen_test_layout_llvm_SymbolTableListParentType_open0_llvm_GlobalVariable_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<llvm_SymbolTableListParentType>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_SymbolTableListParentType)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_SymbolTableListParentType>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_SymbolTableListParentType)
        )
    );
}
#[test]
fn __bindgen_test_layout_llvm_SymbolTableListParentType_open0_llvm_GlobalAlias_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<llvm_SymbolTableListParentType>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_SymbolTableListParentType)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_SymbolTableListParentType>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_SymbolTableListParentType)
        )
    );
}
#[test]
fn __bindgen_test_layout_llvm_SymbolTableListParentType_open0_llvm_GlobalIFunc_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<llvm_SymbolTableListParentType>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_SymbolTableListParentType)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_SymbolTableListParentType>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_SymbolTableListParentType)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_SymbolTableListTraits {
    pub _address: u8,
}
#[doc = " List that automatically updates parent links and symbol tables.\n\n When nodes are inserted into and removed from this list, the associated\n symbol table will be automatically updated.  Similarly, parent links get\n updated automatically."]
pub type llvm_SymbolTableListTraits_ListTy = llvm_SymbolTableList;
pub type llvm_SymbolTableListTraits_iterator = llvm_simple_ilist;
pub type llvm_SymbolTableListTraits_ItemParentClass = llvm_SymbolTableListParentType;
#[doc = " List that automatically updates parent links and symbol tables.\n\n When nodes are inserted into and removed from this list, the associated\n symbol table will be automatically updated.  Similarly, parent links get\n updated automatically."]
#[repr(C)]
#[derive(Debug)]
pub struct llvm_SymbolTableList {
    pub _base: llvm_iplist_impl<llvm_simple_ilist, llvm_SymbolTableListTraits>,
}
pub const llvm_AtomicOrderingCABI_relaxed: llvm_AtomicOrderingCABI = 0;
pub const llvm_AtomicOrderingCABI_consume: llvm_AtomicOrderingCABI = 1;
pub const llvm_AtomicOrderingCABI_acquire: llvm_AtomicOrderingCABI = 2;
pub const llvm_AtomicOrderingCABI_release: llvm_AtomicOrderingCABI = 3;
pub const llvm_AtomicOrderingCABI_acq_rel: llvm_AtomicOrderingCABI = 4;
pub const llvm_AtomicOrderingCABI_seq_cst: llvm_AtomicOrderingCABI = 5;
#[doc = " Atomic ordering for C11 / C++11's memory models.\n\n These values cannot change because they are shared with standard library\n implementations as well as with other compilers."]
pub type llvm_AtomicOrderingCABI = ::std::os::raw::c_int;
pub const llvm_AtomicOrdering_NotAtomic: llvm_AtomicOrdering = 0;
pub const llvm_AtomicOrdering_Unordered: llvm_AtomicOrdering = 1;
pub const llvm_AtomicOrdering_Monotonic: llvm_AtomicOrdering = 2;
pub const llvm_AtomicOrdering_Acquire: llvm_AtomicOrdering = 4;
pub const llvm_AtomicOrdering_Release: llvm_AtomicOrdering = 5;
pub const llvm_AtomicOrdering_AcquireRelease: llvm_AtomicOrdering = 6;
pub const llvm_AtomicOrdering_SequentiallyConsistent: llvm_AtomicOrdering = 7;
pub const llvm_AtomicOrdering_LAST: llvm_AtomicOrdering = 7;
#[doc = " Atomic ordering for LLVM's memory model.\n\n C++ defines ordering as a lattice. LLVM supplements this with NotAtomic and\n Unordered, which are both below the C++ orders.\n\n not_atomic-->unordered-->relaxed-->release--------------->acq_rel-->seq_cst\n                                   \\-->consume-->acquire--/"]
pub type llvm_AtomicOrdering = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_FastMathFlags {
    _unused: [u8; 0],
}
#[test]
fn __bindgen_test_layout_llvm_ilist_alloc_traits_open0_llvm_Instruction_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<llvm_ilist_alloc_traits>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_ilist_alloc_traits)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_ilist_alloc_traits>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_ilist_alloc_traits)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_InsertPosition {
    pub InsertAt: [u64; 2usize],
}
#[doc = " List that automatically updates parent links and symbol tables.\n\n When nodes are inserted into and removed from this list, the associated\n symbol table will be automatically updated.  Similarly, parent links get\n updated automatically."]
pub type llvm_InsertPosition_InstListType = llvm_SymbolTableList;
#[test]
fn bindgen_test_layout_llvm_InsertPosition() {
    const UNINIT: ::std::mem::MaybeUninit<llvm_InsertPosition> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<llvm_InsertPosition>(),
        16usize,
        concat!("Size of: ", stringify!(llvm_InsertPosition))
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_InsertPosition>(),
        8usize,
        concat!("Alignment of ", stringify!(llvm_InsertPosition))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).InsertAt) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_InsertPosition),
            "::",
            stringify!(InsertAt)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm14InsertPositionC1EPNS_11InstructionE"]
    pub fn llvm_InsertPosition_InsertPosition(
        this: *mut llvm_InsertPosition,
        InsertBefore: *mut llvm_Instruction,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm14InsertPositionC1EPNS_10BasicBlockE"]
    pub fn llvm_InsertPosition_InsertPosition1(
        this: *mut llvm_InsertPosition,
        InsertAtEnd: *mut llvm_BasicBlock,
    );
}
impl llvm_InsertPosition {
    #[inline]
    pub unsafe fn new(InsertBefore: *mut llvm_Instruction) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        llvm_InsertPosition_InsertPosition(__bindgen_tmp.as_mut_ptr(), InsertBefore);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(InsertAtEnd: *mut llvm_BasicBlock) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        llvm_InsertPosition_InsertPosition1(__bindgen_tmp.as_mut_ptr(), InsertAtEnd);
        __bindgen_tmp.assume_init()
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct llvm_Instruction {
    pub _base: llvm_User,
    pub __bindgen_padding_0: [u64; 3usize],
    pub DbgLoc: llvm_DebugLoc,
    #[doc = " Relative order of this instruction in its parent basic block. Used for\n O(1) local dominance checks between instructions."]
    pub Order: ::std::os::raw::c_uint,
    #[doc = " Optional marker recording the position for debugging information that\n takes effect immediately before this instruction. Null unless there is\n debugging information present."]
    pub DebugMarker: *mut llvm_DbgMarker,
}
#[doc = " List that automatically updates parent links and symbol tables.\n\n When nodes are inserted into and removed from this list, the associated\n symbol table will be automatically updated.  Similarly, parent links get\n updated automatically."]
pub type llvm_Instruction_InstListType = llvm_SymbolTableList;
pub type llvm_Instruction_OpaqueField = u8;
pub type llvm_Instruction_AlignmentBitfieldElementT = u8;
pub type llvm_Instruction_BoolBitfieldElementT = u8;
pub type llvm_Instruction_AtomicOrderingBitfieldElementT = u8;
pub type llvm_Instruction_HasMetadataField = u8;
#[doc = " Check for equivalence ignoring load/store alignment."]
pub const llvm_Instruction_OperationEquivalenceFlags_CompareIgnoringAlignment:
    llvm_Instruction_OperationEquivalenceFlags = 1;
#[doc = " Check for equivalence treating a type and a vector of that type\n as equivalent."]
pub const llvm_Instruction_OperationEquivalenceFlags_CompareUsingScalarTypes:
    llvm_Instruction_OperationEquivalenceFlags = 2;
#[doc = " When checking for operation equivalence (using isSameOperationAs) it is\n sometimes useful to ignore certain attributes."]
pub type llvm_Instruction_OperationEquivalenceFlags = ::std::os::raw::c_uint;
pub const llvm_Instruction_TermOps_TermOpsBegin: llvm_Instruction_TermOps = 1;
pub const llvm_Instruction_TermOps_Ret: llvm_Instruction_TermOps = 1;
pub const llvm_Instruction_TermOps_Br: llvm_Instruction_TermOps = 2;
pub const llvm_Instruction_TermOps_Switch: llvm_Instruction_TermOps = 3;
pub const llvm_Instruction_TermOps_IndirectBr: llvm_Instruction_TermOps = 4;
pub const llvm_Instruction_TermOps_Invoke: llvm_Instruction_TermOps = 5;
pub const llvm_Instruction_TermOps_Resume: llvm_Instruction_TermOps = 6;
pub const llvm_Instruction_TermOps_Unreachable: llvm_Instruction_TermOps = 7;
pub const llvm_Instruction_TermOps_CleanupRet: llvm_Instruction_TermOps = 8;
pub const llvm_Instruction_TermOps_CatchRet: llvm_Instruction_TermOps = 9;
pub const llvm_Instruction_TermOps_CatchSwitch: llvm_Instruction_TermOps = 10;
pub const llvm_Instruction_TermOps_CallBr: llvm_Instruction_TermOps = 11;
pub const llvm_Instruction_TermOps_TermOpsEnd: llvm_Instruction_TermOps = 12;
pub type llvm_Instruction_TermOps = ::std::os::raw::c_uint;
pub const llvm_Instruction_UnaryOps_UnaryOpsBegin: llvm_Instruction_UnaryOps = 12;
pub const llvm_Instruction_UnaryOps_FNeg: llvm_Instruction_UnaryOps = 12;
pub const llvm_Instruction_UnaryOps_UnaryOpsEnd: llvm_Instruction_UnaryOps = 13;
pub type llvm_Instruction_UnaryOps = ::std::os::raw::c_uint;
pub const llvm_Instruction_BinaryOps_BinaryOpsBegin: llvm_Instruction_BinaryOps = 13;
pub const llvm_Instruction_BinaryOps_Add: llvm_Instruction_BinaryOps = 13;
pub const llvm_Instruction_BinaryOps_FAdd: llvm_Instruction_BinaryOps = 14;
pub const llvm_Instruction_BinaryOps_Sub: llvm_Instruction_BinaryOps = 15;
pub const llvm_Instruction_BinaryOps_FSub: llvm_Instruction_BinaryOps = 16;
pub const llvm_Instruction_BinaryOps_Mul: llvm_Instruction_BinaryOps = 17;
pub const llvm_Instruction_BinaryOps_FMul: llvm_Instruction_BinaryOps = 18;
pub const llvm_Instruction_BinaryOps_UDiv: llvm_Instruction_BinaryOps = 19;
pub const llvm_Instruction_BinaryOps_SDiv: llvm_Instruction_BinaryOps = 20;
pub const llvm_Instruction_BinaryOps_FDiv: llvm_Instruction_BinaryOps = 21;
pub const llvm_Instruction_BinaryOps_URem: llvm_Instruction_BinaryOps = 22;
pub const llvm_Instruction_BinaryOps_SRem: llvm_Instruction_BinaryOps = 23;
pub const llvm_Instruction_BinaryOps_FRem: llvm_Instruction_BinaryOps = 24;
pub const llvm_Instruction_BinaryOps_Shl: llvm_Instruction_BinaryOps = 25;
pub const llvm_Instruction_BinaryOps_LShr: llvm_Instruction_BinaryOps = 26;
pub const llvm_Instruction_BinaryOps_AShr: llvm_Instruction_BinaryOps = 27;
pub const llvm_Instruction_BinaryOps_And: llvm_Instruction_BinaryOps = 28;
pub const llvm_Instruction_BinaryOps_Or: llvm_Instruction_BinaryOps = 29;
pub const llvm_Instruction_BinaryOps_Xor: llvm_Instruction_BinaryOps = 30;
pub const llvm_Instruction_BinaryOps_BinaryOpsEnd: llvm_Instruction_BinaryOps = 31;
pub type llvm_Instruction_BinaryOps = ::std::os::raw::c_uint;
pub const llvm_Instruction_MemoryOps_MemoryOpsBegin: llvm_Instruction_MemoryOps = 31;
pub const llvm_Instruction_MemoryOps_Alloca: llvm_Instruction_MemoryOps = 31;
pub const llvm_Instruction_MemoryOps_Load: llvm_Instruction_MemoryOps = 32;
pub const llvm_Instruction_MemoryOps_Store: llvm_Instruction_MemoryOps = 33;
pub const llvm_Instruction_MemoryOps_GetElementPtr: llvm_Instruction_MemoryOps = 34;
pub const llvm_Instruction_MemoryOps_Fence: llvm_Instruction_MemoryOps = 35;
pub const llvm_Instruction_MemoryOps_AtomicCmpXchg: llvm_Instruction_MemoryOps = 36;
pub const llvm_Instruction_MemoryOps_AtomicRMW: llvm_Instruction_MemoryOps = 37;
pub const llvm_Instruction_MemoryOps_MemoryOpsEnd: llvm_Instruction_MemoryOps = 38;
pub type llvm_Instruction_MemoryOps = ::std::os::raw::c_uint;
pub const llvm_Instruction_CastOps_CastOpsBegin: llvm_Instruction_CastOps = 38;
pub const llvm_Instruction_CastOps_Trunc: llvm_Instruction_CastOps = 38;
pub const llvm_Instruction_CastOps_ZExt: llvm_Instruction_CastOps = 39;
pub const llvm_Instruction_CastOps_SExt: llvm_Instruction_CastOps = 40;
pub const llvm_Instruction_CastOps_FPToUI: llvm_Instruction_CastOps = 41;
pub const llvm_Instruction_CastOps_FPToSI: llvm_Instruction_CastOps = 42;
pub const llvm_Instruction_CastOps_UIToFP: llvm_Instruction_CastOps = 43;
pub const llvm_Instruction_CastOps_SIToFP: llvm_Instruction_CastOps = 44;
pub const llvm_Instruction_CastOps_FPTrunc: llvm_Instruction_CastOps = 45;
pub const llvm_Instruction_CastOps_FPExt: llvm_Instruction_CastOps = 46;
pub const llvm_Instruction_CastOps_PtrToInt: llvm_Instruction_CastOps = 47;
pub const llvm_Instruction_CastOps_IntToPtr: llvm_Instruction_CastOps = 48;
pub const llvm_Instruction_CastOps_BitCast: llvm_Instruction_CastOps = 49;
pub const llvm_Instruction_CastOps_AddrSpaceCast: llvm_Instruction_CastOps = 50;
pub const llvm_Instruction_CastOps_CastOpsEnd: llvm_Instruction_CastOps = 51;
pub type llvm_Instruction_CastOps = ::std::os::raw::c_uint;
pub const llvm_Instruction_FuncletPadOps_FuncletPadOpsBegin: llvm_Instruction_FuncletPadOps = 51;
pub const llvm_Instruction_FuncletPadOps_CleanupPad: llvm_Instruction_FuncletPadOps = 51;
pub const llvm_Instruction_FuncletPadOps_CatchPad: llvm_Instruction_FuncletPadOps = 52;
pub const llvm_Instruction_FuncletPadOps_FuncletPadOpsEnd: llvm_Instruction_FuncletPadOps = 53;
pub type llvm_Instruction_FuncletPadOps = ::std::os::raw::c_uint;
pub const llvm_Instruction_OtherOps_OtherOpsBegin: llvm_Instruction_OtherOps = 53;
pub const llvm_Instruction_OtherOps_ICmp: llvm_Instruction_OtherOps = 53;
pub const llvm_Instruction_OtherOps_FCmp: llvm_Instruction_OtherOps = 54;
pub const llvm_Instruction_OtherOps_PHI: llvm_Instruction_OtherOps = 55;
pub const llvm_Instruction_OtherOps_Call: llvm_Instruction_OtherOps = 56;
pub const llvm_Instruction_OtherOps_Select: llvm_Instruction_OtherOps = 57;
pub const llvm_Instruction_OtherOps_UserOp1: llvm_Instruction_OtherOps = 58;
pub const llvm_Instruction_OtherOps_UserOp2: llvm_Instruction_OtherOps = 59;
pub const llvm_Instruction_OtherOps_VAArg: llvm_Instruction_OtherOps = 60;
pub const llvm_Instruction_OtherOps_ExtractElement: llvm_Instruction_OtherOps = 61;
pub const llvm_Instruction_OtherOps_InsertElement: llvm_Instruction_OtherOps = 62;
pub const llvm_Instruction_OtherOps_ShuffleVector: llvm_Instruction_OtherOps = 63;
pub const llvm_Instruction_OtherOps_ExtractValue: llvm_Instruction_OtherOps = 64;
pub const llvm_Instruction_OtherOps_InsertValue: llvm_Instruction_OtherOps = 65;
pub const llvm_Instruction_OtherOps_LandingPad: llvm_Instruction_OtherOps = 66;
pub const llvm_Instruction_OtherOps_Freeze: llvm_Instruction_OtherOps = 67;
pub const llvm_Instruction_OtherOps_OtherOpsEnd: llvm_Instruction_OtherOps = 68;
pub type llvm_Instruction_OtherOps = ::std::os::raw::c_uint;
#[test]
fn bindgen_test_layout_llvm_Instruction() {
    const UNINIT: ::std::mem::MaybeUninit<llvm_Instruction> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<llvm_Instruction>(),
        72usize,
        concat!("Size of: ", stringify!(llvm_Instruction))
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_Instruction>(),
        8usize,
        concat!("Alignment of ", stringify!(llvm_Instruction))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).DbgLoc) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_Instruction),
            "::",
            stringify!(DbgLoc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Order) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_Instruction),
            "::",
            stringify!(Order)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).DebugMarker) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_Instruction),
            "::",
            stringify!(DebugMarker)
        )
    );
}
extern "C" {
    #[doc = " Clone any debug-info attached to \\p From onto this instruction. Used to\n copy debugging information from one block to another, when copying entire\n blocks. \\see DebugProgramInstruction.h , because the ordering of\n DbgRecords is still important, fine grain control of which instructions\n are moved and where they go is necessary.\n \\p From The instruction to clone debug-info from.\n \\p from_here Optional iterator to limit DbgRecords cloned to be a range\n from\n    from_here to end().\n \\p InsertAtHead Whether the cloned DbgRecords should be placed at the end\n    or the beginning of existing DbgRecords attached to this.\n \\returns A range over the newly cloned DbgRecords."]
    #[link_name = "\u{1}_ZN4llvm11Instruction18cloneDebugInfoFromEPKS0_St8optionalINS_14ilist_iteratorINS_12ilist_detail12node_optionsINS_9DbgRecordELb1ELb0EvLb0EvEELb0ELb0EEEEb"]
    pub fn llvm_Instruction_cloneDebugInfoFrom(
        this: *mut llvm_Instruction,
        From: *const llvm_Instruction,
        FromHere: std_optional,
        InsertAtHead: bool,
    ) -> [u64; 2usize];
}
extern "C" {
    #[doc = " Return an iterator to the position of the \"Next\" DbgRecord after this\n instruction, or std::nullopt. This is the position to pass to\n BasicBlock::reinsertInstInDbgRecords when re-inserting an instruction."]
    #[link_name = "\u{1}_ZN4llvm11Instruction25getDbgReinsertionPositionEv"]
    pub fn llvm_Instruction_getDbgReinsertionPosition(this: *mut llvm_Instruction) -> std_optional;
}
extern "C" {
    #[doc = " Returns true if any DbgRecords are attached to this instruction."]
    #[link_name = "\u{1}_ZNK4llvm11Instruction13hasDbgRecordsEv"]
    pub fn llvm_Instruction_hasDbgRecords(this: *const llvm_Instruction) -> bool;
}
extern "C" {
    #[doc = " Transfer any DbgRecords on the position \\p It onto this instruction,\n by simply adopting the sequence of DbgRecords (which is efficient) if\n possible, by merging two sequences otherwise."]
    #[link_name = "\u{1}_ZN4llvm11Instruction15adoptDbgRecordsEPNS_10BasicBlockENS_21ilist_iterator_w_bitsINS_12ilist_detail12node_optionsIS0_Lb1ELb0EvLb1ES1_EELb0ELb0EEEb"]
    pub fn llvm_Instruction_adoptDbgRecords(
        this: *mut llvm_Instruction,
        BB: *mut llvm_BasicBlock,
        It: [u64; 2usize],
        InsertAtHead: bool,
    );
}
extern "C" {
    #[doc = " Erase any DbgRecords attached to this instruction."]
    #[link_name = "\u{1}_ZN4llvm11Instruction14dropDbgRecordsEv"]
    pub fn llvm_Instruction_dropDbgRecords(this: *mut llvm_Instruction);
}
extern "C" {
    #[doc = " Erase a single DbgRecord \\p I that is attached to this instruction."]
    #[link_name = "\u{1}_ZN4llvm11Instruction16dropOneDbgRecordEPNS_9DbgRecordE"]
    pub fn llvm_Instruction_dropOneDbgRecord(this: *mut llvm_Instruction, I: *mut llvm_DbgRecord);
}
extern "C" {
    #[doc = " Handle the debug-info implications of this instruction being removed. Any\n attached DbgRecords need to \"fall\" down onto the next instruction."]
    #[link_name = "\u{1}_ZN4llvm11Instruction19handleMarkerRemovalEv"]
    pub fn llvm_Instruction_handleMarkerRemoval(this: *mut llvm_Instruction);
}
extern "C" {
    #[doc = " Return the module owning the function this instruction belongs to\n or nullptr it the function does not have a module.\n\n Note: this is undefined behavior if the instruction does not have a\n parent, or the parent basic block does not have a parent function."]
    #[link_name = "\u{1}_ZNK4llvm11Instruction9getModuleEv"]
    pub fn llvm_Instruction_getModule(this: *const llvm_Instruction) -> *const llvm_Module;
}
extern "C" {
    #[doc = " Return the function this instruction belongs to.\n\n Note: it is undefined behavior to call this on an instruction not\n currently inserted into a function."]
    #[link_name = "\u{1}_ZNK4llvm11Instruction11getFunctionEv"]
    pub fn llvm_Instruction_getFunction(this: *const llvm_Instruction) -> *const llvm_Function;
}
extern "C" {
    #[doc = " Get the data layout of the module this instruction belongs to.\n\n Requires the instruction to have a parent module."]
    #[link_name = "\u{1}_ZNK4llvm11Instruction13getDataLayoutEv"]
    pub fn llvm_Instruction_getDataLayout(this: *const llvm_Instruction) -> *const llvm_DataLayout;
}
extern "C" {
    #[doc = " This method unlinks 'this' from the containing basic block, but does not\n delete it."]
    #[link_name = "\u{1}_ZN4llvm11Instruction16removeFromParentEv"]
    pub fn llvm_Instruction_removeFromParent(this: *mut llvm_Instruction);
}
extern "C" {
    #[doc = " This method unlinks 'this' from the containing basic block and deletes it.\n\n \\returns an iterator pointing to the element after the erased one"]
    #[link_name = "\u{1}_ZN4llvm11Instruction15eraseFromParentEv"]
    pub fn llvm_Instruction_eraseFromParent(this: *mut llvm_Instruction) -> [u64; 2usize];
}
extern "C" {
    #[doc = " Insert an unlinked instruction into a basic block immediately before\n the specified instruction."]
    #[link_name = "\u{1}_ZN4llvm11Instruction12insertBeforeEPS0_"]
    pub fn llvm_Instruction_insertBefore(
        this: *mut llvm_Instruction,
        InsertPos: *mut llvm_Instruction,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm11Instruction12insertBeforeENS_21ilist_iterator_w_bitsINS_12ilist_detail12node_optionsIS0_Lb1ELb0EvLb1ENS_10BasicBlockEEELb0ELb0EEE"]
    pub fn llvm_Instruction_insertBefore1(this: *mut llvm_Instruction, InsertPos: [u64; 2usize]);
}
extern "C" {
    #[doc = " Insert an unlinked instruction into a basic block immediately after the\n specified instruction."]
    #[link_name = "\u{1}_ZN4llvm11Instruction11insertAfterEPS0_"]
    pub fn llvm_Instruction_insertAfter(
        this: *mut llvm_Instruction,
        InsertPos: *mut llvm_Instruction,
    );
}
extern "C" {
    #[doc = " Inserts an unlinked instruction into \\p ParentBB at position \\p It and\n returns the iterator of the inserted instruction."]
    #[link_name = "\u{1}_ZN4llvm11Instruction10insertIntoEPNS_10BasicBlockENS_21ilist_iterator_w_bitsINS_12ilist_detail12node_optionsIS0_Lb1ELb0EvLb1ES1_EELb0ELb0EEE"]
    pub fn llvm_Instruction_insertInto(
        this: *mut llvm_Instruction,
        ParentBB: *mut llvm_BasicBlock,
        It: [u64; 2usize],
    ) -> [u64; 2usize];
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm11Instruction12insertBeforeERNS_10BasicBlockENS_21ilist_iterator_w_bitsINS_12ilist_detail12node_optionsIS0_Lb1ELb0EvLb1ES1_EELb0ELb0EEE"]
    pub fn llvm_Instruction_insertBefore2(
        this: *mut llvm_Instruction,
        BB: *mut llvm_BasicBlock,
        InsertPos: [u64; 2usize],
    );
}
extern "C" {
    #[doc = " Unlink this instruction from its current basic block and insert it into\n the basic block that MovePos lives in, right before MovePos."]
    #[link_name = "\u{1}_ZN4llvm11Instruction10moveBeforeEPS0_"]
    pub fn llvm_Instruction_moveBefore(this: *mut llvm_Instruction, MovePos: *mut llvm_Instruction);
}
extern "C" {
    #[doc = " Perform a \\ref moveBefore operation, while signalling that the caller\n intends to preserve the original ordering of instructions. This implicitly\n means that any adjacent debug-info should move with this instruction.\n This method is currently a no-op placeholder, but it will become meaningful\n when the \"RemoveDIs\" project is enabled."]
    #[link_name = "\u{1}_ZN4llvm11Instruction20moveBeforePreservingEPS0_"]
    pub fn llvm_Instruction_moveBeforePreserving(
        this: *mut llvm_Instruction,
        MovePos: *mut llvm_Instruction,
    );
}
extern "C" {
    #[doc = " Unlink this instruction and insert into BB before I.\n\n \\pre I is a valid iterator into BB."]
    #[link_name = "\u{1}_ZN4llvm11Instruction10moveBeforeERNS_10BasicBlockENS_21ilist_iterator_w_bitsINS_12ilist_detail12node_optionsIS0_Lb1ELb0EvLb1ES1_EELb0ELb0EEE"]
    pub fn llvm_Instruction_moveBefore1(
        this: *mut llvm_Instruction,
        BB: *mut llvm_BasicBlock,
        I: [u64; 2usize],
    );
}
extern "C" {
    #[doc = " (See other overload for moveBeforePreserving)."]
    #[link_name = "\u{1}_ZN4llvm11Instruction20moveBeforePreservingERNS_10BasicBlockENS_21ilist_iterator_w_bitsINS_12ilist_detail12node_optionsIS0_Lb1ELb0EvLb1ES1_EELb0ELb0EEE"]
    pub fn llvm_Instruction_moveBeforePreserving1(
        this: *mut llvm_Instruction,
        BB: *mut llvm_BasicBlock,
        I: [u64; 2usize],
    );
}
extern "C" {
    #[doc = " Unlink this instruction from its current basic block and insert it into\n the basic block that MovePos lives in, right after MovePos."]
    #[link_name = "\u{1}_ZN4llvm11Instruction9moveAfterEPS0_"]
    pub fn llvm_Instruction_moveAfter(this: *mut llvm_Instruction, MovePos: *mut llvm_Instruction);
}
extern "C" {
    #[doc = " See \\ref moveBeforePreserving ."]
    #[link_name = "\u{1}_ZN4llvm11Instruction19moveAfterPreservingEPS0_"]
    pub fn llvm_Instruction_moveAfterPreserving(
        this: *mut llvm_Instruction,
        MovePos: *mut llvm_Instruction,
    );
}
extern "C" {
    #[doc = " Given an instruction Other in the same basic block as this instruction,\n return true if this instruction comes before Other. In this worst case,\n this takes linear time in the number of instructions in the block. The\n results are cached, so in common cases when the block remains unmodified,\n it takes constant time."]
    #[link_name = "\u{1}_ZNK4llvm11Instruction11comesBeforeEPKS0_"]
    pub fn llvm_Instruction_comesBefore(
        this: *const llvm_Instruction,
        Other: *const llvm_Instruction,
    ) -> bool;
}
extern "C" {
    #[doc = " Get the first insertion point at which the result of this instruction\n is defined. This is *not* the directly following instruction in a number\n of cases, e.g. phi nodes or terminators that return values. This function\n may return null if the insertion after the definition is not possible,\n e.g. due to a catchswitch terminator."]
    #[link_name = "\u{1}_ZN4llvm11Instruction25getInsertionPointAfterDefEv"]
    pub fn llvm_Instruction_getInsertionPointAfterDef(this: *mut llvm_Instruction) -> std_optional;
}
extern "C" {
    #[doc = " It checks if this instruction is the only user of at least one of\n its operands."]
    #[link_name = "\u{1}_ZN4llvm11Instruction22isOnlyUserOfAnyOperandEv"]
    pub fn llvm_Instruction_isOnlyUserOfAnyOperand(this: *mut llvm_Instruction) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm11Instruction13getOpcodeNameEj"]
    pub fn llvm_Instruction_getOpcodeName(
        Opcode: ::std::os::raw::c_uint,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Set the metadata of the specified kind to the specified node. This updates\n or replaces metadata if already present, or removes it if Node is null."]
    #[link_name = "\u{1}_ZN4llvm11Instruction11setMetadataEjPNS_6MDNodeE"]
    pub fn llvm_Instruction_setMetadata(
        this: *mut llvm_Instruction,
        KindID: ::std::os::raw::c_uint,
        Node: *mut llvm_MDNode,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm11Instruction11setMetadataENS_9StringRefEPNS_6MDNodeE"]
    pub fn llvm_Instruction_setMetadata1(
        this: *mut llvm_Instruction,
        Kind: llvm_StringRef,
        Node: *mut llvm_MDNode,
    );
}
extern "C" {
    #[doc = " Copy metadata from \\p SrcInst to this instruction. \\p WL, if not empty,\n specifies the list of meta data that needs to be copied. If \\p WL is\n empty, all meta data will be copied."]
    #[link_name = "\u{1}_ZN4llvm11Instruction12copyMetadataERKS0_NS_8ArrayRefIjEE"]
    pub fn llvm_Instruction_copyMetadata(
        this: *mut llvm_Instruction,
        SrcInst: *const llvm_Instruction,
        WL: llvm_ArrayRef<::std::os::raw::c_uint>,
    );
}
extern "C" {
    #[doc = " Erase all metadata that matches the predicate."]
    #[link_name = "\u{1}_ZN4llvm11Instruction15eraseMetadataIfENS_12function_refIFbjPNS_6MDNodeEEEE"]
    pub fn llvm_Instruction_eraseMetadataIf(this: *mut llvm_Instruction, Pred: llvm_function_ref);
}
extern "C" {
    #[doc = " If the instruction has \"branch_weights\" MD_prof metadata and the MDNode\n has three operands (including name string), swap the order of the\n metadata."]
    #[link_name = "\u{1}_ZN4llvm11Instruction16swapProfMetadataEv"]
    pub fn llvm_Instruction_swapProfMetadata(this: *mut llvm_Instruction);
}
extern "C" {
    #[doc = " Drop all unknown metadata except for debug locations.\n @{\n Passes are required to drop metadata they don't understand. This is a\n convenience method for passes to do so.\n dropUBImplyingAttrsAndUnknownMetadata should be used instead of\n this API if the Instruction being modified is a call."]
    #[link_name = "\u{1}_ZN4llvm11Instruction27dropUnknownNonDebugMetadataENS_8ArrayRefIjEE"]
    pub fn llvm_Instruction_dropUnknownNonDebugMetadata(
        this: *mut llvm_Instruction,
        KnownIDs: llvm_ArrayRef<::std::os::raw::c_uint>,
    );
}
extern "C" {
    #[doc = " Adds an !annotation metadata node with \\p Annotation to this instruction.\n If this instruction already has !annotation metadata, append \\p Annotation\n to the existing node."]
    #[link_name = "\u{1}_ZN4llvm11Instruction21addAnnotationMetadataENS_9StringRefE"]
    pub fn llvm_Instruction_addAnnotationMetadata(
        this: *mut llvm_Instruction,
        Annotation: llvm_StringRef,
    );
}
extern "C" {
    #[doc = " Adds an !annotation metadata node with an array of \\p Annotations\n as a tuple to this instruction. If this instruction already has\n !annotation metadata, append the tuple to\n the existing node."]
    #[link_name = "\u{1}_ZN4llvm11Instruction21addAnnotationMetadataENS_11SmallVectorINS_9StringRefELj3EEE"]
    pub fn llvm_Instruction_addAnnotationMetadata1(this: *mut llvm_Instruction, Annotations: u8);
}
extern "C" {
    #[doc = " Returns the AA metadata for this instruction."]
    #[link_name = "\u{1}_ZNK4llvm11Instruction13getAAMetadataEv"]
    pub fn llvm_Instruction_getAAMetadata(this: *const llvm_Instruction) -> llvm_AAMDNodes;
}
extern "C" {
    #[doc = " Sets the AA metadata on this instruction from the AAMDNodes structure."]
    #[link_name = "\u{1}_ZN4llvm11Instruction13setAAMetadataERKNS_9AAMDNodesE"]
    pub fn llvm_Instruction_setAAMetadata(this: *mut llvm_Instruction, N: *const llvm_AAMDNodes);
}
extern "C" {
    #[doc = " Sets the nosanitize metadata on this instruction."]
    #[link_name = "\u{1}_ZN4llvm11Instruction21setNoSanitizeMetadataEv"]
    pub fn llvm_Instruction_setNoSanitizeMetadata(this: *mut llvm_Instruction);
}
extern "C" {
    #[doc = " Retrieve total raw weight values of a branch.\n Returns true on success with profile total weights filled in.\n Returns false if no metadata was found."]
    #[link_name = "\u{1}_ZNK4llvm11Instruction22extractProfTotalWeightERm"]
    pub fn llvm_Instruction_extractProfTotalWeight(
        this: *const llvm_Instruction,
        TotalVal: *mut u64,
    ) -> bool;
}
extern "C" {
    #[doc = " Fetch the debug location for this node, unless this is a debug intrinsic,\n in which case fetch the debug location of the next non-debug node."]
    #[link_name = "\u{1}_ZNK4llvm11Instruction17getStableDebugLocEv"]
    pub fn llvm_Instruction_getStableDebugLoc(
        this: *const llvm_Instruction,
    ) -> *const llvm_DebugLoc;
}
extern "C" {
    #[doc = " Set or clear the nuw flag on this instruction, which must be an operator\n which supports this flag. See LangRef.html for the meaning of this flag."]
    #[link_name = "\u{1}_ZN4llvm11Instruction20setHasNoUnsignedWrapEb"]
    pub fn llvm_Instruction_setHasNoUnsignedWrap(this: *mut llvm_Instruction, b: bool);
}
extern "C" {
    #[doc = " Set or clear the nsw flag on this instruction, which must be an operator\n which supports this flag. See LangRef.html for the meaning of this flag."]
    #[link_name = "\u{1}_ZN4llvm11Instruction18setHasNoSignedWrapEb"]
    pub fn llvm_Instruction_setHasNoSignedWrap(this: *mut llvm_Instruction, b: bool);
}
extern "C" {
    #[doc = " Set or clear the exact flag on this instruction, which must be an operator\n which supports this flag. See LangRef.html for the meaning of this flag."]
    #[link_name = "\u{1}_ZN4llvm11Instruction10setIsExactEb"]
    pub fn llvm_Instruction_setIsExact(this: *mut llvm_Instruction, b: bool);
}
extern "C" {
    #[doc = " Set or clear the nneg flag on this instruction, which must be a zext\n instruction."]
    #[link_name = "\u{1}_ZN4llvm11Instruction9setNonNegEb"]
    pub fn llvm_Instruction_setNonNeg(this: *mut llvm_Instruction, b: bool);
}
extern "C" {
    #[doc = " Determine whether the no unsigned wrap flag is set."]
    #[link_name = "\u{1}_ZNK4llvm11Instruction17hasNoUnsignedWrapEv"]
    pub fn llvm_Instruction_hasNoUnsignedWrap(this: *const llvm_Instruction) -> bool;
}
extern "C" {
    #[doc = " Determine whether the no signed wrap flag is set."]
    #[link_name = "\u{1}_ZNK4llvm11Instruction15hasNoSignedWrapEv"]
    pub fn llvm_Instruction_hasNoSignedWrap(this: *const llvm_Instruction) -> bool;
}
extern "C" {
    #[doc = " Determine whether the the nneg flag is set."]
    #[link_name = "\u{1}_ZNK4llvm11Instruction9hasNonNegEv"]
    pub fn llvm_Instruction_hasNonNeg(this: *const llvm_Instruction) -> bool;
}
extern "C" {
    #[doc = " Return true if this operator has flags which may cause this instruction\n to evaluate to poison despite having non-poison inputs."]
    #[link_name = "\u{1}_ZNK4llvm11Instruction24hasPoisonGeneratingFlagsEv"]
    pub fn llvm_Instruction_hasPoisonGeneratingFlags(this: *const llvm_Instruction) -> bool;
}
extern "C" {
    #[doc = " Drops flags that may cause this instruction to evaluate to poison despite\n having non-poison inputs."]
    #[link_name = "\u{1}_ZN4llvm11Instruction25dropPoisonGeneratingFlagsEv"]
    pub fn llvm_Instruction_dropPoisonGeneratingFlags(this: *mut llvm_Instruction);
}
extern "C" {
    #[doc = " Return true if this instruction has poison-generating metadata."]
    #[link_name = "\u{1}_ZNK4llvm11Instruction27hasPoisonGeneratingMetadataEv"]
    pub fn llvm_Instruction_hasPoisonGeneratingMetadata(this: *const llvm_Instruction) -> bool;
}
extern "C" {
    #[doc = " Drops metadata that may generate poison."]
    #[link_name = "\u{1}_ZN4llvm11Instruction28dropPoisonGeneratingMetadataEv"]
    pub fn llvm_Instruction_dropPoisonGeneratingMetadata(this: *mut llvm_Instruction);
}
extern "C" {
    #[doc = " Return true if this instruction has poison-generating attribute."]
    #[link_name = "\u{1}_ZNK4llvm11Instruction35hasPoisonGeneratingReturnAttributesEv"]
    pub fn llvm_Instruction_hasPoisonGeneratingReturnAttributes(
        this: *const llvm_Instruction,
    ) -> bool;
}
extern "C" {
    #[doc = " Drops return attributes that may generate poison."]
    #[link_name = "\u{1}_ZN4llvm11Instruction36dropPoisonGeneratingReturnAttributesEv"]
    pub fn llvm_Instruction_dropPoisonGeneratingReturnAttributes(this: *mut llvm_Instruction);
}
extern "C" {
    #[doc = " This function drops non-debug unknown metadata (through\n dropUnknownNonDebugMetadata). For calls, it also drops parameter and\n return attributes that can cause undefined behaviour. Both of these should\n be done by passes which move instructions in IR."]
    #[link_name = "\u{1}_ZN4llvm11Instruction37dropUBImplyingAttrsAndUnknownMetadataENS_8ArrayRefIjEE"]
    pub fn llvm_Instruction_dropUBImplyingAttrsAndUnknownMetadata(
        this: *mut llvm_Instruction,
        KnownIDs: llvm_ArrayRef<::std::os::raw::c_uint>,
    );
}
extern "C" {
    #[doc = " Drop any attributes or metadata that can cause immediate undefined\n behavior. Retain other attributes/metadata on a best-effort basis.\n This should be used when speculating instructions."]
    #[link_name = "\u{1}_ZN4llvm11Instruction30dropUBImplyingAttrsAndMetadataEv"]
    pub fn llvm_Instruction_dropUBImplyingAttrsAndMetadata(this: *mut llvm_Instruction);
}
extern "C" {
    #[doc = " Determine whether the exact flag is set."]
    #[link_name = "\u{1}_ZNK4llvm11Instruction7isExactEv"]
    pub fn llvm_Instruction_isExact(this: *const llvm_Instruction) -> bool;
}
extern "C" {
    #[doc = " Set or clear all fast-math-flags on this instruction, which must be an\n operator which supports this flag. See LangRef.html for the meaning of\n this flag."]
    #[link_name = "\u{1}_ZN4llvm11Instruction7setFastEb"]
    pub fn llvm_Instruction_setFast(this: *mut llvm_Instruction, B: bool);
}
extern "C" {
    #[doc = " Set or clear the reassociation flag on this instruction, which must be\n an operator which supports this flag. See LangRef.html for the meaning of\n this flag."]
    #[link_name = "\u{1}_ZN4llvm11Instruction18setHasAllowReassocEb"]
    pub fn llvm_Instruction_setHasAllowReassoc(this: *mut llvm_Instruction, B: bool);
}
extern "C" {
    #[doc = " Set or clear the no-nans flag on this instruction, which must be an\n operator which supports this flag. See LangRef.html for the meaning of\n this flag."]
    #[link_name = "\u{1}_ZN4llvm11Instruction12setHasNoNaNsEb"]
    pub fn llvm_Instruction_setHasNoNaNs(this: *mut llvm_Instruction, B: bool);
}
extern "C" {
    #[doc = " Set or clear the no-infs flag on this instruction, which must be an\n operator which supports this flag. See LangRef.html for the meaning of\n this flag."]
    #[link_name = "\u{1}_ZN4llvm11Instruction12setHasNoInfsEb"]
    pub fn llvm_Instruction_setHasNoInfs(this: *mut llvm_Instruction, B: bool);
}
extern "C" {
    #[doc = " Set or clear the no-signed-zeros flag on this instruction, which must be\n an operator which supports this flag. See LangRef.html for the meaning of\n this flag."]
    #[link_name = "\u{1}_ZN4llvm11Instruction19setHasNoSignedZerosEb"]
    pub fn llvm_Instruction_setHasNoSignedZeros(this: *mut llvm_Instruction, B: bool);
}
extern "C" {
    #[doc = " Set or clear the allow-reciprocal flag on this instruction, which must be\n an operator which supports this flag. See LangRef.html for the meaning of\n this flag."]
    #[link_name = "\u{1}_ZN4llvm11Instruction21setHasAllowReciprocalEb"]
    pub fn llvm_Instruction_setHasAllowReciprocal(this: *mut llvm_Instruction, B: bool);
}
extern "C" {
    #[doc = " Set or clear the allow-contract flag on this instruction, which must be\n an operator which supports this flag. See LangRef.html for the meaning of\n this flag."]
    #[link_name = "\u{1}_ZN4llvm11Instruction19setHasAllowContractEb"]
    pub fn llvm_Instruction_setHasAllowContract(this: *mut llvm_Instruction, B: bool);
}
extern "C" {
    #[doc = " Set or clear the approximate-math-functions flag on this instruction,\n which must be an operator which supports this flag. See LangRef.html for\n the meaning of this flag."]
    #[link_name = "\u{1}_ZN4llvm11Instruction16setHasApproxFuncEb"]
    pub fn llvm_Instruction_setHasApproxFunc(this: *mut llvm_Instruction, B: bool);
}
extern "C" {
    #[doc = " Convenience function for setting multiple fast-math flags on this\n instruction, which must be an operator which supports these flags. See\n LangRef.html for the meaning of these flags."]
    #[link_name = "\u{1}_ZN4llvm11Instruction16setFastMathFlagsENS_13FastMathFlagsE"]
    pub fn llvm_Instruction_setFastMathFlags(this: *mut llvm_Instruction, FMF: llvm_FastMathFlags);
}
extern "C" {
    #[doc = " Convenience function for transferring all fast-math flag values to this\n instruction, which must be an operator which supports these flags. See\n LangRef.html for the meaning of these flags."]
    #[link_name = "\u{1}_ZN4llvm11Instruction17copyFastMathFlagsENS_13FastMathFlagsE"]
    pub fn llvm_Instruction_copyFastMathFlags(this: *mut llvm_Instruction, FMF: llvm_FastMathFlags);
}
extern "C" {
    #[doc = " Determine whether all fast-math-flags are set."]
    #[link_name = "\u{1}_ZNK4llvm11Instruction6isFastEv"]
    pub fn llvm_Instruction_isFast(this: *const llvm_Instruction) -> bool;
}
extern "C" {
    #[doc = " Determine whether the allow-reassociation flag is set."]
    #[link_name = "\u{1}_ZNK4llvm11Instruction15hasAllowReassocEv"]
    pub fn llvm_Instruction_hasAllowReassoc(this: *const llvm_Instruction) -> bool;
}
extern "C" {
    #[doc = " Determine whether the no-NaNs flag is set."]
    #[link_name = "\u{1}_ZNK4llvm11Instruction9hasNoNaNsEv"]
    pub fn llvm_Instruction_hasNoNaNs(this: *const llvm_Instruction) -> bool;
}
extern "C" {
    #[doc = " Determine whether the no-infs flag is set."]
    #[link_name = "\u{1}_ZNK4llvm11Instruction9hasNoInfsEv"]
    pub fn llvm_Instruction_hasNoInfs(this: *const llvm_Instruction) -> bool;
}
extern "C" {
    #[doc = " Determine whether the no-signed-zeros flag is set."]
    #[link_name = "\u{1}_ZNK4llvm11Instruction16hasNoSignedZerosEv"]
    pub fn llvm_Instruction_hasNoSignedZeros(this: *const llvm_Instruction) -> bool;
}
extern "C" {
    #[doc = " Determine whether the allow-reciprocal flag is set."]
    #[link_name = "\u{1}_ZNK4llvm11Instruction18hasAllowReciprocalEv"]
    pub fn llvm_Instruction_hasAllowReciprocal(this: *const llvm_Instruction) -> bool;
}
extern "C" {
    #[doc = " Determine whether the allow-contract flag is set."]
    #[link_name = "\u{1}_ZNK4llvm11Instruction16hasAllowContractEv"]
    pub fn llvm_Instruction_hasAllowContract(this: *const llvm_Instruction) -> bool;
}
extern "C" {
    #[doc = " Determine whether the approximate-math-functions flag is set."]
    #[link_name = "\u{1}_ZNK4llvm11Instruction13hasApproxFuncEv"]
    pub fn llvm_Instruction_hasApproxFunc(this: *const llvm_Instruction) -> bool;
}
extern "C" {
    #[doc = " Convenience function for getting all the fast-math flags, which must be an\n operator which supports these flags. See LangRef.html for the meaning of\n these flags."]
    #[link_name = "\u{1}_ZNK4llvm11Instruction16getFastMathFlagsEv"]
    pub fn llvm_Instruction_getFastMathFlags(this: *const llvm_Instruction) -> llvm_FastMathFlags;
}
extern "C" {
    #[doc = " Copy I's fast-math flags"]
    #[link_name = "\u{1}_ZN4llvm11Instruction17copyFastMathFlagsEPKS0_"]
    pub fn llvm_Instruction_copyFastMathFlags1(
        this: *mut llvm_Instruction,
        I: *const llvm_Instruction,
    );
}
extern "C" {
    #[doc = " Convenience method to copy supported exact, fast-math, and (optionally)\n wrapping flags from V to this instruction."]
    #[link_name = "\u{1}_ZN4llvm11Instruction11copyIRFlagsEPKNS_5ValueEb"]
    pub fn llvm_Instruction_copyIRFlags(
        this: *mut llvm_Instruction,
        V: *const llvm_Value,
        IncludeWrapFlags: bool,
    );
}
extern "C" {
    #[doc = " Logical 'and' of any supported wrapping, exact, and fast-math flags of\n V and this instruction."]
    #[link_name = "\u{1}_ZN4llvm11Instruction10andIRFlagsEPKNS_5ValueE"]
    pub fn llvm_Instruction_andIRFlags(this: *mut llvm_Instruction, V: *const llvm_Value);
}
extern "C" {
    #[doc = " Merge 2 debug locations and apply it to the Instruction. If the\n instruction is a CallIns, we need to traverse the inline chain to find\n the common scope. This is not efficient for N-way merging as each time\n you merge 2 iterations, you need to rebuild the hashmap to find the\n common scope. However, we still choose this API because:\n  1) Simplicity: it takes 2 locations instead of a list of locations.\n  2) In worst case, it increases the complexity from O(N*I) to\n     O(2*N*I), where N is # of Instructions to merge, and I is the\n     maximum level of inline stack. So it is still linear.\n  3) Merging of call instructions should be extremely rare in real\n     applications, thus the N-way merging should be in code path.\n The DebugLoc attached to this instruction will be overwritten by the\n merged DebugLoc."]
    #[link_name = "\u{1}_ZN4llvm11Instruction19applyMergedLocationEPNS_10DILocationES2_"]
    pub fn llvm_Instruction_applyMergedLocation(
        this: *mut llvm_Instruction,
        LocA: *mut llvm_DILocation,
        LocB: *mut llvm_DILocation,
    );
}
extern "C" {
    #[doc = " Updates the debug location given that the instruction has been hoisted\n from a block to a predecessor of that block.\n Note: it is undefined behavior to call this on an instruction not\n currently inserted into a function."]
    #[link_name = "\u{1}_ZN4llvm11Instruction24updateLocationAfterHoistEv"]
    pub fn llvm_Instruction_updateLocationAfterHoist(this: *mut llvm_Instruction);
}
extern "C" {
    #[doc = " Drop the instruction's debug location. This does not guarantee removal\n of the !dbg source location attachment, as it must set a line 0 location\n with scope information attached on call instructions. To guarantee\n removal of the !dbg attachment, use the \\ref setDebugLoc() API.\n Note: it is undefined behavior to call this on an instruction not\n currently inserted into a function."]
    #[link_name = "\u{1}_ZN4llvm11Instruction12dropLocationEv"]
    pub fn llvm_Instruction_dropLocation(this: *mut llvm_Instruction);
}
extern "C" {
    #[doc = " Merge the DIAssignID metadata from this instruction and those attached to\n instructions in \\p SourceInstructions. This process performs a RAUW on\n the MetadataAsValue uses of the merged DIAssignID nodes. Not every\n instruction in \\p SourceInstructions needs to have DIAssignID\n metadata. If none of them do then nothing happens. If this instruction\n does not have a DIAssignID attachment but at least one in \\p\n SourceInstructions does then the merged one will be attached to\n it. However, instructions without attachments in \\p SourceInstructions\n are not modified."]
    #[link_name = "\u{1}_ZN4llvm11Instruction15mergeDIAssignIDENS_8ArrayRefIPKS0_EE"]
    pub fn llvm_Instruction_mergeDIAssignID(
        this: *mut llvm_Instruction,
        SourceInstructions: llvm_ArrayRef<*const llvm_Instruction>,
    );
}
extern "C" {
    #[doc = " Return true if the instruction is associative:\n\n   Associative operators satisfy:  x op (y op z) === (x op y) op z\n\n In LLVM, the Add, Mul, And, Or, and Xor operators are associative.\n"]
    #[link_name = "\u{1}_ZNK4llvm11Instruction13isAssociativeEv"]
    pub fn llvm_Instruction_isAssociative(this: *const llvm_Instruction) -> bool;
}
extern "C" {
    #[doc = " Return true if the instruction is commutative:\n\n   Commutative operators satisfy: (x op y) === (y op x)\n\n In LLVM, these are the commutative operators, plus SetEQ and SetNE, when\n applied to any type.\n"]
    #[link_name = "\u{1}_ZNK4llvm11Instruction13isCommutativeEv"]
    pub fn llvm_Instruction_isCommutative(this: *const llvm_Instruction) -> bool;
}
extern "C" {
    #[doc = " Return true if this instruction may modify memory."]
    #[link_name = "\u{1}_ZNK4llvm11Instruction16mayWriteToMemoryEv"]
    pub fn llvm_Instruction_mayWriteToMemory(this: *const llvm_Instruction) -> bool;
}
extern "C" {
    #[doc = " Return true if this instruction may read memory."]
    #[link_name = "\u{1}_ZNK4llvm11Instruction17mayReadFromMemoryEv"]
    pub fn llvm_Instruction_mayReadFromMemory(this: *const llvm_Instruction) -> bool;
}
extern "C" {
    #[doc = " Return true if this instruction has an AtomicOrdering of unordered or\n higher."]
    #[link_name = "\u{1}_ZNK4llvm11Instruction8isAtomicEv"]
    pub fn llvm_Instruction_isAtomic(this: *const llvm_Instruction) -> bool;
}
extern "C" {
    #[doc = " Return true if this atomic instruction loads from memory."]
    #[link_name = "\u{1}_ZNK4llvm11Instruction13hasAtomicLoadEv"]
    pub fn llvm_Instruction_hasAtomicLoad(this: *const llvm_Instruction) -> bool;
}
extern "C" {
    #[doc = " Return true if this atomic instruction stores to memory."]
    #[link_name = "\u{1}_ZNK4llvm11Instruction14hasAtomicStoreEv"]
    pub fn llvm_Instruction_hasAtomicStore(this: *const llvm_Instruction) -> bool;
}
extern "C" {
    #[doc = " Return true if this instruction has a volatile memory access."]
    #[link_name = "\u{1}_ZNK4llvm11Instruction10isVolatileEv"]
    pub fn llvm_Instruction_isVolatile(this: *const llvm_Instruction) -> bool;
}
extern "C" {
    #[doc = " Return the type this instruction accesses in memory, if any."]
    #[link_name = "\u{1}_ZNK4llvm11Instruction13getAccessTypeEv"]
    pub fn llvm_Instruction_getAccessType(this: *const llvm_Instruction) -> *mut llvm_Type;
}
extern "C" {
    #[doc = " Return true if this instruction may throw an exception.\n\n If IncludePhaseOneUnwind is set, this will also include cases where\n phase one unwinding may unwind past this frame due to skipping of\n cleanup landingpads."]
    #[link_name = "\u{1}_ZNK4llvm11Instruction8mayThrowEb"]
    pub fn llvm_Instruction_mayThrow(
        this: *const llvm_Instruction,
        IncludePhaseOneUnwind: bool,
    ) -> bool;
}
extern "C" {
    #[doc = " Return true if the instruction may have side effects.\n\n Side effects are:\n  * Writing to memory.\n  * Unwinding.\n  * Not returning (e.g. an infinite loop).\n\n Note that this does not consider malloc and alloca to have side\n effects because the newly allocated memory is completely invisible to\n instructions which don't use the returned value.  For cases where this\n matters, isSafeToSpeculativelyExecute may be more appropriate."]
    #[link_name = "\u{1}_ZNK4llvm11Instruction18mayHaveSideEffectsEv"]
    pub fn llvm_Instruction_mayHaveSideEffects(this: *const llvm_Instruction) -> bool;
}
extern "C" {
    #[doc = " Return true if the instruction can be removed if the result is unused.\n\n When constant folding some instructions cannot be removed even if their\n results are unused. Specifically terminator instructions and calls that\n may have side effects cannot be removed without semantically changing the\n generated program."]
    #[link_name = "\u{1}_ZNK4llvm11Instruction14isSafeToRemoveEv"]
    pub fn llvm_Instruction_isSafeToRemove(this: *const llvm_Instruction) -> bool;
}
extern "C" {
    #[doc = " Return true if the instruction will return (unwinding is considered as\n a form of returning control flow here)."]
    #[link_name = "\u{1}_ZNK4llvm11Instruction10willReturnEv"]
    pub fn llvm_Instruction_willReturn(this: *const llvm_Instruction) -> bool;
}
extern "C" {
    #[doc = " Return true if the instruction is a llvm.lifetime.start or\n llvm.lifetime.end marker."]
    #[link_name = "\u{1}_ZNK4llvm11Instruction20isLifetimeStartOrEndEv"]
    pub fn llvm_Instruction_isLifetimeStartOrEnd(this: *const llvm_Instruction) -> bool;
}
extern "C" {
    #[doc = " Return true if the instruction is a llvm.launder.invariant.group or\n llvm.strip.invariant.group."]
    #[link_name = "\u{1}_ZNK4llvm11Instruction30isLaunderOrStripInvariantGroupEv"]
    pub fn llvm_Instruction_isLaunderOrStripInvariantGroup(this: *const llvm_Instruction) -> bool;
}
extern "C" {
    #[doc = " Return true if the instruction is a DbgInfoIntrinsic or PseudoProbeInst."]
    #[link_name = "\u{1}_ZNK4llvm11Instruction19isDebugOrPseudoInstEv"]
    pub fn llvm_Instruction_isDebugOrPseudoInst(this: *const llvm_Instruction) -> bool;
}
extern "C" {
    #[doc = " Return a pointer to the next non-debug instruction in the same basic\n block as 'this', or nullptr if no such instruction exists. Skip any pseudo\n operations if \\c SkipPseudoOp is true."]
    #[link_name = "\u{1}_ZNK4llvm11Instruction26getNextNonDebugInstructionEb"]
    pub fn llvm_Instruction_getNextNonDebugInstruction(
        this: *const llvm_Instruction,
        SkipPseudoOp: bool,
    ) -> *const llvm_Instruction;
}
extern "C" {
    #[doc = " Return a pointer to the previous non-debug instruction in the same basic\n block as 'this', or nullptr if no such instruction exists. Skip any pseudo\n operations if \\c SkipPseudoOp is true."]
    #[link_name = "\u{1}_ZNK4llvm11Instruction26getPrevNonDebugInstructionEb"]
    pub fn llvm_Instruction_getPrevNonDebugInstruction(
        this: *const llvm_Instruction,
        SkipPseudoOp: bool,
    ) -> *const llvm_Instruction;
}
extern "C" {
    #[doc = " Create a copy of 'this' instruction that is identical in all ways except\n the following:\n   * The instruction has no parent\n   * The instruction has no name\n"]
    #[link_name = "\u{1}_ZNK4llvm11Instruction5cloneEv"]
    pub fn llvm_Instruction_clone(this: *const llvm_Instruction) -> *mut llvm_Instruction;
}
extern "C" {
    #[doc = " Return true if the specified instruction is exactly identical to the\n current one. This means that all operands match and any extra information\n (e.g. load is volatile) agree."]
    #[link_name = "\u{1}_ZNK4llvm11Instruction13isIdenticalToEPKS0_"]
    pub fn llvm_Instruction_isIdenticalTo(
        this: *const llvm_Instruction,
        I: *const llvm_Instruction,
    ) -> bool;
}
extern "C" {
    #[doc = " This is like isIdenticalTo, except that it ignores the\n SubclassOptionalData flags, which may specify conditions under which the\n instruction's result is undefined."]
    #[link_name = "\u{1}_ZNK4llvm11Instruction24isIdenticalToWhenDefinedEPKS0_"]
    pub fn llvm_Instruction_isIdenticalToWhenDefined(
        this: *const llvm_Instruction,
        I: *const llvm_Instruction,
    ) -> bool;
}
extern "C" {
    #[doc = " This function determines if the specified instruction executes the same\n operation as the current one. This means that the opcodes, type, operand\n types and any other factors affecting the operation must be the same. This\n is similar to isIdenticalTo except the operands themselves don't have to\n be identical.\n @returns true if the specified instruction is the same operation as\n the current one.\n Determine if one instruction is the same operation as another."]
    #[link_name = "\u{1}_ZNK4llvm11Instruction17isSameOperationAsEPKS0_j"]
    pub fn llvm_Instruction_isSameOperationAs(
        this: *const llvm_Instruction,
        I: *const llvm_Instruction,
        flags: ::std::os::raw::c_uint,
    ) -> bool;
}
extern "C" {
    #[doc = " This function determines if the speficied instruction has the same\n \"special\" characteristics as the current one. This means that opcode\n specific details are the same. As a common example, if we are comparing\n loads, then hasSameSpecialState would compare the alignments (among\n other things).\n @returns true if the specific instruction has the same opcde specific\n characteristics as the current one. Determine if one instruction has the\n same state as another."]
    #[link_name = "\u{1}_ZNK4llvm11Instruction19hasSameSpecialStateEPKS0_b"]
    pub fn llvm_Instruction_hasSameSpecialState(
        this: *const llvm_Instruction,
        I2: *const llvm_Instruction,
        IgnoreAlignment: bool,
    ) -> bool;
}
extern "C" {
    #[doc = " Return true if there are any uses of this instruction in blocks other than\n the specified block. Note that PHI nodes are considered to evaluate their\n operands in the corresponding predecessor block."]
    #[link_name = "\u{1}_ZNK4llvm11Instruction20isUsedOutsideOfBlockEPKNS_10BasicBlockE"]
    pub fn llvm_Instruction_isUsedOutsideOfBlock(
        this: *const llvm_Instruction,
        BB: *const llvm_BasicBlock,
    ) -> bool;
}
extern "C" {
    #[doc = " Return the number of successors that this instruction has. The instruction\n must be a terminator."]
    #[link_name = "\u{1}_ZNK4llvm11Instruction16getNumSuccessorsEv"]
    pub fn llvm_Instruction_getNumSuccessors(
        this: *const llvm_Instruction,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " Return the specified successor. This instruction must be a terminator."]
    #[link_name = "\u{1}_ZNK4llvm11Instruction12getSuccessorEj"]
    pub fn llvm_Instruction_getSuccessor(
        this: *const llvm_Instruction,
        Idx: ::std::os::raw::c_uint,
    ) -> *mut llvm_BasicBlock;
}
extern "C" {
    #[doc = " Update the specified successor to point at the provided block. This\n instruction must be a terminator."]
    #[link_name = "\u{1}_ZN4llvm11Instruction12setSuccessorEjPNS_10BasicBlockE"]
    pub fn llvm_Instruction_setSuccessor(
        this: *mut llvm_Instruction,
        Idx: ::std::os::raw::c_uint,
        BB: *mut llvm_BasicBlock,
    );
}
extern "C" {
    #[doc = " Replace specified successor OldBB to point at the provided block.\n This instruction must be a terminator."]
    #[link_name = "\u{1}_ZN4llvm11Instruction20replaceSuccessorWithEPNS_10BasicBlockES2_"]
    pub fn llvm_Instruction_replaceSuccessorWith(
        this: *mut llvm_Instruction,
        OldBB: *mut llvm_BasicBlock,
        NewBB: *mut llvm_BasicBlock,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm11InstructionC1EPNS_4TypeEjPNS_3UseEjNS_14InsertPositionE"]
    pub fn llvm_Instruction_Instruction(
        this: *mut llvm_Instruction,
        Ty: *mut llvm_Type,
        iType: ::std::os::raw::c_uint,
        Ops: *mut llvm_Use,
        NumOps: ::std::os::raw::c_uint,
        InsertBefore: llvm_InsertPosition,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm11InstructionD1Ev"]
    pub fn llvm_Instruction_Instruction_destructor(this: *mut llvm_Instruction);
}
impl llvm_Instruction {
    #[inline]
    pub unsafe fn cloneDebugInfoFrom(
        &mut self,
        From: *const llvm_Instruction,
        FromHere: std_optional,
        InsertAtHead: bool,
    ) -> [u64; 2usize] {
        llvm_Instruction_cloneDebugInfoFrom(self, From, FromHere, InsertAtHead)
    }
    #[inline]
    pub unsafe fn getDbgReinsertionPosition(&mut self) -> std_optional {
        llvm_Instruction_getDbgReinsertionPosition(self)
    }
    #[inline]
    pub unsafe fn hasDbgRecords(&self) -> bool {
        llvm_Instruction_hasDbgRecords(self)
    }
    #[inline]
    pub unsafe fn adoptDbgRecords(
        &mut self,
        BB: *mut llvm_BasicBlock,
        It: [u64; 2usize],
        InsertAtHead: bool,
    ) {
        llvm_Instruction_adoptDbgRecords(self, BB, It, InsertAtHead)
    }
    #[inline]
    pub unsafe fn dropDbgRecords(&mut self) {
        llvm_Instruction_dropDbgRecords(self)
    }
    #[inline]
    pub unsafe fn dropOneDbgRecord(&mut self, I: *mut llvm_DbgRecord) {
        llvm_Instruction_dropOneDbgRecord(self, I)
    }
    #[inline]
    pub unsafe fn handleMarkerRemoval(&mut self) {
        llvm_Instruction_handleMarkerRemoval(self)
    }
    #[inline]
    pub unsafe fn getModule(&self) -> *const llvm_Module {
        llvm_Instruction_getModule(self)
    }
    #[inline]
    pub unsafe fn getFunction(&self) -> *const llvm_Function {
        llvm_Instruction_getFunction(self)
    }
    #[inline]
    pub unsafe fn getDataLayout(&self) -> *const llvm_DataLayout {
        llvm_Instruction_getDataLayout(self)
    }
    #[inline]
    pub unsafe fn removeFromParent(&mut self) {
        llvm_Instruction_removeFromParent(self)
    }
    #[inline]
    pub unsafe fn eraseFromParent(&mut self) -> [u64; 2usize] {
        llvm_Instruction_eraseFromParent(self)
    }
    #[inline]
    pub unsafe fn insertBefore(&mut self, InsertPos: *mut llvm_Instruction) {
        llvm_Instruction_insertBefore(self, InsertPos)
    }
    #[inline]
    pub unsafe fn insertBefore1(&mut self, InsertPos: [u64; 2usize]) {
        llvm_Instruction_insertBefore1(self, InsertPos)
    }
    #[inline]
    pub unsafe fn insertAfter(&mut self, InsertPos: *mut llvm_Instruction) {
        llvm_Instruction_insertAfter(self, InsertPos)
    }
    #[inline]
    pub unsafe fn insertInto(
        &mut self,
        ParentBB: *mut llvm_BasicBlock,
        It: [u64; 2usize],
    ) -> [u64; 2usize] {
        llvm_Instruction_insertInto(self, ParentBB, It)
    }
    #[inline]
    pub unsafe fn insertBefore2(&mut self, BB: *mut llvm_BasicBlock, InsertPos: [u64; 2usize]) {
        llvm_Instruction_insertBefore2(self, BB, InsertPos)
    }
    #[inline]
    pub unsafe fn moveBefore(&mut self, MovePos: *mut llvm_Instruction) {
        llvm_Instruction_moveBefore(self, MovePos)
    }
    #[inline]
    pub unsafe fn moveBeforePreserving(&mut self, MovePos: *mut llvm_Instruction) {
        llvm_Instruction_moveBeforePreserving(self, MovePos)
    }
    #[inline]
    pub unsafe fn moveBefore1(&mut self, BB: *mut llvm_BasicBlock, I: [u64; 2usize]) {
        llvm_Instruction_moveBefore1(self, BB, I)
    }
    #[inline]
    pub unsafe fn moveBeforePreserving1(&mut self, BB: *mut llvm_BasicBlock, I: [u64; 2usize]) {
        llvm_Instruction_moveBeforePreserving1(self, BB, I)
    }
    #[inline]
    pub unsafe fn moveAfter(&mut self, MovePos: *mut llvm_Instruction) {
        llvm_Instruction_moveAfter(self, MovePos)
    }
    #[inline]
    pub unsafe fn moveAfterPreserving(&mut self, MovePos: *mut llvm_Instruction) {
        llvm_Instruction_moveAfterPreserving(self, MovePos)
    }
    #[inline]
    pub unsafe fn comesBefore(&self, Other: *const llvm_Instruction) -> bool {
        llvm_Instruction_comesBefore(self, Other)
    }
    #[inline]
    pub unsafe fn getInsertionPointAfterDef(&mut self) -> std_optional {
        llvm_Instruction_getInsertionPointAfterDef(self)
    }
    #[inline]
    pub unsafe fn isOnlyUserOfAnyOperand(&mut self) -> bool {
        llvm_Instruction_isOnlyUserOfAnyOperand(self)
    }
    #[inline]
    pub unsafe fn getOpcodeName(Opcode: ::std::os::raw::c_uint) -> *const ::std::os::raw::c_char {
        llvm_Instruction_getOpcodeName(Opcode)
    }
    #[inline]
    pub unsafe fn setMetadata(&mut self, KindID: ::std::os::raw::c_uint, Node: *mut llvm_MDNode) {
        llvm_Instruction_setMetadata(self, KindID, Node)
    }
    #[inline]
    pub unsafe fn setMetadata1(&mut self, Kind: llvm_StringRef, Node: *mut llvm_MDNode) {
        llvm_Instruction_setMetadata1(self, Kind, Node)
    }
    #[inline]
    pub unsafe fn copyMetadata(
        &mut self,
        SrcInst: *const llvm_Instruction,
        WL: llvm_ArrayRef<::std::os::raw::c_uint>,
    ) {
        llvm_Instruction_copyMetadata(self, SrcInst, WL)
    }
    #[inline]
    pub unsafe fn eraseMetadataIf(&mut self, Pred: llvm_function_ref) {
        llvm_Instruction_eraseMetadataIf(self, Pred)
    }
    #[inline]
    pub unsafe fn swapProfMetadata(&mut self) {
        llvm_Instruction_swapProfMetadata(self)
    }
    #[inline]
    pub unsafe fn dropUnknownNonDebugMetadata(
        &mut self,
        KnownIDs: llvm_ArrayRef<::std::os::raw::c_uint>,
    ) {
        llvm_Instruction_dropUnknownNonDebugMetadata(self, KnownIDs)
    }
    #[inline]
    pub unsafe fn addAnnotationMetadata(&mut self, Annotation: llvm_StringRef) {
        llvm_Instruction_addAnnotationMetadata(self, Annotation)
    }
    #[inline]
    pub unsafe fn addAnnotationMetadata1(&mut self, Annotations: u8) {
        llvm_Instruction_addAnnotationMetadata1(self, Annotations)
    }
    #[inline]
    pub unsafe fn getAAMetadata(&self) -> llvm_AAMDNodes {
        llvm_Instruction_getAAMetadata(self)
    }
    #[inline]
    pub unsafe fn setAAMetadata(&mut self, N: *const llvm_AAMDNodes) {
        llvm_Instruction_setAAMetadata(self, N)
    }
    #[inline]
    pub unsafe fn setNoSanitizeMetadata(&mut self) {
        llvm_Instruction_setNoSanitizeMetadata(self)
    }
    #[inline]
    pub unsafe fn extractProfTotalWeight(&self, TotalVal: *mut u64) -> bool {
        llvm_Instruction_extractProfTotalWeight(self, TotalVal)
    }
    #[inline]
    pub unsafe fn getStableDebugLoc(&self) -> *const llvm_DebugLoc {
        llvm_Instruction_getStableDebugLoc(self)
    }
    #[inline]
    pub unsafe fn setHasNoUnsignedWrap(&mut self, b: bool) {
        llvm_Instruction_setHasNoUnsignedWrap(self, b)
    }
    #[inline]
    pub unsafe fn setHasNoSignedWrap(&mut self, b: bool) {
        llvm_Instruction_setHasNoSignedWrap(self, b)
    }
    #[inline]
    pub unsafe fn setIsExact(&mut self, b: bool) {
        llvm_Instruction_setIsExact(self, b)
    }
    #[inline]
    pub unsafe fn setNonNeg(&mut self, b: bool) {
        llvm_Instruction_setNonNeg(self, b)
    }
    #[inline]
    pub unsafe fn hasNoUnsignedWrap(&self) -> bool {
        llvm_Instruction_hasNoUnsignedWrap(self)
    }
    #[inline]
    pub unsafe fn hasNoSignedWrap(&self) -> bool {
        llvm_Instruction_hasNoSignedWrap(self)
    }
    #[inline]
    pub unsafe fn hasNonNeg(&self) -> bool {
        llvm_Instruction_hasNonNeg(self)
    }
    #[inline]
    pub unsafe fn hasPoisonGeneratingFlags(&self) -> bool {
        llvm_Instruction_hasPoisonGeneratingFlags(self)
    }
    #[inline]
    pub unsafe fn dropPoisonGeneratingFlags(&mut self) {
        llvm_Instruction_dropPoisonGeneratingFlags(self)
    }
    #[inline]
    pub unsafe fn hasPoisonGeneratingMetadata(&self) -> bool {
        llvm_Instruction_hasPoisonGeneratingMetadata(self)
    }
    #[inline]
    pub unsafe fn dropPoisonGeneratingMetadata(&mut self) {
        llvm_Instruction_dropPoisonGeneratingMetadata(self)
    }
    #[inline]
    pub unsafe fn hasPoisonGeneratingReturnAttributes(&self) -> bool {
        llvm_Instruction_hasPoisonGeneratingReturnAttributes(self)
    }
    #[inline]
    pub unsafe fn dropPoisonGeneratingReturnAttributes(&mut self) {
        llvm_Instruction_dropPoisonGeneratingReturnAttributes(self)
    }
    #[inline]
    pub unsafe fn dropUBImplyingAttrsAndUnknownMetadata(
        &mut self,
        KnownIDs: llvm_ArrayRef<::std::os::raw::c_uint>,
    ) {
        llvm_Instruction_dropUBImplyingAttrsAndUnknownMetadata(self, KnownIDs)
    }
    #[inline]
    pub unsafe fn dropUBImplyingAttrsAndMetadata(&mut self) {
        llvm_Instruction_dropUBImplyingAttrsAndMetadata(self)
    }
    #[inline]
    pub unsafe fn isExact(&self) -> bool {
        llvm_Instruction_isExact(self)
    }
    #[inline]
    pub unsafe fn setFast(&mut self, B: bool) {
        llvm_Instruction_setFast(self, B)
    }
    #[inline]
    pub unsafe fn setHasAllowReassoc(&mut self, B: bool) {
        llvm_Instruction_setHasAllowReassoc(self, B)
    }
    #[inline]
    pub unsafe fn setHasNoNaNs(&mut self, B: bool) {
        llvm_Instruction_setHasNoNaNs(self, B)
    }
    #[inline]
    pub unsafe fn setHasNoInfs(&mut self, B: bool) {
        llvm_Instruction_setHasNoInfs(self, B)
    }
    #[inline]
    pub unsafe fn setHasNoSignedZeros(&mut self, B: bool) {
        llvm_Instruction_setHasNoSignedZeros(self, B)
    }
    #[inline]
    pub unsafe fn setHasAllowReciprocal(&mut self, B: bool) {
        llvm_Instruction_setHasAllowReciprocal(self, B)
    }
    #[inline]
    pub unsafe fn setHasAllowContract(&mut self, B: bool) {
        llvm_Instruction_setHasAllowContract(self, B)
    }
    #[inline]
    pub unsafe fn setHasApproxFunc(&mut self, B: bool) {
        llvm_Instruction_setHasApproxFunc(self, B)
    }
    #[inline]
    pub unsafe fn setFastMathFlags(&mut self, FMF: llvm_FastMathFlags) {
        llvm_Instruction_setFastMathFlags(self, FMF)
    }
    #[inline]
    pub unsafe fn copyFastMathFlags(&mut self, FMF: llvm_FastMathFlags) {
        llvm_Instruction_copyFastMathFlags(self, FMF)
    }
    #[inline]
    pub unsafe fn isFast(&self) -> bool {
        llvm_Instruction_isFast(self)
    }
    #[inline]
    pub unsafe fn hasAllowReassoc(&self) -> bool {
        llvm_Instruction_hasAllowReassoc(self)
    }
    #[inline]
    pub unsafe fn hasNoNaNs(&self) -> bool {
        llvm_Instruction_hasNoNaNs(self)
    }
    #[inline]
    pub unsafe fn hasNoInfs(&self) -> bool {
        llvm_Instruction_hasNoInfs(self)
    }
    #[inline]
    pub unsafe fn hasNoSignedZeros(&self) -> bool {
        llvm_Instruction_hasNoSignedZeros(self)
    }
    #[inline]
    pub unsafe fn hasAllowReciprocal(&self) -> bool {
        llvm_Instruction_hasAllowReciprocal(self)
    }
    #[inline]
    pub unsafe fn hasAllowContract(&self) -> bool {
        llvm_Instruction_hasAllowContract(self)
    }
    #[inline]
    pub unsafe fn hasApproxFunc(&self) -> bool {
        llvm_Instruction_hasApproxFunc(self)
    }
    #[inline]
    pub unsafe fn getFastMathFlags(&self) -> llvm_FastMathFlags {
        llvm_Instruction_getFastMathFlags(self)
    }
    #[inline]
    pub unsafe fn copyFastMathFlags1(&mut self, I: *const llvm_Instruction) {
        llvm_Instruction_copyFastMathFlags1(self, I)
    }
    #[inline]
    pub unsafe fn copyIRFlags(&mut self, V: *const llvm_Value, IncludeWrapFlags: bool) {
        llvm_Instruction_copyIRFlags(self, V, IncludeWrapFlags)
    }
    #[inline]
    pub unsafe fn andIRFlags(&mut self, V: *const llvm_Value) {
        llvm_Instruction_andIRFlags(self, V)
    }
    #[inline]
    pub unsafe fn applyMergedLocation(
        &mut self,
        LocA: *mut llvm_DILocation,
        LocB: *mut llvm_DILocation,
    ) {
        llvm_Instruction_applyMergedLocation(self, LocA, LocB)
    }
    #[inline]
    pub unsafe fn updateLocationAfterHoist(&mut self) {
        llvm_Instruction_updateLocationAfterHoist(self)
    }
    #[inline]
    pub unsafe fn dropLocation(&mut self) {
        llvm_Instruction_dropLocation(self)
    }
    #[inline]
    pub unsafe fn mergeDIAssignID(
        &mut self,
        SourceInstructions: llvm_ArrayRef<*const llvm_Instruction>,
    ) {
        llvm_Instruction_mergeDIAssignID(self, SourceInstructions)
    }
    #[inline]
    pub unsafe fn isAssociative(&self) -> bool {
        llvm_Instruction_isAssociative(self)
    }
    #[inline]
    pub unsafe fn isCommutative(&self) -> bool {
        llvm_Instruction_isCommutative(self)
    }
    #[inline]
    pub unsafe fn mayWriteToMemory(&self) -> bool {
        llvm_Instruction_mayWriteToMemory(self)
    }
    #[inline]
    pub unsafe fn mayReadFromMemory(&self) -> bool {
        llvm_Instruction_mayReadFromMemory(self)
    }
    #[inline]
    pub unsafe fn isAtomic(&self) -> bool {
        llvm_Instruction_isAtomic(self)
    }
    #[inline]
    pub unsafe fn hasAtomicLoad(&self) -> bool {
        llvm_Instruction_hasAtomicLoad(self)
    }
    #[inline]
    pub unsafe fn hasAtomicStore(&self) -> bool {
        llvm_Instruction_hasAtomicStore(self)
    }
    #[inline]
    pub unsafe fn isVolatile(&self) -> bool {
        llvm_Instruction_isVolatile(self)
    }
    #[inline]
    pub unsafe fn getAccessType(&self) -> *mut llvm_Type {
        llvm_Instruction_getAccessType(self)
    }
    #[inline]
    pub unsafe fn mayThrow(&self, IncludePhaseOneUnwind: bool) -> bool {
        llvm_Instruction_mayThrow(self, IncludePhaseOneUnwind)
    }
    #[inline]
    pub unsafe fn mayHaveSideEffects(&self) -> bool {
        llvm_Instruction_mayHaveSideEffects(self)
    }
    #[inline]
    pub unsafe fn isSafeToRemove(&self) -> bool {
        llvm_Instruction_isSafeToRemove(self)
    }
    #[inline]
    pub unsafe fn willReturn(&self) -> bool {
        llvm_Instruction_willReturn(self)
    }
    #[inline]
    pub unsafe fn isLifetimeStartOrEnd(&self) -> bool {
        llvm_Instruction_isLifetimeStartOrEnd(self)
    }
    #[inline]
    pub unsafe fn isLaunderOrStripInvariantGroup(&self) -> bool {
        llvm_Instruction_isLaunderOrStripInvariantGroup(self)
    }
    #[inline]
    pub unsafe fn isDebugOrPseudoInst(&self) -> bool {
        llvm_Instruction_isDebugOrPseudoInst(self)
    }
    #[inline]
    pub unsafe fn getNextNonDebugInstruction(&self, SkipPseudoOp: bool) -> *const llvm_Instruction {
        llvm_Instruction_getNextNonDebugInstruction(self, SkipPseudoOp)
    }
    #[inline]
    pub unsafe fn getPrevNonDebugInstruction(&self, SkipPseudoOp: bool) -> *const llvm_Instruction {
        llvm_Instruction_getPrevNonDebugInstruction(self, SkipPseudoOp)
    }
    #[inline]
    pub unsafe fn clone(&self) -> *mut llvm_Instruction {
        llvm_Instruction_clone(self)
    }
    #[inline]
    pub unsafe fn isIdenticalTo(&self, I: *const llvm_Instruction) -> bool {
        llvm_Instruction_isIdenticalTo(self, I)
    }
    #[inline]
    pub unsafe fn isIdenticalToWhenDefined(&self, I: *const llvm_Instruction) -> bool {
        llvm_Instruction_isIdenticalToWhenDefined(self, I)
    }
    #[inline]
    pub unsafe fn isSameOperationAs(
        &self,
        I: *const llvm_Instruction,
        flags: ::std::os::raw::c_uint,
    ) -> bool {
        llvm_Instruction_isSameOperationAs(self, I, flags)
    }
    #[inline]
    pub unsafe fn hasSameSpecialState(
        &self,
        I2: *const llvm_Instruction,
        IgnoreAlignment: bool,
    ) -> bool {
        llvm_Instruction_hasSameSpecialState(self, I2, IgnoreAlignment)
    }
    #[inline]
    pub unsafe fn isUsedOutsideOfBlock(&self, BB: *const llvm_BasicBlock) -> bool {
        llvm_Instruction_isUsedOutsideOfBlock(self, BB)
    }
    #[inline]
    pub unsafe fn getNumSuccessors(&self) -> ::std::os::raw::c_uint {
        llvm_Instruction_getNumSuccessors(self)
    }
    #[inline]
    pub unsafe fn getSuccessor(&self, Idx: ::std::os::raw::c_uint) -> *mut llvm_BasicBlock {
        llvm_Instruction_getSuccessor(self, Idx)
    }
    #[inline]
    pub unsafe fn setSuccessor(&mut self, Idx: ::std::os::raw::c_uint, BB: *mut llvm_BasicBlock) {
        llvm_Instruction_setSuccessor(self, Idx, BB)
    }
    #[inline]
    pub unsafe fn replaceSuccessorWith(
        &mut self,
        OldBB: *mut llvm_BasicBlock,
        NewBB: *mut llvm_BasicBlock,
    ) {
        llvm_Instruction_replaceSuccessorWith(self, OldBB, NewBB)
    }
    #[inline]
    pub unsafe fn new(
        Ty: *mut llvm_Type,
        iType: ::std::os::raw::c_uint,
        Ops: *mut llvm_Use,
        NumOps: ::std::os::raw::c_uint,
        InsertBefore: llvm_InsertPosition,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        llvm_Instruction_Instruction(
            __bindgen_tmp.as_mut_ptr(),
            Ty,
            iType,
            Ops,
            NumOps,
            InsertBefore,
        );
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn destruct(&mut self) {
        llvm_Instruction_Instruction_destructor(self)
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_DbgVariableIntrinsic {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_DbgInfoIntrinsic {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_DbgLabelInst {
    _unused: [u8; 0],
}
#[doc = " A typed tracking MDNode reference that does not require a definition for its\n parameter type. Necessary to avoid including DebugInfoMetadata.h, which has\n a significant impact on compile times if included in this file."]
#[repr(C)]
#[derive(Debug)]
pub struct llvm_DbgRecordParamRef {
    pub Ref: llvm_TrackingMDNodeRef,
}
#[doc = " Base class for non-instruction debug metadata records that have positions\n within IR. Features various methods copied across from the Instruction\n class to aid ease-of-use. DbgRecords should always be linked into a\n DbgMarker's StoredDbgRecords list. The marker connects a DbgRecord back to\n its position in the BasicBlock.\n\n We need a discriminator for dyn/isa casts. In order to avoid paying for a\n vtable for \"virtual\" functions too, subclasses must add a new discriminator\n value (RecordKind) and cases to a few functions in the base class:\n   deleteRecord\n   clone\n   isIdenticalToWhenDefined\n   both print methods\n   createDebugIntrinsic"]
#[repr(C)]
#[derive(Debug)]
pub struct llvm_DbgRecord {
    pub __bindgen_padding_0: [u64; 2usize],
    #[doc = " Marker that this DbgRecord is linked into."]
    pub Marker: *mut llvm_DbgMarker,
    pub DbgLoc: llvm_DebugLoc,
    #[doc = "< Subclass discriminator."]
    pub RecordKind: llvm_DbgRecord_Kind,
}
pub const llvm_DbgRecord_Kind_ValueKind: llvm_DbgRecord_Kind = 0;
pub const llvm_DbgRecord_Kind_LabelKind: llvm_DbgRecord_Kind = 1;
#[doc = " Subclass discriminator."]
pub type llvm_DbgRecord_Kind = u8;
#[doc = " Iterator for intrusive lists  based on ilist_node."]
pub type llvm_DbgRecord_self_iterator = u64;
pub type llvm_DbgRecord_const_self_iterator = u8;
#[test]
fn bindgen_test_layout_llvm_DbgRecord() {
    const UNINIT: ::std::mem::MaybeUninit<llvm_DbgRecord> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<llvm_DbgRecord>(),
        40usize,
        concat!("Size of: ", stringify!(llvm_DbgRecord))
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_DbgRecord>(),
        8usize,
        concat!("Alignment of ", stringify!(llvm_DbgRecord))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Marker) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_DbgRecord),
            "::",
            stringify!(Marker)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).DbgLoc) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_DbgRecord),
            "::",
            stringify!(DbgLoc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).RecordKind) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_DbgRecord),
            "::",
            stringify!(RecordKind)
        )
    );
}
extern "C" {
    #[doc = " Methods that dispatch to subclass implementations. These need to be\n manually updated when a new subclass is added.\n@{"]
    #[link_name = "\u{1}_ZN4llvm9DbgRecord12deleteRecordEv"]
    pub fn llvm_DbgRecord_deleteRecord(this: *mut llvm_DbgRecord);
}
extern "C" {
    #[link_name = "\u{1}_ZNK4llvm9DbgRecord5cloneEv"]
    pub fn llvm_DbgRecord_clone(this: *const llvm_DbgRecord) -> *mut llvm_DbgRecord;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4llvm9DbgRecord5printERNS_11raw_ostreamEb"]
    pub fn llvm_DbgRecord_print(
        this: *const llvm_DbgRecord,
        O: *mut llvm_raw_ostream,
        IsForDebug: bool,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK4llvm9DbgRecord5printERNS_11raw_ostreamERNS_17ModuleSlotTrackerEb"]
    pub fn llvm_DbgRecord_print1(
        this: *const llvm_DbgRecord,
        O: *mut llvm_raw_ostream,
        MST: *mut llvm_ModuleSlotTracker,
        IsForDebug: bool,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK4llvm9DbgRecord24isIdenticalToWhenDefinedERKS0_"]
    pub fn llvm_DbgRecord_isIdenticalToWhenDefined(
        this: *const llvm_DbgRecord,
        R: *const llvm_DbgRecord,
    ) -> bool;
}
extern "C" {
    #[doc = " Convert this DbgRecord back into an appropriate llvm.dbg.* intrinsic.\n \\p InsertBefore Optional position to insert this intrinsic.\n \\returns A new llvm.dbg.* intrinsic representiung this DbgRecord."]
    #[link_name = "\u{1}_ZNK4llvm9DbgRecord20createDebugIntrinsicEPNS_6ModuleEPNS_11InstructionE"]
    pub fn llvm_DbgRecord_createDebugIntrinsic(
        this: *const llvm_DbgRecord,
        M: *mut llvm_Module,
        InsertBefore: *mut llvm_Instruction,
    ) -> *mut llvm_DbgInfoIntrinsic;
}
extern "C" {
    #[doc = " Same as isIdenticalToWhenDefined but checks DebugLoc too."]
    #[link_name = "\u{1}_ZNK4llvm9DbgRecord14isEquivalentToERKS0_"]
    pub fn llvm_DbgRecord_isEquivalentTo(
        this: *const llvm_DbgRecord,
        R: *const llvm_DbgRecord,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm9DbgRecord8getBlockEv"]
    pub fn llvm_DbgRecord_getBlock(this: *mut llvm_DbgRecord) -> *mut llvm_BasicBlock;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4llvm9DbgRecord8getBlockEv"]
    pub fn llvm_DbgRecord_getBlock1(this: *const llvm_DbgRecord) -> *const llvm_BasicBlock;
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm9DbgRecord11getFunctionEv"]
    pub fn llvm_DbgRecord_getFunction(this: *mut llvm_DbgRecord) -> *mut llvm_Function;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4llvm9DbgRecord11getFunctionEv"]
    pub fn llvm_DbgRecord_getFunction1(this: *const llvm_DbgRecord) -> *const llvm_Function;
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm9DbgRecord9getModuleEv"]
    pub fn llvm_DbgRecord_getModule(this: *mut llvm_DbgRecord) -> *mut llvm_Module;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4llvm9DbgRecord9getModuleEv"]
    pub fn llvm_DbgRecord_getModule1(this: *const llvm_DbgRecord) -> *const llvm_Module;
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm9DbgRecord10getContextEv"]
    pub fn llvm_DbgRecord_getContext(this: *mut llvm_DbgRecord) -> *mut llvm_LLVMContext;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4llvm9DbgRecord10getContextEv"]
    pub fn llvm_DbgRecord_getContext1(this: *const llvm_DbgRecord) -> *const llvm_LLVMContext;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4llvm9DbgRecord14getInstructionEv"]
    pub fn llvm_DbgRecord_getInstruction(this: *const llvm_DbgRecord) -> *const llvm_Instruction;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4llvm9DbgRecord9getParentEv"]
    pub fn llvm_DbgRecord_getParent(this: *const llvm_DbgRecord) -> *const llvm_BasicBlock;
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm9DbgRecord9getParentEv"]
    pub fn llvm_DbgRecord_getParent1(this: *mut llvm_DbgRecord) -> *mut llvm_BasicBlock;
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm9DbgRecord16removeFromParentEv"]
    pub fn llvm_DbgRecord_removeFromParent(this: *mut llvm_DbgRecord);
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm9DbgRecord15eraseFromParentEv"]
    pub fn llvm_DbgRecord_eraseFromParent(this: *mut llvm_DbgRecord);
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm9DbgRecord12insertBeforeEPS0_"]
    pub fn llvm_DbgRecord_insertBefore(
        this: *mut llvm_DbgRecord,
        InsertBefore: *mut llvm_DbgRecord,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm9DbgRecord11insertAfterEPS0_"]
    pub fn llvm_DbgRecord_insertAfter(this: *mut llvm_DbgRecord, InsertAfter: *mut llvm_DbgRecord);
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm9DbgRecord10moveBeforeEPS0_"]
    pub fn llvm_DbgRecord_moveBefore(this: *mut llvm_DbgRecord, MoveBefore: *mut llvm_DbgRecord);
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm9DbgRecord9moveAfterEPS0_"]
    pub fn llvm_DbgRecord_moveAfter(this: *mut llvm_DbgRecord, MoveAfter: *mut llvm_DbgRecord);
}
extern "C" {
    #[link_name = "\u{1}_ZNK4llvm9DbgRecord4dumpEv"]
    pub fn llvm_DbgRecord_dump(this: *const llvm_DbgRecord);
}
impl llvm_DbgRecord {
    #[inline]
    pub unsafe fn deleteRecord(&mut self) {
        llvm_DbgRecord_deleteRecord(self)
    }
    #[inline]
    pub unsafe fn clone(&self) -> *mut llvm_DbgRecord {
        llvm_DbgRecord_clone(self)
    }
    #[inline]
    pub unsafe fn print(&self, O: *mut llvm_raw_ostream, IsForDebug: bool) {
        llvm_DbgRecord_print(self, O, IsForDebug)
    }
    #[inline]
    pub unsafe fn print1(
        &self,
        O: *mut llvm_raw_ostream,
        MST: *mut llvm_ModuleSlotTracker,
        IsForDebug: bool,
    ) {
        llvm_DbgRecord_print1(self, O, MST, IsForDebug)
    }
    #[inline]
    pub unsafe fn isIdenticalToWhenDefined(&self, R: *const llvm_DbgRecord) -> bool {
        llvm_DbgRecord_isIdenticalToWhenDefined(self, R)
    }
    #[inline]
    pub unsafe fn createDebugIntrinsic(
        &self,
        M: *mut llvm_Module,
        InsertBefore: *mut llvm_Instruction,
    ) -> *mut llvm_DbgInfoIntrinsic {
        llvm_DbgRecord_createDebugIntrinsic(self, M, InsertBefore)
    }
    #[inline]
    pub unsafe fn isEquivalentTo(&self, R: *const llvm_DbgRecord) -> bool {
        llvm_DbgRecord_isEquivalentTo(self, R)
    }
    #[inline]
    pub unsafe fn getBlock(&mut self) -> *mut llvm_BasicBlock {
        llvm_DbgRecord_getBlock(self)
    }
    #[inline]
    pub unsafe fn getBlock1(&self) -> *const llvm_BasicBlock {
        llvm_DbgRecord_getBlock1(self)
    }
    #[inline]
    pub unsafe fn getFunction(&mut self) -> *mut llvm_Function {
        llvm_DbgRecord_getFunction(self)
    }
    #[inline]
    pub unsafe fn getFunction1(&self) -> *const llvm_Function {
        llvm_DbgRecord_getFunction1(self)
    }
    #[inline]
    pub unsafe fn getModule(&mut self) -> *mut llvm_Module {
        llvm_DbgRecord_getModule(self)
    }
    #[inline]
    pub unsafe fn getModule1(&self) -> *const llvm_Module {
        llvm_DbgRecord_getModule1(self)
    }
    #[inline]
    pub unsafe fn getContext(&mut self) -> *mut llvm_LLVMContext {
        llvm_DbgRecord_getContext(self)
    }
    #[inline]
    pub unsafe fn getContext1(&self) -> *const llvm_LLVMContext {
        llvm_DbgRecord_getContext1(self)
    }
    #[inline]
    pub unsafe fn getInstruction(&self) -> *const llvm_Instruction {
        llvm_DbgRecord_getInstruction(self)
    }
    #[inline]
    pub unsafe fn getParent(&self) -> *const llvm_BasicBlock {
        llvm_DbgRecord_getParent(self)
    }
    #[inline]
    pub unsafe fn getParent1(&mut self) -> *mut llvm_BasicBlock {
        llvm_DbgRecord_getParent1(self)
    }
    #[inline]
    pub unsafe fn removeFromParent(&mut self) {
        llvm_DbgRecord_removeFromParent(self)
    }
    #[inline]
    pub unsafe fn eraseFromParent(&mut self) {
        llvm_DbgRecord_eraseFromParent(self)
    }
    #[inline]
    pub unsafe fn insertBefore(&mut self, InsertBefore: *mut llvm_DbgRecord) {
        llvm_DbgRecord_insertBefore(self, InsertBefore)
    }
    #[inline]
    pub unsafe fn insertAfter(&mut self, InsertAfter: *mut llvm_DbgRecord) {
        llvm_DbgRecord_insertAfter(self, InsertAfter)
    }
    #[inline]
    pub unsafe fn moveBefore(&mut self, MoveBefore: *mut llvm_DbgRecord) {
        llvm_DbgRecord_moveBefore(self, MoveBefore)
    }
    #[inline]
    pub unsafe fn moveAfter(&mut self, MoveAfter: *mut llvm_DbgRecord) {
        llvm_DbgRecord_moveAfter(self, MoveAfter)
    }
    #[inline]
    pub unsafe fn dump(&self) {
        llvm_DbgRecord_dump(self)
    }
}
#[doc = " Records a position in IR for a source label (DILabel). Corresponds to the\n llvm.dbg.label intrinsic."]
#[repr(C)]
#[derive(Debug)]
pub struct llvm_DbgLabelRecord {
    pub _base: llvm_DbgRecord,
    pub Label: llvm_DbgRecordParamRef,
}
#[test]
fn bindgen_test_layout_llvm_DbgLabelRecord() {
    const UNINIT: ::std::mem::MaybeUninit<llvm_DbgLabelRecord> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<llvm_DbgLabelRecord>(),
        48usize,
        concat!("Size of: ", stringify!(llvm_DbgLabelRecord))
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_DbgLabelRecord>(),
        8usize,
        concat!("Alignment of ", stringify!(llvm_DbgLabelRecord))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Label) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_DbgLabelRecord),
            "::",
            stringify!(Label)
        )
    );
}
extern "C" {
    #[doc = " For use during parsing; creates a DbgLabelRecord from as-of-yet unresolved\n MDNodes. Trying to access the resulting DbgLabelRecord's fields before\n they are resolved, or if they resolve to the wrong type, will result in a\n crash."]
    #[link_name = "\u{1}_ZN4llvm14DbgLabelRecord30createUnresolvedDbgLabelRecordEPNS_6MDNodeES2_"]
    pub fn llvm_DbgLabelRecord_createUnresolvedDbgLabelRecord(
        Label: *mut llvm_MDNode,
        DL: *mut llvm_MDNode,
    ) -> *mut llvm_DbgLabelRecord;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4llvm14DbgLabelRecord5cloneEv"]
    pub fn llvm_DbgLabelRecord_clone(this: *const llvm_DbgLabelRecord) -> *mut llvm_DbgLabelRecord;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4llvm14DbgLabelRecord5printERNS_11raw_ostreamEb"]
    pub fn llvm_DbgLabelRecord_print(
        this: *const llvm_DbgLabelRecord,
        O: *mut llvm_raw_ostream,
        IsForDebug: bool,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK4llvm14DbgLabelRecord5printERNS_11raw_ostreamERNS_17ModuleSlotTrackerEb"]
    pub fn llvm_DbgLabelRecord_print1(
        this: *const llvm_DbgLabelRecord,
        ROS: *mut llvm_raw_ostream,
        MST: *mut llvm_ModuleSlotTracker,
        IsForDebug: bool,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK4llvm14DbgLabelRecord20createDebugIntrinsicEPNS_6ModuleEPNS_11InstructionE"]
    pub fn llvm_DbgLabelRecord_createDebugIntrinsic(
        this: *const llvm_DbgLabelRecord,
        M: *mut llvm_Module,
        InsertBefore: *mut llvm_Instruction,
    ) -> *mut llvm_DbgLabelInst;
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm14DbgLabelRecordC1EPNS_7DILabelENS_8DebugLocE"]
    pub fn llvm_DbgLabelRecord_DbgLabelRecord(
        this: *mut llvm_DbgLabelRecord,
        Label: *mut llvm_DILabel,
        DL: llvm_DebugLoc,
    );
}
impl llvm_DbgLabelRecord {
    #[inline]
    pub unsafe fn createUnresolvedDbgLabelRecord(
        Label: *mut llvm_MDNode,
        DL: *mut llvm_MDNode,
    ) -> *mut llvm_DbgLabelRecord {
        llvm_DbgLabelRecord_createUnresolvedDbgLabelRecord(Label, DL)
    }
    #[inline]
    pub unsafe fn clone(&self) -> *mut llvm_DbgLabelRecord {
        llvm_DbgLabelRecord_clone(self)
    }
    #[inline]
    pub unsafe fn print(&self, O: *mut llvm_raw_ostream, IsForDebug: bool) {
        llvm_DbgLabelRecord_print(self, O, IsForDebug)
    }
    #[inline]
    pub unsafe fn print1(
        &self,
        ROS: *mut llvm_raw_ostream,
        MST: *mut llvm_ModuleSlotTracker,
        IsForDebug: bool,
    ) {
        llvm_DbgLabelRecord_print1(self, ROS, MST, IsForDebug)
    }
    #[inline]
    pub unsafe fn createDebugIntrinsic(
        &self,
        M: *mut llvm_Module,
        InsertBefore: *mut llvm_Instruction,
    ) -> *mut llvm_DbgLabelInst {
        llvm_DbgLabelRecord_createDebugIntrinsic(self, M, InsertBefore)
    }
    #[inline]
    pub unsafe fn new(Label: *mut llvm_DILabel, DL: llvm_DebugLoc) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        llvm_DbgLabelRecord_DbgLabelRecord(__bindgen_tmp.as_mut_ptr(), Label, DL);
        __bindgen_tmp.assume_init()
    }
}
#[doc = " Record of a variable value-assignment, aka a non instruction representation\n of the dbg.value intrinsic.\n\n This class inherits from DebugValueUser to allow LLVM's metadata facilities\n to update our references to metadata beneath our feet."]
#[repr(C)]
#[derive(Debug)]
pub struct llvm_DbgVariableRecord {
    pub _base: llvm_DbgRecord,
    pub _base_1: llvm_DebugValueUser,
    #[doc = " Classification of the debug-info record that this DbgVariableRecord\n represents. Essentially, \"does this correspond to a dbg.value,\n dbg.declare, or dbg.assign?\".\n FIXME: We could use spare padding bits from DbgRecord for this."]
    pub Type: llvm_DbgVariableRecord_LocationType,
    pub Variable: llvm_DbgRecordParamRef,
    pub Expression: llvm_DbgRecordParamRef,
    pub AddressExpression: llvm_DbgRecordParamRef,
}
pub const llvm_DbgVariableRecord_LocationType_Declare: llvm_DbgVariableRecord_LocationType = 0;
pub const llvm_DbgVariableRecord_LocationType_Value: llvm_DbgVariableRecord_LocationType = 1;
pub const llvm_DbgVariableRecord_LocationType_Assign: llvm_DbgVariableRecord_LocationType = 2;
#[doc = "< Marks the end of the concrete types."]
pub const llvm_DbgVariableRecord_LocationType_End: llvm_DbgVariableRecord_LocationType = 3;
#[doc = "< To indicate all LocationTypes in searches."]
pub const llvm_DbgVariableRecord_LocationType_Any: llvm_DbgVariableRecord_LocationType = 4;
pub type llvm_DbgVariableRecord_LocationType = u8;
#[doc = " Iterator for ValueAsMetadata that internally uses direct pointer iteration\n over either a ValueAsMetadata* or a ValueAsMetadata**, dereferencing to the\n ValueAsMetadata ."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_DbgVariableRecord_location_op_iterator {
    pub I: llvm_PointerUnion,
}
#[test]
fn bindgen_test_layout_llvm_DbgVariableRecord_location_op_iterator() {
    const UNINIT: ::std::mem::MaybeUninit<llvm_DbgVariableRecord_location_op_iterator> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<llvm_DbgVariableRecord_location_op_iterator>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(llvm_DbgVariableRecord_location_op_iterator)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_DbgVariableRecord_location_op_iterator>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(llvm_DbgVariableRecord_location_op_iterator)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).I) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_DbgVariableRecord_location_op_iterator),
            "::",
            stringify!(I)
        )
    );
}
#[test]
fn bindgen_test_layout_llvm_DbgVariableRecord() {
    const UNINIT: ::std::mem::MaybeUninit<llvm_DbgVariableRecord> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<llvm_DbgVariableRecord>(),
        96usize,
        concat!("Size of: ", stringify!(llvm_DbgVariableRecord))
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_DbgVariableRecord>(),
        8usize,
        concat!("Alignment of ", stringify!(llvm_DbgVariableRecord))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Type) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_DbgVariableRecord),
            "::",
            stringify!(Type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Variable) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_DbgVariableRecord),
            "::",
            stringify!(Variable)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Expression) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_DbgVariableRecord),
            "::",
            stringify!(Expression)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).AddressExpression) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_DbgVariableRecord),
            "::",
            stringify!(AddressExpression)
        )
    );
}
extern "C" {
    #[doc = " Used to create DbgVariableRecords during parsing, where some metadata\n references may still be unresolved. Although for some fields a generic\n `Metadata*` argument is accepted for forward type-references, the verifier\n and accessors will reject incorrect types later on. The function is used\n for all types of DbgVariableRecords for simplicity while parsing, but\n asserts if any necessary fields are empty or unused fields are not empty,\n i.e. if the #dbg_assign fields are used for a non-dbg-assign type."]
    #[link_name = "\u{1}_ZN4llvm17DbgVariableRecord33createUnresolvedDbgVariableRecordENS0_12LocationTypeEPNS_8MetadataEPNS_6MDNodeES5_S5_S3_S5_S5_"]
    pub fn llvm_DbgVariableRecord_createUnresolvedDbgVariableRecord(
        Type: llvm_DbgVariableRecord_LocationType,
        Val: *mut llvm_Metadata,
        Variable: *mut llvm_MDNode,
        Expression: *mut llvm_MDNode,
        AssignID: *mut llvm_MDNode,
        Address: *mut llvm_Metadata,
        AddressExpression: *mut llvm_MDNode,
        DI: *mut llvm_MDNode,
    ) -> *mut llvm_DbgVariableRecord;
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm17DbgVariableRecord15createDVRAssignEPNS_5ValueEPNS_15DILocalVariableEPNS_12DIExpressionEPNS_10DIAssignIDES2_S6_PKNS_10DILocationE"]
    pub fn llvm_DbgVariableRecord_createDVRAssign(
        Val: *mut llvm_Value,
        Variable: *mut llvm_DILocalVariable,
        Expression: *mut llvm_DIExpression,
        AssignID: *mut llvm_DIAssignID,
        Address: *mut llvm_Value,
        AddressExpression: *mut llvm_DIExpression,
        DI: *const llvm_DILocation,
    ) -> *mut llvm_DbgVariableRecord;
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm17DbgVariableRecord21createLinkedDVRAssignEPNS_11InstructionEPNS_5ValueEPNS_15DILocalVariableEPNS_12DIExpressionES4_S8_PKNS_10DILocationE"]
    pub fn llvm_DbgVariableRecord_createLinkedDVRAssign(
        LinkedInstr: *mut llvm_Instruction,
        Val: *mut llvm_Value,
        Variable: *mut llvm_DILocalVariable,
        Expression: *mut llvm_DIExpression,
        Address: *mut llvm_Value,
        AddressExpression: *mut llvm_DIExpression,
        DI: *const llvm_DILocation,
    ) -> *mut llvm_DbgVariableRecord;
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm17DbgVariableRecord23createDbgVariableRecordEPNS_5ValueEPNS_15DILocalVariableEPNS_12DIExpressionEPKNS_10DILocationE"]
    pub fn llvm_DbgVariableRecord_createDbgVariableRecord(
        Location: *mut llvm_Value,
        DV: *mut llvm_DILocalVariable,
        Expr: *mut llvm_DIExpression,
        DI: *const llvm_DILocation,
    ) -> *mut llvm_DbgVariableRecord;
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm17DbgVariableRecord23createDbgVariableRecordEPNS_5ValueEPNS_15DILocalVariableEPNS_12DIExpressionEPKNS_10DILocationERS0_"]
    pub fn llvm_DbgVariableRecord_createDbgVariableRecord1(
        Location: *mut llvm_Value,
        DV: *mut llvm_DILocalVariable,
        Expr: *mut llvm_DIExpression,
        DI: *const llvm_DILocation,
        InsertBefore: *mut llvm_DbgVariableRecord,
    ) -> *mut llvm_DbgVariableRecord;
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm17DbgVariableRecord16createDVRDeclareEPNS_5ValueEPNS_15DILocalVariableEPNS_12DIExpressionEPKNS_10DILocationE"]
    pub fn llvm_DbgVariableRecord_createDVRDeclare(
        Address: *mut llvm_Value,
        DV: *mut llvm_DILocalVariable,
        Expr: *mut llvm_DIExpression,
        DI: *const llvm_DILocation,
    ) -> *mut llvm_DbgVariableRecord;
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm17DbgVariableRecord16createDVRDeclareEPNS_5ValueEPNS_15DILocalVariableEPNS_12DIExpressionEPKNS_10DILocationERS0_"]
    pub fn llvm_DbgVariableRecord_createDVRDeclare1(
        Address: *mut llvm_Value,
        DV: *mut llvm_DILocalVariable,
        Expr: *mut llvm_DIExpression,
        DI: *const llvm_DILocation,
        InsertBefore: *mut llvm_DbgVariableRecord,
    ) -> *mut llvm_DbgVariableRecord;
}
extern "C" {
    #[doc = " Get the locations corresponding to the variable referenced by the debug\n info intrinsic.  Depending on the intrinsic, this could be the\n variable's value or its address."]
    #[link_name = "\u{1}_ZNK4llvm17DbgVariableRecord12location_opsEv"]
    pub fn llvm_DbgVariableRecord_location_ops(
        this: *const llvm_DbgVariableRecord,
    ) -> llvm_iterator_range<llvm_DbgVariableRecord_location_op_iterator>;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4llvm17DbgVariableRecord21getVariableLocationOpEj"]
    pub fn llvm_DbgVariableRecord_getVariableLocationOp(
        this: *const llvm_DbgVariableRecord,
        OpIdx: ::std::os::raw::c_uint,
    ) -> *mut llvm_Value;
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm17DbgVariableRecord25replaceVariableLocationOpEPNS_5ValueES2_b"]
    pub fn llvm_DbgVariableRecord_replaceVariableLocationOp(
        this: *mut llvm_DbgVariableRecord,
        OldValue: *mut llvm_Value,
        NewValue: *mut llvm_Value,
        AllowEmpty: bool,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm17DbgVariableRecord25replaceVariableLocationOpEjPNS_5ValueE"]
    pub fn llvm_DbgVariableRecord_replaceVariableLocationOp1(
        this: *mut llvm_DbgVariableRecord,
        OpIdx: ::std::os::raw::c_uint,
        NewValue: *mut llvm_Value,
    );
}
extern "C" {
    #[doc = " Adding a new location operand will always result in this intrinsic using\n an ArgList, and must always be accompanied by a new expression that uses\n the new operand."]
    #[link_name = "\u{1}_ZN4llvm17DbgVariableRecord22addVariableLocationOpsENS_8ArrayRefIPNS_5ValueEEEPNS_12DIExpressionE"]
    pub fn llvm_DbgVariableRecord_addVariableLocationOps(
        this: *mut llvm_DbgVariableRecord,
        NewValues: llvm_ArrayRef<*mut llvm_Value>,
        NewExpr: *mut llvm_DIExpression,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK4llvm17DbgVariableRecord25getNumVariableLocationOpsEv"]
    pub fn llvm_DbgVariableRecord_getNumVariableLocationOps(
        this: *const llvm_DbgVariableRecord,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm17DbgVariableRecord15setKillLocationEv"]
    pub fn llvm_DbgVariableRecord_setKillLocation(this: *mut llvm_DbgVariableRecord);
}
extern "C" {
    #[link_name = "\u{1}_ZNK4llvm17DbgVariableRecord14isKillLocationEv"]
    pub fn llvm_DbgVariableRecord_isKillLocation(this: *const llvm_DbgVariableRecord) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4llvm17DbgVariableRecord11getFragmentEv"]
    pub fn llvm_DbgVariableRecord_getFragment(this: *const llvm_DbgVariableRecord) -> std_optional;
}
extern "C" {
    #[doc = " Get the size (in bits) of the variable, or fragment of the variable that\n is described."]
    #[link_name = "\u{1}_ZNK4llvm17DbgVariableRecord21getFragmentSizeInBitsEv"]
    pub fn llvm_DbgVariableRecord_getFragmentSizeInBits(
        this: *const llvm_DbgVariableRecord,
    ) -> std_optional;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4llvm17DbgVariableRecord10getAddressEv"]
    pub fn llvm_DbgVariableRecord_getAddress(
        this: *const llvm_DbgVariableRecord,
    ) -> *mut llvm_Value;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4llvm17DbgVariableRecord11getAssignIDEv"]
    pub fn llvm_DbgVariableRecord_getAssignID(
        this: *const llvm_DbgVariableRecord,
    ) -> *mut llvm_DIAssignID;
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm17DbgVariableRecord11setAssignIdEPNS_10DIAssignIDE"]
    pub fn llvm_DbgVariableRecord_setAssignId(
        this: *mut llvm_DbgVariableRecord,
        New: *mut llvm_DIAssignID,
    );
}
extern "C" {
    #[doc = " Kill the address component."]
    #[link_name = "\u{1}_ZN4llvm17DbgVariableRecord14setKillAddressEv"]
    pub fn llvm_DbgVariableRecord_setKillAddress(this: *mut llvm_DbgVariableRecord);
}
extern "C" {
    #[doc = " Check whether this kills the address component. This doesn't take into\n account the position of the intrinsic, therefore a returned value of false\n does not guarentee the address is a valid location for the variable at the\n intrinsic's position in IR."]
    #[link_name = "\u{1}_ZNK4llvm17DbgVariableRecord13isKillAddressEv"]
    pub fn llvm_DbgVariableRecord_isKillAddress(this: *const llvm_DbgVariableRecord) -> bool;
}
extern "C" {
    #[doc = " @}"]
    #[link_name = "\u{1}_ZNK4llvm17DbgVariableRecord5cloneEv"]
    pub fn llvm_DbgVariableRecord_clone(
        this: *const llvm_DbgVariableRecord,
    ) -> *mut llvm_DbgVariableRecord;
}
extern "C" {
    #[doc = " Convert this DbgVariableRecord back into a dbg.value intrinsic.\n \\p InsertBefore Optional position to insert this intrinsic.\n \\returns A new dbg.value intrinsic representiung this DbgVariableRecord."]
    #[link_name = "\u{1}_ZNK4llvm17DbgVariableRecord20createDebugIntrinsicEPNS_6ModuleEPNS_11InstructionE"]
    pub fn llvm_DbgVariableRecord_createDebugIntrinsic(
        this: *const llvm_DbgVariableRecord,
        M: *mut llvm_Module,
        InsertBefore: *mut llvm_Instruction,
    ) -> *mut llvm_DbgVariableIntrinsic;
}
extern "C" {
    #[doc = " Handle changes to the location of the Value(s) that we refer to happening\n \"under our feet\"."]
    #[link_name = "\u{1}_ZN4llvm17DbgVariableRecord21handleChangedLocationEPNS_8MetadataE"]
    pub fn llvm_DbgVariableRecord_handleChangedLocation(
        this: *mut llvm_DbgVariableRecord,
        NewLocation: *mut llvm_Metadata,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK4llvm17DbgVariableRecord5printERNS_11raw_ostreamEb"]
    pub fn llvm_DbgVariableRecord_print(
        this: *const llvm_DbgVariableRecord,
        O: *mut llvm_raw_ostream,
        IsForDebug: bool,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK4llvm17DbgVariableRecord5printERNS_11raw_ostreamERNS_17ModuleSlotTrackerEb"]
    pub fn llvm_DbgVariableRecord_print1(
        this: *const llvm_DbgVariableRecord,
        ROS: *mut llvm_raw_ostream,
        MST: *mut llvm_ModuleSlotTracker,
        IsForDebug: bool,
    );
}
extern "C" {
    #[doc = " Create a new DbgVariableRecord representing the intrinsic \\p DVI, for\n example the assignment represented by a dbg.value."]
    #[link_name = "\u{1}_ZN4llvm17DbgVariableRecordC1EPKNS_20DbgVariableIntrinsicE"]
    pub fn llvm_DbgVariableRecord_DbgVariableRecord(
        this: *mut llvm_DbgVariableRecord,
        DVI: *const llvm_DbgVariableIntrinsic,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm17DbgVariableRecordC1ERKS0_"]
    pub fn llvm_DbgVariableRecord_DbgVariableRecord1(
        this: *mut llvm_DbgVariableRecord,
        DVR: *const llvm_DbgVariableRecord,
    );
}
extern "C" {
    #[doc = " Directly construct a new DbgVariableRecord representing a dbg.value\n intrinsic assigning \\p Location to the DV / Expr / DI variable."]
    #[link_name = "\u{1}_ZN4llvm17DbgVariableRecordC1EPNS_8MetadataEPNS_15DILocalVariableEPNS_12DIExpressionEPKNS_10DILocationENS0_12LocationTypeE"]
    pub fn llvm_DbgVariableRecord_DbgVariableRecord2(
        this: *mut llvm_DbgVariableRecord,
        Location: *mut llvm_Metadata,
        DV: *mut llvm_DILocalVariable,
        Expr: *mut llvm_DIExpression,
        DI: *const llvm_DILocation,
        Type: llvm_DbgVariableRecord_LocationType,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm17DbgVariableRecordC1EPNS_8MetadataEPNS_15DILocalVariableEPNS_12DIExpressionEPNS_10DIAssignIDES2_S6_PKNS_10DILocationE"]
    pub fn llvm_DbgVariableRecord_DbgVariableRecord3(
        this: *mut llvm_DbgVariableRecord,
        Value: *mut llvm_Metadata,
        Variable: *mut llvm_DILocalVariable,
        Expression: *mut llvm_DIExpression,
        AssignID: *mut llvm_DIAssignID,
        Address: *mut llvm_Metadata,
        AddressExpression: *mut llvm_DIExpression,
        DI: *const llvm_DILocation,
    );
}
impl llvm_DbgVariableRecord {
    #[inline]
    pub unsafe fn createUnresolvedDbgVariableRecord(
        Type: llvm_DbgVariableRecord_LocationType,
        Val: *mut llvm_Metadata,
        Variable: *mut llvm_MDNode,
        Expression: *mut llvm_MDNode,
        AssignID: *mut llvm_MDNode,
        Address: *mut llvm_Metadata,
        AddressExpression: *mut llvm_MDNode,
        DI: *mut llvm_MDNode,
    ) -> *mut llvm_DbgVariableRecord {
        llvm_DbgVariableRecord_createUnresolvedDbgVariableRecord(
            Type,
            Val,
            Variable,
            Expression,
            AssignID,
            Address,
            AddressExpression,
            DI,
        )
    }
    #[inline]
    pub unsafe fn createDVRAssign(
        Val: *mut llvm_Value,
        Variable: *mut llvm_DILocalVariable,
        Expression: *mut llvm_DIExpression,
        AssignID: *mut llvm_DIAssignID,
        Address: *mut llvm_Value,
        AddressExpression: *mut llvm_DIExpression,
        DI: *const llvm_DILocation,
    ) -> *mut llvm_DbgVariableRecord {
        llvm_DbgVariableRecord_createDVRAssign(
            Val,
            Variable,
            Expression,
            AssignID,
            Address,
            AddressExpression,
            DI,
        )
    }
    #[inline]
    pub unsafe fn createLinkedDVRAssign(
        LinkedInstr: *mut llvm_Instruction,
        Val: *mut llvm_Value,
        Variable: *mut llvm_DILocalVariable,
        Expression: *mut llvm_DIExpression,
        Address: *mut llvm_Value,
        AddressExpression: *mut llvm_DIExpression,
        DI: *const llvm_DILocation,
    ) -> *mut llvm_DbgVariableRecord {
        llvm_DbgVariableRecord_createLinkedDVRAssign(
            LinkedInstr,
            Val,
            Variable,
            Expression,
            Address,
            AddressExpression,
            DI,
        )
    }
    #[inline]
    pub unsafe fn createDbgVariableRecord(
        Location: *mut llvm_Value,
        DV: *mut llvm_DILocalVariable,
        Expr: *mut llvm_DIExpression,
        DI: *const llvm_DILocation,
    ) -> *mut llvm_DbgVariableRecord {
        llvm_DbgVariableRecord_createDbgVariableRecord(Location, DV, Expr, DI)
    }
    #[inline]
    pub unsafe fn createDbgVariableRecord1(
        Location: *mut llvm_Value,
        DV: *mut llvm_DILocalVariable,
        Expr: *mut llvm_DIExpression,
        DI: *const llvm_DILocation,
        InsertBefore: *mut llvm_DbgVariableRecord,
    ) -> *mut llvm_DbgVariableRecord {
        llvm_DbgVariableRecord_createDbgVariableRecord1(Location, DV, Expr, DI, InsertBefore)
    }
    #[inline]
    pub unsafe fn createDVRDeclare(
        Address: *mut llvm_Value,
        DV: *mut llvm_DILocalVariable,
        Expr: *mut llvm_DIExpression,
        DI: *const llvm_DILocation,
    ) -> *mut llvm_DbgVariableRecord {
        llvm_DbgVariableRecord_createDVRDeclare(Address, DV, Expr, DI)
    }
    #[inline]
    pub unsafe fn createDVRDeclare1(
        Address: *mut llvm_Value,
        DV: *mut llvm_DILocalVariable,
        Expr: *mut llvm_DIExpression,
        DI: *const llvm_DILocation,
        InsertBefore: *mut llvm_DbgVariableRecord,
    ) -> *mut llvm_DbgVariableRecord {
        llvm_DbgVariableRecord_createDVRDeclare1(Address, DV, Expr, DI, InsertBefore)
    }
    #[inline]
    pub unsafe fn location_ops(
        &self,
    ) -> llvm_iterator_range<llvm_DbgVariableRecord_location_op_iterator> {
        llvm_DbgVariableRecord_location_ops(self)
    }
    #[inline]
    pub unsafe fn getVariableLocationOp(&self, OpIdx: ::std::os::raw::c_uint) -> *mut llvm_Value {
        llvm_DbgVariableRecord_getVariableLocationOp(self, OpIdx)
    }
    #[inline]
    pub unsafe fn replaceVariableLocationOp(
        &mut self,
        OldValue: *mut llvm_Value,
        NewValue: *mut llvm_Value,
        AllowEmpty: bool,
    ) {
        llvm_DbgVariableRecord_replaceVariableLocationOp(self, OldValue, NewValue, AllowEmpty)
    }
    #[inline]
    pub unsafe fn replaceVariableLocationOp1(
        &mut self,
        OpIdx: ::std::os::raw::c_uint,
        NewValue: *mut llvm_Value,
    ) {
        llvm_DbgVariableRecord_replaceVariableLocationOp1(self, OpIdx, NewValue)
    }
    #[inline]
    pub unsafe fn addVariableLocationOps(
        &mut self,
        NewValues: llvm_ArrayRef<*mut llvm_Value>,
        NewExpr: *mut llvm_DIExpression,
    ) {
        llvm_DbgVariableRecord_addVariableLocationOps(self, NewValues, NewExpr)
    }
    #[inline]
    pub unsafe fn getNumVariableLocationOps(&self) -> ::std::os::raw::c_uint {
        llvm_DbgVariableRecord_getNumVariableLocationOps(self)
    }
    #[inline]
    pub unsafe fn setKillLocation(&mut self) {
        llvm_DbgVariableRecord_setKillLocation(self)
    }
    #[inline]
    pub unsafe fn isKillLocation(&self) -> bool {
        llvm_DbgVariableRecord_isKillLocation(self)
    }
    #[inline]
    pub unsafe fn getFragment(&self) -> std_optional {
        llvm_DbgVariableRecord_getFragment(self)
    }
    #[inline]
    pub unsafe fn getFragmentSizeInBits(&self) -> std_optional {
        llvm_DbgVariableRecord_getFragmentSizeInBits(self)
    }
    #[inline]
    pub unsafe fn getAddress(&self) -> *mut llvm_Value {
        llvm_DbgVariableRecord_getAddress(self)
    }
    #[inline]
    pub unsafe fn getAssignID(&self) -> *mut llvm_DIAssignID {
        llvm_DbgVariableRecord_getAssignID(self)
    }
    #[inline]
    pub unsafe fn setAssignId(&mut self, New: *mut llvm_DIAssignID) {
        llvm_DbgVariableRecord_setAssignId(self, New)
    }
    #[inline]
    pub unsafe fn setKillAddress(&mut self) {
        llvm_DbgVariableRecord_setKillAddress(self)
    }
    #[inline]
    pub unsafe fn isKillAddress(&self) -> bool {
        llvm_DbgVariableRecord_isKillAddress(self)
    }
    #[inline]
    pub unsafe fn clone(&self) -> *mut llvm_DbgVariableRecord {
        llvm_DbgVariableRecord_clone(self)
    }
    #[inline]
    pub unsafe fn createDebugIntrinsic(
        &self,
        M: *mut llvm_Module,
        InsertBefore: *mut llvm_Instruction,
    ) -> *mut llvm_DbgVariableIntrinsic {
        llvm_DbgVariableRecord_createDebugIntrinsic(self, M, InsertBefore)
    }
    #[inline]
    pub unsafe fn handleChangedLocation(&mut self, NewLocation: *mut llvm_Metadata) {
        llvm_DbgVariableRecord_handleChangedLocation(self, NewLocation)
    }
    #[inline]
    pub unsafe fn print(&self, O: *mut llvm_raw_ostream, IsForDebug: bool) {
        llvm_DbgVariableRecord_print(self, O, IsForDebug)
    }
    #[inline]
    pub unsafe fn print1(
        &self,
        ROS: *mut llvm_raw_ostream,
        MST: *mut llvm_ModuleSlotTracker,
        IsForDebug: bool,
    ) {
        llvm_DbgVariableRecord_print1(self, ROS, MST, IsForDebug)
    }
    #[inline]
    pub unsafe fn new(DVI: *const llvm_DbgVariableIntrinsic) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        llvm_DbgVariableRecord_DbgVariableRecord(__bindgen_tmp.as_mut_ptr(), DVI);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(DVR: *const llvm_DbgVariableRecord) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        llvm_DbgVariableRecord_DbgVariableRecord1(__bindgen_tmp.as_mut_ptr(), DVR);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new2(
        Location: *mut llvm_Metadata,
        DV: *mut llvm_DILocalVariable,
        Expr: *mut llvm_DIExpression,
        DI: *const llvm_DILocation,
        Type: llvm_DbgVariableRecord_LocationType,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        llvm_DbgVariableRecord_DbgVariableRecord2(
            __bindgen_tmp.as_mut_ptr(),
            Location,
            DV,
            Expr,
            DI,
            Type,
        );
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new3(
        Value: *mut llvm_Metadata,
        Variable: *mut llvm_DILocalVariable,
        Expression: *mut llvm_DIExpression,
        AssignID: *mut llvm_DIAssignID,
        Address: *mut llvm_Metadata,
        AddressExpression: *mut llvm_DIExpression,
        DI: *const llvm_DILocation,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        llvm_DbgVariableRecord_DbgVariableRecord3(
            __bindgen_tmp.as_mut_ptr(),
            Value,
            Variable,
            Expression,
            AssignID,
            Address,
            AddressExpression,
            DI,
        );
        __bindgen_tmp.assume_init()
    }
}
#[doc = " Per-instruction record of debug-info. If an Instruction is the position of\n some debugging information, it points at a DbgMarker storing that info. Each\n marker points back at the instruction that owns it. Various utilities are\n provided for manipulating the DbgRecords contained within this marker.\n\n This class has a rough surface area, because it's needed to preserve the\n one arefact that we can't yet eliminate from the intrinsic / dbg.value\n debug-info design: the order of records is significant, and duplicates can\n exist. Thus, if one has a run of debug-info records such as:\n    dbg.value(...\n    %foo = barinst\n    dbg.value(...\n and remove barinst, then the dbg.values must be preserved in the correct\n order. Hence, the use of iterators to select positions to insert things\n into, or the occasional InsertAtHead parameter indicating that new records\n should go at the start of the list.\n\n There are only five or six places in LLVM that truly rely on this ordering,\n which we can improve in the future. Additionally, many improvements in the\n way that debug-info is stored can be achieved in this class, at a future\n date."]
#[repr(C)]
#[derive(Debug)]
pub struct llvm_DbgMarker {
    #[doc = " Link back to the Instruction that owns this marker. Can be null during\n operations that move a marker from one instruction to another."]
    pub MarkedInstr: *mut llvm_Instruction,
    #[doc = " List of DbgRecords, the non-instruction equivalent of llvm.dbg.*\n intrinsics. There is a one-to-one relationship between each debug\n intrinsic in a block and each DbgRecord once the representation has been\n converted, and the ordering is meaningful in the same way."]
    pub StoredDbgRecords: llvm_simple_ilist,
}
extern "C" {
    #[doc = " We generally act like all llvm Instructions have a range of DbgRecords\n attached to them, but in reality sometimes we don't allocate the DbgMarker\n to save time and memory, but still have to return ranges of DbgRecords.\n When we need to describe such an unallocated DbgRecord range, use this\n static markers range instead. This will bite us if someone tries to insert\n a DbgRecord in that range, but they should be using the Official (TM) API\n for that."]
    #[link_name = "\u{1}_ZN4llvm9DbgMarker14EmptyDbgMarkerE"]
    pub static mut llvm_DbgMarker_EmptyDbgMarker: llvm_DbgMarker;
}
#[test]
fn bindgen_test_layout_llvm_DbgMarker() {
    const UNINIT: ::std::mem::MaybeUninit<llvm_DbgMarker> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<llvm_DbgMarker>(),
        24usize,
        concat!("Size of: ", stringify!(llvm_DbgMarker))
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_DbgMarker>(),
        8usize,
        concat!("Alignment of ", stringify!(llvm_DbgMarker))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).MarkedInstr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_DbgMarker),
            "::",
            stringify!(MarkedInstr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).StoredDbgRecords) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_DbgMarker),
            "::",
            stringify!(StoredDbgRecords)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK4llvm9DbgMarker9getParentEv"]
    pub fn llvm_DbgMarker_getParent(this: *const llvm_DbgMarker) -> *const llvm_BasicBlock;
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm9DbgMarker9getParentEv"]
    pub fn llvm_DbgMarker_getParent1(this: *mut llvm_DbgMarker) -> *mut llvm_BasicBlock;
}
extern "C" {
    #[doc = " Handle the removal of a marker: the position of debug-info has gone away,\n but the stored debug records should not. Drop them onto the next\n instruction, or otherwise work out what to do with them."]
    #[link_name = "\u{1}_ZN4llvm9DbgMarker12removeMarkerEv"]
    pub fn llvm_DbgMarker_removeMarker(this: *mut llvm_DbgMarker);
}
extern "C" {
    #[link_name = "\u{1}_ZNK4llvm9DbgMarker4dumpEv"]
    pub fn llvm_DbgMarker_dump(this: *const llvm_DbgMarker);
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm9DbgMarker16removeFromParentEv"]
    pub fn llvm_DbgMarker_removeFromParent(this: *mut llvm_DbgMarker);
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm9DbgMarker15eraseFromParentEv"]
    pub fn llvm_DbgMarker_eraseFromParent(this: *mut llvm_DbgMarker);
}
extern "C" {
    #[doc = " Implement operator<< on DbgMarker."]
    #[link_name = "\u{1}_ZNK4llvm9DbgMarker5printERNS_11raw_ostreamEb"]
    pub fn llvm_DbgMarker_print(
        this: *const llvm_DbgMarker,
        O: *mut llvm_raw_ostream,
        IsForDebug: bool,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK4llvm9DbgMarker5printERNS_11raw_ostreamERNS_17ModuleSlotTrackerEb"]
    pub fn llvm_DbgMarker_print1(
        this: *const llvm_DbgMarker,
        ROS: *mut llvm_raw_ostream,
        MST: *mut llvm_ModuleSlotTracker,
        IsForDebug: bool,
    );
}
extern "C" {
    #[doc = " Produce a range over all the DbgRecords in this Marker."]
    #[link_name = "\u{1}_ZN4llvm9DbgMarker17getDbgRecordRangeEv"]
    pub fn llvm_DbgMarker_getDbgRecordRange(this: *mut llvm_DbgMarker) -> [u64; 2usize];
}
extern "C" {
    #[link_name = "\u{1}_ZNK4llvm9DbgMarker17getDbgRecordRangeEv"]
    pub fn llvm_DbgMarker_getDbgRecordRange1(this: *const llvm_DbgMarker) -> u8;
}
extern "C" {
    #[doc = " Transfer any DbgRecords from \\p Src into this DbgMarker. If \\p\n InsertAtHead is true, place them before existing DbgRecords, otherwise\n afterwards."]
    #[link_name = "\u{1}_ZN4llvm9DbgMarker17absorbDebugValuesERS0_b"]
    pub fn llvm_DbgMarker_absorbDebugValues(
        this: *mut llvm_DbgMarker,
        Src: *mut llvm_DbgMarker,
        InsertAtHead: bool,
    );
}
extern "C" {
    #[doc = " Transfer the DbgRecords in \\p Range from \\p Src into this DbgMarker. If\n \\p InsertAtHead is true, place them before existing DbgRecords, otherwise"]
    #[link_name = "\u{1}_ZN4llvm9DbgMarker17absorbDebugValuesENS_14iterator_rangeINS_14ilist_iteratorINS_12ilist_detail12node_optionsINS_9DbgRecordELb1ELb0EvLb0EvEELb0ELb0EEEEERS0_b"]
    pub fn llvm_DbgMarker_absorbDebugValues1(
        this: *mut llvm_DbgMarker,
        Range: llvm_iterator_range<llvm_DbgRecord_self_iterator>,
        Src: *mut llvm_DbgMarker,
        InsertAtHead: bool,
    );
}
extern "C" {
    #[doc = " Insert a DbgRecord into this DbgMarker, at the end of the list. If\n \\p InsertAtHead is true, at the start."]
    #[link_name = "\u{1}_ZN4llvm9DbgMarker15insertDbgRecordEPNS_9DbgRecordEb"]
    pub fn llvm_DbgMarker_insertDbgRecord(
        this: *mut llvm_DbgMarker,
        New: *mut llvm_DbgRecord,
        InsertAtHead: bool,
    );
}
extern "C" {
    #[doc = " Insert a DbgRecord prior to a DbgRecord contained within this marker."]
    #[link_name = "\u{1}_ZN4llvm9DbgMarker15insertDbgRecordEPNS_9DbgRecordES2_"]
    pub fn llvm_DbgMarker_insertDbgRecord1(
        this: *mut llvm_DbgMarker,
        New: *mut llvm_DbgRecord,
        InsertBefore: *mut llvm_DbgRecord,
    );
}
extern "C" {
    #[doc = " Insert a DbgRecord after a DbgRecord contained within this marker."]
    #[link_name = "\u{1}_ZN4llvm9DbgMarker20insertDbgRecordAfterEPNS_9DbgRecordES2_"]
    pub fn llvm_DbgMarker_insertDbgRecordAfter(
        this: *mut llvm_DbgMarker,
        New: *mut llvm_DbgRecord,
        InsertAfter: *mut llvm_DbgRecord,
    );
}
extern "C" {
    #[doc = " Clone all DbgMarkers from \\p From into this marker. There are numerous\n options to customise the source/destination, due to gnarliness, see class\n comment.\n \\p FromHere If non-null, copy from FromHere to the end of From's\n DbgRecords\n \\p InsertAtHead Place the cloned DbgRecords at the start of\n StoredDbgRecords\n \\returns Range over all the newly cloned DbgRecords"]
    #[link_name = "\u{1}_ZN4llvm9DbgMarker18cloneDebugInfoFromEPS0_St8optionalINS_14ilist_iteratorINS_12ilist_detail12node_optionsINS_9DbgRecordELb1ELb0EvLb0EvEELb0ELb0EEEEb"]
    pub fn llvm_DbgMarker_cloneDebugInfoFrom(
        this: *mut llvm_DbgMarker,
        From: *mut llvm_DbgMarker,
        FromHere: std_optional,
        InsertAtHead: bool,
    ) -> [u64; 2usize];
}
extern "C" {
    #[doc = " Erase all DbgRecords in this DbgMarker."]
    #[link_name = "\u{1}_ZN4llvm9DbgMarker14dropDbgRecordsEv"]
    pub fn llvm_DbgMarker_dropDbgRecords(this: *mut llvm_DbgMarker);
}
extern "C" {
    #[doc = " Erase a single DbgRecord from this marker. In an ideal future, we would\n never erase an assignment in this way, but it's the equivalent to\n erasing a debug intrinsic from a block."]
    #[link_name = "\u{1}_ZN4llvm9DbgMarker16dropOneDbgRecordEPNS_9DbgRecordE"]
    pub fn llvm_DbgMarker_dropOneDbgRecord(this: *mut llvm_DbgMarker, DR: *mut llvm_DbgRecord);
}
impl llvm_DbgMarker {
    #[inline]
    pub unsafe fn getParent(&self) -> *const llvm_BasicBlock {
        llvm_DbgMarker_getParent(self)
    }
    #[inline]
    pub unsafe fn getParent1(&mut self) -> *mut llvm_BasicBlock {
        llvm_DbgMarker_getParent1(self)
    }
    #[inline]
    pub unsafe fn removeMarker(&mut self) {
        llvm_DbgMarker_removeMarker(self)
    }
    #[inline]
    pub unsafe fn dump(&self) {
        llvm_DbgMarker_dump(self)
    }
    #[inline]
    pub unsafe fn removeFromParent(&mut self) {
        llvm_DbgMarker_removeFromParent(self)
    }
    #[inline]
    pub unsafe fn eraseFromParent(&mut self) {
        llvm_DbgMarker_eraseFromParent(self)
    }
    #[inline]
    pub unsafe fn print(&self, O: *mut llvm_raw_ostream, IsForDebug: bool) {
        llvm_DbgMarker_print(self, O, IsForDebug)
    }
    #[inline]
    pub unsafe fn print1(
        &self,
        ROS: *mut llvm_raw_ostream,
        MST: *mut llvm_ModuleSlotTracker,
        IsForDebug: bool,
    ) {
        llvm_DbgMarker_print1(self, ROS, MST, IsForDebug)
    }
    #[inline]
    pub unsafe fn getDbgRecordRange(&mut self) -> [u64; 2usize] {
        llvm_DbgMarker_getDbgRecordRange(self)
    }
    #[inline]
    pub unsafe fn getDbgRecordRange1(&self) -> u8 {
        llvm_DbgMarker_getDbgRecordRange1(self)
    }
    #[inline]
    pub unsafe fn absorbDebugValues(&mut self, Src: *mut llvm_DbgMarker, InsertAtHead: bool) {
        llvm_DbgMarker_absorbDebugValues(self, Src, InsertAtHead)
    }
    #[inline]
    pub unsafe fn absorbDebugValues1(
        &mut self,
        Range: llvm_iterator_range<llvm_DbgRecord_self_iterator>,
        Src: *mut llvm_DbgMarker,
        InsertAtHead: bool,
    ) {
        llvm_DbgMarker_absorbDebugValues1(self, Range, Src, InsertAtHead)
    }
    #[inline]
    pub unsafe fn insertDbgRecord(&mut self, New: *mut llvm_DbgRecord, InsertAtHead: bool) {
        llvm_DbgMarker_insertDbgRecord(self, New, InsertAtHead)
    }
    #[inline]
    pub unsafe fn insertDbgRecord1(
        &mut self,
        New: *mut llvm_DbgRecord,
        InsertBefore: *mut llvm_DbgRecord,
    ) {
        llvm_DbgMarker_insertDbgRecord1(self, New, InsertBefore)
    }
    #[inline]
    pub unsafe fn insertDbgRecordAfter(
        &mut self,
        New: *mut llvm_DbgRecord,
        InsertAfter: *mut llvm_DbgRecord,
    ) {
        llvm_DbgMarker_insertDbgRecordAfter(self, New, InsertAfter)
    }
    #[inline]
    pub unsafe fn cloneDebugInfoFrom(
        &mut self,
        From: *mut llvm_DbgMarker,
        FromHere: std_optional,
        InsertAtHead: bool,
    ) -> [u64; 2usize] {
        llvm_DbgMarker_cloneDebugInfoFrom(self, From, FromHere, InsertAtHead)
    }
    #[inline]
    pub unsafe fn dropDbgRecords(&mut self) {
        llvm_DbgMarker_dropDbgRecords(self)
    }
    #[inline]
    pub unsafe fn dropOneDbgRecord(&mut self, DR: *mut llvm_DbgRecord) {
        llvm_DbgMarker_dropOneDbgRecord(self, DR)
    }
}
#[doc = " Used to temporarily set the debug info format of a function, module, or\n basic block for the duration of this object's lifetime, after which the\n prior state will be restored."]
#[repr(C)]
#[derive(Debug)]
pub struct llvm_ScopedDbgInfoFormatSetter<T> {
    pub Obj: *mut T,
    pub OldState: bool,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<T>>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_AssemblyAnnotationWriter {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_CallInst {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_LandingPadInst {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_PHINode {
    _unused: [u8; 0],
}
#[doc = " LLVM Basic Block Representation\n\n This represents a single basic block in LLVM. A basic block is simply a\n container of instructions that execute sequentially. Basic blocks are Values\n because they are referenced by instructions such as branches and switch\n tables. The type of a BasicBlock is \"Type::LabelTy\" because the basic block\n represents a label to which a branch can jump.\n\n A well formed basic block is formed of a list of non-terminating\n instructions followed by a single terminator instruction. Terminator\n instructions may not occur in the middle of basic blocks, and must terminate\n the blocks. The BasicBlock class allows malformed basic blocks to occur\n because it may be useful in the intermediate stage of constructing or\n modifying a program. However, the verifier will ensure that basic blocks are\n \"well formed\"."]
#[repr(C)]
#[derive(Debug)]
pub struct llvm_BasicBlock {
    pub _base: llvm_Value,
    pub __bindgen_padding_0: [u8; 16usize],
    #[doc = " Flag recording whether or not this block stores debug-info in the form\n of intrinsic instructions (false) or non-instruction records (true)."]
    pub IsNewDbgInfoFormat: bool,
    #[doc = " Per-function unique number."]
    pub Number: ::std::os::raw::c_uint,
    pub InstList: llvm_BasicBlock_InstListType,
    pub Parent: *mut llvm_Function,
}
#[doc = " List that automatically updates parent links and symbol tables.\n\n When nodes are inserted into and removed from this list, the associated\n symbol table will be automatically updated.  Similarly, parent links get\n updated automatically."]
pub type llvm_BasicBlock_InstListType = llvm_SymbolTableList;
#[doc = " Instruction iterators..."]
pub type llvm_BasicBlock_iterator = [u64; 2usize];
#[doc = " Iterator for intrusive lists  based on ilist_node. Much like ilist_iterator,\n but with the addition of two bits recording whether this position (when in\n a range) is half or fully open."]
pub type llvm_BasicBlock_const_iterator = [u64; 2usize];
#[doc = " Iterator for intrusive lists  based on ilist_node. Much like ilist_iterator,\n but with the addition of two bits recording whether this position (when in\n a range) is half or fully open."]
pub type llvm_BasicBlock_reverse_iterator = [u64; 2usize];
#[doc = " Iterator for intrusive lists  based on ilist_node. Much like ilist_iterator,\n but with the addition of two bits recording whether this position (when in\n a range) is half or fully open."]
pub type llvm_BasicBlock_const_reverse_iterator = [u64; 2usize];
#[doc = " Iterator to walk just the phi nodes in the basic block."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_BasicBlock_phi_iterator_impl<PHINodeT> {
    pub PN: *mut PHINodeT,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<PHINodeT>>,
}
#[doc = " Iterator to walk just the phi nodes in the basic block."]
pub type llvm_BasicBlock_phi_iterator = llvm_BasicBlock_phi_iterator_impl<llvm_PHINode>;
#[doc = " Iterator to walk just the phi nodes in the basic block."]
pub type llvm_BasicBlock_const_phi_iterator = llvm_BasicBlock_phi_iterator_impl<llvm_PHINode>;
#[doc = " Bitfield to help interpret the bits in Value::SubclassData."]
#[repr(C)]
#[repr(align(2))]
#[derive(Debug, Copy, Clone)]
pub struct llvm_BasicBlock_BasicBlockBits {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
}
#[test]
fn bindgen_test_layout_llvm_BasicBlock_BasicBlockBits() {
    assert_eq!(
        ::std::mem::size_of::<llvm_BasicBlock_BasicBlockBits>(),
        2usize,
        concat!("Size of: ", stringify!(llvm_BasicBlock_BasicBlockBits))
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_BasicBlock_BasicBlockBits>(),
        2usize,
        concat!("Alignment of ", stringify!(llvm_BasicBlock_BasicBlockBits))
    );
}
impl llvm_BasicBlock_BasicBlockBits {
    #[inline]
    pub fn BlockAddressRefCount(&self) -> ::std::os::raw::c_ushort {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 15u8) as u16) }
    }
    #[inline]
    pub fn set_BlockAddressRefCount(&mut self, val: ::std::os::raw::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 15u8, val as u64)
        }
    }
    #[inline]
    pub fn InstrOrderValid(&self) -> ::std::os::raw::c_ushort {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_InstrOrderValid(&mut self, val: ::std::os::raw::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        BlockAddressRefCount: ::std::os::raw::c_ushort,
        InstrOrderValid: ::std::os::raw::c_ushort,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 15u8, {
            let BlockAddressRefCount: u16 = unsafe { ::std::mem::transmute(BlockAddressRefCount) };
            BlockAddressRefCount as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let InstrOrderValid: u16 = unsafe { ::std::mem::transmute(InstrOrderValid) };
            InstrOrderValid as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_llvm_BasicBlock() {
    const UNINIT: ::std::mem::MaybeUninit<llvm_BasicBlock> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<llvm_BasicBlock>(),
        80usize,
        concat!("Size of: ", stringify!(llvm_BasicBlock))
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_BasicBlock>(),
        8usize,
        concat!("Alignment of ", stringify!(llvm_BasicBlock))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).IsNewDbgInfoFormat) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_BasicBlock),
            "::",
            stringify!(IsNewDbgInfoFormat)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Number) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_BasicBlock),
            "::",
            stringify!(Number)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).InstList) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_BasicBlock),
            "::",
            stringify!(InstList)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Parent) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_BasicBlock),
            "::",
            stringify!(Parent)
        )
    );
}
extern "C" {
    #[doc = " Attach a DbgMarker to the given instruction. Enables the storage of any\n debug-info at this position in the program."]
    #[link_name = "\u{1}_ZN4llvm10BasicBlock12createMarkerEPNS_11InstructionE"]
    pub fn llvm_BasicBlock_createMarker(
        this: *mut llvm_BasicBlock,
        I: *mut llvm_Instruction,
    ) -> *mut llvm_DbgMarker;
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm10BasicBlock12createMarkerENS_21ilist_iterator_w_bitsINS_12ilist_detail12node_optionsINS_11InstructionELb1ELb0EvLb1ES0_EELb0ELb0EEE"]
    pub fn llvm_BasicBlock_createMarker1(
        this: *mut llvm_BasicBlock,
        It: [u64; 2usize],
    ) -> *mut llvm_DbgMarker;
}
extern "C" {
    #[doc = " Convert variable location debugging information stored in dbg.value\n intrinsics into DbgMarkers / DbgRecords. Deletes all dbg.values in\n the process and sets IsNewDbgInfoFormat = true. Only takes effect if\n the UseNewDbgInfoFormat LLVM command line option is given."]
    #[link_name = "\u{1}_ZN4llvm10BasicBlock21convertToNewDbgValuesEv"]
    pub fn llvm_BasicBlock_convertToNewDbgValues(this: *mut llvm_BasicBlock);
}
extern "C" {
    #[doc = " Convert variable location debugging information stored in DbgMarkers and\n DbgRecords into the dbg.value intrinsic representation. Sets\n IsNewDbgInfoFormat = false."]
    #[link_name = "\u{1}_ZN4llvm10BasicBlock23convertFromNewDbgValuesEv"]
    pub fn llvm_BasicBlock_convertFromNewDbgValues(this: *mut llvm_BasicBlock);
}
extern "C" {
    #[doc = " Ensure the block is in \"old\" dbg.value format (\\p NewFlag == false) or\n in the new format (\\p NewFlag == true), converting to the desired format\n if necessary."]
    #[link_name = "\u{1}_ZN4llvm10BasicBlock21setIsNewDbgInfoFormatEb"]
    pub fn llvm_BasicBlock_setIsNewDbgInfoFormat(this: *mut llvm_BasicBlock, NewFlag: bool);
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm10BasicBlock23setNewDbgInfoFormatFlagEb"]
    pub fn llvm_BasicBlock_setNewDbgInfoFormatFlag(this: *mut llvm_BasicBlock, NewFlag: bool);
}
extern "C" {
    #[doc = " Record that the collection of DbgRecords in \\p M \"trails\" after the last\n instruction of this block. These are equivalent to dbg.value intrinsics\n that exist at the end of a basic block with no terminator (a transient\n state that occurs regularly)."]
    #[link_name = "\u{1}_ZN4llvm10BasicBlock21setTrailingDbgRecordsEPNS_9DbgMarkerE"]
    pub fn llvm_BasicBlock_setTrailingDbgRecords(
        this: *mut llvm_BasicBlock,
        M: *mut llvm_DbgMarker,
    );
}
extern "C" {
    #[doc = " Fetch the collection of DbgRecords that \"trail\" after the last instruction\n of this block, see \\ref setTrailingDbgRecords. If there are none, returns\n nullptr."]
    #[link_name = "\u{1}_ZN4llvm10BasicBlock21getTrailingDbgRecordsEv"]
    pub fn llvm_BasicBlock_getTrailingDbgRecords(this: *mut llvm_BasicBlock)
        -> *mut llvm_DbgMarker;
}
extern "C" {
    #[doc = " Delete any trailing DbgRecords at the end of this block, see\n \\ref setTrailingDbgRecords."]
    #[link_name = "\u{1}_ZN4llvm10BasicBlock24deleteTrailingDbgRecordsEv"]
    pub fn llvm_BasicBlock_deleteTrailingDbgRecords(this: *mut llvm_BasicBlock);
}
extern "C" {
    #[link_name = "\u{1}_ZNK4llvm10BasicBlock13dumpDbgValuesEv"]
    pub fn llvm_BasicBlock_dumpDbgValues(this: *const llvm_BasicBlock);
}
extern "C" {
    #[doc = " Return the DbgMarker for the position given by \\p It, so that DbgRecords\n can be inserted there. This will either be nullptr if not present, a\n DbgMarker, or TrailingDbgRecords if It is end()."]
    #[link_name = "\u{1}_ZN4llvm10BasicBlock9getMarkerENS_21ilist_iterator_w_bitsINS_12ilist_detail12node_optionsINS_11InstructionELb1ELb0EvLb1ES0_EELb0ELb0EEE"]
    pub fn llvm_BasicBlock_getMarker(
        this: *mut llvm_BasicBlock,
        It: [u64; 2usize],
    ) -> *mut llvm_DbgMarker;
}
extern "C" {
    #[doc = " Return the DbgMarker for the position that comes after \\p I. \\see\n BasicBlock::getMarker, this can be nullptr, a DbgMarker, or\n TrailingDbgRecords if there is no next instruction."]
    #[link_name = "\u{1}_ZN4llvm10BasicBlock13getNextMarkerEPNS_11InstructionE"]
    pub fn llvm_BasicBlock_getNextMarker(
        this: *mut llvm_BasicBlock,
        I: *mut llvm_Instruction,
    ) -> *mut llvm_DbgMarker;
}
extern "C" {
    #[doc = " Insert a DbgRecord into a block at the position given by \\p I."]
    #[link_name = "\u{1}_ZN4llvm10BasicBlock20insertDbgRecordAfterEPNS_9DbgRecordEPNS_11InstructionE"]
    pub fn llvm_BasicBlock_insertDbgRecordAfter(
        this: *mut llvm_BasicBlock,
        DR: *mut llvm_DbgRecord,
        I: *mut llvm_Instruction,
    );
}
extern "C" {
    #[doc = " Insert a DbgRecord into a block at the position given by \\p Here."]
    #[link_name = "\u{1}_ZN4llvm10BasicBlock21insertDbgRecordBeforeEPNS_9DbgRecordENS_21ilist_iterator_w_bitsINS_12ilist_detail12node_optionsINS_11InstructionELb1ELb0EvLb1ES0_EELb0ELb0EEE"]
    pub fn llvm_BasicBlock_insertDbgRecordBefore(
        this: *mut llvm_BasicBlock,
        DR: *mut llvm_DbgRecord,
        Here: [u64; 2usize],
    );
}
extern "C" {
    #[doc = " Eject any debug-info trailing at the end of a block. DbgRecords can\n transiently be located \"off the end\" of a block if the blocks terminator\n is temporarily removed. Once a terminator is re-inserted this method will\n move such DbgRecords back to the right place (ahead of the terminator)."]
    #[link_name = "\u{1}_ZN4llvm10BasicBlock25flushTerminatorDbgRecordsEv"]
    pub fn llvm_BasicBlock_flushTerminatorDbgRecords(this: *mut llvm_BasicBlock);
}
extern "C" {
    #[doc = " In rare circumstances instructions can be speculatively removed from\n blocks, and then be re-inserted back into that position later. When this\n happens in RemoveDIs debug-info mode, some special patching-up needs to\n occur: inserting into the middle of a sequence of dbg.value intrinsics\n does not have an equivalent with DbgRecords."]
    #[link_name = "\u{1}_ZN4llvm10BasicBlock24reinsertInstInDbgRecordsEPNS_11InstructionESt8optionalINS_14ilist_iteratorINS_12ilist_detail12node_optionsINS_9DbgRecordELb1ELb0EvLb0EvEELb0ELb0EEEE"]
    pub fn llvm_BasicBlock_reinsertInstInDbgRecords(
        this: *mut llvm_BasicBlock,
        I: *mut llvm_Instruction,
        Pos: std_optional,
    );
}
extern "C" {
    #[doc = " Get the context in which this basic block lives."]
    #[link_name = "\u{1}_ZNK4llvm10BasicBlock10getContextEv"]
    pub fn llvm_BasicBlock_getContext(this: *const llvm_BasicBlock) -> *mut llvm_LLVMContext;
}
extern "C" {
    #[doc = " Return the module owning the function this basic block belongs to, or\n nullptr if the function does not have a module.\n\n Note: this is undefined behavior if the block does not have a parent."]
    #[link_name = "\u{1}_ZNK4llvm10BasicBlock9getModuleEv"]
    pub fn llvm_BasicBlock_getModule(this: *const llvm_BasicBlock) -> *const llvm_Module;
}
extern "C" {
    #[doc = " Get the data layout of the module this basic block belongs to.\n\n Requires the basic block to have a parent module."]
    #[link_name = "\u{1}_ZNK4llvm10BasicBlock13getDataLayoutEv"]
    pub fn llvm_BasicBlock_getDataLayout(this: *const llvm_BasicBlock) -> *const llvm_DataLayout;
}
extern "C" {
    #[doc = " Returns the call instruction calling \\@llvm.experimental.deoptimize\n prior to the terminating return instruction of this basic block, if such\n a call is present.  Otherwise, returns null."]
    #[link_name = "\u{1}_ZNK4llvm10BasicBlock28getTerminatingDeoptimizeCallEv"]
    pub fn llvm_BasicBlock_getTerminatingDeoptimizeCall(
        this: *const llvm_BasicBlock,
    ) -> *const llvm_CallInst;
}
extern "C" {
    #[doc = " Returns the call instruction calling \\@llvm.experimental.deoptimize\n that is present either in current basic block or in block that is a unique\n successor to current block, if such call is present. Otherwise, returns null."]
    #[link_name = "\u{1}_ZNK4llvm10BasicBlock31getPostdominatingDeoptimizeCallEv"]
    pub fn llvm_BasicBlock_getPostdominatingDeoptimizeCall(
        this: *const llvm_BasicBlock,
    ) -> *const llvm_CallInst;
}
extern "C" {
    #[doc = " Returns the call instruction marked 'musttail' prior to the terminating\n return instruction of this basic block, if such a call is present.\n Otherwise, returns null."]
    #[link_name = "\u{1}_ZNK4llvm10BasicBlock26getTerminatingMustTailCallEv"]
    pub fn llvm_BasicBlock_getTerminatingMustTailCall(
        this: *const llvm_BasicBlock,
    ) -> *const llvm_CallInst;
}
extern "C" {
    #[doc = " Returns a pointer to the first instruction in this block that is not a\n PHINode instruction.\n\n When adding instructions to the beginning of the basic block, they should\n be added before the returned value, not before the first instruction,\n which might be PHI. Returns 0 is there's no non-PHI instruction."]
    #[link_name = "\u{1}_ZNK4llvm10BasicBlock14getFirstNonPHIEv"]
    pub fn llvm_BasicBlock_getFirstNonPHI(this: *const llvm_BasicBlock) -> *const llvm_Instruction;
}
extern "C" {
    #[doc = " Iterator returning form of getFirstNonPHI. Installed as a placeholder for\n the RemoveDIs project that will eventually remove debug intrinsics."]
    #[link_name = "\u{1}_ZNK4llvm10BasicBlock16getFirstNonPHIItEv"]
    pub fn llvm_BasicBlock_getFirstNonPHIIt(this: *const llvm_BasicBlock) -> [u64; 2usize];
}
extern "C" {
    #[doc = " Returns a pointer to the first instruction in this block that is not a\n PHINode or a debug intrinsic, or any pseudo operation if \\c SkipPseudoOp\n is true."]
    #[link_name = "\u{1}_ZNK4llvm10BasicBlock19getFirstNonPHIOrDbgEb"]
    pub fn llvm_BasicBlock_getFirstNonPHIOrDbg(
        this: *const llvm_BasicBlock,
        SkipPseudoOp: bool,
    ) -> *const llvm_Instruction;
}
extern "C" {
    #[doc = " Returns a pointer to the first instruction in this block that is not a\n PHINode, a debug intrinsic, or a lifetime intrinsic, or any pseudo\n operation if \\c SkipPseudoOp is true."]
    #[link_name = "\u{1}_ZNK4llvm10BasicBlock29getFirstNonPHIOrDbgOrLifetimeEb"]
    pub fn llvm_BasicBlock_getFirstNonPHIOrDbgOrLifetime(
        this: *const llvm_BasicBlock,
        SkipPseudoOp: bool,
    ) -> *const llvm_Instruction;
}
extern "C" {
    #[doc = " Returns an iterator to the first instruction in this block that is\n suitable for inserting a non-PHI instruction.\n\n In particular, it skips all PHIs and LandingPad instructions."]
    #[link_name = "\u{1}_ZNK4llvm10BasicBlock19getFirstInsertionPtEv"]
    pub fn llvm_BasicBlock_getFirstInsertionPt(
        this: *const llvm_BasicBlock,
    ) -> llvm_BasicBlock_const_iterator;
}
extern "C" {
    #[doc = " Returns an iterator to the first instruction in this block that is\n not a PHINode, a debug intrinsic, a static alloca or any pseudo operation."]
    #[link_name = "\u{1}_ZNK4llvm10BasicBlock27getFirstNonPHIOrDbgOrAllocaEv"]
    pub fn llvm_BasicBlock_getFirstNonPHIOrDbgOrAlloca(
        this: *const llvm_BasicBlock,
    ) -> llvm_BasicBlock_const_iterator;
}
extern "C" {
    #[doc = " Returns the first potential AsynchEH faulty instruction\n currently it checks for loads/stores (which may dereference a null\n pointer) and calls/invokes (which may propagate exceptions)"]
    #[link_name = "\u{1}_ZNK4llvm10BasicBlock20getFirstMayFaultInstEv"]
    pub fn llvm_BasicBlock_getFirstMayFaultInst(
        this: *const llvm_BasicBlock,
    ) -> *const llvm_Instruction;
}
extern "C" {
    #[doc = " Return a const iterator range over the instructions in the block, skipping\n any debug instructions. Skip any pseudo operations as well if \\c\n SkipPseudoOp is true."]
    #[link_name = "\u{1}_ZNK4llvm10BasicBlock24instructionsWithoutDebugEb"]
    pub fn llvm_BasicBlock_instructionsWithoutDebug(
        this: *const llvm_BasicBlock,
        SkipPseudoOp: bool,
    ) -> u8;
}
extern "C" {
    #[doc = " Return an iterator range over the instructions in the block, skipping any\n debug instructions. Skip and any pseudo operations as well if \\c\n SkipPseudoOp is true."]
    #[link_name = "\u{1}_ZN4llvm10BasicBlock24instructionsWithoutDebugEb"]
    pub fn llvm_BasicBlock_instructionsWithoutDebug1(
        this: *mut llvm_BasicBlock,
        SkipPseudoOp: bool,
    ) -> llvm_iterator_range<llvm_filter_iterator_impl<llvm_BasicBlock_iterator, std_function>>;
}
extern "C" {
    #[doc = " Return the size of the basic block ignoring debug instructions"]
    #[link_name = "\u{1}_ZNK4llvm10BasicBlock16sizeWithoutDebugEv"]
    pub fn llvm_BasicBlock_sizeWithoutDebug(this: *const llvm_BasicBlock) -> difference_type;
}
extern "C" {
    #[doc = " Unlink 'this' from the containing function, but do not delete it."]
    #[link_name = "\u{1}_ZN4llvm10BasicBlock16removeFromParentEv"]
    pub fn llvm_BasicBlock_removeFromParent(this: *mut llvm_BasicBlock);
}
extern "C" {
    #[doc = " Unlink 'this' from the containing function and delete it.\n"]
    #[link_name = "\u{1}_ZN4llvm10BasicBlock15eraseFromParentEv"]
    pub fn llvm_BasicBlock_eraseFromParent(this: *mut llvm_BasicBlock) -> u64;
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm10BasicBlock10moveBeforeENS_14ilist_iteratorINS_12ilist_detail12node_optionsIS0_Lb1ELb0EvLb0EvEELb0ELb0EEE"]
    pub fn llvm_BasicBlock_moveBefore(this: *mut llvm_BasicBlock, MovePos: u64);
}
extern "C" {
    #[doc = " Unlink this basic block from its current function and insert it\n right after \\p MovePos in the function \\p MovePos lives in."]
    #[link_name = "\u{1}_ZN4llvm10BasicBlock9moveAfterEPS0_"]
    pub fn llvm_BasicBlock_moveAfter(this: *mut llvm_BasicBlock, MovePos: *mut llvm_BasicBlock);
}
extern "C" {
    #[doc = " Insert unlinked basic block into a function.\n\n Inserts an unlinked basic block into \\c Parent.  If \\c InsertBefore is\n provided, inserts before that basic block, otherwise inserts at the end.\n\n \\pre \\a getParent() is \\c nullptr."]
    #[link_name = "\u{1}_ZN4llvm10BasicBlock10insertIntoEPNS_8FunctionEPS0_"]
    pub fn llvm_BasicBlock_insertInto(
        this: *mut llvm_BasicBlock,
        Parent: *mut llvm_Function,
        InsertBefore: *mut llvm_BasicBlock,
    );
}
extern "C" {
    #[doc = " Return the predecessor of this block if it has a single predecessor\n block. Otherwise return a null pointer."]
    #[link_name = "\u{1}_ZNK4llvm10BasicBlock20getSinglePredecessorEv"]
    pub fn llvm_BasicBlock_getSinglePredecessor(
        this: *const llvm_BasicBlock,
    ) -> *const llvm_BasicBlock;
}
extern "C" {
    #[doc = " Return the predecessor of this block if it has a unique predecessor\n block. Otherwise return a null pointer.\n\n Note that unique predecessor doesn't mean single edge, there can be\n multiple edges from the unique predecessor to this block (for example a\n switch statement with multiple cases having the same destination)."]
    #[link_name = "\u{1}_ZNK4llvm10BasicBlock20getUniquePredecessorEv"]
    pub fn llvm_BasicBlock_getUniquePredecessor(
        this: *const llvm_BasicBlock,
    ) -> *const llvm_BasicBlock;
}
extern "C" {
    #[doc = " Return true if this block has exactly N predecessors."]
    #[link_name = "\u{1}_ZNK4llvm10BasicBlock16hasNPredecessorsEj"]
    pub fn llvm_BasicBlock_hasNPredecessors(
        this: *const llvm_BasicBlock,
        N: ::std::os::raw::c_uint,
    ) -> bool;
}
extern "C" {
    #[doc = " Return true if this block has N predecessors or more."]
    #[link_name = "\u{1}_ZNK4llvm10BasicBlock22hasNPredecessorsOrMoreEj"]
    pub fn llvm_BasicBlock_hasNPredecessorsOrMore(
        this: *const llvm_BasicBlock,
        N: ::std::os::raw::c_uint,
    ) -> bool;
}
extern "C" {
    #[doc = " Return the successor of this block if it has a single successor.\n Otherwise return a null pointer.\n\n This method is analogous to getSinglePredecessor above."]
    #[link_name = "\u{1}_ZNK4llvm10BasicBlock18getSingleSuccessorEv"]
    pub fn llvm_BasicBlock_getSingleSuccessor(
        this: *const llvm_BasicBlock,
    ) -> *const llvm_BasicBlock;
}
extern "C" {
    #[doc = " Return the successor of this block if it has a unique successor.\n Otherwise return a null pointer.\n\n This method is analogous to getUniquePredecessor above."]
    #[link_name = "\u{1}_ZNK4llvm10BasicBlock18getUniqueSuccessorEv"]
    pub fn llvm_BasicBlock_getUniqueSuccessor(
        this: *const llvm_BasicBlock,
    ) -> *const llvm_BasicBlock;
}
extern "C" {
    #[doc = " Print the basic block to an output stream with an optional\n AssemblyAnnotationWriter."]
    #[link_name = "\u{1}_ZNK4llvm10BasicBlock5printERNS_11raw_ostreamEPNS_24AssemblyAnnotationWriterEbb"]
    pub fn llvm_BasicBlock_print(
        this: *const llvm_BasicBlock,
        OS: *mut llvm_raw_ostream,
        AAW: *mut llvm_AssemblyAnnotationWriter,
        ShouldPreserveUseListOrder: bool,
        IsForDebug: bool,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm10BasicBlock4phisEv"]
    pub fn llvm_BasicBlock_phis(
        this: *mut llvm_BasicBlock,
    ) -> llvm_iterator_range<llvm_BasicBlock_phi_iterator>;
}
extern "C" {
    #[doc = " Returns a pointer to the symbol table if one exists."]
    #[link_name = "\u{1}_ZN4llvm10BasicBlock19getValueSymbolTableEv"]
    pub fn llvm_BasicBlock_getValueSymbolTable(
        this: *mut llvm_BasicBlock,
    ) -> *mut llvm_ValueSymbolTable;
}
extern "C" {
    #[doc = " Cause all subinstructions to \"let go\" of all the references that said\n subinstructions are maintaining.\n\n This allows one to 'delete' a whole class at a time, even though there may\n be circular references... first all references are dropped, and all use\n counts go to zero.  Then everything is delete'd for real.  Note that no\n operations are valid on an object that has \"dropped all references\",\n except operator delete."]
    #[link_name = "\u{1}_ZN4llvm10BasicBlock17dropAllReferencesEv"]
    pub fn llvm_BasicBlock_dropAllReferences(this: *mut llvm_BasicBlock);
}
extern "C" {
    #[doc = " Update PHI nodes in this BasicBlock before removal of predecessor \\p Pred.\n Note that this function does not actually remove the predecessor.\n\n If \\p KeepOneInputPHIs is true then don't remove PHIs that are left with\n zero or one incoming values, and don't simplify PHIs with all incoming\n values the same."]
    #[link_name = "\u{1}_ZN4llvm10BasicBlock17removePredecessorEPS0_b"]
    pub fn llvm_BasicBlock_removePredecessor(
        this: *mut llvm_BasicBlock,
        Pred: *mut llvm_BasicBlock,
        KeepOneInputPHIs: bool,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK4llvm10BasicBlock20canSplitPredecessorsEv"]
    pub fn llvm_BasicBlock_canSplitPredecessors(this: *const llvm_BasicBlock) -> bool;
}
extern "C" {
    #[doc = " Split the basic block into two basic blocks at the specified instruction.\n\n If \\p Before is true, splitBasicBlockBefore handles the\n block splitting. Otherwise, execution proceeds as described below.\n\n Note that all instructions BEFORE the specified iterator\n stay as part of the original basic block, an unconditional branch is added\n to the original BB, and the rest of the instructions in the BB are moved\n to the new BB, including the old terminator.  The newly formed basic block\n is returned. This function invalidates the specified iterator.\n\n Note that this only works on well formed basic blocks (must have a\n terminator), and \\p 'I' must not be the end of instruction list (which\n would cause a degenerate basic block to be formed, having a terminator\n inside of the basic block).\n\n Also note that this doesn't preserve any passes. To split blocks while\n keeping loop information consistent, use the SplitBlock utility function."]
    #[link_name = "\u{1}_ZN4llvm10BasicBlock15splitBasicBlockENS_21ilist_iterator_w_bitsINS_12ilist_detail12node_optionsINS_11InstructionELb1ELb0EvLb1ES0_EELb0ELb0EEERKNS_5TwineEb"]
    pub fn llvm_BasicBlock_splitBasicBlock(
        this: *mut llvm_BasicBlock,
        I: llvm_BasicBlock_iterator,
        BBName: *const llvm_Twine,
        Before: bool,
    ) -> *mut llvm_BasicBlock;
}
extern "C" {
    #[doc = " Split the basic block into two basic blocks at the specified instruction\n and insert the new basic blocks as the predecessor of the current block.\n\n This function ensures all instructions AFTER and including the specified\n iterator \\p I are part of the original basic block. All Instructions\n BEFORE the iterator \\p I are moved to the new BB and an unconditional\n branch is added to the new BB. The new basic block is returned.\n\n Note that this only works on well formed basic blocks (must have a\n terminator), and \\p 'I' must not be the end of instruction list (which\n would cause a degenerate basic block to be formed, having a terminator\n inside of the basic block).  \\p 'I' cannot be a iterator for a PHINode\n with multiple incoming blocks.\n\n Also note that this doesn't preserve any passes. To split blocks while\n keeping loop information consistent, use the SplitBlockBefore utility\n function."]
    #[link_name = "\u{1}_ZN4llvm10BasicBlock21splitBasicBlockBeforeENS_21ilist_iterator_w_bitsINS_12ilist_detail12node_optionsINS_11InstructionELb1ELb0EvLb1ES0_EELb0ELb0EEERKNS_5TwineE"]
    pub fn llvm_BasicBlock_splitBasicBlockBefore(
        this: *mut llvm_BasicBlock,
        I: llvm_BasicBlock_iterator,
        BBName: *const llvm_Twine,
    ) -> *mut llvm_BasicBlock;
}
extern "C" {
    #[doc = " Transfer a range of instructions that belong to \\p FromBB from \\p\n FromBeginIt to \\p FromEndIt, to this basic block at \\p ToIt."]
    #[link_name = "\u{1}_ZN4llvm10BasicBlock6spliceENS_21ilist_iterator_w_bitsINS_12ilist_detail12node_optionsINS_11InstructionELb1ELb0EvLb1ES0_EELb0ELb0EEEPS0_S6_S6_"]
    pub fn llvm_BasicBlock_splice(
        this: *mut llvm_BasicBlock,
        ToIt: llvm_BasicBlock_iterator,
        FromBB: *mut llvm_BasicBlock,
        FromBeginIt: llvm_BasicBlock_iterator,
        FromEndIt: llvm_BasicBlock_iterator,
    );
}
extern "C" {
    #[doc = " Erases a range of instructions from \\p FromIt to (not including) \\p ToIt.\n \\Returns \\p ToIt."]
    #[link_name = "\u{1}_ZN4llvm10BasicBlock5eraseENS_21ilist_iterator_w_bitsINS_12ilist_detail12node_optionsINS_11InstructionELb1ELb0EvLb1ES0_EELb0ELb0EEES6_"]
    pub fn llvm_BasicBlock_erase(
        this: *mut llvm_BasicBlock,
        FromIt: llvm_BasicBlock_iterator,
        ToIt: llvm_BasicBlock_iterator,
    ) -> llvm_BasicBlock_iterator;
}
extern "C" {
    #[doc = " Update all phi nodes in this basic block to refer to basic block \\p New\n instead of basic block \\p Old."]
    #[link_name = "\u{1}_ZN4llvm10BasicBlock18replacePhiUsesWithEPS0_S1_"]
    pub fn llvm_BasicBlock_replacePhiUsesWith(
        this: *mut llvm_BasicBlock,
        Old: *mut llvm_BasicBlock,
        New: *mut llvm_BasicBlock,
    );
}
extern "C" {
    #[doc = " Update all phi nodes in this basic block's successors to refer to basic\n block \\p New instead of basic block \\p Old."]
    #[link_name = "\u{1}_ZN4llvm10BasicBlock28replaceSuccessorsPhiUsesWithEPS0_S1_"]
    pub fn llvm_BasicBlock_replaceSuccessorsPhiUsesWith(
        this: *mut llvm_BasicBlock,
        Old: *mut llvm_BasicBlock,
        New: *mut llvm_BasicBlock,
    );
}
extern "C" {
    #[doc = " Update all phi nodes in this basic block's successors to refer to basic\n block \\p New instead of to it."]
    #[link_name = "\u{1}_ZN4llvm10BasicBlock28replaceSuccessorsPhiUsesWithEPS0_"]
    pub fn llvm_BasicBlock_replaceSuccessorsPhiUsesWith1(
        this: *mut llvm_BasicBlock,
        New: *mut llvm_BasicBlock,
    );
}
extern "C" {
    #[doc = " Return true if this basic block is a landing pad.\n\n Being a ``landing pad'' means that the basic block is the destination of\n the 'unwind' edge of an invoke instruction."]
    #[link_name = "\u{1}_ZNK4llvm10BasicBlock12isLandingPadEv"]
    pub fn llvm_BasicBlock_isLandingPad(this: *const llvm_BasicBlock) -> bool;
}
extern "C" {
    #[doc = " Return the landingpad instruction associated with the landing pad."]
    #[link_name = "\u{1}_ZNK4llvm10BasicBlock17getLandingPadInstEv"]
    pub fn llvm_BasicBlock_getLandingPadInst(
        this: *const llvm_BasicBlock,
    ) -> *const llvm_LandingPadInst;
}
extern "C" {
    #[doc = " Return true if it is legal to hoist instructions into this block."]
    #[link_name = "\u{1}_ZNK4llvm10BasicBlock18isLegalToHoistIntoEv"]
    pub fn llvm_BasicBlock_isLegalToHoistInto(this: *const llvm_BasicBlock) -> bool;
}
extern "C" {
    #[doc = " Return true if this is the entry block of the containing function.\n This method can only be used on blocks that have a parent function."]
    #[link_name = "\u{1}_ZNK4llvm10BasicBlock12isEntryBlockEv"]
    pub fn llvm_BasicBlock_isEntryBlock(this: *const llvm_BasicBlock) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4llvm10BasicBlock22getIrrLoopHeaderWeightEv"]
    pub fn llvm_BasicBlock_getIrrLoopHeaderWeight(this: *const llvm_BasicBlock) -> std_optional;
}
extern "C" {
    #[doc = " Renumber instructions and mark the ordering as valid."]
    #[link_name = "\u{1}_ZN4llvm10BasicBlock20renumberInstructionsEv"]
    pub fn llvm_BasicBlock_renumberInstructions(this: *mut llvm_BasicBlock);
}
extern "C" {
    #[doc = " Asserts that instruction order numbers are marked invalid, or that they\n are in ascending order. This is constant time if the ordering is invalid,\n and linear in the number of instructions if the ordering is valid. Callers\n should be careful not to call this in ways that make common operations\n O(n^2). For example, it takes O(n) time to assign order numbers to\n instructions, so the order should be validated no more than once after\n each ordering to ensure that transforms have the same algorithmic\n complexity when asserts are enabled as when they are disabled."]
    #[link_name = "\u{1}_ZNK4llvm10BasicBlock21validateInstrOrderingEv"]
    pub fn llvm_BasicBlock_validateInstrOrdering(this: *const llvm_BasicBlock);
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm10BasicBlockD1Ev"]
    pub fn llvm_BasicBlock_BasicBlock_destructor(this: *mut llvm_BasicBlock);
}
impl llvm_BasicBlock {
    #[inline]
    pub unsafe fn createMarker(&mut self, I: *mut llvm_Instruction) -> *mut llvm_DbgMarker {
        llvm_BasicBlock_createMarker(self, I)
    }
    #[inline]
    pub unsafe fn createMarker1(&mut self, It: [u64; 2usize]) -> *mut llvm_DbgMarker {
        llvm_BasicBlock_createMarker1(self, It)
    }
    #[inline]
    pub unsafe fn convertToNewDbgValues(&mut self) {
        llvm_BasicBlock_convertToNewDbgValues(self)
    }
    #[inline]
    pub unsafe fn convertFromNewDbgValues(&mut self) {
        llvm_BasicBlock_convertFromNewDbgValues(self)
    }
    #[inline]
    pub unsafe fn setIsNewDbgInfoFormat(&mut self, NewFlag: bool) {
        llvm_BasicBlock_setIsNewDbgInfoFormat(self, NewFlag)
    }
    #[inline]
    pub unsafe fn setNewDbgInfoFormatFlag(&mut self, NewFlag: bool) {
        llvm_BasicBlock_setNewDbgInfoFormatFlag(self, NewFlag)
    }
    #[inline]
    pub unsafe fn setTrailingDbgRecords(&mut self, M: *mut llvm_DbgMarker) {
        llvm_BasicBlock_setTrailingDbgRecords(self, M)
    }
    #[inline]
    pub unsafe fn getTrailingDbgRecords(&mut self) -> *mut llvm_DbgMarker {
        llvm_BasicBlock_getTrailingDbgRecords(self)
    }
    #[inline]
    pub unsafe fn deleteTrailingDbgRecords(&mut self) {
        llvm_BasicBlock_deleteTrailingDbgRecords(self)
    }
    #[inline]
    pub unsafe fn dumpDbgValues(&self) {
        llvm_BasicBlock_dumpDbgValues(self)
    }
    #[inline]
    pub unsafe fn getMarker(&mut self, It: [u64; 2usize]) -> *mut llvm_DbgMarker {
        llvm_BasicBlock_getMarker(self, It)
    }
    #[inline]
    pub unsafe fn getNextMarker(&mut self, I: *mut llvm_Instruction) -> *mut llvm_DbgMarker {
        llvm_BasicBlock_getNextMarker(self, I)
    }
    #[inline]
    pub unsafe fn insertDbgRecordAfter(
        &mut self,
        DR: *mut llvm_DbgRecord,
        I: *mut llvm_Instruction,
    ) {
        llvm_BasicBlock_insertDbgRecordAfter(self, DR, I)
    }
    #[inline]
    pub unsafe fn insertDbgRecordBefore(&mut self, DR: *mut llvm_DbgRecord, Here: [u64; 2usize]) {
        llvm_BasicBlock_insertDbgRecordBefore(self, DR, Here)
    }
    #[inline]
    pub unsafe fn flushTerminatorDbgRecords(&mut self) {
        llvm_BasicBlock_flushTerminatorDbgRecords(self)
    }
    #[inline]
    pub unsafe fn reinsertInstInDbgRecords(&mut self, I: *mut llvm_Instruction, Pos: std_optional) {
        llvm_BasicBlock_reinsertInstInDbgRecords(self, I, Pos)
    }
    #[inline]
    pub unsafe fn getContext(&self) -> *mut llvm_LLVMContext {
        llvm_BasicBlock_getContext(self)
    }
    #[inline]
    pub unsafe fn getModule(&self) -> *const llvm_Module {
        llvm_BasicBlock_getModule(self)
    }
    #[inline]
    pub unsafe fn getDataLayout(&self) -> *const llvm_DataLayout {
        llvm_BasicBlock_getDataLayout(self)
    }
    #[inline]
    pub unsafe fn getTerminatingDeoptimizeCall(&self) -> *const llvm_CallInst {
        llvm_BasicBlock_getTerminatingDeoptimizeCall(self)
    }
    #[inline]
    pub unsafe fn getPostdominatingDeoptimizeCall(&self) -> *const llvm_CallInst {
        llvm_BasicBlock_getPostdominatingDeoptimizeCall(self)
    }
    #[inline]
    pub unsafe fn getTerminatingMustTailCall(&self) -> *const llvm_CallInst {
        llvm_BasicBlock_getTerminatingMustTailCall(self)
    }
    #[inline]
    pub unsafe fn getFirstNonPHI(&self) -> *const llvm_Instruction {
        llvm_BasicBlock_getFirstNonPHI(self)
    }
    #[inline]
    pub unsafe fn getFirstNonPHIIt(&self) -> [u64; 2usize] {
        llvm_BasicBlock_getFirstNonPHIIt(self)
    }
    #[inline]
    pub unsafe fn getFirstNonPHIOrDbg(&self, SkipPseudoOp: bool) -> *const llvm_Instruction {
        llvm_BasicBlock_getFirstNonPHIOrDbg(self, SkipPseudoOp)
    }
    #[inline]
    pub unsafe fn getFirstNonPHIOrDbgOrLifetime(
        &self,
        SkipPseudoOp: bool,
    ) -> *const llvm_Instruction {
        llvm_BasicBlock_getFirstNonPHIOrDbgOrLifetime(self, SkipPseudoOp)
    }
    #[inline]
    pub unsafe fn getFirstInsertionPt(&self) -> llvm_BasicBlock_const_iterator {
        llvm_BasicBlock_getFirstInsertionPt(self)
    }
    #[inline]
    pub unsafe fn getFirstNonPHIOrDbgOrAlloca(&self) -> llvm_BasicBlock_const_iterator {
        llvm_BasicBlock_getFirstNonPHIOrDbgOrAlloca(self)
    }
    #[inline]
    pub unsafe fn getFirstMayFaultInst(&self) -> *const llvm_Instruction {
        llvm_BasicBlock_getFirstMayFaultInst(self)
    }
    #[inline]
    pub unsafe fn instructionsWithoutDebug(&self, SkipPseudoOp: bool) -> u8 {
        llvm_BasicBlock_instructionsWithoutDebug(self, SkipPseudoOp)
    }
    #[inline]
    pub unsafe fn instructionsWithoutDebug1(
        &mut self,
        SkipPseudoOp: bool,
    ) -> llvm_iterator_range<llvm_filter_iterator_impl<llvm_BasicBlock_iterator, std_function>>
    {
        llvm_BasicBlock_instructionsWithoutDebug1(self, SkipPseudoOp)
    }
    #[inline]
    pub unsafe fn sizeWithoutDebug(&self) -> difference_type {
        llvm_BasicBlock_sizeWithoutDebug(self)
    }
    #[inline]
    pub unsafe fn removeFromParent(&mut self) {
        llvm_BasicBlock_removeFromParent(self)
    }
    #[inline]
    pub unsafe fn eraseFromParent(&mut self) -> u64 {
        llvm_BasicBlock_eraseFromParent(self)
    }
    #[inline]
    pub unsafe fn moveBefore(&mut self, MovePos: u64) {
        llvm_BasicBlock_moveBefore(self, MovePos)
    }
    #[inline]
    pub unsafe fn moveAfter(&mut self, MovePos: *mut llvm_BasicBlock) {
        llvm_BasicBlock_moveAfter(self, MovePos)
    }
    #[inline]
    pub unsafe fn insertInto(
        &mut self,
        Parent: *mut llvm_Function,
        InsertBefore: *mut llvm_BasicBlock,
    ) {
        llvm_BasicBlock_insertInto(self, Parent, InsertBefore)
    }
    #[inline]
    pub unsafe fn getSinglePredecessor(&self) -> *const llvm_BasicBlock {
        llvm_BasicBlock_getSinglePredecessor(self)
    }
    #[inline]
    pub unsafe fn getUniquePredecessor(&self) -> *const llvm_BasicBlock {
        llvm_BasicBlock_getUniquePredecessor(self)
    }
    #[inline]
    pub unsafe fn hasNPredecessors(&self, N: ::std::os::raw::c_uint) -> bool {
        llvm_BasicBlock_hasNPredecessors(self, N)
    }
    #[inline]
    pub unsafe fn hasNPredecessorsOrMore(&self, N: ::std::os::raw::c_uint) -> bool {
        llvm_BasicBlock_hasNPredecessorsOrMore(self, N)
    }
    #[inline]
    pub unsafe fn getSingleSuccessor(&self) -> *const llvm_BasicBlock {
        llvm_BasicBlock_getSingleSuccessor(self)
    }
    #[inline]
    pub unsafe fn getUniqueSuccessor(&self) -> *const llvm_BasicBlock {
        llvm_BasicBlock_getUniqueSuccessor(self)
    }
    #[inline]
    pub unsafe fn print(
        &self,
        OS: *mut llvm_raw_ostream,
        AAW: *mut llvm_AssemblyAnnotationWriter,
        ShouldPreserveUseListOrder: bool,
        IsForDebug: bool,
    ) {
        llvm_BasicBlock_print(self, OS, AAW, ShouldPreserveUseListOrder, IsForDebug)
    }
    #[inline]
    pub unsafe fn phis(&mut self) -> llvm_iterator_range<llvm_BasicBlock_phi_iterator> {
        llvm_BasicBlock_phis(self)
    }
    #[inline]
    pub unsafe fn getValueSymbolTable(&mut self) -> *mut llvm_ValueSymbolTable {
        llvm_BasicBlock_getValueSymbolTable(self)
    }
    #[inline]
    pub unsafe fn dropAllReferences(&mut self) {
        llvm_BasicBlock_dropAllReferences(self)
    }
    #[inline]
    pub unsafe fn removePredecessor(&mut self, Pred: *mut llvm_BasicBlock, KeepOneInputPHIs: bool) {
        llvm_BasicBlock_removePredecessor(self, Pred, KeepOneInputPHIs)
    }
    #[inline]
    pub unsafe fn canSplitPredecessors(&self) -> bool {
        llvm_BasicBlock_canSplitPredecessors(self)
    }
    #[inline]
    pub unsafe fn splitBasicBlock(
        &mut self,
        I: llvm_BasicBlock_iterator,
        BBName: *const llvm_Twine,
        Before: bool,
    ) -> *mut llvm_BasicBlock {
        llvm_BasicBlock_splitBasicBlock(self, I, BBName, Before)
    }
    #[inline]
    pub unsafe fn splitBasicBlockBefore(
        &mut self,
        I: llvm_BasicBlock_iterator,
        BBName: *const llvm_Twine,
    ) -> *mut llvm_BasicBlock {
        llvm_BasicBlock_splitBasicBlockBefore(self, I, BBName)
    }
    #[inline]
    pub unsafe fn splice(
        &mut self,
        ToIt: llvm_BasicBlock_iterator,
        FromBB: *mut llvm_BasicBlock,
        FromBeginIt: llvm_BasicBlock_iterator,
        FromEndIt: llvm_BasicBlock_iterator,
    ) {
        llvm_BasicBlock_splice(self, ToIt, FromBB, FromBeginIt, FromEndIt)
    }
    #[inline]
    pub unsafe fn erase(
        &mut self,
        FromIt: llvm_BasicBlock_iterator,
        ToIt: llvm_BasicBlock_iterator,
    ) -> llvm_BasicBlock_iterator {
        llvm_BasicBlock_erase(self, FromIt, ToIt)
    }
    #[inline]
    pub unsafe fn replacePhiUsesWith(
        &mut self,
        Old: *mut llvm_BasicBlock,
        New: *mut llvm_BasicBlock,
    ) {
        llvm_BasicBlock_replacePhiUsesWith(self, Old, New)
    }
    #[inline]
    pub unsafe fn replaceSuccessorsPhiUsesWith(
        &mut self,
        Old: *mut llvm_BasicBlock,
        New: *mut llvm_BasicBlock,
    ) {
        llvm_BasicBlock_replaceSuccessorsPhiUsesWith(self, Old, New)
    }
    #[inline]
    pub unsafe fn replaceSuccessorsPhiUsesWith1(&mut self, New: *mut llvm_BasicBlock) {
        llvm_BasicBlock_replaceSuccessorsPhiUsesWith1(self, New)
    }
    #[inline]
    pub unsafe fn isLandingPad(&self) -> bool {
        llvm_BasicBlock_isLandingPad(self)
    }
    #[inline]
    pub unsafe fn getLandingPadInst(&self) -> *const llvm_LandingPadInst {
        llvm_BasicBlock_getLandingPadInst(self)
    }
    #[inline]
    pub unsafe fn isLegalToHoistInto(&self) -> bool {
        llvm_BasicBlock_isLegalToHoistInto(self)
    }
    #[inline]
    pub unsafe fn isEntryBlock(&self) -> bool {
        llvm_BasicBlock_isEntryBlock(self)
    }
    #[inline]
    pub unsafe fn getIrrLoopHeaderWeight(&self) -> std_optional {
        llvm_BasicBlock_getIrrLoopHeaderWeight(self)
    }
    #[inline]
    pub unsafe fn renumberInstructions(&mut self) {
        llvm_BasicBlock_renumberInstructions(self)
    }
    #[inline]
    pub unsafe fn validateInstrOrdering(&self) {
        llvm_BasicBlock_validateInstrOrdering(self)
    }
    #[inline]
    pub unsafe fn destruct(&mut self) {
        llvm_BasicBlock_BasicBlock_destructor(self)
    }
}
extern "C" {
    #[doc = " Advance \\p It while it points to a debug instruction and return the result.\n This assumes that \\p It is not at the end of a block."]
    #[link_name = "\u{1}_ZN4llvm19skipDebugIntrinsicsENS_21ilist_iterator_w_bitsINS_12ilist_detail12node_optionsINS_11InstructionELb1ELb0EvLb1ENS_10BasicBlockEEELb0ELb0EEE"]
    pub fn llvm_skipDebugIntrinsics(It: llvm_BasicBlock_iterator) -> llvm_BasicBlock_iterator;
}
#[test]
fn __bindgen_test_layout_llvm_DenseMapInfo_open0_llvm_ilist_iterator_w_bits_open1_llvm_ilist_detail_node_options_open2_llvm_Instruction_void_llvm_BasicBlock_close2_close1_void_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<llvm_DenseMapInfo>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_DenseMapInfo)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_DenseMapInfo>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_DenseMapInfo)
        )
    );
}
#[doc = " LLVM IR allows to use arbitrary numbers as calling convention identifiers."]
pub type llvm_CallingConv_ID = ::std::os::raw::c_uint;
#[doc = " The default llvm calling convention, compatible with C. This convention\n is the only one that supports varargs calls. As with typical C calling\n conventions, the callee/caller have to tolerate certain amounts of\n prototype mismatch."]
pub const C: llvm_CallingConv__bindgen_ty_1 = 0;
#[doc = " Attempts to make calls as fast as possible (e.g. by passing things in\n registers)."]
pub const Fast: llvm_CallingConv__bindgen_ty_1 = 8;
#[doc = " Attempts to make code in the caller as efficient as possible under the\n assumption that the call is not commonly executed. As such, these calls\n often preserve all registers so that the call does not break any live\n ranges in the caller side."]
pub const Cold: llvm_CallingConv__bindgen_ty_1 = 9;
#[doc = " Used by the Glasgow Haskell Compiler (GHC)."]
pub const GHC: llvm_CallingConv__bindgen_ty_1 = 10;
#[doc = " Used by the High-Performance Erlang Compiler (HiPE)."]
pub const HiPE: llvm_CallingConv__bindgen_ty_1 = 11;
#[doc = " Used for dynamic register based calls (e.g. stackmap and patchpoint\n intrinsics)."]
pub const AnyReg: llvm_CallingConv__bindgen_ty_1 = 13;
#[doc = " Used for runtime calls that preserves most registers."]
pub const PreserveMost: llvm_CallingConv__bindgen_ty_1 = 14;
#[doc = " Used for runtime calls that preserves (almost) all registers."]
pub const PreserveAll: llvm_CallingConv__bindgen_ty_1 = 15;
#[doc = " Calling convention for Swift."]
pub const Swift: llvm_CallingConv__bindgen_ty_1 = 16;
#[doc = " Used for access functions."]
pub const CXX_FAST_TLS: llvm_CallingConv__bindgen_ty_1 = 17;
#[doc = " Attemps to make calls as fast as possible while guaranteeing that tail\n call optimization can always be performed."]
pub const Tail: llvm_CallingConv__bindgen_ty_1 = 18;
#[doc = " Special calling convention on Windows for calling the Control Guard\n Check ICall funtion. The function takes exactly one argument (address of\n the target function) passed in the first argument register, and has no\n return value. All register values are preserved."]
pub const CFGuard_Check: llvm_CallingConv__bindgen_ty_1 = 19;
#[doc = " This follows the Swift calling convention in how arguments are passed\n but guarantees tail calls will be made by making the callee clean up\n their stack."]
pub const SwiftTail: llvm_CallingConv__bindgen_ty_1 = 20;
#[doc = " Used for runtime calls that preserves none general registers."]
pub const PreserveNone: llvm_CallingConv__bindgen_ty_1 = 21;
#[doc = " This is the start of the target-specific calling conventions, e.g.\n fastcall and thiscall on X86."]
pub const FirstTargetCC: llvm_CallingConv__bindgen_ty_1 = 64;
#[doc = " stdcall is mostly used by the Win32 API. It is basically the same as the\n C convention with the difference in that the callee is responsible for\n popping the arguments from the stack."]
pub const X86_StdCall: llvm_CallingConv__bindgen_ty_1 = 64;
#[doc = " 'fast' analog of X86_StdCall. Passes first two arguments in ECX:EDX\n registers, others - via stack. Callee is responsible for stack cleaning."]
pub const X86_FastCall: llvm_CallingConv__bindgen_ty_1 = 65;
#[doc = " ARM Procedure Calling Standard (obsolete, but still used on some\n targets)."]
pub const ARM_APCS: llvm_CallingConv__bindgen_ty_1 = 66;
#[doc = " ARM Architecture Procedure Calling Standard calling convention (aka\n EABI). Soft float variant."]
pub const ARM_AAPCS: llvm_CallingConv__bindgen_ty_1 = 67;
#[doc = " Same as ARM_AAPCS, but uses hard floating point ABI."]
pub const ARM_AAPCS_VFP: llvm_CallingConv__bindgen_ty_1 = 68;
#[doc = " Used for MSP430 interrupt routines."]
pub const MSP430_INTR: llvm_CallingConv__bindgen_ty_1 = 69;
#[doc = " Similar to X86_StdCall. Passes first argument in ECX, others via stack.\n Callee is responsible for stack cleaning. MSVC uses this by default for\n methods in its ABI."]
pub const X86_ThisCall: llvm_CallingConv__bindgen_ty_1 = 70;
#[doc = " Call to a PTX kernel. Passes all arguments in parameter space."]
pub const PTX_Kernel: llvm_CallingConv__bindgen_ty_1 = 71;
#[doc = " Call to a PTX device function. Passes all arguments in register or\n parameter space."]
pub const PTX_Device: llvm_CallingConv__bindgen_ty_1 = 72;
#[doc = " Used for SPIR non-kernel device functions. No lowering or expansion of\n arguments. Structures are passed as a pointer to a struct with the\n byval attribute. Functions can only call SPIR_FUNC and SPIR_KERNEL\n functions. Functions can only have zero or one return values. Variable\n arguments are not allowed, except for printf. How arguments/return\n values are lowered are not specified. Functions are only visible to the\n devices."]
pub const SPIR_FUNC: llvm_CallingConv__bindgen_ty_1 = 75;
#[doc = " Used for SPIR kernel functions. Inherits the restrictions of SPIR_FUNC,\n except it cannot have non-void return values, it cannot have variable\n arguments, it can also be called by the host or it is externally\n visible."]
pub const SPIR_KERNEL: llvm_CallingConv__bindgen_ty_1 = 76;
#[doc = " Used for Intel OpenCL built-ins."]
pub const Intel_OCL_BI: llvm_CallingConv__bindgen_ty_1 = 77;
#[doc = " The C convention as specified in the x86-64 supplement to the System V\n ABI, used on most non-Windows systems."]
pub const X86_64_SysV: llvm_CallingConv__bindgen_ty_1 = 78;
#[doc = " The C convention as implemented on Windows/x86-64 and AArch64. It\n differs from the more common \\c X86_64_SysV convention in a number of\n ways, most notably in that XMM registers used to pass arguments are\n shadowed by GPRs, and vice versa. On AArch64, this is identical to the\n normal C (AAPCS) calling convention for normal functions, but floats are\n passed in integer registers to variadic functions."]
pub const Win64: llvm_CallingConv__bindgen_ty_1 = 79;
#[doc = " MSVC calling convention that passes vectors and vector aggregates in SSE\n registers."]
pub const X86_VectorCall: llvm_CallingConv__bindgen_ty_1 = 80;
#[doc = " Placeholders for HHVM calling conventions (deprecated, removed)."]
pub const DUMMY_HHVM: llvm_CallingConv__bindgen_ty_1 = 81;
#[doc = " Placeholders for HHVM calling conventions (deprecated, removed)."]
pub const DUMMY_HHVM_C: llvm_CallingConv__bindgen_ty_1 = 82;
#[doc = " x86 hardware interrupt context. Callee may take one or two parameters,\n where the 1st represents a pointer to hardware context frame and the 2nd\n represents hardware error code, the presence of the later depends on the\n interrupt vector taken. Valid for both 32- and 64-bit subtargets."]
pub const X86_INTR: llvm_CallingConv__bindgen_ty_1 = 83;
#[doc = " Used for AVR interrupt routines."]
pub const AVR_INTR: llvm_CallingConv__bindgen_ty_1 = 84;
#[doc = " Used for AVR signal routines."]
pub const AVR_SIGNAL: llvm_CallingConv__bindgen_ty_1 = 85;
#[doc = " Used for special AVR rtlib functions which have an \"optimized\"\n convention to preserve registers."]
pub const AVR_BUILTIN: llvm_CallingConv__bindgen_ty_1 = 86;
#[doc = " Used for Mesa vertex shaders, or AMDPAL last shader stage before\n rasterization (vertex shader if tessellation and geometry are not in\n use, or otherwise copy shader if one is needed)."]
pub const AMDGPU_VS: llvm_CallingConv__bindgen_ty_1 = 87;
#[doc = " Used for Mesa/AMDPAL geometry shaders."]
pub const AMDGPU_GS: llvm_CallingConv__bindgen_ty_1 = 88;
#[doc = " Used for Mesa/AMDPAL pixel shaders."]
pub const AMDGPU_PS: llvm_CallingConv__bindgen_ty_1 = 89;
#[doc = " Used for Mesa/AMDPAL compute shaders."]
pub const AMDGPU_CS: llvm_CallingConv__bindgen_ty_1 = 90;
#[doc = " Used for AMDGPU code object kernels."]
pub const AMDGPU_KERNEL: llvm_CallingConv__bindgen_ty_1 = 91;
#[doc = " Register calling convention used for parameters transfer optimization"]
pub const X86_RegCall: llvm_CallingConv__bindgen_ty_1 = 92;
#[doc = " Used for Mesa/AMDPAL hull shaders (= tessellation control shaders)."]
pub const AMDGPU_HS: llvm_CallingConv__bindgen_ty_1 = 93;
#[doc = " Used for special MSP430 rtlib functions which have an \"optimized\"\n convention using additional registers."]
pub const MSP430_BUILTIN: llvm_CallingConv__bindgen_ty_1 = 94;
#[doc = " Used for AMDPAL vertex shader if tessellation is in use."]
pub const AMDGPU_LS: llvm_CallingConv__bindgen_ty_1 = 95;
#[doc = " Used for AMDPAL shader stage before geometry shader if geometry is in\n use. So either the domain (= tessellation evaluation) shader if\n tessellation is in use, or otherwise the vertex shader."]
pub const AMDGPU_ES: llvm_CallingConv__bindgen_ty_1 = 96;
#[doc = " Used between AArch64 Advanced SIMD functions"]
pub const AArch64_VectorCall: llvm_CallingConv__bindgen_ty_1 = 97;
#[doc = " Used between AArch64 SVE functions"]
pub const AArch64_SVE_VectorCall: llvm_CallingConv__bindgen_ty_1 = 98;
#[doc = " For emscripten __invoke_* functions. The first argument is required to\n be the function ptr being indirectly called. The remainder matches the\n regular calling convention."]
pub const WASM_EmscriptenInvoke: llvm_CallingConv__bindgen_ty_1 = 99;
#[doc = " Used for AMD graphics targets."]
pub const AMDGPU_Gfx: llvm_CallingConv__bindgen_ty_1 = 100;
#[doc = " Used for M68k interrupt routines."]
pub const M68k_INTR: llvm_CallingConv__bindgen_ty_1 = 101;
#[doc = " Preserve X0-X13, X19-X29, SP, Z0-Z31, P0-P15."]
pub const AArch64_SME_ABI_Support_Routines_PreserveMost_From_X0: llvm_CallingConv__bindgen_ty_1 =
    102;
#[doc = " Preserve X2-X15, X19-X29, SP, Z0-Z31, P0-P15."]
pub const AArch64_SME_ABI_Support_Routines_PreserveMost_From_X2: llvm_CallingConv__bindgen_ty_1 =
    103;
#[doc = " Used on AMDGPUs to give the middle-end more control over argument\n placement."]
pub const AMDGPU_CS_Chain: llvm_CallingConv__bindgen_ty_1 = 104;
#[doc = " Used on AMDGPUs to give the middle-end more control over argument\n placement. Preserves active lane values for input VGPRs."]
pub const AMDGPU_CS_ChainPreserve: llvm_CallingConv__bindgen_ty_1 = 105;
#[doc = " Used for M68k rtd-based CC (similar to X86's stdcall)."]
pub const M68k_RTD: llvm_CallingConv__bindgen_ty_1 = 106;
#[doc = " Used by GraalVM. Two additional registers are reserved."]
pub const GRAAL: llvm_CallingConv__bindgen_ty_1 = 107;
#[doc = " Calling convention used in the ARM64EC ABI to implement calls between\n x64 code and thunks. This is basically the x64 calling convention using\n ARM64 register names. The first parameter is mapped to x9."]
pub const ARM64EC_Thunk_X64: llvm_CallingConv__bindgen_ty_1 = 108;
#[doc = " Calling convention used in the ARM64EC ABI to implement calls between\n ARM64 code and thunks. This is just the ARM64 calling convention,\n except that the first parameter is mapped to x9."]
pub const ARM64EC_Thunk_Native: llvm_CallingConv__bindgen_ty_1 = 109;
#[doc = " Calling convention used for RISC-V V-extension."]
pub const RISCV_VectorCall: llvm_CallingConv__bindgen_ty_1 = 110;
#[doc = " Preserve X1-X15, X19-X29, SP, Z0-Z31, P0-P15."]
pub const AArch64_SME_ABI_Support_Routines_PreserveMost_From_X1: llvm_CallingConv__bindgen_ty_1 =
    111;
#[doc = " The highest possible ID. Must be some 2^k - 1."]
pub const MaxID: llvm_CallingConv__bindgen_ty_1 = 1023;
#[doc = " A set of enums which specify the assigned numeric values for known llvm\n calling conventions.\n LLVM Calling Convention Representation"]
pub type llvm_CallingConv__bindgen_ty_1 = ::std::os::raw::c_uint;
pub type llvm_Intrinsic_ID = ::std::os::raw::c_uint;
pub const llvm_GlobalIdentifierDelimiter: ::std::os::raw::c_char = 59;
#[repr(C)]
#[derive(Debug)]
pub struct llvm_GlobalValue {
    pub _base: llvm_Constant,
    pub ValueType: *mut llvm_Type,
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    #[doc = " The intrinsic ID for this subclass (which must be a Function).\n\n This member is defined by this class, but not used for anything.\n Subclasses can use it to store their intrinsic ID, if they have one.\n\n This is stored here to save space in Function on 64-bit hosts."]
    pub IntID: llvm_Intrinsic_ID,
    pub Parent: *mut llvm_Module,
}
#[doc = "< Externally visible function"]
pub const llvm_GlobalValue_LinkageTypes_ExternalLinkage: llvm_GlobalValue_LinkageTypes = 0;
#[doc = "< Available for inspection, not emission."]
pub const llvm_GlobalValue_LinkageTypes_AvailableExternallyLinkage: llvm_GlobalValue_LinkageTypes =
    1;
#[doc = "< Keep one copy of function when linking (inline)"]
pub const llvm_GlobalValue_LinkageTypes_LinkOnceAnyLinkage: llvm_GlobalValue_LinkageTypes = 2;
#[doc = "< Same, but only replaced by something equivalent."]
pub const llvm_GlobalValue_LinkageTypes_LinkOnceODRLinkage: llvm_GlobalValue_LinkageTypes = 3;
#[doc = "< Keep one copy of named function when linking (weak)"]
pub const llvm_GlobalValue_LinkageTypes_WeakAnyLinkage: llvm_GlobalValue_LinkageTypes = 4;
#[doc = "< Same, but only replaced by something equivalent."]
pub const llvm_GlobalValue_LinkageTypes_WeakODRLinkage: llvm_GlobalValue_LinkageTypes = 5;
#[doc = "< Special purpose, only applies to global arrays"]
pub const llvm_GlobalValue_LinkageTypes_AppendingLinkage: llvm_GlobalValue_LinkageTypes = 6;
#[doc = "< Rename collisions when linking (static functions)."]
pub const llvm_GlobalValue_LinkageTypes_InternalLinkage: llvm_GlobalValue_LinkageTypes = 7;
#[doc = "< Like Internal, but omit from symbol table."]
pub const llvm_GlobalValue_LinkageTypes_PrivateLinkage: llvm_GlobalValue_LinkageTypes = 8;
#[doc = "< ExternalWeak linkage description."]
pub const llvm_GlobalValue_LinkageTypes_ExternalWeakLinkage: llvm_GlobalValue_LinkageTypes = 9;
#[doc = "< Tentative definitions."]
pub const llvm_GlobalValue_LinkageTypes_CommonLinkage: llvm_GlobalValue_LinkageTypes = 10;
#[doc = " An enumeration for the kinds of linkage for global values."]
pub type llvm_GlobalValue_LinkageTypes = ::std::os::raw::c_uint;
#[doc = "< The GV is visible"]
pub const llvm_GlobalValue_VisibilityTypes_DefaultVisibility: llvm_GlobalValue_VisibilityTypes = 0;
#[doc = "< The GV is hidden"]
pub const llvm_GlobalValue_VisibilityTypes_HiddenVisibility: llvm_GlobalValue_VisibilityTypes = 1;
#[doc = "< The GV is protected"]
pub const llvm_GlobalValue_VisibilityTypes_ProtectedVisibility: llvm_GlobalValue_VisibilityTypes =
    2;
#[doc = " An enumeration for the kinds of visibility of global values."]
pub type llvm_GlobalValue_VisibilityTypes = ::std::os::raw::c_uint;
pub const llvm_GlobalValue_DLLStorageClassTypes_DefaultStorageClass:
    llvm_GlobalValue_DLLStorageClassTypes = 0;
#[doc = "< Function to be imported from DLL"]
pub const llvm_GlobalValue_DLLStorageClassTypes_DLLImportStorageClass:
    llvm_GlobalValue_DLLStorageClassTypes = 1;
#[doc = "< Function to be accessible from DLL."]
pub const llvm_GlobalValue_DLLStorageClassTypes_DLLExportStorageClass:
    llvm_GlobalValue_DLLStorageClassTypes = 2;
#[doc = " Storage classes of global values for PE targets."]
pub type llvm_GlobalValue_DLLStorageClassTypes = ::std::os::raw::c_uint;
pub const llvm_GlobalValue_ThreadLocalMode_NotThreadLocal: llvm_GlobalValue_ThreadLocalMode = 0;
pub const llvm_GlobalValue_ThreadLocalMode_GeneralDynamicTLSModel:
    llvm_GlobalValue_ThreadLocalMode = 1;
pub const llvm_GlobalValue_ThreadLocalMode_LocalDynamicTLSModel: llvm_GlobalValue_ThreadLocalMode =
    2;
pub const llvm_GlobalValue_ThreadLocalMode_InitialExecTLSModel: llvm_GlobalValue_ThreadLocalMode =
    3;
pub const llvm_GlobalValue_ThreadLocalMode_LocalExecTLSModel: llvm_GlobalValue_ThreadLocalMode = 4;
pub type llvm_GlobalValue_ThreadLocalMode = ::std::os::raw::c_uint;
pub const llvm_GlobalValue_UnnamedAddr_None: llvm_GlobalValue_UnnamedAddr = 0;
pub const llvm_GlobalValue_UnnamedAddr_Local: llvm_GlobalValue_UnnamedAddr = 1;
pub const llvm_GlobalValue_UnnamedAddr_Global: llvm_GlobalValue_UnnamedAddr = 2;
pub type llvm_GlobalValue_UnnamedAddr = ::std::os::raw::c_int;
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct llvm_GlobalValue_SanitizerMetadata {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: [u8; 3usize],
}
#[test]
fn bindgen_test_layout_llvm_GlobalValue_SanitizerMetadata() {
    assert_eq!(
        ::std::mem::size_of::<llvm_GlobalValue_SanitizerMetadata>(),
        4usize,
        concat!("Size of: ", stringify!(llvm_GlobalValue_SanitizerMetadata))
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_GlobalValue_SanitizerMetadata>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(llvm_GlobalValue_SanitizerMetadata)
        )
    );
}
impl llvm_GlobalValue_SanitizerMetadata {
    #[inline]
    pub fn NoAddress(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_NoAddress(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn NoHWAddress(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_NoHWAddress(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Memtag(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Memtag(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn IsDynInit(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_IsDynInit(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        NoAddress: ::std::os::raw::c_uint,
        NoHWAddress: ::std::os::raw::c_uint,
        Memtag: ::std::os::raw::c_uint,
        IsDynInit: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let NoAddress: u32 = unsafe { ::std::mem::transmute(NoAddress) };
            NoAddress as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let NoHWAddress: u32 = unsafe { ::std::mem::transmute(NoHWAddress) };
            NoHWAddress as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let Memtag: u32 = unsafe { ::std::mem::transmute(Memtag) };
            Memtag as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let IsDynInit: u32 = unsafe { ::std::mem::transmute(IsDynInit) };
            IsDynInit as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " Declare a type to represent a global unique identifier for a global value.\n This is a 64 bits hash that is used by PGO and ThinLTO to have a compact\n unique way to identify a symbol."]
pub type llvm_GlobalValue_GUID = u64;
pub const llvm_GlobalValue_GlobalValueSubClassDataBits: ::std::os::raw::c_uint = 15;
#[test]
fn bindgen_test_layout_llvm_GlobalValue() {
    const UNINIT: ::std::mem::MaybeUninit<llvm_GlobalValue> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<llvm_GlobalValue>(),
        48usize,
        concat!("Size of: ", stringify!(llvm_GlobalValue))
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_GlobalValue>(),
        8usize,
        concat!("Alignment of ", stringify!(llvm_GlobalValue))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ValueType) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_GlobalValue),
            "::",
            stringify!(ValueType)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).IntID) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_GlobalValue),
            "::",
            stringify!(IntID)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Parent) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_GlobalValue),
            "::",
            stringify!(Parent)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK4llvm11GlobalValue9getComdatEv"]
    pub fn llvm_GlobalValue_getComdat(this: *const llvm_GlobalValue) -> *const llvm_Comdat;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4llvm11GlobalValue10getSectionEv"]
    pub fn llvm_GlobalValue_getSection(this: *const llvm_GlobalValue) -> llvm_StringRef;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4llvm11GlobalValue12getPartitionEv"]
    pub fn llvm_GlobalValue_getPartition(this: *const llvm_GlobalValue) -> llvm_StringRef;
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm11GlobalValue12setPartitionENS_9StringRefE"]
    pub fn llvm_GlobalValue_setPartition(this: *mut llvm_GlobalValue, Part: llvm_StringRef);
}
extern "C" {
    #[link_name = "\u{1}_ZNK4llvm11GlobalValue20getSanitizerMetadataEv"]
    pub fn llvm_GlobalValue_getSanitizerMetadata(
        this: *const llvm_GlobalValue,
    ) -> *const llvm_GlobalValue_SanitizerMetadata;
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm11GlobalValue20setSanitizerMetadataENS0_17SanitizerMetadataE"]
    pub fn llvm_GlobalValue_setSanitizerMetadata(
        this: *mut llvm_GlobalValue,
        Meta: llvm_GlobalValue_SanitizerMetadata,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm11GlobalValue23removeSanitizerMetadataEv"]
    pub fn llvm_GlobalValue_removeSanitizerMetadata(this: *mut llvm_GlobalValue);
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm11GlobalValue21setNoSanitizeMetadataEv"]
    pub fn llvm_GlobalValue_setNoSanitizeMetadata(this: *mut llvm_GlobalValue);
}
extern "C" {
    #[doc = " Return true if this global's definition can be substituted with an\n *arbitrary* definition at link time or load time. We cannot do any IPO or\n inlining across interposable call edges, since the callee can be\n replaced with something arbitrary."]
    #[link_name = "\u{1}_ZNK4llvm11GlobalValue14isInterposableEv"]
    pub fn llvm_GlobalValue_isInterposable(this: *const llvm_GlobalValue) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4llvm11GlobalValue24canBenefitFromLocalAliasEv"]
    pub fn llvm_GlobalValue_canBenefitFromLocalAlias(this: *const llvm_GlobalValue) -> bool;
}
extern "C" {
    #[doc = " Copy all additional attributes (those not needed to create a GlobalValue)\n from the GlobalValue Src to this one."]
    #[link_name = "\u{1}_ZN4llvm11GlobalValue18copyAttributesFromEPKS0_"]
    pub fn llvm_GlobalValue_copyAttributesFrom(
        this: *mut llvm_GlobalValue,
        Src: *const llvm_GlobalValue,
    );
}
extern "C" {
    #[doc = " Return the modified name for a global value suitable to be\n used as the key for a global lookup (e.g. profile or ThinLTO).\n The value's original name is \\c Name and has linkage of type\n \\c Linkage. The value is defined in module \\c FileName."]
    #[link_name = "\u{1}_ZN4llvm11GlobalValue19getGlobalIdentifierB5cxx11ENS_9StringRefENS0_12LinkageTypesES1_"]
    pub fn llvm_GlobalValue_getGlobalIdentifier(
        Name: llvm_StringRef,
        Linkage: llvm_GlobalValue_LinkageTypes,
        FileName: llvm_StringRef,
    ) -> std_string;
}
extern "C" {
    #[doc = " Return the modified name for this global value suitable to be\n used as the key for a global lookup (e.g. profile or ThinLTO)."]
    #[link_name = "\u{1}_ZNK4llvm11GlobalValue19getGlobalIdentifierB5cxx11Ev"]
    pub fn llvm_GlobalValue_getGlobalIdentifier1(this: *const llvm_GlobalValue) -> std_string;
}
extern "C" {
    #[doc = " Return a 64-bit global unique ID constructed from global value name\n (i.e. returned by getGlobalIdentifier())."]
    #[link_name = "\u{1}_ZN4llvm11GlobalValue7getGUIDENS_9StringRefE"]
    pub fn llvm_GlobalValue_getGUID(GlobalName: llvm_StringRef) -> llvm_GlobalValue_GUID;
}
extern "C" {
    #[doc = " If this function's Module is being lazily streamed in functions from disk\n or some other source, this method can be used to check to see if the\n function has been read in yet or not."]
    #[link_name = "\u{1}_ZNK4llvm11GlobalValue16isMaterializableEv"]
    pub fn llvm_GlobalValue_isMaterializable(this: *const llvm_GlobalValue) -> bool;
}
extern "C" {
    #[doc = " Make sure this GlobalValue is fully read."]
    #[link_name = "\u{1}_ZN4llvm11GlobalValue11materializeEv"]
    pub fn llvm_GlobalValue_materialize(this: *mut llvm_GlobalValue) -> llvm_Error;
}
extern "C" {
    #[doc = " Return true if the primary definition of this global value is outside of\n the current translation unit."]
    #[link_name = "\u{1}_ZNK4llvm11GlobalValue13isDeclarationEv"]
    pub fn llvm_GlobalValue_isDeclaration(this: *const llvm_GlobalValue) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4llvm11GlobalValue16getAliaseeObjectEv"]
    pub fn llvm_GlobalValue_getAliaseeObject(
        this: *const llvm_GlobalValue,
    ) -> *const llvm_GlobalObject;
}
extern "C" {
    #[doc = " Returns whether this is a reference to an absolute symbol."]
    #[link_name = "\u{1}_ZNK4llvm11GlobalValue19isAbsoluteSymbolRefEv"]
    pub fn llvm_GlobalValue_isAbsoluteSymbolRef(this: *const llvm_GlobalValue) -> bool;
}
extern "C" {
    #[doc = " If this is an absolute symbol reference, returns the range of the symbol,\n otherwise returns std::nullopt."]
    #[link_name = "\u{1}_ZNK4llvm11GlobalValue22getAbsoluteSymbolRangeEv"]
    pub fn llvm_GlobalValue_getAbsoluteSymbolRange(this: *const llvm_GlobalValue) -> std_optional;
}
extern "C" {
    #[doc = " This method unlinks 'this' from the containing module, but does not delete\n it."]
    #[link_name = "\u{1}_ZN4llvm11GlobalValue16removeFromParentEv"]
    pub fn llvm_GlobalValue_removeFromParent(this: *mut llvm_GlobalValue);
}
extern "C" {
    #[doc = " This method unlinks 'this' from the containing module and deletes it."]
    #[link_name = "\u{1}_ZN4llvm11GlobalValue15eraseFromParentEv"]
    pub fn llvm_GlobalValue_eraseFromParent(this: *mut llvm_GlobalValue);
}
extern "C" {
    #[doc = " Get the data layout of the module this global belongs to.\n\n Requires the global to have a parent module."]
    #[link_name = "\u{1}_ZNK4llvm11GlobalValue13getDataLayoutEv"]
    pub fn llvm_GlobalValue_getDataLayout(this: *const llvm_GlobalValue) -> *const llvm_DataLayout;
}
extern "C" {
    #[doc = " True if GV can be left out of the object symbol table. This is the case\n for linkonce_odr values whose address is not significant. While legal, it\n is not normally profitable to omit them from the .o symbol table. Using\n this analysis makes sense when the information can be passed down to the\n linker or we are in LTO."]
    #[link_name = "\u{1}_ZNK4llvm11GlobalValue27canBeOmittedFromSymbolTableEv"]
    pub fn llvm_GlobalValue_canBeOmittedFromSymbolTable(this: *const llvm_GlobalValue) -> bool;
}
impl llvm_GlobalValue {
    #[inline]
    pub fn Linkage(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_Linkage(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn Visibility(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_Visibility(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn UnnamedAddrVal(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_UnnamedAddrVal(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn DllStorageClass(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_DllStorageClass(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn ThreadLocal(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(10usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_ThreadLocal(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(10usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn HasLLVMReservedName(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_HasLLVMReservedName(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn IsDSOLocal(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_IsDSOLocal(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn HasPartition(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_HasPartition(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn HasSanitizerMetadata(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_HasSanitizerMetadata(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SubClassData(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(17usize, 15u8) as u32) }
    }
    #[inline]
    pub fn set_SubClassData(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(17usize, 15u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        Linkage: ::std::os::raw::c_uint,
        Visibility: ::std::os::raw::c_uint,
        UnnamedAddrVal: ::std::os::raw::c_uint,
        DllStorageClass: ::std::os::raw::c_uint,
        ThreadLocal: ::std::os::raw::c_uint,
        HasLLVMReservedName: ::std::os::raw::c_uint,
        IsDSOLocal: ::std::os::raw::c_uint,
        HasPartition: ::std::os::raw::c_uint,
        HasSanitizerMetadata: ::std::os::raw::c_uint,
        SubClassData: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let Linkage: u32 = unsafe { ::std::mem::transmute(Linkage) };
            Linkage as u64
        });
        __bindgen_bitfield_unit.set(4usize, 2u8, {
            let Visibility: u32 = unsafe { ::std::mem::transmute(Visibility) };
            Visibility as u64
        });
        __bindgen_bitfield_unit.set(6usize, 2u8, {
            let UnnamedAddrVal: u32 = unsafe { ::std::mem::transmute(UnnamedAddrVal) };
            UnnamedAddrVal as u64
        });
        __bindgen_bitfield_unit.set(8usize, 2u8, {
            let DllStorageClass: u32 = unsafe { ::std::mem::transmute(DllStorageClass) };
            DllStorageClass as u64
        });
        __bindgen_bitfield_unit.set(10usize, 3u8, {
            let ThreadLocal: u32 = unsafe { ::std::mem::transmute(ThreadLocal) };
            ThreadLocal as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let HasLLVMReservedName: u32 = unsafe { ::std::mem::transmute(HasLLVMReservedName) };
            HasLLVMReservedName as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let IsDSOLocal: u32 = unsafe { ::std::mem::transmute(IsDSOLocal) };
            IsDSOLocal as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let HasPartition: u32 = unsafe { ::std::mem::transmute(HasPartition) };
            HasPartition as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let HasSanitizerMetadata: u32 = unsafe { ::std::mem::transmute(HasSanitizerMetadata) };
            HasSanitizerMetadata as u64
        });
        __bindgen_bitfield_unit.set(17usize, 15u8, {
            let SubClassData: u32 = unsafe { ::std::mem::transmute(SubClassData) };
            SubClassData as u64
        });
        __bindgen_bitfield_unit
    }
    #[inline]
    pub unsafe fn getComdat(&self) -> *const llvm_Comdat {
        llvm_GlobalValue_getComdat(self)
    }
    #[inline]
    pub unsafe fn getSection(&self) -> llvm_StringRef {
        llvm_GlobalValue_getSection(self)
    }
    #[inline]
    pub unsafe fn getPartition(&self) -> llvm_StringRef {
        llvm_GlobalValue_getPartition(self)
    }
    #[inline]
    pub unsafe fn setPartition(&mut self, Part: llvm_StringRef) {
        llvm_GlobalValue_setPartition(self, Part)
    }
    #[inline]
    pub unsafe fn getSanitizerMetadata(&self) -> *const llvm_GlobalValue_SanitizerMetadata {
        llvm_GlobalValue_getSanitizerMetadata(self)
    }
    #[inline]
    pub unsafe fn setSanitizerMetadata(&mut self, Meta: llvm_GlobalValue_SanitizerMetadata) {
        llvm_GlobalValue_setSanitizerMetadata(self, Meta)
    }
    #[inline]
    pub unsafe fn removeSanitizerMetadata(&mut self) {
        llvm_GlobalValue_removeSanitizerMetadata(self)
    }
    #[inline]
    pub unsafe fn setNoSanitizeMetadata(&mut self) {
        llvm_GlobalValue_setNoSanitizeMetadata(self)
    }
    #[inline]
    pub unsafe fn isInterposable(&self) -> bool {
        llvm_GlobalValue_isInterposable(self)
    }
    #[inline]
    pub unsafe fn canBenefitFromLocalAlias(&self) -> bool {
        llvm_GlobalValue_canBenefitFromLocalAlias(self)
    }
    #[inline]
    pub unsafe fn copyAttributesFrom(&mut self, Src: *const llvm_GlobalValue) {
        llvm_GlobalValue_copyAttributesFrom(self, Src)
    }
    #[inline]
    pub unsafe fn getGlobalIdentifier(
        Name: llvm_StringRef,
        Linkage: llvm_GlobalValue_LinkageTypes,
        FileName: llvm_StringRef,
    ) -> std_string {
        llvm_GlobalValue_getGlobalIdentifier(Name, Linkage, FileName)
    }
    #[inline]
    pub unsafe fn getGlobalIdentifier1(&self) -> std_string {
        llvm_GlobalValue_getGlobalIdentifier1(self)
    }
    #[inline]
    pub unsafe fn getGUID(GlobalName: llvm_StringRef) -> llvm_GlobalValue_GUID {
        llvm_GlobalValue_getGUID(GlobalName)
    }
    #[inline]
    pub unsafe fn isMaterializable(&self) -> bool {
        llvm_GlobalValue_isMaterializable(self)
    }
    #[inline]
    pub unsafe fn materialize(&mut self) -> llvm_Error {
        llvm_GlobalValue_materialize(self)
    }
    #[inline]
    pub unsafe fn isDeclaration(&self) -> bool {
        llvm_GlobalValue_isDeclaration(self)
    }
    #[inline]
    pub unsafe fn getAliaseeObject(&self) -> *const llvm_GlobalObject {
        llvm_GlobalValue_getAliaseeObject(self)
    }
    #[inline]
    pub unsafe fn isAbsoluteSymbolRef(&self) -> bool {
        llvm_GlobalValue_isAbsoluteSymbolRef(self)
    }
    #[inline]
    pub unsafe fn getAbsoluteSymbolRange(&self) -> std_optional {
        llvm_GlobalValue_getAbsoluteSymbolRange(self)
    }
    #[inline]
    pub unsafe fn removeFromParent(&mut self) {
        llvm_GlobalValue_removeFromParent(self)
    }
    #[inline]
    pub unsafe fn eraseFromParent(&mut self) {
        llvm_GlobalValue_eraseFromParent(self)
    }
    #[inline]
    pub unsafe fn getDataLayout(&self) -> *const llvm_DataLayout {
        llvm_GlobalValue_getDataLayout(self)
    }
    #[inline]
    pub unsafe fn canBeOmittedFromSymbolTable(&self) -> bool {
        llvm_GlobalValue_canBeOmittedFromSymbolTable(self)
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct llvm_GlobalObject {
    pub _base: llvm_GlobalValue,
    pub ObjComdat: *mut llvm_Comdat,
}
pub const llvm_GlobalObject_VCallVisibility_VCallVisibilityPublic:
    llvm_GlobalObject_VCallVisibility = 0;
pub const llvm_GlobalObject_VCallVisibility_VCallVisibilityLinkageUnit:
    llvm_GlobalObject_VCallVisibility = 1;
pub const llvm_GlobalObject_VCallVisibility_VCallVisibilityTranslationUnit:
    llvm_GlobalObject_VCallVisibility = 2;
pub type llvm_GlobalObject_VCallVisibility = ::std::os::raw::c_uint;
pub const llvm_GlobalObject_LastAlignmentBit: llvm_GlobalObject__bindgen_ty_1 = 5;
pub const llvm_GlobalObject_LastCodeModelBit: llvm_GlobalObject__bindgen_ty_1 = 8;
pub const llvm_GlobalObject_HasSectionHashEntryBit: llvm_GlobalObject__bindgen_ty_1 = 9;
pub const llvm_GlobalObject_GlobalObjectBits: llvm_GlobalObject__bindgen_ty_1 = 10;
pub type llvm_GlobalObject__bindgen_ty_1 = ::std::os::raw::c_uint;
pub const llvm_GlobalObject_GlobalObjectSubClassDataBits: ::std::os::raw::c_uint = 5;
pub const llvm_GlobalObject_AlignmentBits: ::std::os::raw::c_uint = 6;
pub const llvm_GlobalObject_AlignmentMask: ::std::os::raw::c_uint = 63;
pub const llvm_GlobalObject_GlobalObjectMask: ::std::os::raw::c_uint = 1023;
#[test]
fn bindgen_test_layout_llvm_GlobalObject() {
    const UNINIT: ::std::mem::MaybeUninit<llvm_GlobalObject> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<llvm_GlobalObject>(),
        56usize,
        concat!("Size of: ", stringify!(llvm_GlobalObject))
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_GlobalObject>(),
        8usize,
        concat!("Alignment of ", stringify!(llvm_GlobalObject))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ObjComdat) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_GlobalObject),
            "::",
            stringify!(ObjComdat)
        )
    );
}
extern "C" {
    #[doc = " Sets the alignment attribute of the GlobalObject."]
    #[link_name = "\u{1}_ZN4llvm12GlobalObject12setAlignmentENS_5AlignE"]
    pub fn llvm_GlobalObject_setAlignment(this: *mut llvm_GlobalObject, Align: llvm_Align);
}
extern "C" {
    #[doc = " Sets the alignment attribute of the GlobalObject.\n This method will be deprecated as the alignment property should always be\n defined."]
    #[link_name = "\u{1}_ZN4llvm12GlobalObject12setAlignmentENS_10MaybeAlignE"]
    pub fn llvm_GlobalObject_setAlignment1(this: *mut llvm_GlobalObject, Align: llvm_MaybeAlign);
}
extern "C" {
    #[doc = " Change the section for this global.\n\n Setting the section to the empty string tells LLVM to choose an\n appropriate default object file section."]
    #[link_name = "\u{1}_ZN4llvm12GlobalObject10setSectionENS_9StringRefE"]
    pub fn llvm_GlobalObject_setSection(this: *mut llvm_GlobalObject, S: llvm_StringRef);
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm12GlobalObject9setComdatEPNS_6ComdatE"]
    pub fn llvm_GlobalObject_setComdat(this: *mut llvm_GlobalObject, C: *mut llvm_Comdat);
}
extern "C" {
    #[doc = " Copy metadata from Src, adjusting offsets by Offset."]
    #[link_name = "\u{1}_ZN4llvm12GlobalObject12copyMetadataEPKS0_j"]
    pub fn llvm_GlobalObject_copyMetadata(
        this: *mut llvm_GlobalObject,
        Src: *const llvm_GlobalObject,
        Offset: ::std::os::raw::c_uint,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm12GlobalObject15addTypeMetadataEjPNS_8MetadataE"]
    pub fn llvm_GlobalObject_addTypeMetadata(
        this: *mut llvm_GlobalObject,
        Offset: ::std::os::raw::c_uint,
        TypeID: *mut llvm_Metadata,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm12GlobalObject26setVCallVisibilityMetadataENS0_15VCallVisibilityE"]
    pub fn llvm_GlobalObject_setVCallVisibilityMetadata(
        this: *mut llvm_GlobalObject,
        Visibility: llvm_GlobalObject_VCallVisibility,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK4llvm12GlobalObject18getVCallVisibilityEv"]
    pub fn llvm_GlobalObject_getVCallVisibility(
        this: *const llvm_GlobalObject,
    ) -> llvm_GlobalObject_VCallVisibility;
}
extern "C" {
    #[doc = " Returns true if the alignment of the value can be unilaterally\n increased.\n\n Note that for functions this is the alignment of the code, not the\n alignment of a function pointer."]
    #[link_name = "\u{1}_ZNK4llvm12GlobalObject20canIncreaseAlignmentEv"]
    pub fn llvm_GlobalObject_canIncreaseAlignment(this: *const llvm_GlobalObject) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm12GlobalObject18copyAttributesFromEPKS0_"]
    pub fn llvm_GlobalObject_copyAttributesFrom(
        this: *mut llvm_GlobalObject,
        Src: *const llvm_GlobalObject,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm12GlobalObjectD1Ev"]
    pub fn llvm_GlobalObject_GlobalObject_destructor(this: *mut llvm_GlobalObject);
}
impl llvm_GlobalObject {
    #[inline]
    pub unsafe fn setAlignment(&mut self, Align: llvm_Align) {
        llvm_GlobalObject_setAlignment(self, Align)
    }
    #[inline]
    pub unsafe fn setAlignment1(&mut self, Align: llvm_MaybeAlign) {
        llvm_GlobalObject_setAlignment1(self, Align)
    }
    #[inline]
    pub unsafe fn setSection(&mut self, S: llvm_StringRef) {
        llvm_GlobalObject_setSection(self, S)
    }
    #[inline]
    pub unsafe fn setComdat(&mut self, C: *mut llvm_Comdat) {
        llvm_GlobalObject_setComdat(self, C)
    }
    #[inline]
    pub unsafe fn copyMetadata(
        &mut self,
        Src: *const llvm_GlobalObject,
        Offset: ::std::os::raw::c_uint,
    ) {
        llvm_GlobalObject_copyMetadata(self, Src, Offset)
    }
    #[inline]
    pub unsafe fn addTypeMetadata(
        &mut self,
        Offset: ::std::os::raw::c_uint,
        TypeID: *mut llvm_Metadata,
    ) {
        llvm_GlobalObject_addTypeMetadata(self, Offset, TypeID)
    }
    #[inline]
    pub unsafe fn setVCallVisibilityMetadata(
        &mut self,
        Visibility: llvm_GlobalObject_VCallVisibility,
    ) {
        llvm_GlobalObject_setVCallVisibilityMetadata(self, Visibility)
    }
    #[inline]
    pub unsafe fn getVCallVisibility(&self) -> llvm_GlobalObject_VCallVisibility {
        llvm_GlobalObject_getVCallVisibility(self)
    }
    #[inline]
    pub unsafe fn canIncreaseAlignment(&self) -> bool {
        llvm_GlobalObject_canIncreaseAlignment(self)
    }
    #[inline]
    pub unsafe fn copyAttributesFrom(&mut self, Src: *const llvm_GlobalObject) {
        llvm_GlobalObject_copyAttributesFrom(self, Src)
    }
    #[inline]
    pub unsafe fn destruct(&mut self) {
        llvm_GlobalObject_GlobalObject_destructor(self)
    }
}
#[doc = " VariadicOperandTraits - determine the allocation regime of the Use array\n when it is a prefix to the User object, and the number of Use objects is\n only known at allocation time."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_VariadicOperandTraits {
    pub _address: u8,
}
#[doc = " HungoffOperandTraits - determine the allocation regime of the Use array\n when it is not a prefix to the User object, but allocated at an unrelated\n heap address.\n\n This is the traits class that is needed when the Use array must be\n resizable."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_HungoffOperandTraits {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_llvm_HungoffOperandTraits() {
    assert_eq!(
        ::std::mem::size_of::<llvm_HungoffOperandTraits>(),
        1usize,
        concat!("Size of: ", stringify!(llvm_HungoffOperandTraits))
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_HungoffOperandTraits>(),
        1usize,
        concat!("Alignment of ", stringify!(llvm_HungoffOperandTraits))
    );
}
pub type llvm_LibFunc = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_TargetLibraryInfoImpl {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_BranchProbabilityInfo {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_BlockFrequencyInfo {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug)]
pub struct llvm_Function {
    pub _base: llvm_GlobalObject,
    pub __bindgen_padding_0: [u64; 2usize],
    #[doc = "< The basic blocks"]
    pub BasicBlocks: llvm_Function_BasicBlockListType,
    pub NextBlockNum: ::std::os::raw::c_uint,
    #[doc = " Epoch of block numbers. (Could be shrinked to uint8_t if required.)"]
    pub BlockNumEpoch: ::std::os::raw::c_uint,
    #[doc = "< The formal arguments"]
    pub Arguments: *mut llvm_Argument,
    pub NumArgs: usize,
    #[doc = "< Symbol table of args/instructions"]
    pub SymTab: std_unique_ptr,
    #[doc = "< Parameter attributes"]
    pub AttributeSets: llvm_AttributeList,
    #[doc = " Is this function using intrinsics to record the position of debugging\n information, or non-intrinsic records? See IsNewDbgInfoFormat in\n \\ref BasicBlock."]
    pub IsNewDbgInfoFormat: bool,
    #[doc = " Cache for TLI::getLibFunc() result without prototype validation.\n UnknownLibFunc if uninitialized. NotLibFunc if definitely not lib func.\n Otherwise may be libfunc if prototype validation passes."]
    pub LibFuncCache: llvm_LibFunc,
}
#[doc = " List that automatically updates parent links and symbol tables.\n\n When nodes are inserted into and removed from this list, the associated\n symbol table will be automatically updated.  Similarly, parent links get\n updated automatically."]
pub type llvm_Function_BasicBlockListType = llvm_SymbolTableList;
#[doc = " Iterator for intrusive lists  based on ilist_node."]
pub type llvm_Function_iterator = u64;
#[doc = " Iterator for intrusive lists  based on ilist_node."]
pub type llvm_Function_const_iterator = u64;
pub type llvm_Function_arg_iterator = *mut llvm_Argument;
pub type llvm_Function_const_arg_iterator = *const llvm_Argument;
#[doc = " Whether this function is materializable."]
pub const llvm_Function_IsMaterializableBit: llvm_Function__bindgen_ty_1 = 0;
#[doc = " Bits from GlobalObject::GlobalObjectSubclassData."]
pub type llvm_Function__bindgen_ty_1 = ::std::os::raw::c_uint;
pub const llvm_Function_ProfileCountType_PCT_Real: llvm_Function_ProfileCountType = 0;
pub const llvm_Function_ProfileCountType_PCT_Synthetic: llvm_Function_ProfileCountType = 1;
pub type llvm_Function_ProfileCountType = ::std::os::raw::c_uint;
#[doc = " Class to represent profile counts.\n\n This class represents both real and synthetic profile counts."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_Function_ProfileCount {
    pub Count: u64,
    pub PCT: llvm_Function_ProfileCountType,
}
#[test]
fn bindgen_test_layout_llvm_Function_ProfileCount() {
    const UNINIT: ::std::mem::MaybeUninit<llvm_Function_ProfileCount> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<llvm_Function_ProfileCount>(),
        16usize,
        concat!("Size of: ", stringify!(llvm_Function_ProfileCount))
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_Function_ProfileCount>(),
        8usize,
        concat!("Alignment of ", stringify!(llvm_Function_ProfileCount))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Count) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_Function_ProfileCount),
            "::",
            stringify!(Count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).PCT) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_Function_ProfileCount),
            "::",
            stringify!(PCT)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm8Function14UnknownLibFuncE"]
    pub static llvm_Function_UnknownLibFunc: llvm_LibFunc;
}
#[test]
fn bindgen_test_layout_llvm_Function() {
    const UNINIT: ::std::mem::MaybeUninit<llvm_Function> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<llvm_Function>(),
        136usize,
        concat!("Size of: ", stringify!(llvm_Function))
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_Function>(),
        8usize,
        concat!("Alignment of ", stringify!(llvm_Function))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).BasicBlocks) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_Function),
            "::",
            stringify!(BasicBlocks)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).NextBlockNum) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_Function),
            "::",
            stringify!(NextBlockNum)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).BlockNumEpoch) as usize - ptr as usize },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_Function),
            "::",
            stringify!(BlockNumEpoch)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Arguments) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_Function),
            "::",
            stringify!(Arguments)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).NumArgs) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_Function),
            "::",
            stringify!(NumArgs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).SymTab) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_Function),
            "::",
            stringify!(SymTab)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).AttributeSets) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_Function),
            "::",
            stringify!(AttributeSets)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).IsNewDbgInfoFormat) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_Function),
            "::",
            stringify!(IsNewDbgInfoFormat)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LibFuncCache) as usize - ptr as usize },
        132usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_Function),
            "::",
            stringify!(LibFuncCache)
        )
    );
}
extern "C" {
    #[doc = " \\see BasicBlock::convertToNewDbgValues."]
    #[link_name = "\u{1}_ZN4llvm8Function21convertToNewDbgValuesEv"]
    pub fn llvm_Function_convertToNewDbgValues(this: *mut llvm_Function);
}
extern "C" {
    #[doc = " \\see BasicBlock::convertFromNewDbgValues."]
    #[link_name = "\u{1}_ZN4llvm8Function23convertFromNewDbgValuesEv"]
    pub fn llvm_Function_convertFromNewDbgValues(this: *mut llvm_Function);
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm8Function21setIsNewDbgInfoFormatEb"]
    pub fn llvm_Function_setIsNewDbgInfoFormat(this: *mut llvm_Function, NewVal: bool);
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm8Function23setNewDbgInfoFormatFlagEb"]
    pub fn llvm_Function_setNewDbgInfoFormatFlag(this: *mut llvm_Function, NewVal: bool);
}
extern "C" {
    #[doc = " Creates a new function and attaches it to a module.\n\n Places the function in the program address space as specified\n by the module's data layout."]
    #[link_name = "\u{1}_ZN4llvm8Function6CreateEPNS_12FunctionTypeENS_11GlobalValue12LinkageTypesERKNS_5TwineERNS_6ModuleE"]
    pub fn llvm_Function_Create(
        Ty: *mut llvm_FunctionType,
        Linkage: llvm_GlobalValue_LinkageTypes,
        N: *const llvm_Twine,
        M: *mut llvm_Module,
    ) -> *mut llvm_Function;
}
extern "C" {
    #[doc = " Creates a function with some attributes recorded in llvm.module.flags\n and the LLVMContext applied.\n\n Use this when synthesizing new functions that need attributes that would\n have been set by command line options.\n\n This function should not be called from backends or the LTO pipeline. If\n it is called from one of those places, some default attributes will not be\n applied to the function."]
    #[link_name = "\u{1}_ZN4llvm8Function21createWithDefaultAttrEPNS_12FunctionTypeENS_11GlobalValue12LinkageTypesEjRKNS_5TwineEPNS_6ModuleE"]
    pub fn llvm_Function_createWithDefaultAttr(
        Ty: *mut llvm_FunctionType,
        Linkage: llvm_GlobalValue_LinkageTypes,
        AddrSpace: ::std::os::raw::c_uint,
        N: *const llvm_Twine,
        M: *mut llvm_Module,
    ) -> *mut llvm_Function;
}
extern "C" {
    #[doc = " Returns the number of non-debug IR instructions in this function.\n This is equivalent to the sum of the sizes of each basic block contained\n within this function."]
    #[link_name = "\u{1}_ZNK4llvm8Function19getInstructionCountEv"]
    pub fn llvm_Function_getInstructionCount(this: *const llvm_Function) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " getContext - Return a reference to the LLVMContext associated with this\n function."]
    #[link_name = "\u{1}_ZNK4llvm8Function10getContextEv"]
    pub fn llvm_Function_getContext(this: *const llvm_Function) -> *mut llvm_LLVMContext;
}
extern "C" {
    #[doc = " Get the data layout of the module this function belongs to.\n\n Requires the function to have a parent module."]
    #[link_name = "\u{1}_ZNK4llvm8Function13getDataLayoutEv"]
    pub fn llvm_Function_getDataLayout(this: *const llvm_Function) -> *const llvm_DataLayout;
}
extern "C" {
    #[doc = " isTargetIntrinsic - Returns true if IID is an intrinsic specific to a\n certain target. If it is a generic intrinsic false is returned."]
    #[link_name = "\u{1}_ZN4llvm8Function17isTargetIntrinsicEj"]
    pub fn llvm_Function_isTargetIntrinsic(IID: llvm_Intrinsic_ID) -> bool;
}
extern "C" {
    #[doc = " isTargetIntrinsic - Returns true if this function is an intrinsic and the\n intrinsic is specific to a certain target. If this is not an intrinsic\n or a generic intrinsic, false is returned."]
    #[link_name = "\u{1}_ZNK4llvm8Function17isTargetIntrinsicEv"]
    pub fn llvm_Function_isTargetIntrinsic1(this: *const llvm_Function) -> bool;
}
extern "C" {
    #[doc = " Returns true if the function is one of the \"Constrained Floating-Point\n Intrinsics\". Returns false if not, and returns false when\n getIntrinsicID() returns Intrinsic::not_intrinsic."]
    #[link_name = "\u{1}_ZNK4llvm8Function24isConstrainedFPIntrinsicEv"]
    pub fn llvm_Function_isConstrainedFPIntrinsic(this: *const llvm_Function) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm8Function17lookupIntrinsicIDENS_9StringRefE"]
    pub fn llvm_Function_lookupIntrinsicID(Name: llvm_StringRef) -> llvm_Intrinsic_ID;
}
extern "C" {
    #[doc = " Update internal caches that depend on the function name (such as the\n intrinsic ID and libcall cache).\n Note, this method does not need to be called directly, as it is called\n from Value::setName() whenever the name of this function changes."]
    #[link_name = "\u{1}_ZN4llvm8Function21updateAfterNameChangeEv"]
    pub fn llvm_Function_updateAfterNameChange(this: *mut llvm_Function);
}
extern "C" {
    #[doc = " Set the entry count for this function.\n\n Entry count is the number of times this function was executed based on\n pgo data. \\p Imports points to a set of GUIDs that needs to\n be imported by the function for sample PGO, to enable the same inlines as\n the profiled optimized binary."]
    #[link_name = "\u{1}_ZN4llvm8Function13setEntryCountENS0_12ProfileCountEPKNS_8DenseSetImNS_12DenseMapInfoImvEEEE"]
    pub fn llvm_Function_setEntryCount(
        this: *mut llvm_Function,
        Count: llvm_Function_ProfileCount,
        Imports: *const llvm_DenseSet,
    );
}
extern "C" {
    #[doc = " A convenience wrapper for setting entry count"]
    #[link_name = "\u{1}_ZN4llvm8Function13setEntryCountEmNS0_16ProfileCountTypeEPKNS_8DenseSetImNS_12DenseMapInfoImvEEEE"]
    pub fn llvm_Function_setEntryCount1(
        this: *mut llvm_Function,
        Count: u64,
        Type: llvm_Function_ProfileCountType,
        Imports: *const llvm_DenseSet,
    );
}
extern "C" {
    #[doc = " Get the entry count for this function.\n\n Entry count is the number of times the function was executed.\n When AllowSynthetic is false, only pgo_data will be returned."]
    #[link_name = "\u{1}_ZNK4llvm8Function13getEntryCountEb"]
    pub fn llvm_Function_getEntryCount(
        this: *const llvm_Function,
        AllowSynthetic: bool,
    ) -> std_optional;
}
extern "C" {
    #[doc = " Returns the set of GUIDs that needs to be imported to the function for\n sample PGO, to enable the same inlines as the profiled optimized binary."]
    #[link_name = "\u{1}_ZNK4llvm8Function14getImportGUIDsEv"]
    pub fn llvm_Function_getImportGUIDs(this: *const llvm_Function) -> llvm_DenseSet;
}
extern "C" {
    #[doc = " Set the section prefix for this function."]
    #[link_name = "\u{1}_ZN4llvm8Function16setSectionPrefixENS_9StringRefE"]
    pub fn llvm_Function_setSectionPrefix(this: *mut llvm_Function, Prefix: llvm_StringRef);
}
extern "C" {
    #[doc = " Get the section prefix for this function."]
    #[link_name = "\u{1}_ZNK4llvm8Function16getSectionPrefixEv"]
    pub fn llvm_Function_getSectionPrefix(this: *const llvm_Function) -> std_optional;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4llvm8Function5getGCB5cxx11Ev"]
    pub fn llvm_Function_getGC(this: *const llvm_Function) -> *const std_string;
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm8Function5setGCENSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE"]
    pub fn llvm_Function_setGC(this: *mut llvm_Function, Str: std_string);
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm8Function7clearGCEv"]
    pub fn llvm_Function_clearGC(this: *mut llvm_Function);
}
extern "C" {
    #[doc = " adds the attribute to the list of attributes."]
    #[link_name = "\u{1}_ZN4llvm8Function19addAttributeAtIndexEjNS_9AttributeE"]
    pub fn llvm_Function_addAttributeAtIndex(
        this: *mut llvm_Function,
        i: ::std::os::raw::c_uint,
        Attr: llvm_Attribute,
    );
}
extern "C" {
    #[doc = " Add function attributes to this function."]
    #[link_name = "\u{1}_ZN4llvm8Function9addFnAttrENS_9Attribute8AttrKindE"]
    pub fn llvm_Function_addFnAttr(this: *mut llvm_Function, Kind: llvm_Attribute_AttrKind);
}
extern "C" {
    #[doc = " Add function attributes to this function."]
    #[link_name = "\u{1}_ZN4llvm8Function9addFnAttrENS_9StringRefES1_"]
    pub fn llvm_Function_addFnAttr1(
        this: *mut llvm_Function,
        Kind: llvm_StringRef,
        Val: llvm_StringRef,
    );
}
extern "C" {
    #[doc = " Add function attributes to this function."]
    #[link_name = "\u{1}_ZN4llvm8Function9addFnAttrENS_9AttributeE"]
    pub fn llvm_Function_addFnAttr2(this: *mut llvm_Function, Attr: llvm_Attribute);
}
extern "C" {
    #[doc = " Add function attributes to this function."]
    #[link_name = "\u{1}_ZN4llvm8Function10addFnAttrsERKNS_11AttrBuilderE"]
    pub fn llvm_Function_addFnAttrs(this: *mut llvm_Function, Attrs: *const llvm_AttrBuilder);
}
extern "C" {
    #[doc = " Add return value attributes to this function."]
    #[link_name = "\u{1}_ZN4llvm8Function10addRetAttrENS_9Attribute8AttrKindE"]
    pub fn llvm_Function_addRetAttr(this: *mut llvm_Function, Kind: llvm_Attribute_AttrKind);
}
extern "C" {
    #[doc = " Add return value attributes to this function."]
    #[link_name = "\u{1}_ZN4llvm8Function10addRetAttrENS_9AttributeE"]
    pub fn llvm_Function_addRetAttr1(this: *mut llvm_Function, Attr: llvm_Attribute);
}
extern "C" {
    #[doc = " Add return value attributes to this function."]
    #[link_name = "\u{1}_ZN4llvm8Function11addRetAttrsERKNS_11AttrBuilderE"]
    pub fn llvm_Function_addRetAttrs(this: *mut llvm_Function, Attrs: *const llvm_AttrBuilder);
}
extern "C" {
    #[doc = " adds the attribute to the list of attributes for the given arg."]
    #[link_name = "\u{1}_ZN4llvm8Function12addParamAttrEjNS_9Attribute8AttrKindE"]
    pub fn llvm_Function_addParamAttr(
        this: *mut llvm_Function,
        ArgNo: ::std::os::raw::c_uint,
        Kind: llvm_Attribute_AttrKind,
    );
}
extern "C" {
    #[doc = " adds the attribute to the list of attributes for the given arg."]
    #[link_name = "\u{1}_ZN4llvm8Function12addParamAttrEjNS_9AttributeE"]
    pub fn llvm_Function_addParamAttr1(
        this: *mut llvm_Function,
        ArgNo: ::std::os::raw::c_uint,
        Attr: llvm_Attribute,
    );
}
extern "C" {
    #[doc = " adds the attributes to the list of attributes for the given arg."]
    #[link_name = "\u{1}_ZN4llvm8Function13addParamAttrsEjRKNS_11AttrBuilderE"]
    pub fn llvm_Function_addParamAttrs(
        this: *mut llvm_Function,
        ArgNo: ::std::os::raw::c_uint,
        Attrs: *const llvm_AttrBuilder,
    );
}
extern "C" {
    #[doc = " removes the attribute from the list of attributes."]
    #[link_name = "\u{1}_ZN4llvm8Function22removeAttributeAtIndexEjNS_9Attribute8AttrKindE"]
    pub fn llvm_Function_removeAttributeAtIndex(
        this: *mut llvm_Function,
        i: ::std::os::raw::c_uint,
        Kind: llvm_Attribute_AttrKind,
    );
}
extern "C" {
    #[doc = " removes the attribute from the list of attributes."]
    #[link_name = "\u{1}_ZN4llvm8Function22removeAttributeAtIndexEjNS_9StringRefE"]
    pub fn llvm_Function_removeAttributeAtIndex1(
        this: *mut llvm_Function,
        i: ::std::os::raw::c_uint,
        Kind: llvm_StringRef,
    );
}
extern "C" {
    #[doc = " Remove function attributes from this function."]
    #[link_name = "\u{1}_ZN4llvm8Function12removeFnAttrENS_9Attribute8AttrKindE"]
    pub fn llvm_Function_removeFnAttr(this: *mut llvm_Function, Kind: llvm_Attribute_AttrKind);
}
extern "C" {
    #[doc = " Remove function attribute from this function."]
    #[link_name = "\u{1}_ZN4llvm8Function12removeFnAttrENS_9StringRefE"]
    pub fn llvm_Function_removeFnAttr1(this: *mut llvm_Function, Kind: llvm_StringRef);
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm8Function13removeFnAttrsERKNS_13AttributeMaskE"]
    pub fn llvm_Function_removeFnAttrs(this: *mut llvm_Function, Attrs: *const llvm_AttributeMask);
}
extern "C" {
    #[doc = " removes the attribute from the return value list of attributes."]
    #[link_name = "\u{1}_ZN4llvm8Function13removeRetAttrENS_9Attribute8AttrKindE"]
    pub fn llvm_Function_removeRetAttr(this: *mut llvm_Function, Kind: llvm_Attribute_AttrKind);
}
extern "C" {
    #[doc = " removes the attribute from the return value list of attributes."]
    #[link_name = "\u{1}_ZN4llvm8Function13removeRetAttrENS_9StringRefE"]
    pub fn llvm_Function_removeRetAttr1(this: *mut llvm_Function, Kind: llvm_StringRef);
}
extern "C" {
    #[doc = " removes the attributes from the return value list of attributes."]
    #[link_name = "\u{1}_ZN4llvm8Function14removeRetAttrsERKNS_13AttributeMaskE"]
    pub fn llvm_Function_removeRetAttrs(this: *mut llvm_Function, Attrs: *const llvm_AttributeMask);
}
extern "C" {
    #[doc = " removes the attribute from the list of attributes."]
    #[link_name = "\u{1}_ZN4llvm8Function15removeParamAttrEjNS_9Attribute8AttrKindE"]
    pub fn llvm_Function_removeParamAttr(
        this: *mut llvm_Function,
        ArgNo: ::std::os::raw::c_uint,
        Kind: llvm_Attribute_AttrKind,
    );
}
extern "C" {
    #[doc = " removes the attribute from the list of attributes."]
    #[link_name = "\u{1}_ZN4llvm8Function15removeParamAttrEjNS_9StringRefE"]
    pub fn llvm_Function_removeParamAttr1(
        this: *mut llvm_Function,
        ArgNo: ::std::os::raw::c_uint,
        Kind: llvm_StringRef,
    );
}
extern "C" {
    #[doc = " removes the attribute from the list of attributes."]
    #[link_name = "\u{1}_ZN4llvm8Function16removeParamAttrsEjRKNS_13AttributeMaskE"]
    pub fn llvm_Function_removeParamAttrs(
        this: *mut llvm_Function,
        ArgNo: ::std::os::raw::c_uint,
        Attrs: *const llvm_AttributeMask,
    );
}
extern "C" {
    #[doc = " Return true if the function has the attribute."]
    #[link_name = "\u{1}_ZNK4llvm8Function14hasFnAttributeENS_9Attribute8AttrKindE"]
    pub fn llvm_Function_hasFnAttribute(
        this: *const llvm_Function,
        Kind: llvm_Attribute_AttrKind,
    ) -> bool;
}
extern "C" {
    #[doc = " Return true if the function has the attribute."]
    #[link_name = "\u{1}_ZNK4llvm8Function14hasFnAttributeENS_9StringRefE"]
    pub fn llvm_Function_hasFnAttribute1(this: *const llvm_Function, Kind: llvm_StringRef) -> bool;
}
extern "C" {
    #[doc = " check if an attribute is in the list of attributes for the return value."]
    #[link_name = "\u{1}_ZNK4llvm8Function15hasRetAttributeENS_9Attribute8AttrKindE"]
    pub fn llvm_Function_hasRetAttribute(
        this: *const llvm_Function,
        Kind: llvm_Attribute_AttrKind,
    ) -> bool;
}
extern "C" {
    #[doc = " check if an attributes is in the list of attributes."]
    #[link_name = "\u{1}_ZNK4llvm8Function17hasParamAttributeEjNS_9Attribute8AttrKindE"]
    pub fn llvm_Function_hasParamAttribute(
        this: *const llvm_Function,
        ArgNo: ::std::os::raw::c_uint,
        Kind: llvm_Attribute_AttrKind,
    ) -> bool;
}
extern "C" {
    #[doc = " gets the attribute from the list of attributes."]
    #[link_name = "\u{1}_ZNK4llvm8Function19getAttributeAtIndexEjNS_9Attribute8AttrKindE"]
    pub fn llvm_Function_getAttributeAtIndex(
        this: *const llvm_Function,
        i: ::std::os::raw::c_uint,
        Kind: llvm_Attribute_AttrKind,
    ) -> llvm_Attribute;
}
extern "C" {
    #[doc = " gets the attribute from the list of attributes."]
    #[link_name = "\u{1}_ZNK4llvm8Function19getAttributeAtIndexEjNS_9StringRefE"]
    pub fn llvm_Function_getAttributeAtIndex1(
        this: *const llvm_Function,
        i: ::std::os::raw::c_uint,
        Kind: llvm_StringRef,
    ) -> llvm_Attribute;
}
extern "C" {
    #[doc = " Return the attribute for the given attribute kind."]
    #[link_name = "\u{1}_ZNK4llvm8Function14getFnAttributeENS_9Attribute8AttrKindE"]
    pub fn llvm_Function_getFnAttribute(
        this: *const llvm_Function,
        Kind: llvm_Attribute_AttrKind,
    ) -> llvm_Attribute;
}
extern "C" {
    #[doc = " Return the attribute for the given attribute kind."]
    #[link_name = "\u{1}_ZNK4llvm8Function14getFnAttributeENS_9StringRefE"]
    pub fn llvm_Function_getFnAttribute1(
        this: *const llvm_Function,
        Kind: llvm_StringRef,
    ) -> llvm_Attribute;
}
extern "C" {
    #[doc = " Return the attribute for the given attribute kind for the return value."]
    #[link_name = "\u{1}_ZNK4llvm8Function15getRetAttributeENS_9Attribute8AttrKindE"]
    pub fn llvm_Function_getRetAttribute(
        this: *const llvm_Function,
        Kind: llvm_Attribute_AttrKind,
    ) -> llvm_Attribute;
}
extern "C" {
    #[doc = " For a string attribute \\p Kind, parse attribute as an integer.\n\n \\returns \\p Default if attribute is not present.\n\n \\returns \\p Default if there is an error parsing the attribute integer,\n and error is emitted to the LLVMContext"]
    #[link_name = "\u{1}_ZNK4llvm8Function29getFnAttributeAsParsedIntegerENS_9StringRefEm"]
    pub fn llvm_Function_getFnAttributeAsParsedInteger(
        this: *const llvm_Function,
        Kind: llvm_StringRef,
        Default: u64,
    ) -> u64;
}
extern "C" {
    #[doc = " gets the specified attribute from the list of attributes."]
    #[link_name = "\u{1}_ZNK4llvm8Function17getParamAttributeEjNS_9Attribute8AttrKindE"]
    pub fn llvm_Function_getParamAttribute(
        this: *const llvm_Function,
        ArgNo: ::std::os::raw::c_uint,
        Kind: llvm_Attribute_AttrKind,
    ) -> llvm_Attribute;
}
extern "C" {
    #[doc = " Returns true if the function has ssp, sspstrong, or sspreq fn attrs."]
    #[link_name = "\u{1}_ZNK4llvm8Function23hasStackProtectorFnAttrEv"]
    pub fn llvm_Function_hasStackProtectorFnAttr(this: *const llvm_Function) -> bool;
}
extern "C" {
    #[doc = " adds the dereferenceable attribute to the list of attributes for\n the given arg."]
    #[link_name = "\u{1}_ZN4llvm8Function27addDereferenceableParamAttrEjm"]
    pub fn llvm_Function_addDereferenceableParamAttr(
        this: *mut llvm_Function,
        ArgNo: ::std::os::raw::c_uint,
        Bytes: u64,
    );
}
extern "C" {
    #[doc = " adds the dereferenceable_or_null attribute to the list of\n attributes for the given arg."]
    #[link_name = "\u{1}_ZN4llvm8Function33addDereferenceableOrNullParamAttrEjm"]
    pub fn llvm_Function_addDereferenceableOrNullParamAttr(
        this: *mut llvm_Function,
        ArgNo: ::std::os::raw::c_uint,
        Bytes: u64,
    );
}
extern "C" {
    #[doc = " adds the range attribute to the list of attributes for the return value."]
    #[link_name = "\u{1}_ZN4llvm8Function15addRangeRetAttrERKNS_13ConstantRangeE"]
    pub fn llvm_Function_addRangeRetAttr(this: *mut llvm_Function, CR: *const llvm_ConstantRange);
}
extern "C" {
    #[link_name = "\u{1}_ZNK4llvm8Function16getMemoryEffectsEv"]
    pub fn llvm_Function_getMemoryEffects(this: *const llvm_Function) -> llvm_MemoryEffects;
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm8Function16setMemoryEffectsENS_17MemoryEffectsBaseINS_13IRMemLocationEEE"]
    pub fn llvm_Function_setMemoryEffects(this: *mut llvm_Function, ME: llvm_MemoryEffects);
}
extern "C" {
    #[doc = " Determine if the function does not access memory."]
    #[link_name = "\u{1}_ZNK4llvm8Function19doesNotAccessMemoryEv"]
    pub fn llvm_Function_doesNotAccessMemory(this: *const llvm_Function) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm8Function22setDoesNotAccessMemoryEv"]
    pub fn llvm_Function_setDoesNotAccessMemory(this: *mut llvm_Function);
}
extern "C" {
    #[doc = " Determine if the function does not access or only reads memory."]
    #[link_name = "\u{1}_ZNK4llvm8Function15onlyReadsMemoryEv"]
    pub fn llvm_Function_onlyReadsMemory(this: *const llvm_Function) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm8Function18setOnlyReadsMemoryEv"]
    pub fn llvm_Function_setOnlyReadsMemory(this: *mut llvm_Function);
}
extern "C" {
    #[doc = " Determine if the function does not access or only writes memory."]
    #[link_name = "\u{1}_ZNK4llvm8Function16onlyWritesMemoryEv"]
    pub fn llvm_Function_onlyWritesMemory(this: *const llvm_Function) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm8Function19setOnlyWritesMemoryEv"]
    pub fn llvm_Function_setOnlyWritesMemory(this: *mut llvm_Function);
}
extern "C" {
    #[doc = " Determine if the call can access memmory only using pointers based\n on its arguments."]
    #[link_name = "\u{1}_ZNK4llvm8Function21onlyAccessesArgMemoryEv"]
    pub fn llvm_Function_onlyAccessesArgMemory(this: *const llvm_Function) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm8Function24setOnlyAccessesArgMemoryEv"]
    pub fn llvm_Function_setOnlyAccessesArgMemory(this: *mut llvm_Function);
}
extern "C" {
    #[doc = " Determine if the function may only access memory that is\n  inaccessible from the IR."]
    #[link_name = "\u{1}_ZNK4llvm8Function30onlyAccessesInaccessibleMemoryEv"]
    pub fn llvm_Function_onlyAccessesInaccessibleMemory(this: *const llvm_Function) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm8Function33setOnlyAccessesInaccessibleMemoryEv"]
    pub fn llvm_Function_setOnlyAccessesInaccessibleMemory(this: *mut llvm_Function);
}
extern "C" {
    #[doc = " Determine if the function may only access memory that is\n  either inaccessible from the IR or pointed to by its arguments."]
    #[link_name = "\u{1}_ZNK4llvm8Function35onlyAccessesInaccessibleMemOrArgMemEv"]
    pub fn llvm_Function_onlyAccessesInaccessibleMemOrArgMem(this: *const llvm_Function) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm8Function38setOnlyAccessesInaccessibleMemOrArgMemEv"]
    pub fn llvm_Function_setOnlyAccessesInaccessibleMemOrArgMem(this: *mut llvm_Function);
}
extern "C" {
    #[doc = " Returns the denormal handling type for the default rounding mode of the\n function."]
    #[link_name = "\u{1}_ZNK4llvm8Function15getDenormalModeERKNS_12fltSemanticsE"]
    pub fn llvm_Function_getDenormalMode(
        this: *const llvm_Function,
        FPType: *const llvm_fltSemantics,
    ) -> llvm_DenormalMode;
}
extern "C" {
    #[doc = " Return the representational value of \"denormal-fp-math\". Code interested\n in the semantics of the function should use getDenormalMode instead."]
    #[link_name = "\u{1}_ZNK4llvm8Function18getDenormalModeRawEv"]
    pub fn llvm_Function_getDenormalModeRaw(this: *const llvm_Function) -> llvm_DenormalMode;
}
extern "C" {
    #[doc = " Return the representational value of \"denormal-fp-math-f32\". Code\n interested in the semantics of the function should use getDenormalMode\n instead."]
    #[link_name = "\u{1}_ZNK4llvm8Function21getDenormalModeF32RawEv"]
    pub fn llvm_Function_getDenormalModeF32Raw(this: *const llvm_Function) -> llvm_DenormalMode;
}
extern "C" {
    #[doc = " copyAttributesFrom - copy all additional attributes (those not needed to\n create a Function) from the Function Src to this one."]
    #[link_name = "\u{1}_ZN4llvm8Function18copyAttributesFromEPKS0_"]
    pub fn llvm_Function_copyAttributesFrom(this: *mut llvm_Function, Src: *const llvm_Function);
}
extern "C" {
    #[doc = " removeFromParent - This method unlinks 'this' from the containing module,\n but does not delete it.\n"]
    #[link_name = "\u{1}_ZN4llvm8Function16removeFromParentEv"]
    pub fn llvm_Function_removeFromParent(this: *mut llvm_Function);
}
extern "C" {
    #[doc = " eraseFromParent - This method unlinks 'this' from the containing module\n and deletes it.\n"]
    #[link_name = "\u{1}_ZN4llvm8Function15eraseFromParentEv"]
    pub fn llvm_Function_eraseFromParent(this: *mut llvm_Function);
}
extern "C" {
    #[doc = " Steal arguments from another function.\n\n Drop this function's arguments and splice in the ones from \\c Src.\n Requires that this has no function body."]
    #[link_name = "\u{1}_ZN4llvm8Function21stealArgumentListFromERS0_"]
    pub fn llvm_Function_stealArgumentListFrom(this: *mut llvm_Function, Src: *mut llvm_Function);
}
extern "C" {
    #[doc = " Transfer a range of basic blocks that belong to \\p FromF from \\p\n FromBeginIt to \\p FromEndIt, to this function at \\p ToIt."]
    #[link_name = "\u{1}_ZN4llvm8Function6spliceENS_14ilist_iteratorINS_12ilist_detail12node_optionsINS_10BasicBlockELb1ELb0EvLb0EvEELb0ELb0EEEPS0_S6_S6_"]
    pub fn llvm_Function_splice(
        this: *mut llvm_Function,
        ToIt: llvm_Function_iterator,
        FromF: *mut llvm_Function,
        FromBeginIt: llvm_Function_iterator,
        FromEndIt: llvm_Function_iterator,
    );
}
extern "C" {
    #[doc = " Erases a range of BasicBlocks from \\p FromIt to (not including) \\p ToIt.\n \\Returns \\p ToIt."]
    #[link_name = "\u{1}_ZN4llvm8Function5eraseENS_14ilist_iteratorINS_12ilist_detail12node_optionsINS_10BasicBlockELb1ELb0EvLb0EvEELb0ELb0EEES6_"]
    pub fn llvm_Function_erase(
        this: *mut llvm_Function,
        FromIt: llvm_Function_iterator,
        ToIt: llvm_Function_iterator,
    ) -> llvm_Function_iterator;
}
extern "C" {
    #[doc = " Renumber basic blocks into a dense value range starting from 0. Be aware\n that other data structures and analyses (e.g., DominatorTree) may depend\n on the value numbers and need to be updated or invalidated."]
    #[link_name = "\u{1}_ZN4llvm8Function14renumberBlocksEv"]
    pub fn llvm_Function_renumberBlocks(this: *mut llvm_Function);
}
extern "C" {
    #[doc = " Get the personality function associated with this function."]
    #[link_name = "\u{1}_ZNK4llvm8Function16getPersonalityFnEv"]
    pub fn llvm_Function_getPersonalityFn(this: *const llvm_Function) -> *mut llvm_Constant;
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm8Function16setPersonalityFnEPNS_8ConstantE"]
    pub fn llvm_Function_setPersonalityFn(this: *mut llvm_Function, Fn: *mut llvm_Constant);
}
extern "C" {
    #[doc = " Get the prefix data associated with this function."]
    #[link_name = "\u{1}_ZNK4llvm8Function13getPrefixDataEv"]
    pub fn llvm_Function_getPrefixData(this: *const llvm_Function) -> *mut llvm_Constant;
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm8Function13setPrefixDataEPNS_8ConstantE"]
    pub fn llvm_Function_setPrefixData(this: *mut llvm_Function, PrefixData: *mut llvm_Constant);
}
extern "C" {
    #[doc = " Get the prologue data associated with this function."]
    #[link_name = "\u{1}_ZNK4llvm8Function15getPrologueDataEv"]
    pub fn llvm_Function_getPrologueData(this: *const llvm_Function) -> *mut llvm_Constant;
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm8Function15setPrologueDataEPNS_8ConstantE"]
    pub fn llvm_Function_setPrologueData(
        this: *mut llvm_Function,
        PrologueData: *mut llvm_Constant,
    );
}
extern "C" {
    #[doc = " Print the function to an output stream with an optional\n AssemblyAnnotationWriter."]
    #[link_name = "\u{1}_ZNK4llvm8Function5printERNS_11raw_ostreamEPNS_24AssemblyAnnotationWriterEbb"]
    pub fn llvm_Function_print(
        this: *const llvm_Function,
        OS: *mut llvm_raw_ostream,
        AAW: *mut llvm_AssemblyAnnotationWriter,
        ShouldPreserveUseListOrder: bool,
        IsForDebug: bool,
    );
}
extern "C" {
    #[doc = " viewCFG - This function is meant for use from the debugger.  You can just\n say 'call F->viewCFG()' and a ghostview window should pop up from the\n program, displaying the CFG of the current function with the code for each\n basic block inside.  This depends on there being a 'dot' and 'gv' program\n in your path.\n"]
    #[link_name = "\u{1}_ZNK4llvm8Function7viewCFGEv"]
    pub fn llvm_Function_viewCFG(this: *const llvm_Function);
}
extern "C" {
    #[doc = " Extended form to print edge weights."]
    #[link_name = "\u{1}_ZNK4llvm8Function7viewCFGEbPKNS_18BlockFrequencyInfoEPKNS_21BranchProbabilityInfoE"]
    pub fn llvm_Function_viewCFG1(
        this: *const llvm_Function,
        ViewCFGOnly: bool,
        BFI: *const llvm_BlockFrequencyInfo,
        BPI: *const llvm_BranchProbabilityInfo,
    );
}
extern "C" {
    #[doc = " viewCFGOnly - This function is meant for use from the debugger.  It works\n just like viewCFG, but it does not include the contents of basic blocks\n into the nodes, just the label.  If you are only interested in the CFG\n this can make the graph smaller.\n"]
    #[link_name = "\u{1}_ZNK4llvm8Function11viewCFGOnlyEv"]
    pub fn llvm_Function_viewCFGOnly(this: *const llvm_Function);
}
extern "C" {
    #[doc = " Extended form to print edge weights."]
    #[link_name = "\u{1}_ZNK4llvm8Function11viewCFGOnlyEPKNS_18BlockFrequencyInfoEPKNS_21BranchProbabilityInfoE"]
    pub fn llvm_Function_viewCFGOnly1(
        this: *const llvm_Function,
        BFI: *const llvm_BlockFrequencyInfo,
        BPI: *const llvm_BranchProbabilityInfo,
    );
}
extern "C" {
    #[doc = " hasAddressTaken - returns true if there are any uses of this function\n other than direct calls or invokes to it, or blockaddress expressions.\n Optionally passes back an offending user for diagnostic purposes,\n ignores callback uses, assume like pointer annotation calls, references in\n llvm.used and llvm.compiler.used variables, operand bundle\n \"clang.arc.attachedcall\", and direct calls with a different call site\n signature (the function is implicitly casted)."]
    #[link_name = "\u{1}_ZNK4llvm8Function15hasAddressTakenEPPKNS_4UserEbbbbb"]
    pub fn llvm_Function_hasAddressTaken(
        this: *const llvm_Function,
        arg1: *mut *const llvm_User,
        IgnoreCallbackUses: bool,
        IgnoreAssumeLikeCalls: bool,
        IngoreLLVMUsed: bool,
        IgnoreARCAttachedCall: bool,
        IgnoreCastedDirectCall: bool,
    ) -> bool;
}
extern "C" {
    #[doc = " isDefTriviallyDead - Return true if it is trivially safe to remove\n this function definition from the module (because it isn't externally\n visible, does not have its address taken, and has no callers).  To make\n this more accurate, call removeDeadConstantUsers first."]
    #[link_name = "\u{1}_ZNK4llvm8Function18isDefTriviallyDeadEv"]
    pub fn llvm_Function_isDefTriviallyDead(this: *const llvm_Function) -> bool;
}
extern "C" {
    #[doc = " callsFunctionThatReturnsTwice - Return true if the function has a call to\n setjmp or other function that gcc recognizes as \"returning twice\"."]
    #[link_name = "\u{1}_ZNK4llvm8Function29callsFunctionThatReturnsTwiceEv"]
    pub fn llvm_Function_callsFunctionThatReturnsTwice(this: *const llvm_Function) -> bool;
}
extern "C" {
    #[doc = " Set the attached subprogram.\n\n Calls \\a setMetadata() with \\a LLVMContext::MD_dbg."]
    #[link_name = "\u{1}_ZN4llvm8Function13setSubprogramEPNS_12DISubprogramE"]
    pub fn llvm_Function_setSubprogram(this: *mut llvm_Function, SP: *mut llvm_DISubprogram);
}
extern "C" {
    #[doc = " Get the attached subprogram.\n\n Calls \\a getMetadata() with \\a LLVMContext::MD_dbg and casts the result\n to \\a DISubprogram."]
    #[link_name = "\u{1}_ZNK4llvm8Function13getSubprogramEv"]
    pub fn llvm_Function_getSubprogram(this: *const llvm_Function) -> *mut llvm_DISubprogram;
}
extern "C" {
    #[doc = " Returns true if we should emit debug info for profiling."]
    #[link_name = "\u{1}_ZNK4llvm8Function31shouldEmitDebugInfoForProfilingEv"]
    pub fn llvm_Function_shouldEmitDebugInfoForProfiling(this: *const llvm_Function) -> bool;
}
extern "C" {
    #[doc = " Check if null pointer dereferencing is considered undefined behavior for\n the function.\n Return value: false => null pointer dereference is undefined.\n Return value: true =>  null pointer dereference is not undefined."]
    #[link_name = "\u{1}_ZNK4llvm8Function20nullPointerIsDefinedEv"]
    pub fn llvm_Function_nullPointerIsDefined(this: *const llvm_Function) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm8FunctionD1Ev"]
    pub fn llvm_Function_Function_destructor(this: *mut llvm_Function);
}
impl llvm_Function {
    #[inline]
    pub unsafe fn convertToNewDbgValues(&mut self) {
        llvm_Function_convertToNewDbgValues(self)
    }
    #[inline]
    pub unsafe fn convertFromNewDbgValues(&mut self) {
        llvm_Function_convertFromNewDbgValues(self)
    }
    #[inline]
    pub unsafe fn setIsNewDbgInfoFormat(&mut self, NewVal: bool) {
        llvm_Function_setIsNewDbgInfoFormat(self, NewVal)
    }
    #[inline]
    pub unsafe fn setNewDbgInfoFormatFlag(&mut self, NewVal: bool) {
        llvm_Function_setNewDbgInfoFormatFlag(self, NewVal)
    }
    #[inline]
    pub unsafe fn Create(
        Ty: *mut llvm_FunctionType,
        Linkage: llvm_GlobalValue_LinkageTypes,
        N: *const llvm_Twine,
        M: *mut llvm_Module,
    ) -> *mut llvm_Function {
        llvm_Function_Create(Ty, Linkage, N, M)
    }
    #[inline]
    pub unsafe fn createWithDefaultAttr(
        Ty: *mut llvm_FunctionType,
        Linkage: llvm_GlobalValue_LinkageTypes,
        AddrSpace: ::std::os::raw::c_uint,
        N: *const llvm_Twine,
        M: *mut llvm_Module,
    ) -> *mut llvm_Function {
        llvm_Function_createWithDefaultAttr(Ty, Linkage, AddrSpace, N, M)
    }
    #[inline]
    pub unsafe fn getInstructionCount(&self) -> ::std::os::raw::c_uint {
        llvm_Function_getInstructionCount(self)
    }
    #[inline]
    pub unsafe fn getContext(&self) -> *mut llvm_LLVMContext {
        llvm_Function_getContext(self)
    }
    #[inline]
    pub unsafe fn getDataLayout(&self) -> *const llvm_DataLayout {
        llvm_Function_getDataLayout(self)
    }
    #[inline]
    pub unsafe fn isTargetIntrinsic(IID: llvm_Intrinsic_ID) -> bool {
        llvm_Function_isTargetIntrinsic(IID)
    }
    #[inline]
    pub unsafe fn isTargetIntrinsic1(&self) -> bool {
        llvm_Function_isTargetIntrinsic1(self)
    }
    #[inline]
    pub unsafe fn isConstrainedFPIntrinsic(&self) -> bool {
        llvm_Function_isConstrainedFPIntrinsic(self)
    }
    #[inline]
    pub unsafe fn lookupIntrinsicID(Name: llvm_StringRef) -> llvm_Intrinsic_ID {
        llvm_Function_lookupIntrinsicID(Name)
    }
    #[inline]
    pub unsafe fn updateAfterNameChange(&mut self) {
        llvm_Function_updateAfterNameChange(self)
    }
    #[inline]
    pub unsafe fn setEntryCount(
        &mut self,
        Count: llvm_Function_ProfileCount,
        Imports: *const llvm_DenseSet,
    ) {
        llvm_Function_setEntryCount(self, Count, Imports)
    }
    #[inline]
    pub unsafe fn setEntryCount1(
        &mut self,
        Count: u64,
        Type: llvm_Function_ProfileCountType,
        Imports: *const llvm_DenseSet,
    ) {
        llvm_Function_setEntryCount1(self, Count, Type, Imports)
    }
    #[inline]
    pub unsafe fn getEntryCount(&self, AllowSynthetic: bool) -> std_optional {
        llvm_Function_getEntryCount(self, AllowSynthetic)
    }
    #[inline]
    pub unsafe fn getImportGUIDs(&self) -> llvm_DenseSet {
        llvm_Function_getImportGUIDs(self)
    }
    #[inline]
    pub unsafe fn setSectionPrefix(&mut self, Prefix: llvm_StringRef) {
        llvm_Function_setSectionPrefix(self, Prefix)
    }
    #[inline]
    pub unsafe fn getSectionPrefix(&self) -> std_optional {
        llvm_Function_getSectionPrefix(self)
    }
    #[inline]
    pub unsafe fn getGC(&self) -> *const std_string {
        llvm_Function_getGC(self)
    }
    #[inline]
    pub unsafe fn setGC(&mut self, Str: std_string) {
        llvm_Function_setGC(self, Str)
    }
    #[inline]
    pub unsafe fn clearGC(&mut self) {
        llvm_Function_clearGC(self)
    }
    #[inline]
    pub unsafe fn addAttributeAtIndex(&mut self, i: ::std::os::raw::c_uint, Attr: llvm_Attribute) {
        llvm_Function_addAttributeAtIndex(self, i, Attr)
    }
    #[inline]
    pub unsafe fn addFnAttr(&mut self, Kind: llvm_Attribute_AttrKind) {
        llvm_Function_addFnAttr(self, Kind)
    }
    #[inline]
    pub unsafe fn addFnAttr1(&mut self, Kind: llvm_StringRef, Val: llvm_StringRef) {
        llvm_Function_addFnAttr1(self, Kind, Val)
    }
    #[inline]
    pub unsafe fn addFnAttr2(&mut self, Attr: llvm_Attribute) {
        llvm_Function_addFnAttr2(self, Attr)
    }
    #[inline]
    pub unsafe fn addFnAttrs(&mut self, Attrs: *const llvm_AttrBuilder) {
        llvm_Function_addFnAttrs(self, Attrs)
    }
    #[inline]
    pub unsafe fn addRetAttr(&mut self, Kind: llvm_Attribute_AttrKind) {
        llvm_Function_addRetAttr(self, Kind)
    }
    #[inline]
    pub unsafe fn addRetAttr1(&mut self, Attr: llvm_Attribute) {
        llvm_Function_addRetAttr1(self, Attr)
    }
    #[inline]
    pub unsafe fn addRetAttrs(&mut self, Attrs: *const llvm_AttrBuilder) {
        llvm_Function_addRetAttrs(self, Attrs)
    }
    #[inline]
    pub unsafe fn addParamAttr(
        &mut self,
        ArgNo: ::std::os::raw::c_uint,
        Kind: llvm_Attribute_AttrKind,
    ) {
        llvm_Function_addParamAttr(self, ArgNo, Kind)
    }
    #[inline]
    pub unsafe fn addParamAttr1(&mut self, ArgNo: ::std::os::raw::c_uint, Attr: llvm_Attribute) {
        llvm_Function_addParamAttr1(self, ArgNo, Attr)
    }
    #[inline]
    pub unsafe fn addParamAttrs(
        &mut self,
        ArgNo: ::std::os::raw::c_uint,
        Attrs: *const llvm_AttrBuilder,
    ) {
        llvm_Function_addParamAttrs(self, ArgNo, Attrs)
    }
    #[inline]
    pub unsafe fn removeAttributeAtIndex(
        &mut self,
        i: ::std::os::raw::c_uint,
        Kind: llvm_Attribute_AttrKind,
    ) {
        llvm_Function_removeAttributeAtIndex(self, i, Kind)
    }
    #[inline]
    pub unsafe fn removeAttributeAtIndex1(
        &mut self,
        i: ::std::os::raw::c_uint,
        Kind: llvm_StringRef,
    ) {
        llvm_Function_removeAttributeAtIndex1(self, i, Kind)
    }
    #[inline]
    pub unsafe fn removeFnAttr(&mut self, Kind: llvm_Attribute_AttrKind) {
        llvm_Function_removeFnAttr(self, Kind)
    }
    #[inline]
    pub unsafe fn removeFnAttr1(&mut self, Kind: llvm_StringRef) {
        llvm_Function_removeFnAttr1(self, Kind)
    }
    #[inline]
    pub unsafe fn removeFnAttrs(&mut self, Attrs: *const llvm_AttributeMask) {
        llvm_Function_removeFnAttrs(self, Attrs)
    }
    #[inline]
    pub unsafe fn removeRetAttr(&mut self, Kind: llvm_Attribute_AttrKind) {
        llvm_Function_removeRetAttr(self, Kind)
    }
    #[inline]
    pub unsafe fn removeRetAttr1(&mut self, Kind: llvm_StringRef) {
        llvm_Function_removeRetAttr1(self, Kind)
    }
    #[inline]
    pub unsafe fn removeRetAttrs(&mut self, Attrs: *const llvm_AttributeMask) {
        llvm_Function_removeRetAttrs(self, Attrs)
    }
    #[inline]
    pub unsafe fn removeParamAttr(
        &mut self,
        ArgNo: ::std::os::raw::c_uint,
        Kind: llvm_Attribute_AttrKind,
    ) {
        llvm_Function_removeParamAttr(self, ArgNo, Kind)
    }
    #[inline]
    pub unsafe fn removeParamAttr1(&mut self, ArgNo: ::std::os::raw::c_uint, Kind: llvm_StringRef) {
        llvm_Function_removeParamAttr1(self, ArgNo, Kind)
    }
    #[inline]
    pub unsafe fn removeParamAttrs(
        &mut self,
        ArgNo: ::std::os::raw::c_uint,
        Attrs: *const llvm_AttributeMask,
    ) {
        llvm_Function_removeParamAttrs(self, ArgNo, Attrs)
    }
    #[inline]
    pub unsafe fn hasFnAttribute(&self, Kind: llvm_Attribute_AttrKind) -> bool {
        llvm_Function_hasFnAttribute(self, Kind)
    }
    #[inline]
    pub unsafe fn hasFnAttribute1(&self, Kind: llvm_StringRef) -> bool {
        llvm_Function_hasFnAttribute1(self, Kind)
    }
    #[inline]
    pub unsafe fn hasRetAttribute(&self, Kind: llvm_Attribute_AttrKind) -> bool {
        llvm_Function_hasRetAttribute(self, Kind)
    }
    #[inline]
    pub unsafe fn hasParamAttribute(
        &self,
        ArgNo: ::std::os::raw::c_uint,
        Kind: llvm_Attribute_AttrKind,
    ) -> bool {
        llvm_Function_hasParamAttribute(self, ArgNo, Kind)
    }
    #[inline]
    pub unsafe fn getAttributeAtIndex(
        &self,
        i: ::std::os::raw::c_uint,
        Kind: llvm_Attribute_AttrKind,
    ) -> llvm_Attribute {
        llvm_Function_getAttributeAtIndex(self, i, Kind)
    }
    #[inline]
    pub unsafe fn getAttributeAtIndex1(
        &self,
        i: ::std::os::raw::c_uint,
        Kind: llvm_StringRef,
    ) -> llvm_Attribute {
        llvm_Function_getAttributeAtIndex1(self, i, Kind)
    }
    #[inline]
    pub unsafe fn getFnAttribute(&self, Kind: llvm_Attribute_AttrKind) -> llvm_Attribute {
        llvm_Function_getFnAttribute(self, Kind)
    }
    #[inline]
    pub unsafe fn getFnAttribute1(&self, Kind: llvm_StringRef) -> llvm_Attribute {
        llvm_Function_getFnAttribute1(self, Kind)
    }
    #[inline]
    pub unsafe fn getRetAttribute(&self, Kind: llvm_Attribute_AttrKind) -> llvm_Attribute {
        llvm_Function_getRetAttribute(self, Kind)
    }
    #[inline]
    pub unsafe fn getFnAttributeAsParsedInteger(&self, Kind: llvm_StringRef, Default: u64) -> u64 {
        llvm_Function_getFnAttributeAsParsedInteger(self, Kind, Default)
    }
    #[inline]
    pub unsafe fn getParamAttribute(
        &self,
        ArgNo: ::std::os::raw::c_uint,
        Kind: llvm_Attribute_AttrKind,
    ) -> llvm_Attribute {
        llvm_Function_getParamAttribute(self, ArgNo, Kind)
    }
    #[inline]
    pub unsafe fn hasStackProtectorFnAttr(&self) -> bool {
        llvm_Function_hasStackProtectorFnAttr(self)
    }
    #[inline]
    pub unsafe fn addDereferenceableParamAttr(
        &mut self,
        ArgNo: ::std::os::raw::c_uint,
        Bytes: u64,
    ) {
        llvm_Function_addDereferenceableParamAttr(self, ArgNo, Bytes)
    }
    #[inline]
    pub unsafe fn addDereferenceableOrNullParamAttr(
        &mut self,
        ArgNo: ::std::os::raw::c_uint,
        Bytes: u64,
    ) {
        llvm_Function_addDereferenceableOrNullParamAttr(self, ArgNo, Bytes)
    }
    #[inline]
    pub unsafe fn addRangeRetAttr(&mut self, CR: *const llvm_ConstantRange) {
        llvm_Function_addRangeRetAttr(self, CR)
    }
    #[inline]
    pub unsafe fn getMemoryEffects(&self) -> llvm_MemoryEffects {
        llvm_Function_getMemoryEffects(self)
    }
    #[inline]
    pub unsafe fn setMemoryEffects(&mut self, ME: llvm_MemoryEffects) {
        llvm_Function_setMemoryEffects(self, ME)
    }
    #[inline]
    pub unsafe fn doesNotAccessMemory(&self) -> bool {
        llvm_Function_doesNotAccessMemory(self)
    }
    #[inline]
    pub unsafe fn setDoesNotAccessMemory(&mut self) {
        llvm_Function_setDoesNotAccessMemory(self)
    }
    #[inline]
    pub unsafe fn onlyReadsMemory(&self) -> bool {
        llvm_Function_onlyReadsMemory(self)
    }
    #[inline]
    pub unsafe fn setOnlyReadsMemory(&mut self) {
        llvm_Function_setOnlyReadsMemory(self)
    }
    #[inline]
    pub unsafe fn onlyWritesMemory(&self) -> bool {
        llvm_Function_onlyWritesMemory(self)
    }
    #[inline]
    pub unsafe fn setOnlyWritesMemory(&mut self) {
        llvm_Function_setOnlyWritesMemory(self)
    }
    #[inline]
    pub unsafe fn onlyAccessesArgMemory(&self) -> bool {
        llvm_Function_onlyAccessesArgMemory(self)
    }
    #[inline]
    pub unsafe fn setOnlyAccessesArgMemory(&mut self) {
        llvm_Function_setOnlyAccessesArgMemory(self)
    }
    #[inline]
    pub unsafe fn onlyAccessesInaccessibleMemory(&self) -> bool {
        llvm_Function_onlyAccessesInaccessibleMemory(self)
    }
    #[inline]
    pub unsafe fn setOnlyAccessesInaccessibleMemory(&mut self) {
        llvm_Function_setOnlyAccessesInaccessibleMemory(self)
    }
    #[inline]
    pub unsafe fn onlyAccessesInaccessibleMemOrArgMem(&self) -> bool {
        llvm_Function_onlyAccessesInaccessibleMemOrArgMem(self)
    }
    #[inline]
    pub unsafe fn setOnlyAccessesInaccessibleMemOrArgMem(&mut self) {
        llvm_Function_setOnlyAccessesInaccessibleMemOrArgMem(self)
    }
    #[inline]
    pub unsafe fn getDenormalMode(&self, FPType: *const llvm_fltSemantics) -> llvm_DenormalMode {
        llvm_Function_getDenormalMode(self, FPType)
    }
    #[inline]
    pub unsafe fn getDenormalModeRaw(&self) -> llvm_DenormalMode {
        llvm_Function_getDenormalModeRaw(self)
    }
    #[inline]
    pub unsafe fn getDenormalModeF32Raw(&self) -> llvm_DenormalMode {
        llvm_Function_getDenormalModeF32Raw(self)
    }
    #[inline]
    pub unsafe fn copyAttributesFrom(&mut self, Src: *const llvm_Function) {
        llvm_Function_copyAttributesFrom(self, Src)
    }
    #[inline]
    pub unsafe fn removeFromParent(&mut self) {
        llvm_Function_removeFromParent(self)
    }
    #[inline]
    pub unsafe fn eraseFromParent(&mut self) {
        llvm_Function_eraseFromParent(self)
    }
    #[inline]
    pub unsafe fn stealArgumentListFrom(&mut self, Src: *mut llvm_Function) {
        llvm_Function_stealArgumentListFrom(self, Src)
    }
    #[inline]
    pub unsafe fn splice(
        &mut self,
        ToIt: llvm_Function_iterator,
        FromF: *mut llvm_Function,
        FromBeginIt: llvm_Function_iterator,
        FromEndIt: llvm_Function_iterator,
    ) {
        llvm_Function_splice(self, ToIt, FromF, FromBeginIt, FromEndIt)
    }
    #[inline]
    pub unsafe fn erase(
        &mut self,
        FromIt: llvm_Function_iterator,
        ToIt: llvm_Function_iterator,
    ) -> llvm_Function_iterator {
        llvm_Function_erase(self, FromIt, ToIt)
    }
    #[inline]
    pub unsafe fn renumberBlocks(&mut self) {
        llvm_Function_renumberBlocks(self)
    }
    #[inline]
    pub unsafe fn getPersonalityFn(&self) -> *mut llvm_Constant {
        llvm_Function_getPersonalityFn(self)
    }
    #[inline]
    pub unsafe fn setPersonalityFn(&mut self, Fn: *mut llvm_Constant) {
        llvm_Function_setPersonalityFn(self, Fn)
    }
    #[inline]
    pub unsafe fn getPrefixData(&self) -> *mut llvm_Constant {
        llvm_Function_getPrefixData(self)
    }
    #[inline]
    pub unsafe fn setPrefixData(&mut self, PrefixData: *mut llvm_Constant) {
        llvm_Function_setPrefixData(self, PrefixData)
    }
    #[inline]
    pub unsafe fn getPrologueData(&self) -> *mut llvm_Constant {
        llvm_Function_getPrologueData(self)
    }
    #[inline]
    pub unsafe fn setPrologueData(&mut self, PrologueData: *mut llvm_Constant) {
        llvm_Function_setPrologueData(self, PrologueData)
    }
    #[inline]
    pub unsafe fn print(
        &self,
        OS: *mut llvm_raw_ostream,
        AAW: *mut llvm_AssemblyAnnotationWriter,
        ShouldPreserveUseListOrder: bool,
        IsForDebug: bool,
    ) {
        llvm_Function_print(self, OS, AAW, ShouldPreserveUseListOrder, IsForDebug)
    }
    #[inline]
    pub unsafe fn viewCFG(&self) {
        llvm_Function_viewCFG(self)
    }
    #[inline]
    pub unsafe fn viewCFG1(
        &self,
        ViewCFGOnly: bool,
        BFI: *const llvm_BlockFrequencyInfo,
        BPI: *const llvm_BranchProbabilityInfo,
    ) {
        llvm_Function_viewCFG1(self, ViewCFGOnly, BFI, BPI)
    }
    #[inline]
    pub unsafe fn viewCFGOnly(&self) {
        llvm_Function_viewCFGOnly(self)
    }
    #[inline]
    pub unsafe fn viewCFGOnly1(
        &self,
        BFI: *const llvm_BlockFrequencyInfo,
        BPI: *const llvm_BranchProbabilityInfo,
    ) {
        llvm_Function_viewCFGOnly1(self, BFI, BPI)
    }
    #[inline]
    pub unsafe fn hasAddressTaken(
        &self,
        arg1: *mut *const llvm_User,
        IgnoreCallbackUses: bool,
        IgnoreAssumeLikeCalls: bool,
        IngoreLLVMUsed: bool,
        IgnoreARCAttachedCall: bool,
        IgnoreCastedDirectCall: bool,
    ) -> bool {
        llvm_Function_hasAddressTaken(
            self,
            arg1,
            IgnoreCallbackUses,
            IgnoreAssumeLikeCalls,
            IngoreLLVMUsed,
            IgnoreARCAttachedCall,
            IgnoreCastedDirectCall,
        )
    }
    #[inline]
    pub unsafe fn isDefTriviallyDead(&self) -> bool {
        llvm_Function_isDefTriviallyDead(self)
    }
    #[inline]
    pub unsafe fn callsFunctionThatReturnsTwice(&self) -> bool {
        llvm_Function_callsFunctionThatReturnsTwice(self)
    }
    #[inline]
    pub unsafe fn setSubprogram(&mut self, SP: *mut llvm_DISubprogram) {
        llvm_Function_setSubprogram(self, SP)
    }
    #[inline]
    pub unsafe fn getSubprogram(&self) -> *mut llvm_DISubprogram {
        llvm_Function_getSubprogram(self)
    }
    #[inline]
    pub unsafe fn shouldEmitDebugInfoForProfiling(&self) -> bool {
        llvm_Function_shouldEmitDebugInfoForProfiling(self)
    }
    #[inline]
    pub unsafe fn nullPointerIsDefined(&self) -> bool {
        llvm_Function_nullPointerIsDefined(self)
    }
    #[inline]
    pub unsafe fn destruct(&mut self) {
        llvm_Function_Function_destructor(self)
    }
}
extern "C" {
    #[doc = " Check whether null pointer dereferencing is considered undefined behavior\n for a given function or an address space.\n Null pointer access in non-zero address space is not considered undefined.\n Return value: false => null pointer dereference is undefined.\n Return value: true =>  null pointer dereference is not undefined."]
    #[link_name = "\u{1}_ZN4llvm20NullPointerIsDefinedEPKNS_8FunctionEj"]
    pub fn llvm_NullPointerIsDefined(F: *const llvm_Function, AS: ::std::os::raw::c_uint) -> bool;
}
#[test]
fn __bindgen_test_layout_llvm_OperandTraits_open0_llvm_Function_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<llvm_OperandTraits>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_OperandTraits)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_OperandTraits>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_OperandTraits)
        )
    );
}
#[repr(C)]
#[derive(Debug)]
pub struct llvm_GlobalAlias {
    pub _base: llvm_GlobalValue,
    pub __bindgen_padding_0: [u64; 2usize],
}
#[test]
fn bindgen_test_layout_llvm_GlobalAlias() {
    assert_eq!(
        ::std::mem::size_of::<llvm_GlobalAlias>(),
        64usize,
        concat!("Size of: ", stringify!(llvm_GlobalAlias))
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_GlobalAlias>(),
        8usize,
        concat!("Alignment of ", stringify!(llvm_GlobalAlias))
    );
}
extern "C" {
    #[doc = " If a parent module is specified, the alias is automatically inserted into\n the end of the specified module's alias list."]
    #[link_name = "\u{1}_ZN4llvm11GlobalAlias6createEPNS_4TypeEjNS_11GlobalValue12LinkageTypesERKNS_5TwineEPNS_8ConstantEPNS_6ModuleE"]
    pub fn llvm_GlobalAlias_create(
        Ty: *mut llvm_Type,
        AddressSpace: ::std::os::raw::c_uint,
        Linkage: llvm_GlobalValue_LinkageTypes,
        Name: *const llvm_Twine,
        Aliasee: *mut llvm_Constant,
        Parent: *mut llvm_Module,
    ) -> *mut llvm_GlobalAlias;
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm11GlobalAlias6createEPNS_4TypeEjNS_11GlobalValue12LinkageTypesERKNS_5TwineEPNS_6ModuleE"]
    pub fn llvm_GlobalAlias_create1(
        Ty: *mut llvm_Type,
        AddressSpace: ::std::os::raw::c_uint,
        Linkage: llvm_GlobalValue_LinkageTypes,
        Name: *const llvm_Twine,
        Parent: *mut llvm_Module,
    ) -> *mut llvm_GlobalAlias;
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm11GlobalAlias6createEPNS_4TypeEjNS_11GlobalValue12LinkageTypesERKNS_5TwineEPS3_"]
    pub fn llvm_GlobalAlias_create2(
        Ty: *mut llvm_Type,
        AddressSpace: ::std::os::raw::c_uint,
        Linkage: llvm_GlobalValue_LinkageTypes,
        Name: *const llvm_Twine,
        Aliasee: *mut llvm_GlobalValue,
    ) -> *mut llvm_GlobalAlias;
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm11GlobalAlias6createENS_11GlobalValue12LinkageTypesERKNS_5TwineEPS1_"]
    pub fn llvm_GlobalAlias_create3(
        Linkage: llvm_GlobalValue_LinkageTypes,
        Name: *const llvm_Twine,
        Aliasee: *mut llvm_GlobalValue,
    ) -> *mut llvm_GlobalAlias;
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm11GlobalAlias6createERKNS_5TwineEPNS_11GlobalValueE"]
    pub fn llvm_GlobalAlias_create4(
        Name: *const llvm_Twine,
        Aliasee: *mut llvm_GlobalValue,
    ) -> *mut llvm_GlobalAlias;
}
extern "C" {
    #[doc = " removeFromParent - This method unlinks 'this' from the containing module,\n but does not delete it.\n"]
    #[link_name = "\u{1}_ZN4llvm11GlobalAlias16removeFromParentEv"]
    pub fn llvm_GlobalAlias_removeFromParent(this: *mut llvm_GlobalAlias);
}
extern "C" {
    #[doc = " eraseFromParent - This method unlinks 'this' from the containing module\n and deletes it.\n"]
    #[link_name = "\u{1}_ZN4llvm11GlobalAlias15eraseFromParentEv"]
    pub fn llvm_GlobalAlias_eraseFromParent(this: *mut llvm_GlobalAlias);
}
extern "C" {
    #[doc = " These methods retrieve and set alias target."]
    #[link_name = "\u{1}_ZN4llvm11GlobalAlias10setAliaseeEPNS_8ConstantE"]
    pub fn llvm_GlobalAlias_setAliasee(this: *mut llvm_GlobalAlias, Aliasee: *mut llvm_Constant);
}
extern "C" {
    #[link_name = "\u{1}_ZNK4llvm11GlobalAlias16getAliaseeObjectEv"]
    pub fn llvm_GlobalAlias_getAliaseeObject(
        this: *const llvm_GlobalAlias,
    ) -> *const llvm_GlobalObject;
}
impl llvm_GlobalAlias {
    #[inline]
    pub unsafe fn create(
        Ty: *mut llvm_Type,
        AddressSpace: ::std::os::raw::c_uint,
        Linkage: llvm_GlobalValue_LinkageTypes,
        Name: *const llvm_Twine,
        Aliasee: *mut llvm_Constant,
        Parent: *mut llvm_Module,
    ) -> *mut llvm_GlobalAlias {
        llvm_GlobalAlias_create(Ty, AddressSpace, Linkage, Name, Aliasee, Parent)
    }
    #[inline]
    pub unsafe fn create1(
        Ty: *mut llvm_Type,
        AddressSpace: ::std::os::raw::c_uint,
        Linkage: llvm_GlobalValue_LinkageTypes,
        Name: *const llvm_Twine,
        Parent: *mut llvm_Module,
    ) -> *mut llvm_GlobalAlias {
        llvm_GlobalAlias_create1(Ty, AddressSpace, Linkage, Name, Parent)
    }
    #[inline]
    pub unsafe fn create2(
        Ty: *mut llvm_Type,
        AddressSpace: ::std::os::raw::c_uint,
        Linkage: llvm_GlobalValue_LinkageTypes,
        Name: *const llvm_Twine,
        Aliasee: *mut llvm_GlobalValue,
    ) -> *mut llvm_GlobalAlias {
        llvm_GlobalAlias_create2(Ty, AddressSpace, Linkage, Name, Aliasee)
    }
    #[inline]
    pub unsafe fn create3(
        Linkage: llvm_GlobalValue_LinkageTypes,
        Name: *const llvm_Twine,
        Aliasee: *mut llvm_GlobalValue,
    ) -> *mut llvm_GlobalAlias {
        llvm_GlobalAlias_create3(Linkage, Name, Aliasee)
    }
    #[inline]
    pub unsafe fn create4(
        Name: *const llvm_Twine,
        Aliasee: *mut llvm_GlobalValue,
    ) -> *mut llvm_GlobalAlias {
        llvm_GlobalAlias_create4(Name, Aliasee)
    }
    #[inline]
    pub unsafe fn removeFromParent(&mut self) {
        llvm_GlobalAlias_removeFromParent(self)
    }
    #[inline]
    pub unsafe fn eraseFromParent(&mut self) {
        llvm_GlobalAlias_eraseFromParent(self)
    }
    #[inline]
    pub unsafe fn setAliasee(&mut self, Aliasee: *mut llvm_Constant) {
        llvm_GlobalAlias_setAliasee(self, Aliasee)
    }
    #[inline]
    pub unsafe fn getAliaseeObject(&self) -> *const llvm_GlobalObject {
        llvm_GlobalAlias_getAliaseeObject(self)
    }
}
#[test]
fn __bindgen_test_layout_llvm_OperandTraits_open0_llvm_GlobalAlias_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<llvm_OperandTraits>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_OperandTraits)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_OperandTraits>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_OperandTraits)
        )
    );
}
#[repr(C)]
#[derive(Debug)]
pub struct llvm_GlobalIFunc {
    pub _base: llvm_GlobalObject,
    pub __bindgen_padding_0: [u64; 2usize],
}
#[test]
fn bindgen_test_layout_llvm_GlobalIFunc() {
    assert_eq!(
        ::std::mem::size_of::<llvm_GlobalIFunc>(),
        72usize,
        concat!("Size of: ", stringify!(llvm_GlobalIFunc))
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_GlobalIFunc>(),
        8usize,
        concat!("Alignment of ", stringify!(llvm_GlobalIFunc))
    );
}
extern "C" {
    #[doc = " If a parent module is specified, the ifunc is automatically inserted into\n the end of the specified module's ifunc list."]
    #[link_name = "\u{1}_ZN4llvm11GlobalIFunc6createEPNS_4TypeEjNS_11GlobalValue12LinkageTypesERKNS_5TwineEPNS_8ConstantEPNS_6ModuleE"]
    pub fn llvm_GlobalIFunc_create(
        Ty: *mut llvm_Type,
        AddressSpace: ::std::os::raw::c_uint,
        Linkage: llvm_GlobalValue_LinkageTypes,
        Name: *const llvm_Twine,
        Resolver: *mut llvm_Constant,
        Parent: *mut llvm_Module,
    ) -> *mut llvm_GlobalIFunc;
}
extern "C" {
    #[doc = " This method unlinks 'this' from the containing module, but does not\n delete it."]
    #[link_name = "\u{1}_ZN4llvm11GlobalIFunc16removeFromParentEv"]
    pub fn llvm_GlobalIFunc_removeFromParent(this: *mut llvm_GlobalIFunc);
}
extern "C" {
    #[doc = " This method unlinks 'this' from the containing module and deletes it."]
    #[link_name = "\u{1}_ZN4llvm11GlobalIFunc15eraseFromParentEv"]
    pub fn llvm_GlobalIFunc_eraseFromParent(this: *mut llvm_GlobalIFunc);
}
extern "C" {
    #[link_name = "\u{1}_ZNK4llvm11GlobalIFunc19getResolverFunctionEv"]
    pub fn llvm_GlobalIFunc_getResolverFunction(
        this: *const llvm_GlobalIFunc,
    ) -> *const llvm_Function;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4llvm11GlobalIFunc22applyAlongResolverPathENS_12function_refIFvRKNS_11GlobalValueEEEE"]
    pub fn llvm_GlobalIFunc_applyAlongResolverPath(
        this: *const llvm_GlobalIFunc,
        Op: llvm_function_ref,
    );
}
impl llvm_GlobalIFunc {
    #[inline]
    pub unsafe fn create(
        Ty: *mut llvm_Type,
        AddressSpace: ::std::os::raw::c_uint,
        Linkage: llvm_GlobalValue_LinkageTypes,
        Name: *const llvm_Twine,
        Resolver: *mut llvm_Constant,
        Parent: *mut llvm_Module,
    ) -> *mut llvm_GlobalIFunc {
        llvm_GlobalIFunc_create(Ty, AddressSpace, Linkage, Name, Resolver, Parent)
    }
    #[inline]
    pub unsafe fn removeFromParent(&mut self) {
        llvm_GlobalIFunc_removeFromParent(self)
    }
    #[inline]
    pub unsafe fn eraseFromParent(&mut self) {
        llvm_GlobalIFunc_eraseFromParent(self)
    }
    #[inline]
    pub unsafe fn getResolverFunction(&self) -> *const llvm_Function {
        llvm_GlobalIFunc_getResolverFunction(self)
    }
    #[inline]
    pub unsafe fn applyAlongResolverPath(&self, Op: llvm_function_ref) {
        llvm_GlobalIFunc_applyAlongResolverPath(self, Op)
    }
}
#[test]
fn __bindgen_test_layout_llvm_OperandTraits_open0_llvm_GlobalIFunc_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<llvm_OperandTraits>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_OperandTraits)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_OperandTraits>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_OperandTraits)
        )
    );
}
#[repr(C)]
#[derive(Debug)]
pub struct llvm_GlobalVariable {
    pub _base: llvm_GlobalObject,
    pub __bindgen_padding_0: [u64; 2usize],
    pub Attrs: llvm_AttributeSet,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_1: [u8; 7usize],
}
pub const llvm_GlobalVariable_CodeModelBits: ::std::os::raw::c_uint = 3;
pub const llvm_GlobalVariable_CodeModelMask: ::std::os::raw::c_uint = 7;
pub const llvm_GlobalVariable_CodeModelShift: ::std::os::raw::c_uint = 6;
#[test]
fn bindgen_test_layout_llvm_GlobalVariable() {
    const UNINIT: ::std::mem::MaybeUninit<llvm_GlobalVariable> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<llvm_GlobalVariable>(),
        88usize,
        concat!("Size of: ", stringify!(llvm_GlobalVariable))
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_GlobalVariable>(),
        8usize,
        concat!("Alignment of ", stringify!(llvm_GlobalVariable))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Attrs) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_GlobalVariable),
            "::",
            stringify!(Attrs)
        )
    );
}
extern "C" {
    #[doc = " setInitializer - Sets the initializer for this global variable, removing\n any existing initializer if InitVal==NULL. The initializer must have the\n type getValueType()."]
    #[link_name = "\u{1}_ZN4llvm14GlobalVariable14setInitializerEPNS_8ConstantE"]
    pub fn llvm_GlobalVariable_setInitializer(
        this: *mut llvm_GlobalVariable,
        InitVal: *mut llvm_Constant,
    );
}
extern "C" {
    #[doc = " replaceInitializer - Sets the initializer for this global variable, and\n sets the value type of the global to the type of the initializer. The\n initializer must not be null.  This may affect the global's alignment if\n it isn't explicitly set."]
    #[link_name = "\u{1}_ZN4llvm14GlobalVariable18replaceInitializerEPNS_8ConstantE"]
    pub fn llvm_GlobalVariable_replaceInitializer(
        this: *mut llvm_GlobalVariable,
        InitVal: *mut llvm_Constant,
    );
}
extern "C" {
    #[doc = " copyAttributesFrom - copy all additional attributes (those not needed to\n create a GlobalVariable) from the GlobalVariable Src to this one."]
    #[link_name = "\u{1}_ZN4llvm14GlobalVariable18copyAttributesFromEPKS0_"]
    pub fn llvm_GlobalVariable_copyAttributesFrom(
        this: *mut llvm_GlobalVariable,
        Src: *const llvm_GlobalVariable,
    );
}
extern "C" {
    #[doc = " removeFromParent - This method unlinks 'this' from the containing module,\n but does not delete it.\n"]
    #[link_name = "\u{1}_ZN4llvm14GlobalVariable16removeFromParentEv"]
    pub fn llvm_GlobalVariable_removeFromParent(this: *mut llvm_GlobalVariable);
}
extern "C" {
    #[doc = " eraseFromParent - This method unlinks 'this' from the containing module\n and deletes it.\n"]
    #[link_name = "\u{1}_ZN4llvm14GlobalVariable15eraseFromParentEv"]
    pub fn llvm_GlobalVariable_eraseFromParent(this: *mut llvm_GlobalVariable);
}
extern "C" {
    #[doc = " Drop all references in preparation to destroy the GlobalVariable. This\n drops not only the reference to the initializer but also to any metadata."]
    #[link_name = "\u{1}_ZN4llvm14GlobalVariable17dropAllReferencesEv"]
    pub fn llvm_GlobalVariable_dropAllReferences(this: *mut llvm_GlobalVariable);
}
extern "C" {
    #[doc = " Attach a DIGlobalVariableExpression."]
    #[link_name = "\u{1}_ZN4llvm14GlobalVariable12addDebugInfoEPNS_26DIGlobalVariableExpressionE"]
    pub fn llvm_GlobalVariable_addDebugInfo(
        this: *mut llvm_GlobalVariable,
        GV: *mut llvm_DIGlobalVariableExpression,
    );
}
extern "C" {
    #[doc = " Fill the vector with all debug info attachements."]
    #[link_name = "\u{1}_ZNK4llvm14GlobalVariable12getDebugInfoERNS_15SmallVectorImplIPNS_26DIGlobalVariableExpressionEEE"]
    pub fn llvm_GlobalVariable_getDebugInfo(
        this: *const llvm_GlobalVariable,
        GVs: *mut llvm_SmallVectorImpl,
    );
}
extern "C" {
    #[doc = " Change the code model for this global.\n"]
    #[link_name = "\u{1}_ZN4llvm14GlobalVariable12setCodeModelENS_9CodeModel5ModelE"]
    pub fn llvm_GlobalVariable_setCodeModel(
        this: *mut llvm_GlobalVariable,
        CM: llvm_CodeModel_Model,
    );
}
extern "C" {
    #[doc = " GlobalVariable ctor - If a parent module is specified, the global is\n automatically inserted into the end of the specified modules global list."]
    #[link_name = "\u{1}_ZN4llvm14GlobalVariableC1EPNS_4TypeEbNS_11GlobalValue12LinkageTypesEPNS_8ConstantERKNS_5TwineENS3_15ThreadLocalModeEjb"]
    pub fn llvm_GlobalVariable_GlobalVariable(
        this: *mut llvm_GlobalVariable,
        Ty: *mut llvm_Type,
        isConstant: bool,
        Linkage: llvm_GlobalValue_LinkageTypes,
        Initializer: *mut llvm_Constant,
        Name: *const llvm_Twine,
        arg1: llvm_GlobalValue_ThreadLocalMode,
        AddressSpace: ::std::os::raw::c_uint,
        isExternallyInitialized: bool,
    );
}
extern "C" {
    #[doc = " GlobalVariable ctor - This creates a global and inserts it before the\n specified other global."]
    #[link_name = "\u{1}_ZN4llvm14GlobalVariableC1ERNS_6ModuleEPNS_4TypeEbNS_11GlobalValue12LinkageTypesEPNS_8ConstantERKNS_5TwineEPS0_NS5_15ThreadLocalModeESt8optionalIjEb"]
    pub fn llvm_GlobalVariable_GlobalVariable1(
        this: *mut llvm_GlobalVariable,
        M: *mut llvm_Module,
        Ty: *mut llvm_Type,
        isConstant: bool,
        Linkage: llvm_GlobalValue_LinkageTypes,
        Initializer: *mut llvm_Constant,
        Name: *const llvm_Twine,
        InsertBefore: *mut llvm_GlobalVariable,
        arg1: llvm_GlobalValue_ThreadLocalMode,
        AddressSpace: std_optional,
        isExternallyInitialized: bool,
    );
}
impl llvm_GlobalVariable {
    #[inline]
    pub fn isConstantGlobal(&self) -> bool {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_isConstantGlobal(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn isExternallyInitializedConstant(&self) -> bool {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_isExternallyInitializedConstant(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        isConstantGlobal: bool,
        isExternallyInitializedConstant: bool,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let isConstantGlobal: u8 = unsafe { ::std::mem::transmute(isConstantGlobal) };
            isConstantGlobal as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let isExternallyInitializedConstant: u8 =
                unsafe { ::std::mem::transmute(isExternallyInitializedConstant) };
            isExternallyInitializedConstant as u64
        });
        __bindgen_bitfield_unit
    }
    #[inline]
    pub unsafe fn setInitializer(&mut self, InitVal: *mut llvm_Constant) {
        llvm_GlobalVariable_setInitializer(self, InitVal)
    }
    #[inline]
    pub unsafe fn replaceInitializer(&mut self, InitVal: *mut llvm_Constant) {
        llvm_GlobalVariable_replaceInitializer(self, InitVal)
    }
    #[inline]
    pub unsafe fn copyAttributesFrom(&mut self, Src: *const llvm_GlobalVariable) {
        llvm_GlobalVariable_copyAttributesFrom(self, Src)
    }
    #[inline]
    pub unsafe fn removeFromParent(&mut self) {
        llvm_GlobalVariable_removeFromParent(self)
    }
    #[inline]
    pub unsafe fn eraseFromParent(&mut self) {
        llvm_GlobalVariable_eraseFromParent(self)
    }
    #[inline]
    pub unsafe fn dropAllReferences(&mut self) {
        llvm_GlobalVariable_dropAllReferences(self)
    }
    #[inline]
    pub unsafe fn addDebugInfo(&mut self, GV: *mut llvm_DIGlobalVariableExpression) {
        llvm_GlobalVariable_addDebugInfo(self, GV)
    }
    #[inline]
    pub unsafe fn getDebugInfo(&self, GVs: *mut llvm_SmallVectorImpl) {
        llvm_GlobalVariable_getDebugInfo(self, GVs)
    }
    #[inline]
    pub unsafe fn setCodeModel(&mut self, CM: llvm_CodeModel_Model) {
        llvm_GlobalVariable_setCodeModel(self, CM)
    }
    #[inline]
    pub unsafe fn new(
        Ty: *mut llvm_Type,
        isConstant: bool,
        Linkage: llvm_GlobalValue_LinkageTypes,
        Initializer: *mut llvm_Constant,
        Name: *const llvm_Twine,
        arg1: llvm_GlobalValue_ThreadLocalMode,
        AddressSpace: ::std::os::raw::c_uint,
        isExternallyInitialized: bool,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        llvm_GlobalVariable_GlobalVariable(
            __bindgen_tmp.as_mut_ptr(),
            Ty,
            isConstant,
            Linkage,
            Initializer,
            Name,
            arg1,
            AddressSpace,
            isExternallyInitialized,
        );
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(
        M: *mut llvm_Module,
        Ty: *mut llvm_Type,
        isConstant: bool,
        Linkage: llvm_GlobalValue_LinkageTypes,
        Initializer: *mut llvm_Constant,
        Name: *const llvm_Twine,
        InsertBefore: *mut llvm_GlobalVariable,
        arg1: llvm_GlobalValue_ThreadLocalMode,
        AddressSpace: std_optional,
        isExternallyInitialized: bool,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        llvm_GlobalVariable_GlobalVariable1(
            __bindgen_tmp.as_mut_ptr(),
            M,
            Ty,
            isConstant,
            Linkage,
            Initializer,
            Name,
            InsertBefore,
            arg1,
            AddressSpace,
            isExternallyInitialized,
        );
        __bindgen_tmp.assume_init()
    }
}
#[test]
fn __bindgen_test_layout_llvm_OperandTraits_open0_llvm_GlobalVariable_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<llvm_OperandTraits>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_OperandTraits)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_OperandTraits>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_OperandTraits)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_ProfileSummaryEntry {
    #[doc = "< The required percentile of counts."]
    pub Cutoff: u32,
    #[doc = "< The minimum count for this percentile."]
    pub MinCount: u64,
    #[doc = "< Number of counts >= the minimum count."]
    pub NumCounts: u64,
}
#[test]
fn bindgen_test_layout_llvm_ProfileSummaryEntry() {
    const UNINIT: ::std::mem::MaybeUninit<llvm_ProfileSummaryEntry> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<llvm_ProfileSummaryEntry>(),
        24usize,
        concat!("Size of: ", stringify!(llvm_ProfileSummaryEntry))
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_ProfileSummaryEntry>(),
        8usize,
        concat!("Alignment of ", stringify!(llvm_ProfileSummaryEntry))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Cutoff) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_ProfileSummaryEntry),
            "::",
            stringify!(Cutoff)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).MinCount) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_ProfileSummaryEntry),
            "::",
            stringify!(MinCount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).NumCounts) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_ProfileSummaryEntry),
            "::",
            stringify!(NumCounts)
        )
    );
}
pub type llvm_SummaryEntryVector = std_vector;
#[repr(C)]
pub struct llvm_ProfileSummary {
    pub PSK: llvm_ProfileSummary_Kind,
    pub DetailedSummary: llvm_SummaryEntryVector,
    pub TotalCount: u64,
    pub MaxCount: u64,
    pub MaxInternalCount: u64,
    pub MaxFunctionCount: u64,
    pub NumCounts: u32,
    pub NumFunctions: u32,
    #[doc = " If 'Partial' is false, it means the profile being used to optimize\n a target is collected from the same target.\n If 'Partial' is true, it means the profile is for common/shared\n code. The common profile is usually merged from profiles collected\n from running other targets."]
    pub Partial: bool,
    #[doc = " This approximately represents the ratio of the number of profile counters\n of the program being built to the number of profile counters in the\n partial sample profile. When 'Partial' is false, it is undefined. This is\n currently only available under thin LTO mode."]
    pub PartialProfileRatio: f64,
}
pub const llvm_ProfileSummary_Kind_PSK_Instr: llvm_ProfileSummary_Kind = 0;
pub const llvm_ProfileSummary_Kind_PSK_CSInstr: llvm_ProfileSummary_Kind = 1;
pub const llvm_ProfileSummary_Kind_PSK_Sample: llvm_ProfileSummary_Kind = 2;
pub type llvm_ProfileSummary_Kind = ::std::os::raw::c_uint;
pub const llvm_ProfileSummary_Scale: ::std::os::raw::c_int = 1000000;
#[test]
fn bindgen_test_layout_llvm_ProfileSummary() {
    const UNINIT: ::std::mem::MaybeUninit<llvm_ProfileSummary> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<llvm_ProfileSummary>(),
        88usize,
        concat!("Size of: ", stringify!(llvm_ProfileSummary))
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_ProfileSummary>(),
        8usize,
        concat!("Alignment of ", stringify!(llvm_ProfileSummary))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).PSK) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_ProfileSummary),
            "::",
            stringify!(PSK)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).DetailedSummary) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_ProfileSummary),
            "::",
            stringify!(DetailedSummary)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).TotalCount) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_ProfileSummary),
            "::",
            stringify!(TotalCount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).MaxCount) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_ProfileSummary),
            "::",
            stringify!(MaxCount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).MaxInternalCount) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_ProfileSummary),
            "::",
            stringify!(MaxInternalCount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).MaxFunctionCount) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_ProfileSummary),
            "::",
            stringify!(MaxFunctionCount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).NumCounts) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_ProfileSummary),
            "::",
            stringify!(NumCounts)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).NumFunctions) as usize - ptr as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_ProfileSummary),
            "::",
            stringify!(NumFunctions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Partial) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_ProfileSummary),
            "::",
            stringify!(Partial)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).PartialProfileRatio) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_ProfileSummary),
            "::",
            stringify!(PartialProfileRatio)
        )
    );
}
extern "C" {
    #[doc = " Return summary information as metadata."]
    #[link_name = "\u{1}_ZN4llvm14ProfileSummary5getMDERNS_11LLVMContextEbb"]
    pub fn llvm_ProfileSummary_getMD(
        this: *mut llvm_ProfileSummary,
        Context: *mut llvm_LLVMContext,
        AddPartialField: bool,
        AddPartialProfileRatioField: bool,
    ) -> *mut llvm_Metadata;
}
extern "C" {
    #[doc = " Construct profile summary from metdata."]
    #[link_name = "\u{1}_ZN4llvm14ProfileSummary9getFromMDEPNS_8MetadataE"]
    pub fn llvm_ProfileSummary_getFromMD(MD: *mut llvm_Metadata) -> *mut llvm_ProfileSummary;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4llvm14ProfileSummary12printSummaryERNS_11raw_ostreamE"]
    pub fn llvm_ProfileSummary_printSummary(
        this: *const llvm_ProfileSummary,
        OS: *mut llvm_raw_ostream,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK4llvm14ProfileSummary20printDetailedSummaryERNS_11raw_ostreamE"]
    pub fn llvm_ProfileSummary_printDetailedSummary(
        this: *const llvm_ProfileSummary,
        OS: *mut llvm_raw_ostream,
    );
}
impl llvm_ProfileSummary {
    #[inline]
    pub unsafe fn getMD(
        &mut self,
        Context: *mut llvm_LLVMContext,
        AddPartialField: bool,
        AddPartialProfileRatioField: bool,
    ) -> *mut llvm_Metadata {
        llvm_ProfileSummary_getMD(self, Context, AddPartialField, AddPartialProfileRatioField)
    }
    #[inline]
    pub unsafe fn getFromMD(MD: *mut llvm_Metadata) -> *mut llvm_ProfileSummary {
        llvm_ProfileSummary_getFromMD(MD)
    }
    #[inline]
    pub unsafe fn printSummary(&self, OS: *mut llvm_raw_ostream) {
        llvm_ProfileSummary_printSummary(self, OS)
    }
    #[inline]
    pub unsafe fn printDetailedSummary(&self, OS: *mut llvm_raw_ostream) {
        llvm_ProfileSummary_printDetailedSummary(self, OS)
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_GVMaterializer {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_ModuleSummaryIndex {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_RandomNumberGenerator {
    _unused: [u8; 0],
}
#[doc = " A Module instance is used to store all the information related to an\n LLVM module. Modules are the top level container of all other LLVM\n Intermediate Representation (IR) objects. Each module directly contains a\n list of globals variables, a list of functions, a list of libraries (or\n other modules) this module depends on, a symbol table, and various data\n about the target's characteristics.\n\n A module maintains a GlobalList object that is used to hold all\n constant references to global variables in the module.  When a global\n variable is destroyed, it should have no entries in the GlobalList.\n The main container class for the LLVM Intermediate Representation."]
#[repr(C)]
pub struct llvm_Module {
    #[doc = "< The LLVMContext from which types and\n< constants are allocated."]
    pub Context: *mut llvm_LLVMContext,
    #[doc = "< The Global Variables in the module"]
    pub GlobalList: llvm_Module_GlobalListType,
    #[doc = "< The Functions in the module"]
    pub FunctionList: llvm_Module_FunctionListType,
    #[doc = "< The Aliases in the module"]
    pub AliasList: llvm_Module_AliasListType,
    #[doc = "< The IFuncs in the module"]
    pub IFuncList: llvm_Module_IFuncListType,
    #[doc = "< The named metadata in the module"]
    pub NamedMDList: llvm_Module_NamedMDListType,
    #[doc = "< Inline Asm at global scope."]
    pub GlobalScopeAsm: std_string,
    #[doc = "< Symbol table for values"]
    pub ValSymTab: std_unique_ptr,
    #[doc = "< Symbol table for COMDATs"]
    pub ComdatSymTab: llvm_Module_ComdatSymTabType,
    #[doc = "< Memory buffer directly owned by this\n< module, for legacy clients only."]
    pub OwnedMemoryBuffer: std_unique_ptr,
    #[doc = "< Used to materialize GlobalValues"]
    pub Materializer: std_unique_ptr,
    #[doc = "< Human readable identifier for the module"]
    pub ModuleID: std_string,
    #[doc = "< Original source file name for module,\n< recorded in bitcode."]
    pub SourceFileName: std_string,
    #[doc = "< Platform target triple Module compiled on\n< Format: (arch)(sub)-(vendor)-(sys0-(abi)"]
    pub TargetTriple: std_string,
    #[doc = "< NamedMDNode names."]
    pub NamedMDSymTab: llvm_Module_NamedMDSymTabType,
    #[doc = "< DataLayout associated with the module"]
    pub DL: llvm_DataLayout,
    #[doc = "< Keep track of the current unique id count for\n< the specified intrinsic basename."]
    pub CurrentIntrinsicIds: llvm_StringMap<llvm_MallocAllocator>,
    #[doc = "< Keep track of uniqued names of intrinsics\n< based on unnamed types. The combination of\n< ID and FunctionType maps to the extension that\n< is used to make the intrinsic name unique."]
    pub UniquedIntrinsicNames: llvm_DenseMap<
        llvm_detail_DenseMapPair<
            std_pair<::std::os::raw::c_uint, *const llvm_FunctionType>,
            ::std::os::raw::c_uint,
        >,
    >,
    #[doc = " llvm.module.flags metadata"]
    pub ModuleFlags: *mut llvm_NamedMDNode,
    #[doc = " Is this Module using intrinsics to record the position of debugging\n information, or non-intrinsic records? See IsNewDbgInfoFormat in\n \\ref BasicBlock."]
    pub IsNewDbgInfoFormat: bool,
}
#[doc = " The type for the list of global variables."]
pub type llvm_Module_GlobalListType = llvm_SymbolTableList;
#[doc = " The type for the list of functions."]
pub type llvm_Module_FunctionListType = llvm_SymbolTableList;
#[doc = " The type for the list of aliases."]
pub type llvm_Module_AliasListType = llvm_SymbolTableList;
#[doc = " The type for the list of ifuncs."]
pub type llvm_Module_IFuncListType = llvm_SymbolTableList;
#[doc = " The type for the list of named metadata."]
pub type llvm_Module_NamedMDListType = llvm_iplist;
#[doc = " The type of the comdat \"symbol\" table."]
pub type llvm_Module_ComdatSymTabType = llvm_StringMap<llvm_MallocAllocator>;
#[doc = " The type for mapping names to named metadata."]
pub type llvm_Module_NamedMDSymTabType = llvm_StringMap<llvm_MallocAllocator>;
#[doc = " The Global Variable iterator."]
pub type llvm_Module_global_iterator = u64;
#[doc = " The Global Variable constant iterator."]
pub type llvm_Module_const_global_iterator = u64;
#[doc = " The Function iterators."]
pub type llvm_Module_iterator = u64;
#[doc = " The Function constant iterator"]
pub type llvm_Module_const_iterator = u64;
#[doc = " The Function reverse iterator."]
pub type llvm_Module_reverse_iterator = u64;
#[doc = " The Function constant reverse iterator."]
pub type llvm_Module_const_reverse_iterator = u64;
#[doc = " The Global Alias iterators."]
pub type llvm_Module_alias_iterator = u64;
#[doc = " The Global Alias constant iterator"]
pub type llvm_Module_const_alias_iterator = u64;
#[doc = " The Global IFunc iterators."]
pub type llvm_Module_ifunc_iterator = u64;
#[doc = " The Global IFunc constant iterator"]
pub type llvm_Module_const_ifunc_iterator = u64;
#[doc = " The named metadata iterators."]
pub type llvm_Module_named_metadata_iterator = u64;
#[doc = " The named metadata constant iterators."]
pub type llvm_Module_const_named_metadata_iterator = u64;
#[doc = " Emits an error if two values disagree, otherwise the resulting value is\n that of the operands."]
pub const llvm_Module_ModFlagBehavior_Error: llvm_Module_ModFlagBehavior = 1;
#[doc = " Emits a warning if two values disagree. The result value will be the\n operand for the flag from the first module being linked."]
pub const llvm_Module_ModFlagBehavior_Warning: llvm_Module_ModFlagBehavior = 2;
#[doc = " Adds a requirement that another module flag be present and have a\n specified value after linking is performed. The value must be a metadata\n pair, where the first element of the pair is the ID of the module flag\n to be restricted, and the second element of the pair is the value the\n module flag should be restricted to. This behavior can be used to\n restrict the allowable results (via triggering of an error) of linking\n IDs with the **Override** behavior."]
pub const llvm_Module_ModFlagBehavior_Require: llvm_Module_ModFlagBehavior = 3;
#[doc = " Uses the specified value, regardless of the behavior or value of the\n other module. If both modules specify **Override**, but the values\n differ, an error will be emitted."]
pub const llvm_Module_ModFlagBehavior_Override: llvm_Module_ModFlagBehavior = 4;
#[doc = " Appends the two values, which are required to be metadata nodes."]
pub const llvm_Module_ModFlagBehavior_Append: llvm_Module_ModFlagBehavior = 5;
#[doc = " Appends the two values, which are required to be metadata\n nodes. However, duplicate entries in the second list are dropped\n during the append operation."]
pub const llvm_Module_ModFlagBehavior_AppendUnique: llvm_Module_ModFlagBehavior = 6;
#[doc = " Takes the max of the two values, which are required to be integers."]
pub const llvm_Module_ModFlagBehavior_Max: llvm_Module_ModFlagBehavior = 7;
#[doc = " Takes the min of the two values, which are required to be integers."]
pub const llvm_Module_ModFlagBehavior_Min: llvm_Module_ModFlagBehavior = 8;
#[doc = " Takes the min of the two values, which are required to be integers."]
pub const llvm_Module_ModFlagBehavior_ModFlagBehaviorFirstVal: llvm_Module_ModFlagBehavior = 1;
#[doc = " Takes the min of the two values, which are required to be integers."]
pub const llvm_Module_ModFlagBehavior_ModFlagBehaviorLastVal: llvm_Module_ModFlagBehavior = 8;
#[doc = " This enumeration defines the supported behaviors of module flags."]
pub type llvm_Module_ModFlagBehavior = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_Module_ModuleFlagEntry {
    pub Behavior: llvm_Module_ModFlagBehavior,
    pub Key: *mut llvm_MDString,
    pub Val: *mut llvm_Metadata,
}
#[test]
fn bindgen_test_layout_llvm_Module_ModuleFlagEntry() {
    const UNINIT: ::std::mem::MaybeUninit<llvm_Module_ModuleFlagEntry> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<llvm_Module_ModuleFlagEntry>(),
        24usize,
        concat!("Size of: ", stringify!(llvm_Module_ModuleFlagEntry))
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_Module_ModuleFlagEntry>(),
        8usize,
        concat!("Alignment of ", stringify!(llvm_Module_ModuleFlagEntry))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Behavior) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_Module_ModuleFlagEntry),
            "::",
            stringify!(Behavior)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Key) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_Module_ModuleFlagEntry),
            "::",
            stringify!(Key)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Val) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_Module_ModuleFlagEntry),
            "::",
            stringify!(Val)
        )
    );
}
#[doc = " @}\n @name Convenience iterators\n @{"]
pub type llvm_Module_global_object_iterator = llvm_concat_iterator;
pub type llvm_Module_const_global_object_iterator = llvm_concat_iterator;
pub type llvm_Module_global_value_iterator = llvm_concat_iterator;
pub type llvm_Module_const_global_value_iterator = llvm_concat_iterator;
#[doc = " An iterator for DICompileUnits that skips those marked NoDebug."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_Module_debug_compile_units_iterator {
    pub CUs: *mut llvm_NamedMDNode,
    pub Idx: ::std::os::raw::c_uint,
}
pub type llvm_Module_debug_compile_units_iterator_iterator_category = std_input_iterator_tag;
pub type llvm_Module_debug_compile_units_iterator_value_type = *mut llvm_DICompileUnit;
pub type llvm_Module_debug_compile_units_iterator_difference_type = isize;
pub type llvm_Module_debug_compile_units_iterator_pointer =
    *mut llvm_Module_debug_compile_units_iterator_value_type;
pub type llvm_Module_debug_compile_units_iterator_reference =
    *mut llvm_Module_debug_compile_units_iterator_value_type;
#[test]
fn bindgen_test_layout_llvm_Module_debug_compile_units_iterator() {
    const UNINIT: ::std::mem::MaybeUninit<llvm_Module_debug_compile_units_iterator> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<llvm_Module_debug_compile_units_iterator>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(llvm_Module_debug_compile_units_iterator)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_Module_debug_compile_units_iterator>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(llvm_Module_debug_compile_units_iterator)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).CUs) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_Module_debug_compile_units_iterator),
            "::",
            stringify!(CUs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Idx) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_Module_debug_compile_units_iterator),
            "::",
            stringify!(Idx)
        )
    );
}
#[test]
fn bindgen_test_layout_llvm_Module() {
    const UNINIT: ::std::mem::MaybeUninit<llvm_Module> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<llvm_Module>(),
        872usize,
        concat!("Size of: ", stringify!(llvm_Module))
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_Module>(),
        8usize,
        concat!("Alignment of ", stringify!(llvm_Module))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Context) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_Module),
            "::",
            stringify!(Context)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).GlobalList) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_Module),
            "::",
            stringify!(GlobalList)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).FunctionList) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_Module),
            "::",
            stringify!(FunctionList)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).AliasList) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_Module),
            "::",
            stringify!(AliasList)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).IFuncList) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_Module),
            "::",
            stringify!(IFuncList)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).NamedMDList) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_Module),
            "::",
            stringify!(NamedMDList)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).GlobalScopeAsm) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_Module),
            "::",
            stringify!(GlobalScopeAsm)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ValSymTab) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_Module),
            "::",
            stringify!(ValSymTab)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ComdatSymTab) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_Module),
            "::",
            stringify!(ComdatSymTab)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).OwnedMemoryBuffer) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_Module),
            "::",
            stringify!(OwnedMemoryBuffer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Materializer) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_Module),
            "::",
            stringify!(Materializer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ModuleID) as usize - ptr as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_Module),
            "::",
            stringify!(ModuleID)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).SourceFileName) as usize - ptr as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_Module),
            "::",
            stringify!(SourceFileName)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).TargetTriple) as usize - ptr as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_Module),
            "::",
            stringify!(TargetTriple)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).NamedMDSymTab) as usize - ptr as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_Module),
            "::",
            stringify!(NamedMDSymTab)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).DL) as usize - ptr as usize },
        288usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_Module),
            "::",
            stringify!(DL)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).CurrentIntrinsicIds) as usize - ptr as usize },
        800usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_Module),
            "::",
            stringify!(CurrentIntrinsicIds)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).UniquedIntrinsicNames) as usize - ptr as usize },
        824usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_Module),
            "::",
            stringify!(UniquedIntrinsicNames)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ModuleFlags) as usize - ptr as usize },
        856usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_Module),
            "::",
            stringify!(ModuleFlags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).IsNewDbgInfoFormat) as usize - ptr as usize },
        864usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_Module),
            "::",
            stringify!(IsNewDbgInfoFormat)
        )
    );
}
extern "C" {
    #[doc = " Checks if Metadata represents a valid ModFlagBehavior, and stores the\n converted result in MFB."]
    #[link_name = "\u{1}_ZN4llvm6Module22isValidModFlagBehaviorEPNS_8MetadataERNS0_15ModFlagBehaviorE"]
    pub fn llvm_Module_isValidModFlagBehavior(
        MD: *mut llvm_Metadata,
        MFB: *mut llvm_Module_ModFlagBehavior,
    ) -> bool;
}
extern "C" {
    #[doc = " Used when printing this module in the new debug info format; removes all\n declarations of debug intrinsics that are replaced by non-intrinsic\n records in the new format."]
    #[link_name = "\u{1}_ZN4llvm6Module32removeDebugIntrinsicDeclarationsEv"]
    pub fn llvm_Module_removeDebugIntrinsicDeclarations(this: *mut llvm_Module);
}
extern "C" {
    #[doc = " Returns the number of non-debug IR instructions in the module.\n This is equivalent to the sum of the IR instruction counts of each\n function contained in the module."]
    #[link_name = "\u{1}_ZNK4llvm6Module19getInstructionCountEv"]
    pub fn llvm_Module_getInstructionCount(this: *const llvm_Module) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " Get a RandomNumberGenerator salted for use with this module. The\n RNG can be seeded via -rng-seed=<uint64> and is salted with the\n ModuleID and the provided pass salt. The returned RNG should not\n be shared across threads or passes.\n\n A unique RNG per pass ensures a reproducible random stream even\n when other randomness consuming passes are added or removed. In\n addition, the random stream will be reproducible across LLVM\n versions when the pass does not change."]
    #[link_name = "\u{1}_ZNK4llvm6Module9createRNGENS_9StringRefE"]
    pub fn llvm_Module_createRNG(this: *const llvm_Module, Name: llvm_StringRef) -> std_unique_ptr;
}
extern "C" {
    #[doc = " Set the data layout"]
    #[link_name = "\u{1}_ZN4llvm6Module13setDataLayoutENS_9StringRefE"]
    pub fn llvm_Module_setDataLayout(this: *mut llvm_Module, Desc: llvm_StringRef);
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm6Module13setDataLayoutERKNS_10DataLayoutE"]
    pub fn llvm_Module_setDataLayout1(this: *mut llvm_Module, Other: *const llvm_DataLayout);
}
extern "C" {
    #[doc = " Return the global value in the module with the specified name, of\n arbitrary type. This method returns null if a global with the specified\n name is not found."]
    #[link_name = "\u{1}_ZNK4llvm6Module13getNamedValueENS_9StringRefE"]
    pub fn llvm_Module_getNamedValue(
        this: *const llvm_Module,
        Name: llvm_StringRef,
    ) -> *mut llvm_GlobalValue;
}
extern "C" {
    #[doc = " Return the number of global values in the module."]
    #[link_name = "\u{1}_ZNK4llvm6Module17getNumNamedValuesEv"]
    pub fn llvm_Module_getNumNamedValues(this: *const llvm_Module) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " Return a unique non-zero ID for the specified metadata kind. This ID is\n uniqued across modules in the current LLVMContext."]
    #[link_name = "\u{1}_ZNK4llvm6Module11getMDKindIDENS_9StringRefE"]
    pub fn llvm_Module_getMDKindID(
        this: *const llvm_Module,
        Name: llvm_StringRef,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " Populate client supplied SmallVector with the name for custom metadata IDs\n registered in this LLVMContext."]
    #[link_name = "\u{1}_ZNK4llvm6Module14getMDKindNamesERNS_15SmallVectorImplINS_9StringRefEEE"]
    pub fn llvm_Module_getMDKindNames(this: *const llvm_Module, Result: *mut llvm_SmallVectorImpl);
}
extern "C" {
    #[doc = " Populate client supplied SmallVector with the bundle tags registered in\n this LLVMContext.  The bundle tags are ordered by increasing bundle IDs.\n \\see LLVMContext::getOperandBundleTagID"]
    #[link_name = "\u{1}_ZNK4llvm6Module20getOperandBundleTagsERNS_15SmallVectorImplINS_9StringRefEEE"]
    pub fn llvm_Module_getOperandBundleTags(
        this: *const llvm_Module,
        Result: *mut llvm_SmallVectorImpl,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK4llvm6Module24getIdentifiedStructTypesEv"]
    pub fn llvm_Module_getIdentifiedStructTypes(this: *const llvm_Module) -> std_vector;
}
extern "C" {
    #[doc = " Return a unique name for an intrinsic whose mangling is based on an\n unnamed type. The Proto represents the function prototype."]
    #[link_name = "\u{1}_ZN4llvm6Module22getUniqueIntrinsicNameB5cxx11ENS_9StringRefEjPKNS_12FunctionTypeE"]
    pub fn llvm_Module_getUniqueIntrinsicName(
        this: *mut llvm_Module,
        BaseName: llvm_StringRef,
        Id: llvm_Intrinsic_ID,
        Proto: *const llvm_FunctionType,
    ) -> std_string;
}
extern "C" {
    #[doc = " Look up the specified function in the module symbol table. If it does not\n exist, add a prototype for the function and return it. Otherwise, return\n the existing function.\n\n In all cases, the returned value is a FunctionCallee wrapper around the\n 'FunctionType *T' passed in, as well as the 'Value*' of the Function. The\n function type of the function may differ from the function type stored in\n FunctionCallee if it was previously created with a different type.\n\n Note: For library calls getOrInsertLibFunc() should be used instead."]
    #[link_name = "\u{1}_ZN4llvm6Module19getOrInsertFunctionENS_9StringRefEPNS_12FunctionTypeENS_13AttributeListE"]
    pub fn llvm_Module_getOrInsertFunction(
        this: *mut llvm_Module,
        Name: llvm_StringRef,
        T: *mut llvm_FunctionType,
        AttributeList: llvm_AttributeList,
    ) -> llvm_FunctionCallee;
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm6Module19getOrInsertFunctionENS_9StringRefEPNS_12FunctionTypeE"]
    pub fn llvm_Module_getOrInsertFunction1(
        this: *mut llvm_Module,
        Name: llvm_StringRef,
        T: *mut llvm_FunctionType,
    ) -> llvm_FunctionCallee;
}
extern "C" {
    #[doc = " Look up the specified function in the module symbol table. If it does not\n exist, return null."]
    #[link_name = "\u{1}_ZNK4llvm6Module11getFunctionENS_9StringRefE"]
    pub fn llvm_Module_getFunction(
        this: *const llvm_Module,
        Name: llvm_StringRef,
    ) -> *mut llvm_Function;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4llvm6Module17getGlobalVariableENS_9StringRefEb"]
    pub fn llvm_Module_getGlobalVariable(
        this: *const llvm_Module,
        Name: llvm_StringRef,
        AllowInternal: bool,
    ) -> *mut llvm_GlobalVariable;
}
extern "C" {
    #[doc = " Look up the specified global in the module symbol table.\n If it does not exist, invoke a callback to create a declaration of the\n global and return it. The global is constantexpr casted to the expected\n type if necessary."]
    #[link_name = "\u{1}_ZN4llvm6Module17getOrInsertGlobalENS_9StringRefEPNS_4TypeENS_12function_refIFPNS_14GlobalVariableEvEEE"]
    pub fn llvm_Module_getOrInsertGlobal(
        this: *mut llvm_Module,
        Name: llvm_StringRef,
        Ty: *mut llvm_Type,
        CreateGlobalCallback: llvm_function_ref,
    ) -> *mut llvm_Constant;
}
extern "C" {
    #[doc = " Look up the specified global in the module symbol table. If required, this\n overload constructs the global variable using its constructor's defaults."]
    #[link_name = "\u{1}_ZN4llvm6Module17getOrInsertGlobalENS_9StringRefEPNS_4TypeE"]
    pub fn llvm_Module_getOrInsertGlobal1(
        this: *mut llvm_Module,
        Name: llvm_StringRef,
        Ty: *mut llvm_Type,
    ) -> *mut llvm_Constant;
}
extern "C" {
    #[doc = " Return the global alias in the module with the specified name, of\n arbitrary type. This method returns null if a global with the specified\n name is not found."]
    #[link_name = "\u{1}_ZNK4llvm6Module13getNamedAliasENS_9StringRefE"]
    pub fn llvm_Module_getNamedAlias(
        this: *const llvm_Module,
        Name: llvm_StringRef,
    ) -> *mut llvm_GlobalAlias;
}
extern "C" {
    #[doc = " Return the global ifunc in the module with the specified name, of\n arbitrary type. This method returns null if a global with the specified\n name is not found."]
    #[link_name = "\u{1}_ZNK4llvm6Module13getNamedIFuncENS_9StringRefE"]
    pub fn llvm_Module_getNamedIFunc(
        this: *const llvm_Module,
        Name: llvm_StringRef,
    ) -> *mut llvm_GlobalIFunc;
}
extern "C" {
    #[doc = " Return the first NamedMDNode in the module with the specified name. This\n method returns null if a NamedMDNode with the specified name is not found."]
    #[link_name = "\u{1}_ZNK4llvm6Module16getNamedMetadataENS_9StringRefE"]
    pub fn llvm_Module_getNamedMetadata(
        this: *const llvm_Module,
        Name: llvm_StringRef,
    ) -> *mut llvm_NamedMDNode;
}
extern "C" {
    #[doc = " Return the named MDNode in the module with the specified name. This method\n returns a new NamedMDNode if a NamedMDNode with the specified name is not\n found."]
    #[link_name = "\u{1}_ZN4llvm6Module24getOrInsertNamedMetadataENS_9StringRefE"]
    pub fn llvm_Module_getOrInsertNamedMetadata(
        this: *mut llvm_Module,
        Name: llvm_StringRef,
    ) -> *mut llvm_NamedMDNode;
}
extern "C" {
    #[doc = " Remove the given NamedMDNode from this module and delete it."]
    #[link_name = "\u{1}_ZN4llvm6Module18eraseNamedMetadataEPNS_11NamedMDNodeE"]
    pub fn llvm_Module_eraseNamedMetadata(this: *mut llvm_Module, NMD: *mut llvm_NamedMDNode);
}
extern "C" {
    #[doc = " Return the Comdat in the module with the specified name. It is created\n if it didn't already exist."]
    #[link_name = "\u{1}_ZN4llvm6Module17getOrInsertComdatENS_9StringRefE"]
    pub fn llvm_Module_getOrInsertComdat(
        this: *mut llvm_Module,
        Name: llvm_StringRef,
    ) -> *mut llvm_Comdat;
}
extern "C" {
    #[doc = " Returns the module flags in the provided vector."]
    #[link_name = "\u{1}_ZNK4llvm6Module22getModuleFlagsMetadataERNS_15SmallVectorImplINS0_15ModuleFlagEntryEEE"]
    pub fn llvm_Module_getModuleFlagsMetadata(
        this: *const llvm_Module,
        Flags: *mut llvm_SmallVectorImpl,
    );
}
extern "C" {
    #[doc = " Return the corresponding value if Key appears in module flags, otherwise\n return null."]
    #[link_name = "\u{1}_ZNK4llvm6Module13getModuleFlagENS_9StringRefE"]
    pub fn llvm_Module_getModuleFlag(
        this: *const llvm_Module,
        Key: llvm_StringRef,
    ) -> *mut llvm_Metadata;
}
extern "C" {
    #[doc = " Returns the NamedMDNode in the module that represents module-level flags.\n If module-level flags aren't found, it creates the named metadata that\n contains them."]
    #[link_name = "\u{1}_ZN4llvm6Module30getOrInsertModuleFlagsMetadataEv"]
    pub fn llvm_Module_getOrInsertModuleFlagsMetadata(
        this: *mut llvm_Module,
    ) -> *mut llvm_NamedMDNode;
}
extern "C" {
    #[doc = " Add a module-level flag to the module-level flags metadata. It will create\n the module-level flags named metadata if it doesn't already exist."]
    #[link_name = "\u{1}_ZN4llvm6Module13addModuleFlagENS0_15ModFlagBehaviorENS_9StringRefEPNS_8MetadataE"]
    pub fn llvm_Module_addModuleFlag(
        this: *mut llvm_Module,
        Behavior: llvm_Module_ModFlagBehavior,
        Key: llvm_StringRef,
        Val: *mut llvm_Metadata,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm6Module13addModuleFlagENS0_15ModFlagBehaviorENS_9StringRefEPNS_8ConstantE"]
    pub fn llvm_Module_addModuleFlag1(
        this: *mut llvm_Module,
        Behavior: llvm_Module_ModFlagBehavior,
        Key: llvm_StringRef,
        Val: *mut llvm_Constant,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm6Module13addModuleFlagENS0_15ModFlagBehaviorENS_9StringRefEj"]
    pub fn llvm_Module_addModuleFlag2(
        this: *mut llvm_Module,
        Behavior: llvm_Module_ModFlagBehavior,
        Key: llvm_StringRef,
        Val: u32,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm6Module13addModuleFlagEPNS_6MDNodeE"]
    pub fn llvm_Module_addModuleFlag3(this: *mut llvm_Module, Node: *mut llvm_MDNode);
}
extern "C" {
    #[doc = " Like addModuleFlag but replaces the old module flag if it already exists."]
    #[link_name = "\u{1}_ZN4llvm6Module13setModuleFlagENS0_15ModFlagBehaviorENS_9StringRefEPNS_8MetadataE"]
    pub fn llvm_Module_setModuleFlag(
        this: *mut llvm_Module,
        Behavior: llvm_Module_ModFlagBehavior,
        Key: llvm_StringRef,
        Val: *mut llvm_Metadata,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm6Module13setModuleFlagENS0_15ModFlagBehaviorENS_9StringRefEPNS_8ConstantE"]
    pub fn llvm_Module_setModuleFlag1(
        this: *mut llvm_Module,
        Behavior: llvm_Module_ModFlagBehavior,
        Key: llvm_StringRef,
        Val: *mut llvm_Constant,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm6Module13setModuleFlagENS0_15ModFlagBehaviorENS_9StringRefEj"]
    pub fn llvm_Module_setModuleFlag2(
        this: *mut llvm_Module,
        Behavior: llvm_Module_ModFlagBehavior,
        Key: llvm_StringRef,
        Val: u32,
    );
}
extern "C" {
    #[doc = " Sets the GVMaterializer to GVM. This module must not yet have a\n Materializer. To reset the materializer for a module that already has one,\n call materializeAll first. Destroying this module will destroy\n its materializer without materializing any more GlobalValues. Without\n destroying the Module, there is no way to detach or destroy a materializer\n without materializing all the GVs it controls, to avoid leaving orphan\n unmaterialized GVs."]
    #[link_name = "\u{1}_ZN4llvm6Module15setMaterializerEPNS_14GVMaterializerE"]
    pub fn llvm_Module_setMaterializer(this: *mut llvm_Module, GVM: *mut llvm_GVMaterializer);
}
extern "C" {
    #[doc = " Make sure the GlobalValue is fully read."]
    #[link_name = "\u{1}_ZN4llvm6Module11materializeEPNS_11GlobalValueE"]
    pub fn llvm_Module_materialize(this: *mut llvm_Module, GV: *mut llvm_GlobalValue)
        -> llvm_Error;
}
extern "C" {
    #[doc = " Make sure all GlobalValues in this Module are fully read and clear the\n Materializer."]
    #[link_name = "\u{1}_ZN4llvm6Module14materializeAllEv"]
    pub fn llvm_Module_materializeAll(this: *mut llvm_Module) -> llvm_Error;
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm6Module19materializeMetadataEv"]
    pub fn llvm_Module_materializeMetadata(this: *mut llvm_Module) -> llvm_Error;
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm6Module14global_objectsEv"]
    pub fn llvm_Module_global_objects(
        this: *mut llvm_Module,
    ) -> llvm_iterator_range<llvm_Module_global_object_iterator>;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4llvm6Module14global_objectsEv"]
    pub fn llvm_Module_global_objects1(
        this: *const llvm_Module,
    ) -> llvm_iterator_range<llvm_Module_const_global_object_iterator>;
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm6Module13global_valuesEv"]
    pub fn llvm_Module_global_values(
        this: *mut llvm_Module,
    ) -> llvm_iterator_range<llvm_Module_global_value_iterator>;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4llvm6Module13global_valuesEv"]
    pub fn llvm_Module_global_values1(
        this: *const llvm_Module,
    ) -> llvm_iterator_range<llvm_Module_const_global_value_iterator>;
}
extern "C" {
    #[doc = " Destroy ConstantArrays in LLVMContext if they are not used.\n ConstantArrays constructed during linking can cause quadratic memory\n explosion. Releasing all unused constants can cause a 20% LTO compile-time\n slowdown for a large application.\n\n NOTE: Constants are currently owned by LLVMContext. This can then only\n be called where all uses of the LLVMContext are understood."]
    #[link_name = "\u{1}_ZN4llvm6Module31dropTriviallyDeadConstantArraysEv"]
    pub fn llvm_Module_dropTriviallyDeadConstantArrays(this: *mut llvm_Module);
}
extern "C" {
    #[doc = " Print the module to an output stream with an optional\n AssemblyAnnotationWriter.  If \\c ShouldPreserveUseListOrder, then include\n uselistorder directives so that use-lists can be recreated when reading\n the assembly."]
    #[link_name = "\u{1}_ZNK4llvm6Module5printERNS_11raw_ostreamEPNS_24AssemblyAnnotationWriterEbb"]
    pub fn llvm_Module_print(
        this: *const llvm_Module,
        OS: *mut llvm_raw_ostream,
        AAW: *mut llvm_AssemblyAnnotationWriter,
        ShouldPreserveUseListOrder: bool,
        IsForDebug: bool,
    );
}
extern "C" {
    #[doc = " Dump the module to stderr (for debugging)."]
    #[link_name = "\u{1}_ZNK4llvm6Module4dumpEv"]
    pub fn llvm_Module_dump(this: *const llvm_Module);
}
extern "C" {
    #[doc = " This function causes all the subinstructions to \"let go\" of all references\n that they are maintaining.  This allows one to 'delete' a whole class at\n a time, even though there may be circular references... first all\n references are dropped, and all use counts go to zero.  Then everything\n is delete'd for real.  Note that no operations are valid on an object\n that has \"dropped all references\", except operator delete."]
    #[link_name = "\u{1}_ZN4llvm6Module17dropAllReferencesEv"]
    pub fn llvm_Module_dropAllReferences(this: *mut llvm_Module);
}
extern "C" {
    #[doc = " Returns the Number of Register ParametersDwarf Version by checking\n module flags."]
    #[link_name = "\u{1}_ZNK4llvm6Module27getNumberRegisterParametersEv"]
    pub fn llvm_Module_getNumberRegisterParameters(
        this: *const llvm_Module,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " Returns the Dwarf Version by checking module flags."]
    #[link_name = "\u{1}_ZNK4llvm6Module15getDwarfVersionEv"]
    pub fn llvm_Module_getDwarfVersion(this: *const llvm_Module) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " Returns the DWARF format by checking module flags."]
    #[link_name = "\u{1}_ZNK4llvm6Module9isDwarf64Ev"]
    pub fn llvm_Module_isDwarf64(this: *const llvm_Module) -> bool;
}
extern "C" {
    #[doc = " Returns the CodeView Version by checking module flags.\n Returns zero if not present in module."]
    #[link_name = "\u{1}_ZNK4llvm6Module15getCodeViewFlagEv"]
    pub fn llvm_Module_getCodeViewFlag(this: *const llvm_Module) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " Returns the PIC level (small or large model)"]
    #[link_name = "\u{1}_ZNK4llvm6Module11getPICLevelEv"]
    pub fn llvm_Module_getPICLevel(this: *const llvm_Module) -> llvm_PICLevel_Level;
}
extern "C" {
    #[doc = " Set the PIC level (small or large model)"]
    #[link_name = "\u{1}_ZN4llvm6Module11setPICLevelENS_8PICLevel5LevelE"]
    pub fn llvm_Module_setPICLevel(this: *mut llvm_Module, PL: llvm_PICLevel_Level);
}
extern "C" {
    #[doc = " Returns the PIE level (small or large model)"]
    #[link_name = "\u{1}_ZNK4llvm6Module11getPIELevelEv"]
    pub fn llvm_Module_getPIELevel(this: *const llvm_Module) -> llvm_PIELevel_Level;
}
extern "C" {
    #[doc = " Set the PIE level (small or large model)"]
    #[link_name = "\u{1}_ZN4llvm6Module11setPIELevelENS_8PIELevel5LevelE"]
    pub fn llvm_Module_setPIELevel(this: *mut llvm_Module, PL: llvm_PIELevel_Level);
}
extern "C" {
    #[doc = " Returns the code model (tiny, small, kernel, medium or large model)"]
    #[link_name = "\u{1}_ZNK4llvm6Module12getCodeModelEv"]
    pub fn llvm_Module_getCodeModel(this: *const llvm_Module) -> std_optional;
}
extern "C" {
    #[doc = " Set the code model (tiny, small, kernel, medium or large)"]
    #[link_name = "\u{1}_ZN4llvm6Module12setCodeModelENS_9CodeModel5ModelE"]
    pub fn llvm_Module_setCodeModel(this: *mut llvm_Module, CL: llvm_CodeModel_Model);
}
extern "C" {
    #[doc = " Returns the code model (tiny, small, kernel, medium or large model)"]
    #[link_name = "\u{1}_ZNK4llvm6Module21getLargeDataThresholdEv"]
    pub fn llvm_Module_getLargeDataThreshold(this: *const llvm_Module) -> std_optional;
}
extern "C" {
    #[doc = " Set the code model (tiny, small, kernel, medium or large)"]
    #[link_name = "\u{1}_ZN4llvm6Module21setLargeDataThresholdEm"]
    pub fn llvm_Module_setLargeDataThreshold(this: *mut llvm_Module, Threshold: u64);
}
extern "C" {
    #[doc = " Attach profile summary metadata to this module."]
    #[link_name = "\u{1}_ZN4llvm6Module17setProfileSummaryEPNS_8MetadataENS_14ProfileSummary4KindE"]
    pub fn llvm_Module_setProfileSummary(
        this: *mut llvm_Module,
        M: *mut llvm_Metadata,
        Kind: llvm_ProfileSummary_Kind,
    );
}
extern "C" {
    #[doc = " Returns profile summary metadata. When IsCS is true, use the context\n sensitive profile summary."]
    #[link_name = "\u{1}_ZNK4llvm6Module17getProfileSummaryEb"]
    pub fn llvm_Module_getProfileSummary(
        this: *const llvm_Module,
        IsCS: bool,
    ) -> *mut llvm_Metadata;
}
extern "C" {
    #[doc = " Returns whether semantic interposition is to be respected."]
    #[link_name = "\u{1}_ZNK4llvm6Module24getSemanticInterpositionEv"]
    pub fn llvm_Module_getSemanticInterposition(this: *const llvm_Module) -> bool;
}
extern "C" {
    #[doc = " Set whether semantic interposition is to be respected."]
    #[link_name = "\u{1}_ZN4llvm6Module24setSemanticInterpositionEb"]
    pub fn llvm_Module_setSemanticInterposition(this: *mut llvm_Module, arg1: bool);
}
extern "C" {
    #[doc = " Returns true if PLT should be avoided for RTLib calls."]
    #[link_name = "\u{1}_ZNK4llvm6Module14getRtLibUseGOTEv"]
    pub fn llvm_Module_getRtLibUseGOT(this: *const llvm_Module) -> bool;
}
extern "C" {
    #[doc = " Set that PLT should be avoid for RTLib calls."]
    #[link_name = "\u{1}_ZN4llvm6Module14setRtLibUseGOTEv"]
    pub fn llvm_Module_setRtLibUseGOT(this: *mut llvm_Module);
}
extern "C" {
    #[doc = " Get/set whether referencing global variables can use direct access\n relocations on ELF targets."]
    #[link_name = "\u{1}_ZNK4llvm6Module27getDirectAccessExternalDataEv"]
    pub fn llvm_Module_getDirectAccessExternalData(this: *const llvm_Module) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm6Module27setDirectAccessExternalDataEb"]
    pub fn llvm_Module_setDirectAccessExternalData(this: *mut llvm_Module, Value: bool);
}
extern "C" {
    #[doc = " Get/set whether synthesized functions should get the uwtable attribute."]
    #[link_name = "\u{1}_ZNK4llvm6Module10getUwtableEv"]
    pub fn llvm_Module_getUwtable(this: *const llvm_Module) -> llvm_UWTableKind;
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm6Module10setUwtableENS_11UWTableKindE"]
    pub fn llvm_Module_setUwtable(this: *mut llvm_Module, Kind: llvm_UWTableKind);
}
extern "C" {
    #[doc = " Get/set whether synthesized functions should get the \"frame-pointer\"\n attribute."]
    #[link_name = "\u{1}_ZNK4llvm6Module15getFramePointerEv"]
    pub fn llvm_Module_getFramePointer(this: *const llvm_Module) -> llvm_FramePointerKind;
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm6Module15setFramePointerENS_16FramePointerKindE"]
    pub fn llvm_Module_setFramePointer(this: *mut llvm_Module, Kind: llvm_FramePointerKind);
}
extern "C" {
    #[doc = " Get/set what kind of stack protector guard to use."]
    #[link_name = "\u{1}_ZNK4llvm6Module22getStackProtectorGuardEv"]
    pub fn llvm_Module_getStackProtectorGuard(this: *const llvm_Module) -> llvm_StringRef;
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm6Module22setStackProtectorGuardENS_9StringRefE"]
    pub fn llvm_Module_setStackProtectorGuard(this: *mut llvm_Module, Kind: llvm_StringRef);
}
extern "C" {
    #[doc = " Get/set which register to use as the stack protector guard register. The\n empty string is equivalent to \"global\". Other values may be \"tls\" or\n \"sysreg\"."]
    #[link_name = "\u{1}_ZNK4llvm6Module25getStackProtectorGuardRegEv"]
    pub fn llvm_Module_getStackProtectorGuardReg(this: *const llvm_Module) -> llvm_StringRef;
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm6Module25setStackProtectorGuardRegENS_9StringRefE"]
    pub fn llvm_Module_setStackProtectorGuardReg(this: *mut llvm_Module, Reg: llvm_StringRef);
}
extern "C" {
    #[doc = " Get/set a symbol to use as the stack protector guard."]
    #[link_name = "\u{1}_ZNK4llvm6Module28getStackProtectorGuardSymbolEv"]
    pub fn llvm_Module_getStackProtectorGuardSymbol(this: *const llvm_Module) -> llvm_StringRef;
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm6Module28setStackProtectorGuardSymbolENS_9StringRefE"]
    pub fn llvm_Module_setStackProtectorGuardSymbol(this: *mut llvm_Module, Symbol: llvm_StringRef);
}
extern "C" {
    #[doc = " Get/set what offset from the stack protector to use."]
    #[link_name = "\u{1}_ZNK4llvm6Module28getStackProtectorGuardOffsetEv"]
    pub fn llvm_Module_getStackProtectorGuardOffset(
        this: *const llvm_Module,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm6Module28setStackProtectorGuardOffsetEi"]
    pub fn llvm_Module_setStackProtectorGuardOffset(
        this: *mut llvm_Module,
        Offset: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " Get/set the stack alignment overridden from the default."]
    #[link_name = "\u{1}_ZNK4llvm6Module25getOverrideStackAlignmentEv"]
    pub fn llvm_Module_getOverrideStackAlignment(
        this: *const llvm_Module,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm6Module25setOverrideStackAlignmentEj"]
    pub fn llvm_Module_setOverrideStackAlignment(
        this: *mut llvm_Module,
        Align: ::std::os::raw::c_uint,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK4llvm6Module18getMaxTLSAlignmentEv"]
    pub fn llvm_Module_getMaxTLSAlignment(this: *const llvm_Module) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " Attach a build SDK version metadata to this module."]
    #[link_name = "\u{1}_ZN4llvm6Module13setSDKVersionERKNS_12VersionTupleE"]
    pub fn llvm_Module_setSDKVersion(this: *mut llvm_Module, V: *const llvm_VersionTuple);
}
extern "C" {
    #[doc = " Get the build SDK version metadata.\n\n An empty version is returned if no such metadata is attached."]
    #[link_name = "\u{1}_ZNK4llvm6Module13getSDKVersionEv"]
    pub fn llvm_Module_getSDKVersion(this: *const llvm_Module) -> llvm_VersionTuple;
}
extern "C" {
    #[doc = " Take ownership of the given memory buffer."]
    #[link_name = "\u{1}_ZN4llvm6Module20setOwnedMemoryBufferESt10unique_ptrINS_12MemoryBufferESt14default_deleteIS2_EE"]
    pub fn llvm_Module_setOwnedMemoryBuffer(this: *mut llvm_Module, MB: std_unique_ptr);
}
extern "C" {
    #[doc = " Set the partial sample profile ratio in the profile summary module flag,\n if applicable."]
    #[link_name = "\u{1}_ZN4llvm6Module28setPartialSampleProfileRatioERKNS_18ModuleSummaryIndexE"]
    pub fn llvm_Module_setPartialSampleProfileRatio(
        this: *mut llvm_Module,
        Index: *const llvm_ModuleSummaryIndex,
    );
}
extern "C" {
    #[doc = " Get the target variant triple which is a string describing a variant of\n the target host platform. For example, Mac Catalyst can be a variant\n target triple for a macOS target.\n @returns a string containing the target variant triple."]
    #[link_name = "\u{1}_ZNK4llvm6Module28getDarwinTargetVariantTripleEv"]
    pub fn llvm_Module_getDarwinTargetVariantTriple(this: *const llvm_Module) -> llvm_StringRef;
}
extern "C" {
    #[doc = " Set the target variant triple which is a string describing a variant of\n the target host platform."]
    #[link_name = "\u{1}_ZN4llvm6Module28setDarwinTargetVariantTripleENS_9StringRefE"]
    pub fn llvm_Module_setDarwinTargetVariantTriple(this: *mut llvm_Module, T: llvm_StringRef);
}
extern "C" {
    #[doc = " Get the target variant version build SDK version metadata.\n\n An empty version is returned if no such metadata is attached."]
    #[link_name = "\u{1}_ZNK4llvm6Module32getDarwinTargetVariantSDKVersionEv"]
    pub fn llvm_Module_getDarwinTargetVariantSDKVersion(
        this: *const llvm_Module,
    ) -> llvm_VersionTuple;
}
extern "C" {
    #[doc = " Set the target variant version build SDK version metadata."]
    #[link_name = "\u{1}_ZN4llvm6Module32setDarwinTargetVariantSDKVersionENS_12VersionTupleE"]
    pub fn llvm_Module_setDarwinTargetVariantSDKVersion(
        this: *mut llvm_Module,
        Version: llvm_VersionTuple,
    );
}
extern "C" {
    #[doc = " The Module constructor. Note that there is no default constructor. You\n must provide a name for the module upon construction."]
    #[link_name = "\u{1}_ZN4llvm6ModuleC1ENS_9StringRefERNS_11LLVMContextE"]
    pub fn llvm_Module_Module(
        this: *mut llvm_Module,
        ModuleID: llvm_StringRef,
        C: *mut llvm_LLVMContext,
    );
}
extern "C" {
    #[doc = " The module destructor. This will dropAllReferences."]
    #[link_name = "\u{1}_ZN4llvm6ModuleD1Ev"]
    pub fn llvm_Module_Module_destructor(this: *mut llvm_Module);
}
impl llvm_Module {
    #[inline]
    pub unsafe fn isValidModFlagBehavior(
        MD: *mut llvm_Metadata,
        MFB: *mut llvm_Module_ModFlagBehavior,
    ) -> bool {
        llvm_Module_isValidModFlagBehavior(MD, MFB)
    }
    #[inline]
    pub unsafe fn removeDebugIntrinsicDeclarations(&mut self) {
        llvm_Module_removeDebugIntrinsicDeclarations(self)
    }
    #[inline]
    pub unsafe fn getInstructionCount(&self) -> ::std::os::raw::c_uint {
        llvm_Module_getInstructionCount(self)
    }
    #[inline]
    pub unsafe fn createRNG(&self, Name: llvm_StringRef) -> std_unique_ptr {
        llvm_Module_createRNG(self, Name)
    }
    #[inline]
    pub unsafe fn setDataLayout(&mut self, Desc: llvm_StringRef) {
        llvm_Module_setDataLayout(self, Desc)
    }
    #[inline]
    pub unsafe fn setDataLayout1(&mut self, Other: *const llvm_DataLayout) {
        llvm_Module_setDataLayout1(self, Other)
    }
    #[inline]
    pub unsafe fn getNamedValue(&self, Name: llvm_StringRef) -> *mut llvm_GlobalValue {
        llvm_Module_getNamedValue(self, Name)
    }
    #[inline]
    pub unsafe fn getNumNamedValues(&self) -> ::std::os::raw::c_uint {
        llvm_Module_getNumNamedValues(self)
    }
    #[inline]
    pub unsafe fn getMDKindID(&self, Name: llvm_StringRef) -> ::std::os::raw::c_uint {
        llvm_Module_getMDKindID(self, Name)
    }
    #[inline]
    pub unsafe fn getMDKindNames(&self, Result: *mut llvm_SmallVectorImpl) {
        llvm_Module_getMDKindNames(self, Result)
    }
    #[inline]
    pub unsafe fn getOperandBundleTags(&self, Result: *mut llvm_SmallVectorImpl) {
        llvm_Module_getOperandBundleTags(self, Result)
    }
    #[inline]
    pub unsafe fn getIdentifiedStructTypes(&self) -> std_vector {
        llvm_Module_getIdentifiedStructTypes(self)
    }
    #[inline]
    pub unsafe fn getUniqueIntrinsicName(
        &mut self,
        BaseName: llvm_StringRef,
        Id: llvm_Intrinsic_ID,
        Proto: *const llvm_FunctionType,
    ) -> std_string {
        llvm_Module_getUniqueIntrinsicName(self, BaseName, Id, Proto)
    }
    #[inline]
    pub unsafe fn getOrInsertFunction(
        &mut self,
        Name: llvm_StringRef,
        T: *mut llvm_FunctionType,
        AttributeList: llvm_AttributeList,
    ) -> llvm_FunctionCallee {
        llvm_Module_getOrInsertFunction(self, Name, T, AttributeList)
    }
    #[inline]
    pub unsafe fn getOrInsertFunction1(
        &mut self,
        Name: llvm_StringRef,
        T: *mut llvm_FunctionType,
    ) -> llvm_FunctionCallee {
        llvm_Module_getOrInsertFunction1(self, Name, T)
    }
    #[inline]
    pub unsafe fn getFunction(&self, Name: llvm_StringRef) -> *mut llvm_Function {
        llvm_Module_getFunction(self, Name)
    }
    #[inline]
    pub unsafe fn getGlobalVariable(
        &self,
        Name: llvm_StringRef,
        AllowInternal: bool,
    ) -> *mut llvm_GlobalVariable {
        llvm_Module_getGlobalVariable(self, Name, AllowInternal)
    }
    #[inline]
    pub unsafe fn getOrInsertGlobal(
        &mut self,
        Name: llvm_StringRef,
        Ty: *mut llvm_Type,
        CreateGlobalCallback: llvm_function_ref,
    ) -> *mut llvm_Constant {
        llvm_Module_getOrInsertGlobal(self, Name, Ty, CreateGlobalCallback)
    }
    #[inline]
    pub unsafe fn getOrInsertGlobal1(
        &mut self,
        Name: llvm_StringRef,
        Ty: *mut llvm_Type,
    ) -> *mut llvm_Constant {
        llvm_Module_getOrInsertGlobal1(self, Name, Ty)
    }
    #[inline]
    pub unsafe fn getNamedAlias(&self, Name: llvm_StringRef) -> *mut llvm_GlobalAlias {
        llvm_Module_getNamedAlias(self, Name)
    }
    #[inline]
    pub unsafe fn getNamedIFunc(&self, Name: llvm_StringRef) -> *mut llvm_GlobalIFunc {
        llvm_Module_getNamedIFunc(self, Name)
    }
    #[inline]
    pub unsafe fn getNamedMetadata(&self, Name: llvm_StringRef) -> *mut llvm_NamedMDNode {
        llvm_Module_getNamedMetadata(self, Name)
    }
    #[inline]
    pub unsafe fn getOrInsertNamedMetadata(
        &mut self,
        Name: llvm_StringRef,
    ) -> *mut llvm_NamedMDNode {
        llvm_Module_getOrInsertNamedMetadata(self, Name)
    }
    #[inline]
    pub unsafe fn eraseNamedMetadata(&mut self, NMD: *mut llvm_NamedMDNode) {
        llvm_Module_eraseNamedMetadata(self, NMD)
    }
    #[inline]
    pub unsafe fn getOrInsertComdat(&mut self, Name: llvm_StringRef) -> *mut llvm_Comdat {
        llvm_Module_getOrInsertComdat(self, Name)
    }
    #[inline]
    pub unsafe fn getModuleFlagsMetadata(&self, Flags: *mut llvm_SmallVectorImpl) {
        llvm_Module_getModuleFlagsMetadata(self, Flags)
    }
    #[inline]
    pub unsafe fn getModuleFlag(&self, Key: llvm_StringRef) -> *mut llvm_Metadata {
        llvm_Module_getModuleFlag(self, Key)
    }
    #[inline]
    pub unsafe fn getOrInsertModuleFlagsMetadata(&mut self) -> *mut llvm_NamedMDNode {
        llvm_Module_getOrInsertModuleFlagsMetadata(self)
    }
    #[inline]
    pub unsafe fn addModuleFlag(
        &mut self,
        Behavior: llvm_Module_ModFlagBehavior,
        Key: llvm_StringRef,
        Val: *mut llvm_Metadata,
    ) {
        llvm_Module_addModuleFlag(self, Behavior, Key, Val)
    }
    #[inline]
    pub unsafe fn addModuleFlag1(
        &mut self,
        Behavior: llvm_Module_ModFlagBehavior,
        Key: llvm_StringRef,
        Val: *mut llvm_Constant,
    ) {
        llvm_Module_addModuleFlag1(self, Behavior, Key, Val)
    }
    #[inline]
    pub unsafe fn addModuleFlag2(
        &mut self,
        Behavior: llvm_Module_ModFlagBehavior,
        Key: llvm_StringRef,
        Val: u32,
    ) {
        llvm_Module_addModuleFlag2(self, Behavior, Key, Val)
    }
    #[inline]
    pub unsafe fn addModuleFlag3(&mut self, Node: *mut llvm_MDNode) {
        llvm_Module_addModuleFlag3(self, Node)
    }
    #[inline]
    pub unsafe fn setModuleFlag(
        &mut self,
        Behavior: llvm_Module_ModFlagBehavior,
        Key: llvm_StringRef,
        Val: *mut llvm_Metadata,
    ) {
        llvm_Module_setModuleFlag(self, Behavior, Key, Val)
    }
    #[inline]
    pub unsafe fn setModuleFlag1(
        &mut self,
        Behavior: llvm_Module_ModFlagBehavior,
        Key: llvm_StringRef,
        Val: *mut llvm_Constant,
    ) {
        llvm_Module_setModuleFlag1(self, Behavior, Key, Val)
    }
    #[inline]
    pub unsafe fn setModuleFlag2(
        &mut self,
        Behavior: llvm_Module_ModFlagBehavior,
        Key: llvm_StringRef,
        Val: u32,
    ) {
        llvm_Module_setModuleFlag2(self, Behavior, Key, Val)
    }
    #[inline]
    pub unsafe fn setMaterializer(&mut self, GVM: *mut llvm_GVMaterializer) {
        llvm_Module_setMaterializer(self, GVM)
    }
    #[inline]
    pub unsafe fn materialize(&mut self, GV: *mut llvm_GlobalValue) -> llvm_Error {
        llvm_Module_materialize(self, GV)
    }
    #[inline]
    pub unsafe fn materializeAll(&mut self) -> llvm_Error {
        llvm_Module_materializeAll(self)
    }
    #[inline]
    pub unsafe fn materializeMetadata(&mut self) -> llvm_Error {
        llvm_Module_materializeMetadata(self)
    }
    #[inline]
    pub unsafe fn global_objects(
        &mut self,
    ) -> llvm_iterator_range<llvm_Module_global_object_iterator> {
        llvm_Module_global_objects(self)
    }
    #[inline]
    pub unsafe fn global_objects1(
        &self,
    ) -> llvm_iterator_range<llvm_Module_const_global_object_iterator> {
        llvm_Module_global_objects1(self)
    }
    #[inline]
    pub unsafe fn global_values(
        &mut self,
    ) -> llvm_iterator_range<llvm_Module_global_value_iterator> {
        llvm_Module_global_values(self)
    }
    #[inline]
    pub unsafe fn global_values1(
        &self,
    ) -> llvm_iterator_range<llvm_Module_const_global_value_iterator> {
        llvm_Module_global_values1(self)
    }
    #[inline]
    pub unsafe fn dropTriviallyDeadConstantArrays(&mut self) {
        llvm_Module_dropTriviallyDeadConstantArrays(self)
    }
    #[inline]
    pub unsafe fn print(
        &self,
        OS: *mut llvm_raw_ostream,
        AAW: *mut llvm_AssemblyAnnotationWriter,
        ShouldPreserveUseListOrder: bool,
        IsForDebug: bool,
    ) {
        llvm_Module_print(self, OS, AAW, ShouldPreserveUseListOrder, IsForDebug)
    }
    #[inline]
    pub unsafe fn dump(&self) {
        llvm_Module_dump(self)
    }
    #[inline]
    pub unsafe fn dropAllReferences(&mut self) {
        llvm_Module_dropAllReferences(self)
    }
    #[inline]
    pub unsafe fn getNumberRegisterParameters(&self) -> ::std::os::raw::c_uint {
        llvm_Module_getNumberRegisterParameters(self)
    }
    #[inline]
    pub unsafe fn getDwarfVersion(&self) -> ::std::os::raw::c_uint {
        llvm_Module_getDwarfVersion(self)
    }
    #[inline]
    pub unsafe fn isDwarf64(&self) -> bool {
        llvm_Module_isDwarf64(self)
    }
    #[inline]
    pub unsafe fn getCodeViewFlag(&self) -> ::std::os::raw::c_uint {
        llvm_Module_getCodeViewFlag(self)
    }
    #[inline]
    pub unsafe fn getPICLevel(&self) -> llvm_PICLevel_Level {
        llvm_Module_getPICLevel(self)
    }
    #[inline]
    pub unsafe fn setPICLevel(&mut self, PL: llvm_PICLevel_Level) {
        llvm_Module_setPICLevel(self, PL)
    }
    #[inline]
    pub unsafe fn getPIELevel(&self) -> llvm_PIELevel_Level {
        llvm_Module_getPIELevel(self)
    }
    #[inline]
    pub unsafe fn setPIELevel(&mut self, PL: llvm_PIELevel_Level) {
        llvm_Module_setPIELevel(self, PL)
    }
    #[inline]
    pub unsafe fn getCodeModel(&self) -> std_optional {
        llvm_Module_getCodeModel(self)
    }
    #[inline]
    pub unsafe fn setCodeModel(&mut self, CL: llvm_CodeModel_Model) {
        llvm_Module_setCodeModel(self, CL)
    }
    #[inline]
    pub unsafe fn getLargeDataThreshold(&self) -> std_optional {
        llvm_Module_getLargeDataThreshold(self)
    }
    #[inline]
    pub unsafe fn setLargeDataThreshold(&mut self, Threshold: u64) {
        llvm_Module_setLargeDataThreshold(self, Threshold)
    }
    #[inline]
    pub unsafe fn setProfileSummary(
        &mut self,
        M: *mut llvm_Metadata,
        Kind: llvm_ProfileSummary_Kind,
    ) {
        llvm_Module_setProfileSummary(self, M, Kind)
    }
    #[inline]
    pub unsafe fn getProfileSummary(&self, IsCS: bool) -> *mut llvm_Metadata {
        llvm_Module_getProfileSummary(self, IsCS)
    }
    #[inline]
    pub unsafe fn getSemanticInterposition(&self) -> bool {
        llvm_Module_getSemanticInterposition(self)
    }
    #[inline]
    pub unsafe fn setSemanticInterposition(&mut self, arg1: bool) {
        llvm_Module_setSemanticInterposition(self, arg1)
    }
    #[inline]
    pub unsafe fn getRtLibUseGOT(&self) -> bool {
        llvm_Module_getRtLibUseGOT(self)
    }
    #[inline]
    pub unsafe fn setRtLibUseGOT(&mut self) {
        llvm_Module_setRtLibUseGOT(self)
    }
    #[inline]
    pub unsafe fn getDirectAccessExternalData(&self) -> bool {
        llvm_Module_getDirectAccessExternalData(self)
    }
    #[inline]
    pub unsafe fn setDirectAccessExternalData(&mut self, Value: bool) {
        llvm_Module_setDirectAccessExternalData(self, Value)
    }
    #[inline]
    pub unsafe fn getUwtable(&self) -> llvm_UWTableKind {
        llvm_Module_getUwtable(self)
    }
    #[inline]
    pub unsafe fn setUwtable(&mut self, Kind: llvm_UWTableKind) {
        llvm_Module_setUwtable(self, Kind)
    }
    #[inline]
    pub unsafe fn getFramePointer(&self) -> llvm_FramePointerKind {
        llvm_Module_getFramePointer(self)
    }
    #[inline]
    pub unsafe fn setFramePointer(&mut self, Kind: llvm_FramePointerKind) {
        llvm_Module_setFramePointer(self, Kind)
    }
    #[inline]
    pub unsafe fn getStackProtectorGuard(&self) -> llvm_StringRef {
        llvm_Module_getStackProtectorGuard(self)
    }
    #[inline]
    pub unsafe fn setStackProtectorGuard(&mut self, Kind: llvm_StringRef) {
        llvm_Module_setStackProtectorGuard(self, Kind)
    }
    #[inline]
    pub unsafe fn getStackProtectorGuardReg(&self) -> llvm_StringRef {
        llvm_Module_getStackProtectorGuardReg(self)
    }
    #[inline]
    pub unsafe fn setStackProtectorGuardReg(&mut self, Reg: llvm_StringRef) {
        llvm_Module_setStackProtectorGuardReg(self, Reg)
    }
    #[inline]
    pub unsafe fn getStackProtectorGuardSymbol(&self) -> llvm_StringRef {
        llvm_Module_getStackProtectorGuardSymbol(self)
    }
    #[inline]
    pub unsafe fn setStackProtectorGuardSymbol(&mut self, Symbol: llvm_StringRef) {
        llvm_Module_setStackProtectorGuardSymbol(self, Symbol)
    }
    #[inline]
    pub unsafe fn getStackProtectorGuardOffset(&self) -> ::std::os::raw::c_int {
        llvm_Module_getStackProtectorGuardOffset(self)
    }
    #[inline]
    pub unsafe fn setStackProtectorGuardOffset(&mut self, Offset: ::std::os::raw::c_int) {
        llvm_Module_setStackProtectorGuardOffset(self, Offset)
    }
    #[inline]
    pub unsafe fn getOverrideStackAlignment(&self) -> ::std::os::raw::c_uint {
        llvm_Module_getOverrideStackAlignment(self)
    }
    #[inline]
    pub unsafe fn setOverrideStackAlignment(&mut self, Align: ::std::os::raw::c_uint) {
        llvm_Module_setOverrideStackAlignment(self, Align)
    }
    #[inline]
    pub unsafe fn getMaxTLSAlignment(&self) -> ::std::os::raw::c_uint {
        llvm_Module_getMaxTLSAlignment(self)
    }
    #[inline]
    pub unsafe fn setSDKVersion(&mut self, V: *const llvm_VersionTuple) {
        llvm_Module_setSDKVersion(self, V)
    }
    #[inline]
    pub unsafe fn getSDKVersion(&self) -> llvm_VersionTuple {
        llvm_Module_getSDKVersion(self)
    }
    #[inline]
    pub unsafe fn setOwnedMemoryBuffer(&mut self, MB: std_unique_ptr) {
        llvm_Module_setOwnedMemoryBuffer(self, MB)
    }
    #[inline]
    pub unsafe fn setPartialSampleProfileRatio(&mut self, Index: *const llvm_ModuleSummaryIndex) {
        llvm_Module_setPartialSampleProfileRatio(self, Index)
    }
    #[inline]
    pub unsafe fn getDarwinTargetVariantTriple(&self) -> llvm_StringRef {
        llvm_Module_getDarwinTargetVariantTriple(self)
    }
    #[inline]
    pub unsafe fn setDarwinTargetVariantTriple(&mut self, T: llvm_StringRef) {
        llvm_Module_setDarwinTargetVariantTriple(self, T)
    }
    #[inline]
    pub unsafe fn getDarwinTargetVariantSDKVersion(&self) -> llvm_VersionTuple {
        llvm_Module_getDarwinTargetVariantSDKVersion(self)
    }
    #[inline]
    pub unsafe fn setDarwinTargetVariantSDKVersion(&mut self, Version: llvm_VersionTuple) {
        llvm_Module_setDarwinTargetVariantSDKVersion(self, Version)
    }
    #[inline]
    pub unsafe fn new(ModuleID: llvm_StringRef, C: *mut llvm_LLVMContext) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        llvm_Module_Module(__bindgen_tmp.as_mut_ptr(), ModuleID, C);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn destruct(&mut self) {
        llvm_Module_Module_destructor(self)
    }
}
extern "C" {
    #[doc = " Given \"llvm.used\" or \"llvm.compiler.used\" as a global name, collect the\n initializer elements of that global in a SmallVector and return the global\n itself."]
    #[link_name = "\u{1}_ZN4llvm26collectUsedGlobalVariablesERKNS_6ModuleERNS_15SmallVectorImplIPNS_11GlobalValueEEEb"]
    pub fn llvm_collectUsedGlobalVariables(
        M: *const llvm_Module,
        Vec: *mut llvm_SmallVectorImpl,
        CompilerUsed: bool,
    ) -> *mut llvm_GlobalVariable;
}
pub const llvm_BitstreamWrapperHeader_BWH_MagicField: llvm_BitstreamWrapperHeader = 0;
pub const llvm_BitstreamWrapperHeader_BWH_VersionField: llvm_BitstreamWrapperHeader = 4;
pub const llvm_BitstreamWrapperHeader_BWH_OffsetField: llvm_BitstreamWrapperHeader = 8;
pub const llvm_BitstreamWrapperHeader_BWH_SizeField: llvm_BitstreamWrapperHeader = 12;
pub const llvm_BitstreamWrapperHeader_BWH_CPUTypeField: llvm_BitstreamWrapperHeader = 16;
pub const llvm_BitstreamWrapperHeader_BWH_HeaderSize: llvm_BitstreamWrapperHeader = 20;
#[doc = " Offsets of the 32-bit fields of bitstream wrapper header."]
pub type llvm_BitstreamWrapperHeader = ::std::os::raw::c_uint;
pub const llvm_bitc_StandardWidths_BlockIDWidth: llvm_bitc_StandardWidths = 8;
pub const llvm_bitc_StandardWidths_CodeLenWidth: llvm_bitc_StandardWidths = 4;
pub const llvm_bitc_StandardWidths_BlockSizeWidth: llvm_bitc_StandardWidths = 32;
pub type llvm_bitc_StandardWidths = ::std::os::raw::c_uint;
pub const llvm_bitc_FixedAbbrevIDs_END_BLOCK: llvm_bitc_FixedAbbrevIDs = 0;
pub const llvm_bitc_FixedAbbrevIDs_ENTER_SUBBLOCK: llvm_bitc_FixedAbbrevIDs = 1;
#[doc = " DEFINE_ABBREV - Defines an abbrev for the current block.  It consists\n of a vbr5 for # operand infos.  Each operand info is emitted with a\n single bit to indicate if it is a literal encoding.  If so, the value is\n emitted with a vbr8.  If not, the encoding is emitted as 3 bits followed\n by the info value as a vbr5 if needed."]
pub const llvm_bitc_FixedAbbrevIDs_DEFINE_ABBREV: llvm_bitc_FixedAbbrevIDs = 2;
pub const llvm_bitc_FixedAbbrevIDs_UNABBREV_RECORD: llvm_bitc_FixedAbbrevIDs = 3;
pub const llvm_bitc_FixedAbbrevIDs_FIRST_APPLICATION_ABBREV: llvm_bitc_FixedAbbrevIDs = 4;
pub type llvm_bitc_FixedAbbrevIDs = ::std::os::raw::c_uint;
#[doc = " BLOCKINFO_BLOCK is used to define metadata about blocks, for example,\n standard abbrevs that should be available to all blocks of a specified\n ID."]
pub const llvm_bitc_StandardBlockIDs_BLOCKINFO_BLOCK_ID: llvm_bitc_StandardBlockIDs = 0;
#[doc = " BLOCKINFO_BLOCK is used to define metadata about blocks, for example,\n standard abbrevs that should be available to all blocks of a specified\n ID."]
pub const llvm_bitc_StandardBlockIDs_FIRST_APPLICATION_BLOCKID: llvm_bitc_StandardBlockIDs = 8;
#[doc = " StandardBlockIDs - All bitcode files can optionally include a BLOCKINFO\n block, which contains metadata about other blocks in the file."]
pub type llvm_bitc_StandardBlockIDs = ::std::os::raw::c_uint;
pub const llvm_bitc_BlockInfoCodes_BLOCKINFO_CODE_SETBID: llvm_bitc_BlockInfoCodes = 1;
pub const llvm_bitc_BlockInfoCodes_BLOCKINFO_CODE_BLOCKNAME: llvm_bitc_BlockInfoCodes = 2;
pub const llvm_bitc_BlockInfoCodes_BLOCKINFO_CODE_SETRECORDNAME: llvm_bitc_BlockInfoCodes = 3;
#[doc = " BlockInfoCodes - The blockinfo block contains metadata about user-defined\n blocks."]
pub type llvm_bitc_BlockInfoCodes = ::std::os::raw::c_uint;
pub const aligned: llvm_support__bindgen_ty_1 = 0;
pub const unaligned: llvm_support__bindgen_ty_1 = 1;
pub type llvm_support__bindgen_ty_1 = ::std::os::raw::c_uint;
pub const llvm_support_detail_PickAlignment_value: llvm_support_detail_PickAlignment__bindgen_ty_1 =
    0;
pub type llvm_support_detail_PickAlignment__bindgen_ty_1 = i32;
pub type llvm_support_detail_packed_endian_specific_integral_value_type<ValueType> = ValueType;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_support_detail_packed_endian_specific_integral__bindgen_ty_1 {
    pub buffer: *mut ::std::os::raw::c_char,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_support_detail_packed_endian_specific_integral_ref {
    pub Ptr: *mut ::std::os::raw::c_void,
}
#[repr(C)]
pub struct llvm_support_detail_format_adapter__bindgen_vtable(::std::os::raw::c_void);
#[repr(C)]
#[derive(Debug)]
pub struct llvm_support_detail_format_adapter {
    pub vtable_: *const llvm_support_detail_format_adapter__bindgen_vtable,
}
#[test]
fn bindgen_test_layout_llvm_support_detail_format_adapter() {
    assert_eq!(
        ::std::mem::size_of::<llvm_support_detail_format_adapter>(),
        8usize,
        concat!("Size of: ", stringify!(llvm_support_detail_format_adapter))
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_support_detail_format_adapter>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(llvm_support_detail_format_adapter)
        )
    );
}
#[repr(C)]
#[derive(Debug)]
pub struct llvm_support_detail_provider_format_adapter<T> {
    pub _base: llvm_support_detail_format_adapter,
    pub Item: T,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<T>>,
}
#[repr(C)]
#[derive(Debug)]
pub struct llvm_support_detail_stream_operator_format_adapter<T> {
    pub _base: llvm_support_detail_format_adapter,
    pub Item: T,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<T>>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_support_detail_missing_format_adapter {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_support_detail_has_FormatProvider {
    pub _address: u8,
}
pub type llvm_support_detail_has_FormatProvider_Decayed = std_decay_t;
pub type llvm_support_detail_has_FormatProvider_Signature_format = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *const llvm_support_detail_has_FormatProvider_Decayed,
        arg2: *mut llvm_raw_ostream,
        arg3: llvm_StringRef,
    ),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_support_detail_has_StreamOperator {
    pub _address: u8,
}
pub type llvm_support_detail_has_StreamOperator_ConstRefT = *const std_decay_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_support_detail_uses_format_member {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_support_detail_uses_format_provider {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_support_detail_uses_stream_operator {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_support_detail_uses_missing_provider {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_support_detail_use_integral_formatter {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_support_detail_use_char_formatter {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_support_detail_is_cstring {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_support_detail_use_string_formatter {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_support_detail_use_pointer_formatter {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_support_detail_use_double_formatter {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_support_detail_HelperFunctions {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_llvm_support_detail_HelperFunctions() {
    assert_eq!(
        ::std::mem::size_of::<llvm_support_detail_HelperFunctions>(),
        1usize,
        concat!("Size of: ", stringify!(llvm_support_detail_HelperFunctions))
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_support_detail_HelperFunctions>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(llvm_support_detail_HelperFunctions)
        )
    );
}
pub type llvm_support_detail_IterValue = std_iterator_traits;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_support_detail_range_item_has_provider {
    pub _address: u8,
}
pub type llvm_support_endian_make_unsigned_t = std_make_unsigned_t;
pub type llvm_support_ulittle16_t = [u8; 2usize];
pub type llvm_support_ulittle32_t = [u8; 4usize];
pub type llvm_support_ulittle64_t = [u8; 8usize];
pub type llvm_support_little16_t = u8;
pub type llvm_support_little32_t = u8;
pub type llvm_support_little64_t = u8;
pub type llvm_support_aligned_ulittle16_t = u8;
pub type llvm_support_aligned_ulittle32_t = u8;
pub type llvm_support_aligned_ulittle64_t = u8;
pub type llvm_support_aligned_little16_t = u8;
pub type llvm_support_aligned_little32_t = u8;
pub type llvm_support_aligned_little64_t = u8;
pub type llvm_support_ubig16_t = [u8; 2usize];
pub type llvm_support_ubig32_t = [u8; 4usize];
pub type llvm_support_ubig64_t = [u8; 8usize];
pub type llvm_support_big16_t = u8;
pub type llvm_support_big32_t = u8;
pub type llvm_support_big64_t = u8;
pub type llvm_support_aligned_ubig16_t = u8;
pub type llvm_support_aligned_ubig32_t = u8;
pub type llvm_support_aligned_ubig64_t = u8;
pub type llvm_support_aligned_big16_t = u8;
pub type llvm_support_aligned_big32_t = u8;
pub type llvm_support_aligned_big64_t = u8;
pub type llvm_support_unaligned_uint16_t = [u8; 2usize];
pub type llvm_support_unaligned_uint32_t = [u8; 4usize];
pub type llvm_support_unaligned_uint64_t = [u8; 8usize];
pub type llvm_support_unaligned_int16_t = u8;
pub type llvm_support_unaligned_int32_t = u8;
pub type llvm_support_unaligned_int64_t = u8;
pub type llvm_support_little_t = u8;
pub type llvm_support_big_t = u8;
pub type llvm_support_aligned_little_t = u8;
pub type llvm_support_aligned_big_t = u8;
extern "C" {
    #[doc = " isCurrentDebugType - Return true if the specified string is the debug type\n specified on the command line, or if none was specified on the command line\n with the -debug-only=X option.\n"]
    #[link_name = "\u{1}_ZN4llvm18isCurrentDebugTypeEPKc"]
    pub fn llvm_isCurrentDebugType(Type: *const ::std::os::raw::c_char) -> bool;
}
extern "C" {
    #[doc = " setCurrentDebugType - Set the current debug type, as if the -debug-only=X\n option were specified.  Note that DebugFlag also needs to be set to true for\n debug output to be produced.\n"]
    #[link_name = "\u{1}_ZN4llvm19setCurrentDebugTypeEPKc"]
    pub fn llvm_setCurrentDebugType(Type: *const ::std::os::raw::c_char);
}
extern "C" {
    #[doc = " setCurrentDebugTypes - Set the current debug type, as if the\n -debug-only=X,Y,Z option were specified. Note that DebugFlag\n also needs to be set to true for debug output to be produced.\n"]
    #[link_name = "\u{1}_ZN4llvm20setCurrentDebugTypesEPPKcj"]
    pub fn llvm_setCurrentDebugTypes(
        Types: *mut *const ::std::os::raw::c_char,
        Count: ::std::os::raw::c_uint,
    );
}
extern "C" {
    #[doc = " This boolean is set to true if the '-debug' command line option\n is specified.  This should probably not be referenced directly, instead, use\n the DEBUG macro below.\n"]
    #[link_name = "\u{1}_ZN4llvm9DebugFlagE"]
    pub static mut llvm_DebugFlag: bool;
}
extern "C" {
    #[doc = " EnableDebugBuffering - This defaults to false.  If true, the debug\n stream will install signal handlers to dump any buffered debug\n output.  It allows clients to selectively allow the debug stream\n to install signal handlers if they are certain there will be no\n conflict.\n"]
    #[link_name = "\u{1}_ZN4llvm20EnableDebugBufferingE"]
    pub static mut llvm_EnableDebugBuffering: bool;
}
extern "C" {
    #[doc = " dbgs() - This returns a reference to a raw_ostream for debugging\n messages.  If debugging is disabled it returns errs().  Use it\n like: dbgs() << \"foo\" << \"bar\";"]
    #[link_name = "\u{1}_ZN4llvm4dbgsEv"]
    pub fn llvm_dbgs() -> *mut llvm_raw_ostream;
}
#[repr(C)]
pub struct llvm_format_object_base__bindgen_vtable(::std::os::raw::c_void);
#[doc = " This is a helper class used for handling formatted output.  It is the\n abstract base class of a templated derived class."]
#[repr(C)]
#[derive(Debug)]
pub struct llvm_format_object_base {
    pub vtable_: *const llvm_format_object_base__bindgen_vtable,
    pub Fmt: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_llvm_format_object_base() {
    const UNINIT: ::std::mem::MaybeUninit<llvm_format_object_base> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<llvm_format_object_base>(),
        16usize,
        concat!("Size of: ", stringify!(llvm_format_object_base))
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_format_object_base>(),
        8usize,
        concat!("Alignment of ", stringify!(llvm_format_object_base))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Fmt) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_format_object_base),
            "::",
            stringify!(Fmt)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm18format_object_base4homeEv"]
    pub fn llvm_format_object_base_home(this: *mut ::std::os::raw::c_void);
}
#[doc = " These are templated helper classes used by the format function that\n capture the object to be formatted and the format string. When actually\n printed, this synthesizes the string into a temporary buffer provided and\n returns whether or not it is big enough."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_validate_format_parameters {
    pub _address: u8,
}
#[test]
fn __bindgen_test_layout_llvm_validate_format_parameters_open0_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<llvm_validate_format_parameters>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_validate_format_parameters)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_validate_format_parameters>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_validate_format_parameters)
        )
    );
}
#[repr(C)]
#[derive(Debug)]
pub struct llvm_format_object {
    pub _base: llvm_format_object_base,
    pub Vals: std_tuple,
}
#[doc = " This is a helper class for left_justify, right_justify, and center_justify."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_FormattedString {
    pub Str: llvm_StringRef,
    pub Width: ::std::os::raw::c_uint,
    pub Justify: llvm_FormattedString_Justification,
}
pub const llvm_FormattedString_Justification_JustifyNone: llvm_FormattedString_Justification = 0;
pub const llvm_FormattedString_Justification_JustifyLeft: llvm_FormattedString_Justification = 1;
pub const llvm_FormattedString_Justification_JustifyRight: llvm_FormattedString_Justification = 2;
pub const llvm_FormattedString_Justification_JustifyCenter: llvm_FormattedString_Justification = 3;
pub type llvm_FormattedString_Justification = ::std::os::raw::c_uint;
#[test]
fn bindgen_test_layout_llvm_FormattedString() {
    const UNINIT: ::std::mem::MaybeUninit<llvm_FormattedString> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<llvm_FormattedString>(),
        24usize,
        concat!("Size of: ", stringify!(llvm_FormattedString))
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_FormattedString>(),
        8usize,
        concat!("Alignment of ", stringify!(llvm_FormattedString))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Str) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_FormattedString),
            "::",
            stringify!(Str)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Width) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_FormattedString),
            "::",
            stringify!(Width)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Justify) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_FormattedString),
            "::",
            stringify!(Justify)
        )
    );
}
#[doc = " This is a helper class used for format_hex() and format_decimal()."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_FormattedNumber {
    pub HexValue: u64,
    pub DecValue: i64,
    pub Width: ::std::os::raw::c_uint,
    pub Hex: bool,
    pub Upper: bool,
    pub HexPrefix: bool,
}
#[test]
fn bindgen_test_layout_llvm_FormattedNumber() {
    const UNINIT: ::std::mem::MaybeUninit<llvm_FormattedNumber> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<llvm_FormattedNumber>(),
        24usize,
        concat!("Size of: ", stringify!(llvm_FormattedNumber))
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_FormattedNumber>(),
        8usize,
        concat!("Alignment of ", stringify!(llvm_FormattedNumber))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).HexValue) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_FormattedNumber),
            "::",
            stringify!(HexValue)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).DecValue) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_FormattedNumber),
            "::",
            stringify!(DecValue)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Width) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_FormattedNumber),
            "::",
            stringify!(Width)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Hex) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_FormattedNumber),
            "::",
            stringify!(Hex)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Upper) as usize - ptr as usize },
        21usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_FormattedNumber),
            "::",
            stringify!(Upper)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).HexPrefix) as usize - ptr as usize },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_FormattedNumber),
            "::",
            stringify!(HexPrefix)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_FormattedBytes {
    pub Bytes: llvm_ArrayRef<u8>,
    pub FirstByteOffset: std_optional,
    pub IndentLevel: u32,
    pub NumPerLine: u32,
    pub ByteGroupSize: u8,
    pub Upper: bool,
    pub ASCII: bool,
}
#[test]
fn bindgen_test_layout_llvm_FormattedBytes() {
    const UNINIT: ::std::mem::MaybeUninit<llvm_FormattedBytes> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<llvm_FormattedBytes>(),
        48usize,
        concat!("Size of: ", stringify!(llvm_FormattedBytes))
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_FormattedBytes>(),
        8usize,
        concat!("Alignment of ", stringify!(llvm_FormattedBytes))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Bytes) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_FormattedBytes),
            "::",
            stringify!(Bytes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).FirstByteOffset) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_FormattedBytes),
            "::",
            stringify!(FirstByteOffset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).IndentLevel) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_FormattedBytes),
            "::",
            stringify!(IndentLevel)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).NumPerLine) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_FormattedBytes),
            "::",
            stringify!(NumPerLine)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ByteGroupSize) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_FormattedBytes),
            "::",
            stringify!(ByteGroupSize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Upper) as usize - ptr as usize },
        41usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_FormattedBytes),
            "::",
            stringify!(Upper)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ASCII) as usize - ptr as usize },
        42usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_FormattedBytes),
            "::",
            stringify!(ASCII)
        )
    );
}
#[repr(C)]
pub struct llvm_ErrorInfoBase__bindgen_vtable(::std::os::raw::c_void);
#[doc = " Base class for error info classes. Do not extend this directly: Extend\n the ErrorInfo template subclass instead."]
#[repr(C)]
#[derive(Debug)]
pub struct llvm_ErrorInfoBase {
    pub vtable_: *const llvm_ErrorInfoBase__bindgen_vtable,
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm13ErrorInfoBase2IDE"]
    pub static mut llvm_ErrorInfoBase_ID: ::std::os::raw::c_char;
}
#[test]
fn bindgen_test_layout_llvm_ErrorInfoBase() {
    assert_eq!(
        ::std::mem::size_of::<llvm_ErrorInfoBase>(),
        8usize,
        concat!("Size of: ", stringify!(llvm_ErrorInfoBase))
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_ErrorInfoBase>(),
        8usize,
        concat!("Alignment of ", stringify!(llvm_ErrorInfoBase))
    );
}
#[doc = " Lightweight error class with error context and mandatory checking.\n\n Instances of this class wrap a ErrorInfoBase pointer. Failure states\n are represented by setting the pointer to a ErrorInfoBase subclass\n instance containing information describing the failure. Success is\n represented by a null pointer value.\n\n Instances of Error also contains a 'Checked' flag, which must be set\n before the destructor is called, otherwise the destructor will trigger a\n runtime error. This enforces at runtime the requirement that all Error\n instances be checked or returned to the caller.\n\n There are two ways to set the checked flag, depending on what state the\n Error instance is in. For Error instances indicating success, it\n is sufficient to invoke the boolean conversion operator. E.g.:\n\n   @code{.cpp}\n   Error foo(<...>);\n\n   if (auto E = foo(<...>))\n     return E; // <- Return E if it is in the error state.\n   // We have verified that E was in the success state. It can now be safely\n   // destroyed.\n   @endcode\n\n A success value *can not* be dropped. For example, just calling 'foo(<...>)'\n without testing the return value will raise a runtime error, even if foo\n returns success.\n\n For Error instances representing failure, you must use either the\n handleErrors or handleAllErrors function with a typed handler. E.g.:\n\n   @code{.cpp}\n   class MyErrorInfo : public ErrorInfo<MyErrorInfo> {\n     // Custom error info.\n   };\n\n   Error foo(<...>) { return make_error<MyErrorInfo>(...); }\n\n   auto E = foo(<...>); // <- foo returns failure with MyErrorInfo.\n   auto NewE =\n     handleErrors(std::move(E),\n       [](const MyErrorInfo &M) {\n         // Deal with the error.\n       },\n       [](std::unique_ptr<OtherError> M) -> Error {\n         if (canHandle(*M)) {\n           // handle error.\n           return Error::success();\n         }\n         // Couldn't handle this error instance. Pass it up the stack.\n         return Error(std::move(M));\n     });\n   // Note - The error passed to handleErrors will be marked as checked. If\n   // there is no matched handler, a new error with the same payload is\n   // created and returned.\n   // The handlers take the error checked by handleErrors as an argument,\n   // which can be used to retrieve more information. If a new error is\n   // created by a handler, it will be passed back to the caller of\n   // handleErrors and needs to be checked or return up to the stack.\n   // Otherwise, the passed-in error is considered consumed.\n   @endcode\n\n The handleAllErrors function is identical to handleErrors, except\n that it has a void return type, and requires all errors to be handled and\n no new errors be returned. It prevents errors (assuming they can all be\n handled) from having to be bubbled all the way to the top-level.\n\n *All* Error instances must be checked before destruction, even if\n they're moved-assigned or constructed from Success values that have already\n been checked. This enforces checking through all levels of the call stack."]
#[repr(C)]
#[derive(Debug)]
pub struct llvm_Error {
    pub Payload: *mut llvm_ErrorInfoBase,
}
#[test]
fn bindgen_test_layout_llvm_Error() {
    const UNINIT: ::std::mem::MaybeUninit<llvm_Error> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<llvm_Error>(),
        8usize,
        concat!("Size of: ", stringify!(llvm_Error))
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_Error>(),
        8usize,
        concat!("Alignment of ", stringify!(llvm_Error))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Payload) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_Error),
            "::",
            stringify!(Payload)
        )
    );
}
#[doc = " Subclass of Error for the sole purpose of identifying the success path in\n the type system. This allows to catch invalid conversion to Expected<T> at\n compile time."]
#[repr(C)]
#[derive(Debug)]
pub struct llvm_ErrorSuccess {
    pub _base: llvm_Error,
}
#[test]
fn bindgen_test_layout_llvm_ErrorSuccess() {
    assert_eq!(
        ::std::mem::size_of::<llvm_ErrorSuccess>(),
        8usize,
        concat!("Size of: ", stringify!(llvm_ErrorSuccess))
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_ErrorSuccess>(),
        8usize,
        concat!("Alignment of ", stringify!(llvm_ErrorSuccess))
    );
}
#[doc = " Base class for user error types. Users should declare their error types\n like:\n\n class MyError : public ErrorInfo<MyError> {\n   ....\n };\n\n This class provides an implementation of the ErrorInfoBase::kind\n method, which is used by the Error RTTI system."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_ErrorInfo<ParentErrT> {
    pub _base: ParentErrT,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<ParentErrT>>,
}
#[repr(C)]
pub struct llvm_ErrorList__bindgen_vtable(::std::os::raw::c_void);
#[doc = " Special ErrorInfo subclass representing a list of ErrorInfos.\n Instances of this class are constructed by joinError."]
#[repr(C)]
pub struct llvm_ErrorList {
    pub vtable_: *const llvm_ErrorList__bindgen_vtable,
    pub _base: llvm_ErrorInfo<llvm_ErrorInfoBase>,
    pub Payloads: std_vector,
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm9ErrorList2IDE"]
    pub static mut llvm_ErrorList_ID: ::std::os::raw::c_char;
}
#[test]
fn bindgen_test_layout_llvm_ErrorList() {
    const UNINIT: ::std::mem::MaybeUninit<llvm_ErrorList> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<llvm_ErrorList>(),
        32usize,
        concat!("Size of: ", stringify!(llvm_ErrorList))
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_ErrorList>(),
        8usize,
        concat!("Alignment of ", stringify!(llvm_ErrorList))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Payloads) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_ErrorList),
            "::",
            stringify!(Payloads)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK4llvm9ErrorList18convertToErrorCodeEv"]
    pub fn llvm_ErrorList_convertToErrorCode(this: *mut ::std::os::raw::c_void) -> std_error_code;
}
#[doc = " Tagged union holding either a T or a Error.\n\n This class parallels ErrorOr, but replaces error_code with Error. Since\n Error cannot be copied, this class replaces getError() with\n takeError(). It also adds an bool errorIsA<ErrT>() method for testing the\n error class type.\n\n Example usage of 'Expected<T>' as a function return type:\n\n   @code{.cpp}\n     Expected<int> myDivide(int A, int B) {\n       if (B == 0) {\n         // return an Error\n         return createStringError(inconvertibleErrorCode(),\n                                  \"B must not be zero!\");\n       }\n       // return an integer\n       return A / B;\n     }\n   @endcode\n\n   Checking the results of to a function returning 'Expected<T>':\n   @code{.cpp}\n     if (auto E = Result.takeError()) {\n       // We must consume the error. Typically one of:\n       // - return the error to our caller\n       // - toString(), when logging\n       // - consumeError(), to silently swallow the error\n       // - handleErrors(), to distinguish error types\n       errs() << \"Problem with division \" << toString(std::move(E)) << \"\\n\";\n       return;\n     }\n     // use the result\n     outs() << \"The answer is \" << *Result << \"\\n\";\n   @endcode\n\n  For unit-testing a function returning an 'Expected<T>', see the\n  'EXPECT_THAT_EXPECTED' macros in llvm/Testing/Support/Error.h"]
#[repr(C)]
pub struct llvm_Expected {
    pub __bindgen_anon_1: llvm_Expected__bindgen_ty_1,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
pub type llvm_Expected_wrap = std_reference_wrapper<_Tp>;
pub type llvm_Expected_error_type = std_unique_ptr;
pub type llvm_Expected_storage_type = std_conditional_t;
pub type llvm_Expected_value_type<T> = T;
pub type llvm_Expected_reference = *mut std_remove_reference_t;
pub type llvm_Expected_const_reference = *const std_remove_reference_t;
pub type llvm_Expected_pointer = *mut std_remove_reference_t;
pub type llvm_Expected_const_pointer = *const std_remove_reference_t;
#[repr(C)]
pub struct llvm_Expected__bindgen_ty_1 {
    pub TStorage: __BindgenUnionField<llvm_AlignedCharArrayUnion>,
    pub ErrorStorage: __BindgenUnionField<llvm_AlignedCharArrayUnion>,
    pub bindgen_union_field: u64,
}
impl llvm_Expected {
    #[inline]
    pub fn HasError(&self) -> bool {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_HasError(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Unchecked(&self) -> bool {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_Unchecked(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(HasError: bool, Unchecked: bool) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let HasError: u8 = unsafe { ::std::mem::transmute(HasError) };
            HasError as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let Unchecked: u8 = unsafe { ::std::mem::transmute(Unchecked) };
            Unchecked as u64
        });
        __bindgen_bitfield_unit
    }
}
extern "C" {
    #[doc = " Report a serious error, calling any installed error handler. See\n ErrorHandling.h."]
    #[link_name = "\u{1}_ZN4llvm18report_fatal_errorENS_5ErrorEb"]
    pub fn llvm_report_fatal_error3(Err: llvm_Error, gen_crash_diag: bool);
}
#[doc = " Helper for testing applicability of, and applying, handlers for\n ErrorInfo types."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_ErrorHandlerTraits {
    pub _address: u8,
}
extern "C" {
    #[doc = " Log all errors (if any) in E to OS. If there are any errors, ErrorBanner\n will be printed before the first one is logged. A newline will be printed\n after each error.\n\n This function is compatible with the helpers from Support/WithColor.h. You\n can pass any of them as the OS. Please consider using them instead of\n including 'error: ' in the ErrorBanner.\n\n This is useful in the base level of your program to allow clean termination\n (allowing clean deallocation of resources, etc.), while reporting error\n information to the user."]
    #[link_name = "\u{1}_ZN4llvm21logAllUnhandledErrorsENS_5ErrorERNS_11raw_ostreamENS_5TwineE"]
    pub fn llvm_logAllUnhandledErrors(
        E: llvm_Error,
        OS: *mut llvm_raw_ostream,
        ErrorBanner: llvm_Twine,
    );
}
extern "C" {
    #[doc = " Write all error messages (if any) in E to a string. The newline character\n is used to separate error messages."]
    #[link_name = "\u{1}_ZN4llvm8toStringB5cxx11ENS_5ErrorE"]
    pub fn llvm_toString(E: llvm_Error) -> std_string;
}
extern "C" {
    #[doc = " Like toString(), but does not consume the error. This can be used to print\n a warning while retaining the original error object."]
    #[link_name = "\u{1}_ZN4llvm24toStringWithoutConsumingB5cxx11ERKNS_5ErrorE"]
    pub fn llvm_toStringWithoutConsuming(E: *const llvm_Error) -> std_string;
}
#[doc = " Helper for Errors used as out-parameters.\n\n This helper is for use with the Error-as-out-parameter idiom, where an error\n is passed to a function or method by reference, rather than being returned.\n In such cases it is helpful to set the checked bit on entry to the function\n so that the error can be written to (unchecked Errors abort on assignment)\n and clear the checked bit on exit so that clients cannot accidentally forget\n to check the result. This helper performs these actions automatically using\n RAII:\n\n   @code{.cpp}\n   Result foo(Error &Err) {\n     ErrorAsOutParameter ErrAsOutParam(&Err); // 'Checked' flag set\n     // <body of foo>\n     // <- 'Checked' flag auto-cleared when ErrAsOutParam is destructed.\n   }\n   @endcode\n\n ErrorAsOutParameter takes an Error* rather than Error& so that it can be\n used with optional Errors (Error pointers that are allowed to be null). If\n ErrorAsOutParameter took an Error reference, an instance would have to be\n created inside every condition that verified that Error was non-null. By\n taking an Error pointer we can just create one instance at the top of the\n function."]
#[repr(C)]
#[derive(Debug)]
pub struct llvm_ErrorAsOutParameter {
    pub Err: *mut llvm_Error,
}
#[test]
fn bindgen_test_layout_llvm_ErrorAsOutParameter() {
    const UNINIT: ::std::mem::MaybeUninit<llvm_ErrorAsOutParameter> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<llvm_ErrorAsOutParameter>(),
        8usize,
        concat!("Size of: ", stringify!(llvm_ErrorAsOutParameter))
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_ErrorAsOutParameter>(),
        8usize,
        concat!("Alignment of ", stringify!(llvm_ErrorAsOutParameter))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Err) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_ErrorAsOutParameter),
            "::",
            stringify!(Err)
        )
    );
}
#[doc = " Helper for Expected<T>s used as out-parameters.\n\n See ErrorAsOutParameter."]
#[repr(C)]
#[derive(Debug)]
pub struct llvm_ExpectedAsOutParameter {
    pub ValOrErr: *mut llvm_Expected,
}
#[repr(C)]
pub struct llvm_ECError__bindgen_vtable(::std::os::raw::c_void);
#[doc = " This class wraps a std::error_code in a Error.\n\n This is useful if you're writing an interface that returns a Error\n (or Expected) and you want to call code that still returns\n std::error_codes."]
#[repr(C)]
#[derive(Debug)]
pub struct llvm_ECError {
    pub vtable_: *const llvm_ECError__bindgen_vtable,
    pub _base: llvm_ErrorInfo<llvm_ErrorInfoBase>,
    pub EC: std_error_code,
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm7ECError2IDE"]
    pub static mut llvm_ECError_ID: ::std::os::raw::c_char;
}
#[test]
fn bindgen_test_layout_llvm_ECError() {
    const UNINIT: ::std::mem::MaybeUninit<llvm_ECError> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<llvm_ECError>(),
        24usize,
        concat!("Size of: ", stringify!(llvm_ECError))
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_ECError>(),
        8usize,
        concat!("Alignment of ", stringify!(llvm_ECError))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).EC) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_ECError),
            "::",
            stringify!(EC)
        )
    );
}
extern "C" {
    #[doc = " The value returned by this function can be returned from convertToErrorCode\n for Error values where no sensible translation to std::error_code exists.\n It should only be used in this situation, and should never be used where a\n sensible conversion to std::error_code is available, as attempts to convert\n to/from this error will result in a fatal error. (i.e. it is a programmatic\n error to try to convert such a value)."]
    #[link_name = "\u{1}_ZN4llvm22inconvertibleErrorCodeEv"]
    pub fn llvm_inconvertibleErrorCode() -> std_error_code;
}
extern "C" {
    #[doc = " Helper for converting an std::error_code to a Error."]
    #[link_name = "\u{1}_ZN4llvm16errorCodeToErrorESt10error_code"]
    pub fn llvm_errorCodeToError(EC: std_error_code) -> llvm_Error;
}
extern "C" {
    #[doc = " Helper for converting an ECError to a std::error_code.\n\n This method requires that Err be Error() or an ECError, otherwise it\n will trigger a call to abort()."]
    #[link_name = "\u{1}_ZN4llvm16errorToErrorCodeENS_5ErrorE"]
    pub fn llvm_errorToErrorCode(Err: llvm_Error) -> std_error_code;
}
#[repr(C)]
pub struct llvm_StringError__bindgen_vtable(::std::os::raw::c_void);
#[doc = " This class wraps a string in an Error.\n\n StringError is useful in cases where the client is not expected to be able\n to consume the specific error message programmatically (for example, if the\n error message is to be presented to the user).\n\n StringError can also be used when additional information is to be printed\n along with a error_code message. Depending on the constructor called, this\n class can either display:\n    1. the error_code message (ECError behavior)\n    2. a string\n    3. the error_code message and a string\n\n These behaviors are useful when subtyping is required; for example, when a\n specific library needs an explicit error type. In the example below,\n PDBError is derived from StringError:\n\n   @code{.cpp}\n   Expected<int> foo() {\n      return llvm::make_error<PDBError>(pdb_error_code::dia_failed_loading,\n                                        \"Additional information\");\n   }\n   @endcode\n"]
#[repr(C)]
pub struct llvm_StringError {
    pub vtable_: *const llvm_StringError__bindgen_vtable,
    pub _base: llvm_ErrorInfo<llvm_ErrorInfoBase>,
    pub Msg: std_string,
    pub EC: std_error_code,
    pub PrintMsgOnly: bool,
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm11StringError2IDE"]
    pub static mut llvm_StringError_ID: ::std::os::raw::c_char;
}
#[test]
fn bindgen_test_layout_llvm_StringError() {
    const UNINIT: ::std::mem::MaybeUninit<llvm_StringError> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<llvm_StringError>(),
        64usize,
        concat!("Size of: ", stringify!(llvm_StringError))
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_StringError>(),
        8usize,
        concat!("Alignment of ", stringify!(llvm_StringError))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Msg) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_StringError),
            "::",
            stringify!(Msg)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).EC) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_StringError),
            "::",
            stringify!(EC)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).PrintMsgOnly) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_StringError),
            "::",
            stringify!(PrintMsgOnly)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm11StringErrorC1EONSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEESt10error_codeb"]
    pub fn llvm_StringError_StringError(
        this: *mut llvm_StringError,
        S: *mut std_string,
        EC: std_error_code,
        PrintMsgOnly: bool,
    );
}
extern "C" {
    #[doc = " Prints EC + S and converts to EC."]
    #[link_name = "\u{1}_ZN4llvm11StringErrorC1ESt10error_codeRKNS_5TwineE"]
    pub fn llvm_StringError_StringError1(
        this: *mut llvm_StringError,
        EC: std_error_code,
        S: *const llvm_Twine,
    );
}
extern "C" {
    #[doc = " Prints S and converts to EC."]
    #[link_name = "\u{1}_ZN4llvm11StringErrorC1ERKNS_5TwineESt10error_code"]
    pub fn llvm_StringError_StringError2(
        this: *mut llvm_StringError,
        S: *const llvm_Twine,
        EC: std_error_code,
    );
}
impl llvm_StringError {
    #[inline]
    pub unsafe fn new(S: *mut std_string, EC: std_error_code, PrintMsgOnly: bool) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        llvm_StringError_StringError(__bindgen_tmp.as_mut_ptr(), S, EC, PrintMsgOnly);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(EC: std_error_code, S: *const llvm_Twine) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        llvm_StringError_StringError1(__bindgen_tmp.as_mut_ptr(), EC, S);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new2(S: *const llvm_Twine, EC: std_error_code) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        llvm_StringError_StringError2(__bindgen_tmp.as_mut_ptr(), S, EC);
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[link_name = "\u{1}_ZNK4llvm11StringError3logERNS_11raw_ostreamE"]
    pub fn llvm_StringError_log(this: *mut ::std::os::raw::c_void, OS: *mut llvm_raw_ostream);
}
extern "C" {
    #[link_name = "\u{1}_ZNK4llvm11StringError18convertToErrorCodeEv"]
    pub fn llvm_StringError_convertToErrorCode(this: *mut ::std::os::raw::c_void)
        -> std_error_code;
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm17createStringErrorEONSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEESt10error_code"]
    pub fn llvm_createStringError(Msg: *mut std_string, EC: std_error_code) -> llvm_Error;
}
#[repr(C)]
pub struct llvm_FileError__bindgen_vtable(::std::os::raw::c_void);
#[doc = " This class wraps a filename and another Error.\n\n In some cases, an error needs to live along a 'source' name, in order to\n show more detailed information to the user."]
#[repr(C)]
pub struct llvm_FileError {
    pub vtable_: *const llvm_FileError__bindgen_vtable,
    pub _base: llvm_ErrorInfo<llvm_ErrorInfoBase>,
    pub FileName: std_string,
    pub Line: std_optional,
    pub Err: std_unique_ptr,
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm9FileError2IDE"]
    pub static mut llvm_FileError_ID: ::std::os::raw::c_char;
}
#[test]
fn bindgen_test_layout_llvm_FileError() {
    const UNINIT: ::std::mem::MaybeUninit<llvm_FileError> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<llvm_FileError>(),
        64usize,
        concat!("Size of: ", stringify!(llvm_FileError))
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_FileError>(),
        8usize,
        concat!("Alignment of ", stringify!(llvm_FileError))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).FileName) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_FileError),
            "::",
            stringify!(FileName)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Line) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_FileError),
            "::",
            stringify!(Line)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Err) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_FileError),
            "::",
            stringify!(Err)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK4llvm9FileError18convertToErrorCodeEv"]
    pub fn llvm_FileError_convertToErrorCode(this: *mut ::std::os::raw::c_void) -> std_error_code;
}
#[doc = " Helper for check-and-exit error handling.\n\n For tool use only. NOT FOR USE IN LIBRARY CODE.\n"]
#[repr(C)]
pub struct llvm_ExitOnError {
    pub Banner: std_string,
    pub GetExitCode: [u64; 4usize],
}
#[test]
fn bindgen_test_layout_llvm_ExitOnError() {
    const UNINIT: ::std::mem::MaybeUninit<llvm_ExitOnError> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<llvm_ExitOnError>(),
        64usize,
        concat!("Size of: ", stringify!(llvm_ExitOnError))
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_ExitOnError>(),
        8usize,
        concat!("Alignment of ", stringify!(llvm_ExitOnError))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Banner) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_ExitOnError),
            "::",
            stringify!(Banner)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).GetExitCode) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_ExitOnError),
            "::",
            stringify!(GetExitCode)
        )
    );
}
pub type llvm_DataLayoutCallbackFuncTy = [u64; 4usize];
pub type llvm_GetTypeByIDTy = std_function;
pub type llvm_GetContainedTypeIDTy = std_function;
pub type llvm_ValueTypeCallbackTy = [u64; 4usize];
pub type llvm_MDTypeCallbackTy = [u64; 4usize];
extern "C" {
    #[link_name = "\u{1}_ZN4llvm29errorToErrorCodeAndEmitErrorsERNS_11LLVMContextENS_5ErrorE"]
    pub fn llvm_errorToErrorCodeAndEmitErrors(
        Ctx: *mut llvm_LLVMContext,
        Err: llvm_Error,
    ) -> std_error_code;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_ParserCallbacks {
    pub DataLayout: std_optional,
    #[doc = " The ValueType callback is called for every function definition or\n declaration and allows accessing the type information, also behind\n pointers. This can be useful, when the opaque pointer upgrade cleans all\n type information behind pointers.\n The second argument to ValueTypeCallback is the type ID of the\n function, the two passed functions can be used to extract type\n information."]
    pub ValueType: std_optional,
    #[doc = " The MDType callback is called for every value in metadata."]
    pub MDType: std_optional,
}
#[test]
fn bindgen_test_layout_llvm_ParserCallbacks() {
    const UNINIT: ::std::mem::MaybeUninit<llvm_ParserCallbacks> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<llvm_ParserCallbacks>(),
        120usize,
        concat!("Size of: ", stringify!(llvm_ParserCallbacks))
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_ParserCallbacks>(),
        8usize,
        concat!("Alignment of ", stringify!(llvm_ParserCallbacks))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).DataLayout) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_ParserCallbacks),
            "::",
            stringify!(DataLayout)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ValueType) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_ParserCallbacks),
            "::",
            stringify!(ValueType)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).MDType) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_ParserCallbacks),
            "::",
            stringify!(MDType)
        )
    );
}
#[doc = " Basic information extracted from a bitcode module to be used for LTO."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_BitcodeLTOInfo {
    pub IsThinLTO: bool,
    pub HasSummary: bool,
    pub EnableSplitLTOUnit: bool,
    pub UnifiedLTO: bool,
}
#[test]
fn bindgen_test_layout_llvm_BitcodeLTOInfo() {
    const UNINIT: ::std::mem::MaybeUninit<llvm_BitcodeLTOInfo> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<llvm_BitcodeLTOInfo>(),
        4usize,
        concat!("Size of: ", stringify!(llvm_BitcodeLTOInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_BitcodeLTOInfo>(),
        1usize,
        concat!("Alignment of ", stringify!(llvm_BitcodeLTOInfo))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).IsThinLTO) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_BitcodeLTOInfo),
            "::",
            stringify!(IsThinLTO)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).HasSummary) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_BitcodeLTOInfo),
            "::",
            stringify!(HasSummary)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).EnableSplitLTOUnit) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_BitcodeLTOInfo),
            "::",
            stringify!(EnableSplitLTOUnit)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).UnifiedLTO) as usize - ptr as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_BitcodeLTOInfo),
            "::",
            stringify!(UnifiedLTO)
        )
    );
}
#[doc = " Represents a module in a bitcode file."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_BitcodeModule {
    pub Buffer: llvm_ArrayRef<u8>,
    pub ModuleIdentifier: llvm_StringRef,
    pub Strtab: llvm_StringRef,
    pub IdentificationBit: u64,
    pub ModuleBit: u64,
}
#[test]
fn bindgen_test_layout_llvm_BitcodeModule() {
    const UNINIT: ::std::mem::MaybeUninit<llvm_BitcodeModule> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<llvm_BitcodeModule>(),
        64usize,
        concat!("Size of: ", stringify!(llvm_BitcodeModule))
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_BitcodeModule>(),
        8usize,
        concat!("Alignment of ", stringify!(llvm_BitcodeModule))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Buffer) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_BitcodeModule),
            "::",
            stringify!(Buffer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ModuleIdentifier) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_BitcodeModule),
            "::",
            stringify!(ModuleIdentifier)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Strtab) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_BitcodeModule),
            "::",
            stringify!(Strtab)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).IdentificationBit) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_BitcodeModule),
            "::",
            stringify!(IdentificationBit)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ModuleBit) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_BitcodeModule),
            "::",
            stringify!(ModuleBit)
        )
    );
}
extern "C" {
    #[doc = " Read the bitcode module and prepare for lazy deserialization of function\n bodies. If ShouldLazyLoadMetadata is true, lazily load metadata as well.\n If IsImporting is true, this module is being parsed for ThinLTO\n importing into another module."]
    #[link_name = "\u{1}_ZN4llvm13BitcodeModule13getLazyModuleERNS_11LLVMContextEbbNS_15ParserCallbacksE"]
    pub fn llvm_BitcodeModule_getLazyModule(
        this: *mut llvm_BitcodeModule,
        Context: *mut llvm_LLVMContext,
        ShouldLazyLoadMetadata: bool,
        IsImporting: bool,
        Callbacks: llvm_ParserCallbacks,
    ) -> llvm_Expected;
}
extern "C" {
    #[doc = " Read the entire bitcode module and return it."]
    #[link_name = "\u{1}_ZN4llvm13BitcodeModule11parseModuleERNS_11LLVMContextENS_15ParserCallbacksE"]
    pub fn llvm_BitcodeModule_parseModule(
        this: *mut llvm_BitcodeModule,
        Context: *mut llvm_LLVMContext,
        Callbacks: llvm_ParserCallbacks,
    ) -> llvm_Expected;
}
extern "C" {
    #[doc = " Returns information about the module to be used for LTO: whether to\n compile with ThinLTO, and whether it has a summary."]
    #[link_name = "\u{1}_ZN4llvm13BitcodeModule10getLTOInfoEv"]
    pub fn llvm_BitcodeModule_getLTOInfo(this: *mut llvm_BitcodeModule) -> llvm_Expected;
}
extern "C" {
    #[doc = " Parse the specified bitcode buffer, returning the module summary index."]
    #[link_name = "\u{1}_ZN4llvm13BitcodeModule10getSummaryEv"]
    pub fn llvm_BitcodeModule_getSummary(this: *mut llvm_BitcodeModule) -> llvm_Expected;
}
extern "C" {
    #[doc = " Parse the specified bitcode buffer and merge its module summary index\n into CombinedIndex."]
    #[link_name = "\u{1}_ZN4llvm13BitcodeModule11readSummaryERNS_18ModuleSummaryIndexENS_9StringRefESt8functionIFbmEE"]
    pub fn llvm_BitcodeModule_readSummary(
        this: *mut llvm_BitcodeModule,
        CombinedIndex: *mut llvm_ModuleSummaryIndex,
        ModulePath: llvm_StringRef,
        IsPrevailing: [u64; 4usize],
    ) -> llvm_Error;
}
impl llvm_BitcodeModule {
    #[inline]
    pub unsafe fn getLazyModule(
        &mut self,
        Context: *mut llvm_LLVMContext,
        ShouldLazyLoadMetadata: bool,
        IsImporting: bool,
        Callbacks: llvm_ParserCallbacks,
    ) -> llvm_Expected {
        llvm_BitcodeModule_getLazyModule(
            self,
            Context,
            ShouldLazyLoadMetadata,
            IsImporting,
            Callbacks,
        )
    }
    #[inline]
    pub unsafe fn parseModule(
        &mut self,
        Context: *mut llvm_LLVMContext,
        Callbacks: llvm_ParserCallbacks,
    ) -> llvm_Expected {
        llvm_BitcodeModule_parseModule(self, Context, Callbacks)
    }
    #[inline]
    pub unsafe fn getLTOInfo(&mut self) -> llvm_Expected {
        llvm_BitcodeModule_getLTOInfo(self)
    }
    #[inline]
    pub unsafe fn getSummary(&mut self) -> llvm_Expected {
        llvm_BitcodeModule_getSummary(self)
    }
    #[inline]
    pub unsafe fn readSummary(
        &mut self,
        CombinedIndex: *mut llvm_ModuleSummaryIndex,
        ModulePath: llvm_StringRef,
        IsPrevailing: [u64; 4usize],
    ) -> llvm_Error {
        llvm_BitcodeModule_readSummary(self, CombinedIndex, ModulePath, IsPrevailing)
    }
}
#[repr(C)]
pub struct llvm_BitcodeFileContents {
    pub Mods: std_vector,
    pub Symtab: llvm_StringRef,
    pub StrtabForSymtab: llvm_StringRef,
}
#[test]
fn bindgen_test_layout_llvm_BitcodeFileContents() {
    const UNINIT: ::std::mem::MaybeUninit<llvm_BitcodeFileContents> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<llvm_BitcodeFileContents>(),
        56usize,
        concat!("Size of: ", stringify!(llvm_BitcodeFileContents))
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_BitcodeFileContents>(),
        8usize,
        concat!("Alignment of ", stringify!(llvm_BitcodeFileContents))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Mods) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_BitcodeFileContents),
            "::",
            stringify!(Mods)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Symtab) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_BitcodeFileContents),
            "::",
            stringify!(Symtab)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).StrtabForSymtab) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_BitcodeFileContents),
            "::",
            stringify!(StrtabForSymtab)
        )
    );
}
extern "C" {
    #[doc = " Returns the contents of a bitcode file. This includes the raw contents of\n the symbol table embedded in the bitcode file. Clients which require a\n symbol table should prefer to use irsymtab::read instead of this function\n because it creates a reader for the irsymtab and handles upgrading bitcode\n files without a symbol table or with an old symbol table."]
    #[link_name = "\u{1}_ZN4llvm22getBitcodeFileContentsENS_15MemoryBufferRefE"]
    pub fn llvm_getBitcodeFileContents(Buffer: llvm_MemoryBufferRef) -> llvm_Expected;
}
extern "C" {
    #[doc = " Returns a list of modules in the specified bitcode buffer."]
    #[link_name = "\u{1}_ZN4llvm20getBitcodeModuleListENS_15MemoryBufferRefE"]
    pub fn llvm_getBitcodeModuleList(Buffer: llvm_MemoryBufferRef) -> llvm_Expected;
}
extern "C" {
    #[doc = " Read the header of the specified bitcode buffer and prepare for lazy\n deserialization of function bodies. If ShouldLazyLoadMetadata is true,\n lazily load metadata as well. If IsImporting is true, this module is\n being parsed for ThinLTO importing into another module."]
    #[link_name = "\u{1}_ZN4llvm20getLazyBitcodeModuleENS_15MemoryBufferRefERNS_11LLVMContextEbbNS_15ParserCallbacksE"]
    pub fn llvm_getLazyBitcodeModule(
        Buffer: llvm_MemoryBufferRef,
        Context: *mut llvm_LLVMContext,
        ShouldLazyLoadMetadata: bool,
        IsImporting: bool,
        Callbacks: llvm_ParserCallbacks,
    ) -> llvm_Expected;
}
extern "C" {
    #[doc = " Like getLazyBitcodeModule, except that the module takes ownership of\n the memory buffer if successful. If successful, this moves Buffer. On\n error, this *does not* move Buffer. If IsImporting is true, this module is\n being parsed for ThinLTO importing into another module."]
    #[link_name = "\u{1}_ZN4llvm26getOwningLazyBitcodeModuleEOSt10unique_ptrINS_12MemoryBufferESt14default_deleteIS1_EERNS_11LLVMContextEbbNS_15ParserCallbacksE"]
    pub fn llvm_getOwningLazyBitcodeModule(
        Buffer: *mut std_unique_ptr,
        Context: *mut llvm_LLVMContext,
        ShouldLazyLoadMetadata: bool,
        IsImporting: bool,
        Callbacks: llvm_ParserCallbacks,
    ) -> llvm_Expected;
}
extern "C" {
    #[doc = " Read the header of the specified bitcode buffer and extract just the\n triple information. If successful, this returns a string. On error, this\n returns \"\"."]
    #[link_name = "\u{1}_ZN4llvm22getBitcodeTargetTripleB5cxx11ENS_15MemoryBufferRefE"]
    pub fn llvm_getBitcodeTargetTriple(Buffer: llvm_MemoryBufferRef) -> llvm_Expected;
}
extern "C" {
    #[doc = " Return true if \\p Buffer contains a bitcode file with ObjC code (category\n or class) in it."]
    #[link_name = "\u{1}_ZN4llvm31isBitcodeContainingObjCCategoryENS_15MemoryBufferRefE"]
    pub fn llvm_isBitcodeContainingObjCCategory(Buffer: llvm_MemoryBufferRef) -> llvm_Expected;
}
extern "C" {
    #[doc = " Read the header of the specified bitcode buffer and extract just the\n producer string information. If successful, this returns a string. On\n error, this returns \"\"."]
    #[link_name = "\u{1}_ZN4llvm24getBitcodeProducerStringB5cxx11ENS_15MemoryBufferRefE"]
    pub fn llvm_getBitcodeProducerString(Buffer: llvm_MemoryBufferRef) -> llvm_Expected;
}
extern "C" {
    #[doc = " Read the specified bitcode file, returning the module."]
    #[link_name = "\u{1}_ZN4llvm16parseBitcodeFileENS_15MemoryBufferRefERNS_11LLVMContextENS_15ParserCallbacksE"]
    pub fn llvm_parseBitcodeFile(
        Buffer: llvm_MemoryBufferRef,
        Context: *mut llvm_LLVMContext,
        Callbacks: llvm_ParserCallbacks,
    ) -> llvm_Expected;
}
extern "C" {
    #[doc = " Returns LTO information for the specified bitcode file."]
    #[link_name = "\u{1}_ZN4llvm17getBitcodeLTOInfoENS_15MemoryBufferRefE"]
    pub fn llvm_getBitcodeLTOInfo(Buffer: llvm_MemoryBufferRef) -> llvm_Expected;
}
extern "C" {
    #[doc = " Parse the specified bitcode buffer, returning the module summary index."]
    #[link_name = "\u{1}_ZN4llvm21getModuleSummaryIndexENS_15MemoryBufferRefE"]
    pub fn llvm_getModuleSummaryIndex(Buffer: llvm_MemoryBufferRef) -> llvm_Expected;
}
extern "C" {
    #[doc = " Parse the specified bitcode buffer and merge the index into CombinedIndex."]
    #[link_name = "\u{1}_ZN4llvm22readModuleSummaryIndexENS_15MemoryBufferRefERNS_18ModuleSummaryIndexE"]
    pub fn llvm_readModuleSummaryIndex(
        Buffer: llvm_MemoryBufferRef,
        CombinedIndex: *mut llvm_ModuleSummaryIndex,
    ) -> llvm_Error;
}
extern "C" {
    #[doc = " Parse the module summary index out of an IR file and return the module\n summary index object if found, or an empty summary if not. If Path refers\n to an empty file and IgnoreEmptyThinLTOIndexFile is true, then\n this function will return nullptr."]
    #[link_name = "\u{1}_ZN4llvm28getModuleSummaryIndexForFileENS_9StringRefEb"]
    pub fn llvm_getModuleSummaryIndexForFile(
        Path: llvm_StringRef,
        IgnoreEmptyThinLTOIndexFile: bool,
    ) -> llvm_Expected;
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm13readWideAPIntENS_8ArrayRefImEEj"]
    pub fn llvm_readWideAPInt(
        Vals: llvm_ArrayRef<u64>,
        TypeBits: ::std::os::raw::c_uint,
    ) -> llvm_APInt;
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm20BitcodeErrorCategoryEv"]
    pub fn llvm_BitcodeErrorCategory() -> *const std__V2_error_category;
}
pub const llvm_BitcodeError_CorruptedBitcode: llvm_BitcodeError = 1;
pub type llvm_BitcodeError = ::std::os::raw::c_int;
extern "C" {
    #[doc = " If the given MemoryBuffer holds a bitcode image, return a Module\n for it which does lazy deserialization of function bodies.  Otherwise,\n attempt to parse it as LLVM Assembly and return a fully populated\n Module. The ShouldLazyLoadMetadata flag is passed down to the bitcode\n reader to optionally enable lazy metadata loading. This takes ownership\n of \\p Buffer."]
    #[link_name = "\u{1}_ZN4llvm15getLazyIRModuleESt10unique_ptrINS_12MemoryBufferESt14default_deleteIS1_EERNS_12SMDiagnosticERNS_11LLVMContextEb"]
    pub fn llvm_getLazyIRModule(
        Buffer: std_unique_ptr,
        Err: *mut llvm_SMDiagnostic,
        Context: *mut llvm_LLVMContext,
        ShouldLazyLoadMetadata: bool,
    ) -> std_unique_ptr;
}
extern "C" {
    #[doc = " If the given file holds a bitcode image, return a Module\n for it which does lazy deserialization of function bodies.  Otherwise,\n attempt to parse it as LLVM Assembly and return a fully populated\n Module. The ShouldLazyLoadMetadata flag is passed down to the bitcode\n reader to optionally enable lazy metadata loading."]
    #[link_name = "\u{1}_ZN4llvm19getLazyIRFileModuleENS_9StringRefERNS_12SMDiagnosticERNS_11LLVMContextEb"]
    pub fn llvm_getLazyIRFileModule(
        Filename: llvm_StringRef,
        Err: *mut llvm_SMDiagnostic,
        Context: *mut llvm_LLVMContext,
        ShouldLazyLoadMetadata: bool,
    ) -> std_unique_ptr;
}
extern "C" {
    #[doc = " If the given MemoryBuffer holds a bitcode image, return a Module\n for it.  Otherwise, attempt to parse it as LLVM Assembly and return\n a Module for it.\n \\param DataLayoutCallback Override datalayout in the llvm assembly."]
    #[link_name = "\u{1}_ZN4llvm7parseIRENS_15MemoryBufferRefERNS_12SMDiagnosticERNS_11LLVMContextENS_15ParserCallbacksE"]
    pub fn llvm_parseIR(
        Buffer: llvm_MemoryBufferRef,
        Err: *mut llvm_SMDiagnostic,
        Context: *mut llvm_LLVMContext,
        Callbacks: llvm_ParserCallbacks,
    ) -> std_unique_ptr;
}
extern "C" {
    #[doc = " If the given file holds a bitcode image, return a Module for it.\n Otherwise, attempt to parse it as LLVM Assembly and return a Module\n for it.\n \\param DataLayoutCallback Override datalayout in the llvm assembly."]
    #[link_name = "\u{1}_ZN4llvm11parseIRFileENS_9StringRefERNS_12SMDiagnosticERNS_11LLVMContextENS_15ParserCallbacksE"]
    pub fn llvm_parseIRFile(
        Filename: llvm_StringRef,
        Err: *mut llvm_SMDiagnostic,
        Context: *mut llvm_LLVMContext,
        Callbacks: llvm_ParserCallbacks,
    ) -> std_unique_ptr;
}
#[doc = " A switch()-like statement whose cases are string literals.\n\n The StringSwitch class is a simple form of a switch() statement that\n determines whether the given string matches one of the given string\n literals. The template type parameter \\p T is the type of the value that\n will be returned from the string-switch expression. For example,\n the following code switches on the name of a color in \\c argv[i]:\n\n \\code\n Color color = StringSwitch<Color>(argv[i])\n   .Case(\"red\", Red)\n   .Case(\"orange\", Orange)\n   .Case(\"yellow\", Yellow)\n   .Case(\"green\", Green)\n   .Case(\"blue\", Blue)\n   .Case(\"indigo\", Indigo)\n   .Cases(\"violet\", \"purple\", Violet)\n   .Default(UnknownColor);\n \\endcode"]
#[repr(C)]
#[derive(Debug)]
pub struct llvm_StringSwitch {
    #[doc = " The string we are matching."]
    pub Str: llvm_StringRef,
    #[doc = " The pointer to the result of this switch statement, once known,\n null before that."]
    pub Result: std_optional,
}
#[doc = "< roundTowardZero."]
pub const llvm_RoundingMode_TowardZero: llvm_RoundingMode = 0;
#[doc = "< roundTiesToEven."]
pub const llvm_RoundingMode_NearestTiesToEven: llvm_RoundingMode = 1;
#[doc = "< roundTowardPositive."]
pub const llvm_RoundingMode_TowardPositive: llvm_RoundingMode = 2;
#[doc = "< roundTowardNegative."]
pub const llvm_RoundingMode_TowardNegative: llvm_RoundingMode = 3;
#[doc = "< roundTiesToAway."]
pub const llvm_RoundingMode_NearestTiesToAway: llvm_RoundingMode = 4;
#[doc = "< Denotes mode unknown at compile time."]
pub const llvm_RoundingMode_Dynamic: llvm_RoundingMode = 7;
#[doc = "< Denotes invalid value."]
pub const llvm_RoundingMode_Invalid: llvm_RoundingMode = -1;
#[doc = " Rounding mode.\n\n Enumerates supported rounding modes, as well as some special values. The set\n of the modes must agree with IEEE-754, 4.3.1 and 4.3.2. The constants\n assigned to the IEEE rounding modes must agree with the values used by\n FLT_ROUNDS (C11, 5.2.4.2.2p8).\n\n This value is packed into bitfield in some cases, including \\c FPOptions, so\n the rounding mode values and the special value \\c Dynamic must fit into the\n the bit field (now - 3 bits). The value \\c Invalid is used only in values\n returned by intrinsics to indicate errors, it should never be stored as\n rounding mode value, so it does not need to fit the bit fields.\n"]
pub type llvm_RoundingMode = i8;
#[doc = " Represent subnormal handling kind for floating point instruction inputs and\n outputs."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_DenormalMode {
    #[doc = " Denormal flushing mode for floating point instruction results in the\n default floating point environment."]
    pub Output: llvm_DenormalMode_DenormalModeKind,
    #[doc = " Denormal treatment kind for floating point instruction inputs in the\n default floating-point environment. If this is not DenormalModeKind::IEEE,\n floating-point instructions implicitly treat the input value as 0."]
    pub Input: llvm_DenormalMode_DenormalModeKind,
}
pub const llvm_DenormalMode_DenormalModeKind_Invalid: llvm_DenormalMode_DenormalModeKind = -1;
#[doc = " IEEE-754 denormal numbers preserved."]
pub const llvm_DenormalMode_DenormalModeKind_IEEE: llvm_DenormalMode_DenormalModeKind = 0;
#[doc = " The sign of a flushed-to-zero number is preserved in the sign of 0"]
pub const llvm_DenormalMode_DenormalModeKind_PreserveSign: llvm_DenormalMode_DenormalModeKind = 1;
#[doc = " Denormals are flushed to positive zero."]
pub const llvm_DenormalMode_DenormalModeKind_PositiveZero: llvm_DenormalMode_DenormalModeKind = 2;
#[doc = " Denormals have unknown treatment."]
pub const llvm_DenormalMode_DenormalModeKind_Dynamic: llvm_DenormalMode_DenormalModeKind = 3;
#[doc = " Represent handled modes for denormal (aka subnormal) modes in the floating\n point environment."]
pub type llvm_DenormalMode_DenormalModeKind = i8;
#[test]
fn bindgen_test_layout_llvm_DenormalMode() {
    const UNINIT: ::std::mem::MaybeUninit<llvm_DenormalMode> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<llvm_DenormalMode>(),
        2usize,
        concat!("Size of: ", stringify!(llvm_DenormalMode))
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_DenormalMode>(),
        1usize,
        concat!("Alignment of ", stringify!(llvm_DenormalMode))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Output) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_DenormalMode),
            "::",
            stringify!(Output)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Input) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_DenormalMode),
            "::",
            stringify!(Input)
        )
    );
}
pub const llvm_FPClassTest_fcNone: llvm_FPClassTest = 0;
pub const llvm_FPClassTest_fcSNan: llvm_FPClassTest = 1;
pub const llvm_FPClassTest_fcQNan: llvm_FPClassTest = 2;
pub const llvm_FPClassTest_fcNegInf: llvm_FPClassTest = 4;
pub const llvm_FPClassTest_fcNegNormal: llvm_FPClassTest = 8;
pub const llvm_FPClassTest_fcNegSubnormal: llvm_FPClassTest = 16;
pub const llvm_FPClassTest_fcNegZero: llvm_FPClassTest = 32;
pub const llvm_FPClassTest_fcPosZero: llvm_FPClassTest = 64;
pub const llvm_FPClassTest_fcPosSubnormal: llvm_FPClassTest = 128;
pub const llvm_FPClassTest_fcPosNormal: llvm_FPClassTest = 256;
pub const llvm_FPClassTest_fcPosInf: llvm_FPClassTest = 512;
pub const llvm_FPClassTest_fcNan: llvm_FPClassTest = 3;
pub const llvm_FPClassTest_fcInf: llvm_FPClassTest = 516;
pub const llvm_FPClassTest_fcNormal: llvm_FPClassTest = 264;
pub const llvm_FPClassTest_fcSubnormal: llvm_FPClassTest = 144;
pub const llvm_FPClassTest_fcZero: llvm_FPClassTest = 96;
pub const llvm_FPClassTest_fcPosFinite: llvm_FPClassTest = 448;
pub const llvm_FPClassTest_fcNegFinite: llvm_FPClassTest = 56;
pub const llvm_FPClassTest_fcFinite: llvm_FPClassTest = 504;
pub const llvm_FPClassTest_fcPositive: llvm_FPClassTest = 960;
pub const llvm_FPClassTest_fcNegative: llvm_FPClassTest = 60;
pub const llvm_FPClassTest_fcAllFlags: llvm_FPClassTest = 1023;
#[doc = " Floating-point class tests, supported by 'is_fpclass' intrinsic. Actual\n test may be an OR combination of basic tests."]
pub type llvm_FPClassTest = ::std::os::raw::c_uint;
#[test]
fn __bindgen_test_layout_llvm_is_bitmask_enum_open0_llvm_FPClassTest_void_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<llvm_is_bitmask_enum>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_is_bitmask_enum)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_is_bitmask_enum>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_is_bitmask_enum)
        )
    );
}
#[test]
fn __bindgen_test_layout_llvm_largest_bitmask_enum_bit_open0_llvm_FPClassTest_void_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<llvm_largest_bitmask_enum_bit>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_largest_bitmask_enum_bit)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_largest_bitmask_enum_bit>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_largest_bitmask_enum_bit)
        )
    );
}
extern "C" {
    #[doc = " Return the test mask which returns true if the value's sign bit is flipped."]
    #[link_name = "\u{1}_ZN4llvm4fnegENS_11FPClassTestE"]
    pub fn llvm_fneg(Mask: llvm_FPClassTest) -> llvm_FPClassTest;
}
extern "C" {
    #[doc = " Return the test mask which returns true after fabs is applied to the value."]
    #[link_name = "\u{1}_ZN4llvm12inverse_fabsENS_11FPClassTestE"]
    pub fn llvm_inverse_fabs(Mask: llvm_FPClassTest) -> llvm_FPClassTest;
}
extern "C" {
    #[doc = " Return the test mask which returns true if the value could have the same set\n of classes, but with a different sign."]
    #[link_name = "\u{1}_ZN4llvm12unknown_signENS_11FPClassTestE"]
    pub fn llvm_unknown_sign(Mask: llvm_FPClassTest) -> llvm_FPClassTest;
}
#[doc = "< No compression"]
pub const llvm_DebugCompressionType_None: llvm_DebugCompressionType = 0;
#[doc = "< zlib"]
pub const llvm_DebugCompressionType_Zlib: llvm_DebugCompressionType = 1;
#[doc = "< Zstandard"]
pub const llvm_DebugCompressionType_Zstd: llvm_DebugCompressionType = 2;
pub type llvm_DebugCompressionType = ::std::os::raw::c_int;
pub const llvm_compression_zlib_NoCompression: ::std::os::raw::c_int = 0;
pub const llvm_compression_zlib_BestSpeedCompression: ::std::os::raw::c_int = 1;
pub const llvm_compression_zlib_DefaultCompression: ::std::os::raw::c_int = 6;
pub const llvm_compression_zlib_BestSizeCompression: ::std::os::raw::c_int = 9;
extern "C" {
    #[link_name = "\u{1}_ZN4llvm11compression4zlib11isAvailableEv"]
    pub fn llvm_compression_zlib_isAvailable() -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm11compression4zlib8compressENS_8ArrayRefIhEERNS_15SmallVectorImplIhEEi"]
    pub fn llvm_compression_zlib_compress(
        Input: llvm_ArrayRef<u8>,
        CompressedBuffer: *mut llvm_SmallVectorImpl,
        Level: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm11compression4zlib10decompressENS_8ArrayRefIhEEPhRm"]
    pub fn llvm_compression_zlib_decompress(
        Input: llvm_ArrayRef<u8>,
        Output: *mut u8,
        UncompressedSize: *mut usize,
    ) -> llvm_Error;
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm11compression4zlib10decompressENS_8ArrayRefIhEERNS_15SmallVectorImplIhEEm"]
    pub fn llvm_compression_zlib_decompress1(
        Input: llvm_ArrayRef<u8>,
        Output: *mut llvm_SmallVectorImpl,
        UncompressedSize: usize,
    ) -> llvm_Error;
}
pub const llvm_compression_zstd_NoCompression: ::std::os::raw::c_int = -5;
pub const llvm_compression_zstd_BestSpeedCompression: ::std::os::raw::c_int = 1;
pub const llvm_compression_zstd_DefaultCompression: ::std::os::raw::c_int = 5;
pub const llvm_compression_zstd_BestSizeCompression: ::std::os::raw::c_int = 12;
extern "C" {
    #[link_name = "\u{1}_ZN4llvm11compression4zstd11isAvailableEv"]
    pub fn llvm_compression_zstd_isAvailable() -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm11compression4zstd8compressENS_8ArrayRefIhEERNS_15SmallVectorImplIhEEib"]
    pub fn llvm_compression_zstd_compress(
        Input: llvm_ArrayRef<u8>,
        CompressedBuffer: *mut llvm_SmallVectorImpl,
        Level: ::std::os::raw::c_int,
        EnableLdm: bool,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm11compression4zstd10decompressENS_8ArrayRefIhEEPhRm"]
    pub fn llvm_compression_zstd_decompress(
        Input: llvm_ArrayRef<u8>,
        Output: *mut u8,
        UncompressedSize: *mut usize,
    ) -> llvm_Error;
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm11compression4zstd10decompressENS_8ArrayRefIhEERNS_15SmallVectorImplIhEEm"]
    pub fn llvm_compression_zstd_decompress1(
        Input: llvm_ArrayRef<u8>,
        Output: *mut llvm_SmallVectorImpl,
        UncompressedSize: usize,
    ) -> llvm_Error;
}
pub const llvm_compression_Format_Zlib: llvm_compression_Format = 0;
pub const llvm_compression_Format_Zstd: llvm_compression_Format = 1;
pub type llvm_compression_Format = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_compression_Params {
    pub format: llvm_compression_Format,
    pub level: ::std::os::raw::c_int,
    pub zstdEnableLdm: bool,
}
#[test]
fn bindgen_test_layout_llvm_compression_Params() {
    const UNINIT: ::std::mem::MaybeUninit<llvm_compression_Params> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<llvm_compression_Params>(),
        12usize,
        concat!("Size of: ", stringify!(llvm_compression_Params))
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_compression_Params>(),
        4usize,
        concat!("Alignment of ", stringify!(llvm_compression_Params))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).format) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_compression_Params),
            "::",
            stringify!(format)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).level) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_compression_Params),
            "::",
            stringify!(level)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).zstdEnableLdm) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_compression_Params),
            "::",
            stringify!(zstdEnableLdm)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm11compression22getReasonIfUnsupportedENS0_6FormatE"]
    pub fn llvm_compression_getReasonIfUnsupported(
        F: llvm_compression_Format,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm11compression8compressENS0_6ParamsENS_8ArrayRefIhEERNS_15SmallVectorImplIhEE"]
    pub fn llvm_compression_compress(
        P: llvm_compression_Params,
        Input: llvm_ArrayRef<u8>,
        Output: *mut llvm_SmallVectorImpl,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm11compression10decompressENS_20DebugCompressionTypeENS_8ArrayRefIhEEPhm"]
    pub fn llvm_compression_decompress(
        T: llvm_DebugCompressionType,
        Input: llvm_ArrayRef<u8>,
        Output: *mut u8,
        UncompressedSize: usize,
    ) -> llvm_Error;
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm11compression10decompressENS0_6FormatENS_8ArrayRefIhEERNS_15SmallVectorImplIhEEm"]
    pub fn llvm_compression_decompress1(
        F: llvm_compression_Format,
        Input: llvm_ArrayRef<u8>,
        Output: *mut llvm_SmallVectorImpl,
        UncompressedSize: usize,
    ) -> llvm_Error;
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm11compression10decompressENS_20DebugCompressionTypeENS_8ArrayRefIhEERNS_15SmallVectorImplIhEEm"]
    pub fn llvm_compression_decompress2(
        T: llvm_DebugCompressionType,
        Input: llvm_ArrayRef<u8>,
        Output: *mut llvm_SmallVectorImpl,
        UncompressedSize: usize,
    ) -> llvm_Error;
}
#[doc = "< No exception support"]
pub const llvm_ExceptionHandling_None: llvm_ExceptionHandling = 0;
#[doc = "< DWARF-like instruction based exceptions"]
pub const llvm_ExceptionHandling_DwarfCFI: llvm_ExceptionHandling = 1;
#[doc = "< setjmp/longjmp based exceptions"]
pub const llvm_ExceptionHandling_SjLj: llvm_ExceptionHandling = 2;
#[doc = "< ARM EHABI"]
pub const llvm_ExceptionHandling_ARM: llvm_ExceptionHandling = 3;
#[doc = "< Windows Exception Handling"]
pub const llvm_ExceptionHandling_WinEH: llvm_ExceptionHandling = 4;
#[doc = "< WebAssembly Exception Handling"]
pub const llvm_ExceptionHandling_Wasm: llvm_ExceptionHandling = 5;
#[doc = "< AIX Exception Handling"]
pub const llvm_ExceptionHandling_AIX: llvm_ExceptionHandling = 6;
#[doc = "< z/OS MVS Exception Handling. Very similar to DwarfCFI, but the PPA1\n< is used instead of an .eh_frame section."]
pub const llvm_ExceptionHandling_ZOS: llvm_ExceptionHandling = 7;
pub type llvm_ExceptionHandling = ::std::os::raw::c_int;
pub const llvm_EmitDwarfUnwindType_Always: llvm_EmitDwarfUnwindType = 0;
pub const llvm_EmitDwarfUnwindType_NoCompactUnwind: llvm_EmitDwarfUnwindType = 1;
pub const llvm_EmitDwarfUnwindType_Default: llvm_EmitDwarfUnwindType = 2;
pub type llvm_EmitDwarfUnwindType = ::std::os::raw::c_int;
#[repr(C)]
pub struct llvm_MCTargetOptions {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
    pub Crel: bool,
    pub ImplicitMapSyms: bool,
    pub X86RelaxRelocations: bool,
    pub X86Sse2Avx: bool,
    pub EmitDwarfUnwind: llvm_EmitDwarfUnwindType,
    pub DwarfVersion: ::std::os::raw::c_int,
    pub MCUseDwarfDirectory: llvm_MCTargetOptions_DwarfDirectory,
    pub CompressDebugSections: llvm_DebugCompressionType,
    pub ABIName: std_string,
    pub AssemblyLanguage: std_string,
    pub SplitDwarfFile: std_string,
    pub AsSecureLogFile: std_string,
    pub Argv0: *const ::std::os::raw::c_char,
    pub CommandLineArgs: llvm_ArrayRef<std_string>,
    #[doc = " Additional paths to search for `.include` directives when using the\n integrated assembler."]
    pub IASSearchPaths: std_vector,
    pub _bitfield_align_2: [u8; 0],
    pub _bitfield_2: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: [u8; 7usize],
}
pub const llvm_MCTargetOptions_AsmInstrumentation_AsmInstrumentationNone:
    llvm_MCTargetOptions_AsmInstrumentation = 0;
pub const llvm_MCTargetOptions_AsmInstrumentation_AsmInstrumentationAddress:
    llvm_MCTargetOptions_AsmInstrumentation = 1;
pub type llvm_MCTargetOptions_AsmInstrumentation = ::std::os::raw::c_uint;
pub const llvm_MCTargetOptions_DwarfDirectory_DisableDwarfDirectory:
    llvm_MCTargetOptions_DwarfDirectory = 0;
pub const llvm_MCTargetOptions_DwarfDirectory_EnableDwarfDirectory:
    llvm_MCTargetOptions_DwarfDirectory = 1;
pub const llvm_MCTargetOptions_DwarfDirectory_DefaultDwarfDirectory:
    llvm_MCTargetOptions_DwarfDirectory = 2;
pub type llvm_MCTargetOptions_DwarfDirectory = ::std::os::raw::c_uint;
#[test]
fn bindgen_test_layout_llvm_MCTargetOptions() {
    const UNINIT: ::std::mem::MaybeUninit<llvm_MCTargetOptions> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<llvm_MCTargetOptions>(),
        208usize,
        concat!("Size of: ", stringify!(llvm_MCTargetOptions))
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_MCTargetOptions>(),
        8usize,
        concat!("Alignment of ", stringify!(llvm_MCTargetOptions))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Crel) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_MCTargetOptions),
            "::",
            stringify!(Crel)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ImplicitMapSyms) as usize - ptr as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_MCTargetOptions),
            "::",
            stringify!(ImplicitMapSyms)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).X86RelaxRelocations) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_MCTargetOptions),
            "::",
            stringify!(X86RelaxRelocations)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).X86Sse2Avx) as usize - ptr as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_MCTargetOptions),
            "::",
            stringify!(X86Sse2Avx)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).EmitDwarfUnwind) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_MCTargetOptions),
            "::",
            stringify!(EmitDwarfUnwind)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).DwarfVersion) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_MCTargetOptions),
            "::",
            stringify!(DwarfVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).MCUseDwarfDirectory) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_MCTargetOptions),
            "::",
            stringify!(MCUseDwarfDirectory)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).CompressDebugSections) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_MCTargetOptions),
            "::",
            stringify!(CompressDebugSections)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ABIName) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_MCTargetOptions),
            "::",
            stringify!(ABIName)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).AssemblyLanguage) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_MCTargetOptions),
            "::",
            stringify!(AssemblyLanguage)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).SplitDwarfFile) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_MCTargetOptions),
            "::",
            stringify!(SplitDwarfFile)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).AsSecureLogFile) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_MCTargetOptions),
            "::",
            stringify!(AsSecureLogFile)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Argv0) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_MCTargetOptions),
            "::",
            stringify!(Argv0)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).CommandLineArgs) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_MCTargetOptions),
            "::",
            stringify!(CommandLineArgs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).IASSearchPaths) as usize - ptr as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_MCTargetOptions),
            "::",
            stringify!(IASSearchPaths)
        )
    );
}
extern "C" {
    #[doc = " getABIName - If this returns a non-empty string this represents the\n textual name of the ABI that we want the backend to use, e.g. o32, or\n aapcs-linux."]
    #[link_name = "\u{1}_ZNK4llvm15MCTargetOptions10getABINameEv"]
    pub fn llvm_MCTargetOptions_getABIName(this: *const llvm_MCTargetOptions) -> llvm_StringRef;
}
extern "C" {
    #[doc = " getAssemblyLanguage - If this returns a non-empty string this represents\n the textual name of the assembly language that we will use for this\n target, e.g. masm."]
    #[link_name = "\u{1}_ZNK4llvm15MCTargetOptions19getAssemblyLanguageEv"]
    pub fn llvm_MCTargetOptions_getAssemblyLanguage(
        this: *const llvm_MCTargetOptions,
    ) -> llvm_StringRef;
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm15MCTargetOptionsC1Ev"]
    pub fn llvm_MCTargetOptions_MCTargetOptions(this: *mut llvm_MCTargetOptions);
}
impl llvm_MCTargetOptions {
    #[inline]
    pub fn MCRelaxAll(&self) -> bool {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_MCRelaxAll(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn MCNoExecStack(&self) -> bool {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_MCNoExecStack(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn MCFatalWarnings(&self) -> bool {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_MCFatalWarnings(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn MCNoWarn(&self) -> bool {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_MCNoWarn(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn MCNoDeprecatedWarn(&self) -> bool {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_MCNoDeprecatedWarn(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn MCNoTypeCheck(&self) -> bool {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_MCNoTypeCheck(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn MCSaveTempLabels(&self) -> bool {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_MCSaveTempLabels(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn MCIncrementalLinkerCompatible(&self) -> bool {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_MCIncrementalLinkerCompatible(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn FDPIC(&self) -> bool {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_FDPIC(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ShowMCEncoding(&self) -> bool {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_ShowMCEncoding(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ShowMCInst(&self) -> bool {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_ShowMCInst(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn AsmVerbose(&self) -> bool {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_AsmVerbose(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PreserveAsmComments(&self) -> bool {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_PreserveAsmComments(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Dwarf64(&self) -> bool {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_Dwarf64(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        MCRelaxAll: bool,
        MCNoExecStack: bool,
        MCFatalWarnings: bool,
        MCNoWarn: bool,
        MCNoDeprecatedWarn: bool,
        MCNoTypeCheck: bool,
        MCSaveTempLabels: bool,
        MCIncrementalLinkerCompatible: bool,
        FDPIC: bool,
        ShowMCEncoding: bool,
        ShowMCInst: bool,
        AsmVerbose: bool,
        PreserveAsmComments: bool,
        Dwarf64: bool,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let MCRelaxAll: u8 = unsafe { ::std::mem::transmute(MCRelaxAll) };
            MCRelaxAll as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let MCNoExecStack: u8 = unsafe { ::std::mem::transmute(MCNoExecStack) };
            MCNoExecStack as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let MCFatalWarnings: u8 = unsafe { ::std::mem::transmute(MCFatalWarnings) };
            MCFatalWarnings as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let MCNoWarn: u8 = unsafe { ::std::mem::transmute(MCNoWarn) };
            MCNoWarn as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let MCNoDeprecatedWarn: u8 = unsafe { ::std::mem::transmute(MCNoDeprecatedWarn) };
            MCNoDeprecatedWarn as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let MCNoTypeCheck: u8 = unsafe { ::std::mem::transmute(MCNoTypeCheck) };
            MCNoTypeCheck as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let MCSaveTempLabels: u8 = unsafe { ::std::mem::transmute(MCSaveTempLabels) };
            MCSaveTempLabels as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let MCIncrementalLinkerCompatible: u8 =
                unsafe { ::std::mem::transmute(MCIncrementalLinkerCompatible) };
            MCIncrementalLinkerCompatible as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let FDPIC: u8 = unsafe { ::std::mem::transmute(FDPIC) };
            FDPIC as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let ShowMCEncoding: u8 = unsafe { ::std::mem::transmute(ShowMCEncoding) };
            ShowMCEncoding as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let ShowMCInst: u8 = unsafe { ::std::mem::transmute(ShowMCInst) };
            ShowMCInst as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let AsmVerbose: u8 = unsafe { ::std::mem::transmute(AsmVerbose) };
            AsmVerbose as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let PreserveAsmComments: u8 = unsafe { ::std::mem::transmute(PreserveAsmComments) };
            PreserveAsmComments as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let Dwarf64: u8 = unsafe { ::std::mem::transmute(Dwarf64) };
            Dwarf64 as u64
        });
        __bindgen_bitfield_unit
    }
    #[inline]
    pub fn EmitCompactUnwindNonCanonical(&self) -> bool {
        unsafe { ::std::mem::transmute(self._bitfield_2.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_EmitCompactUnwindNonCanonical(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_2.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PPCUseFullRegisterNames(&self) -> bool {
        unsafe { ::std::mem::transmute(self._bitfield_2.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_PPCUseFullRegisterNames(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_2.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_2(
        EmitCompactUnwindNonCanonical: bool,
        PPCUseFullRegisterNames: bool,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let EmitCompactUnwindNonCanonical: u8 =
                unsafe { ::std::mem::transmute(EmitCompactUnwindNonCanonical) };
            EmitCompactUnwindNonCanonical as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let PPCUseFullRegisterNames: u8 =
                unsafe { ::std::mem::transmute(PPCUseFullRegisterNames) };
            PPCUseFullRegisterNames as u64
        });
        __bindgen_bitfield_unit
    }
    #[inline]
    pub unsafe fn getABIName(&self) -> llvm_StringRef {
        llvm_MCTargetOptions_getABIName(self)
    }
    #[inline]
    pub unsafe fn getAssemblyLanguage(&self) -> llvm_StringRef {
        llvm_MCTargetOptions_getAssemblyLanguage(self)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        llvm_MCTargetOptions_MCTargetOptions(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_MachineFunction {
    _unused: [u8; 0],
}
pub const llvm_FloatABI_ABIType_Default: llvm_FloatABI_ABIType = 0;
pub const llvm_FloatABI_ABIType_Soft: llvm_FloatABI_ABIType = 1;
pub const llvm_FloatABI_ABIType_Hard: llvm_FloatABI_ABIType = 2;
pub type llvm_FloatABI_ABIType = ::std::os::raw::c_uint;
pub const llvm_FPOpFusion_FPOpFusionMode_Fast: llvm_FPOpFusion_FPOpFusionMode = 0;
pub const llvm_FPOpFusion_FPOpFusionMode_Standard: llvm_FPOpFusion_FPOpFusionMode = 1;
pub const llvm_FPOpFusion_FPOpFusionMode_Strict: llvm_FPOpFusion_FPOpFusionMode = 2;
pub type llvm_FPOpFusion_FPOpFusionMode = ::std::os::raw::c_uint;
pub const llvm_JumpTable_JumpTableType_Single: llvm_JumpTable_JumpTableType = 0;
pub const llvm_JumpTable_JumpTableType_Arity: llvm_JumpTable_JumpTableType = 1;
pub const llvm_JumpTable_JumpTableType_Simplified: llvm_JumpTable_JumpTableType = 2;
pub const llvm_JumpTable_JumpTableType_Full: llvm_JumpTable_JumpTableType = 3;
pub type llvm_JumpTable_JumpTableType = ::std::os::raw::c_uint;
pub const llvm_ThreadModel_Model_POSIX: llvm_ThreadModel_Model = 0;
pub const llvm_ThreadModel_Model_Single: llvm_ThreadModel_Model = 1;
pub type llvm_ThreadModel_Model = ::std::os::raw::c_uint;
pub const llvm_BasicBlockSection_All: llvm_BasicBlockSection = 0;
pub const llvm_BasicBlockSection_List: llvm_BasicBlockSection = 1;
pub const llvm_BasicBlockSection_Labels: llvm_BasicBlockSection = 2;
pub const llvm_BasicBlockSection_Preset: llvm_BasicBlockSection = 3;
pub const llvm_BasicBlockSection_None: llvm_BasicBlockSection = 4;
pub type llvm_BasicBlockSection = ::std::os::raw::c_int;
pub const llvm_EABI_Unknown: llvm_EABI = 0;
pub const llvm_EABI_Default: llvm_EABI = 1;
pub const llvm_EABI_EABI4: llvm_EABI = 2;
pub const llvm_EABI_EABI5: llvm_EABI = 3;
pub const llvm_EABI_GNU: llvm_EABI = 4;
pub type llvm_EABI = ::std::os::raw::c_int;
#[doc = "< No specific tuning requested."]
pub const llvm_DebuggerKind_Default: llvm_DebuggerKind = 0;
#[doc = "< Tune debug info for gdb."]
pub const llvm_DebuggerKind_GDB: llvm_DebuggerKind = 1;
#[doc = "< Tune debug info for lldb."]
pub const llvm_DebuggerKind_LLDB: llvm_DebuggerKind = 2;
#[doc = "< Tune debug info for SCE targets (e.g. PS4)."]
pub const llvm_DebuggerKind_SCE: llvm_DebuggerKind = 3;
#[doc = "< Tune debug info for dbx."]
pub const llvm_DebuggerKind_DBX: llvm_DebuggerKind = 4;
#[doc = " Identify a debugger for \"tuning\" the debug info.\n\n The \"debugger tuning\" concept allows us to present a more intuitive\n interface that unpacks into different sets of defaults for the various\n individual feature-flag settings, that suit the preferences of the\n various debuggers.  However, it's worth remembering that debuggers are\n not the only consumers of debug info, and some variations in DWARF might\n better be treated as target/platform issues. Fundamentally,\n o if the feature is useful (or not) to a particular debugger, regardless\n   of the target, that's a tuning decision;\n o if the feature is useful (or not) on a particular platform, regardless\n   of the debugger, that's a target decision.\n It's not impossible to see both factors in some specific case."]
pub type llvm_DebuggerKind = ::std::os::raw::c_int;
pub const llvm_GlobalISelAbortMode_Disable: llvm_GlobalISelAbortMode = 0;
pub const llvm_GlobalISelAbortMode_Enable: llvm_GlobalISelAbortMode = 1;
pub const llvm_GlobalISelAbortMode_DisableWithDiag: llvm_GlobalISelAbortMode = 2;
#[doc = " Enable abort calls when global instruction selection fails to lower/select\n an instruction."]
pub type llvm_GlobalISelAbortMode = ::std::os::raw::c_int;
#[doc = " Determine whether to set the bit statically or dynamically based\n on the deployment target."]
pub const llvm_SwiftAsyncFramePointerMode_DeploymentBased: llvm_SwiftAsyncFramePointerMode = 0;
#[doc = " Always set the bit."]
pub const llvm_SwiftAsyncFramePointerMode_Always: llvm_SwiftAsyncFramePointerMode = 1;
#[doc = " Never set the bit."]
pub const llvm_SwiftAsyncFramePointerMode_Never: llvm_SwiftAsyncFramePointerMode = 2;
#[doc = " Indicates when and how the Swift async frame pointer bit should be set."]
pub type llvm_SwiftAsyncFramePointerMode = ::std::os::raw::c_int;
pub const llvm_CodeObjectVersionKind_COV_None: llvm_CodeObjectVersionKind = 0;
pub const llvm_CodeObjectVersionKind_COV_2: llvm_CodeObjectVersionKind = 200;
pub const llvm_CodeObjectVersionKind_COV_3: llvm_CodeObjectVersionKind = 300;
pub const llvm_CodeObjectVersionKind_COV_4: llvm_CodeObjectVersionKind = 400;
pub const llvm_CodeObjectVersionKind_COV_5: llvm_CodeObjectVersionKind = 500;
pub const llvm_CodeObjectVersionKind_COV_6: llvm_CodeObjectVersionKind = 600;
#[doc = " \\brief Enumeration value for AMDGPU code object version, which is the\n code object version times 100."]
pub type llvm_CodeObjectVersionKind = ::std::os::raw::c_uint;
#[repr(C)]
pub struct llvm_TargetOptions {
    #[doc = " If greater than 0, override the default value of\n MCAsmInfo::BinutilsVersion."]
    pub BinutilsVersion: std_pair<::std::os::raw::c_int, ::std::os::raw::c_int>,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
    #[doc = " EnableGlobalISelAbort - Control abort behaviour when global instruction\n selection fails to lower/select an instruction."]
    pub GlobalISelAbort: llvm_GlobalISelAbortMode,
    #[doc = " Control when and how the Swift async frame pointer bit should\n be set."]
    pub SwiftAsyncFramePointer: llvm_SwiftAsyncFramePointerMode,
    pub _bitfield_align_2: [u8; 0],
    pub _bitfield_2: __BindgenBitfieldUnit<[u8; 4usize]>,
    #[doc = " Emit basic blocks into separate sections."]
    pub BBSections: llvm_BasicBlockSection,
    #[doc = " Memory Buffer that contains information on sampled basic blocks and used\n to selectively generate basic block sections."]
    pub BBSectionsFuncListBuf: std_shared_ptr,
    pub _bitfield_align_3: [u8; 0],
    pub _bitfield_3: __BindgenBitfieldUnit<[u8; 2usize]>,
    #[doc = " Name of the stack usage file (i.e., .su file) if user passes\n -fstack-usage. If empty, it can be implied that -fstack-usage is not\n passed on the command line."]
    pub StackUsageOutput: std_string,
    #[doc = " If greater than 0, override TargetLoweringBase::PrefLoopAlignment."]
    pub LoopAlignment: ::std::os::raw::c_uint,
    #[doc = " FloatABIType - This setting is set by -float-abi=xxx option is specfied\n on the command line. This setting may either be Default, Soft, or Hard.\n Default selects the target's default behavior. Soft selects the ABI for\n software floating point, but does not indicate that FP hardware may not\n be used. Such a combination is unfortunately popular (e.g.\n arm-apple-darwin). Hard presumes that the normal FP ABI is used."]
    pub FloatABIType: llvm_FloatABI_ABIType,
    #[doc = " AllowFPOpFusion - This flag is set by the -fp-contract=xxx option.\n This controls the creation of fused FP ops that store intermediate\n results in higher precision than IEEE allows (E.g. FMAs).\n\n Fast mode - allows formation of fused FP ops whenever they're\n profitable.\n Standard mode - allow fusion only for 'blessed' FP ops. At present the\n only blessed op is the fmuladd intrinsic. In the future more blessed ops\n may be added.\n Strict mode - allow fusion only if/when it can be proven that the excess\n precision won't effect the result.\n\n Note: This option only controls formation of fused ops by the\n optimizers.  Fused operations that are explicitly specified (e.g. FMA\n via the llvm.fma.* intrinsic) will always be honored, regardless of\n the value of this option."]
    pub AllowFPOpFusion: llvm_FPOpFusion_FPOpFusionMode,
    #[doc = " ThreadModel - This flag specifies the type of threading model to assume\n for things like atomics"]
    pub ThreadModel: llvm_ThreadModel_Model,
    #[doc = " EABIVersion - This flag specifies the EABI version"]
    pub EABIVersion: llvm_EABI,
    #[doc = " Which debugger to tune for."]
    pub DebuggerTuning: llvm_DebuggerKind,
    #[doc = " Flushing mode to assume in default FP environment."]
    pub FPDenormalMode: llvm_DenormalMode,
    #[doc = " Flushing mode to assume in default FP environment, for float/vector of\n float."]
    pub FP32DenormalMode: llvm_DenormalMode,
    #[doc = " What exception model to use"]
    pub ExceptionModel: llvm_ExceptionHandling,
    #[doc = " Machine level options."]
    pub MCOptions: llvm_MCTargetOptions,
    #[doc = " Stores the filename/path of the final .o/.obj file, to be written in the\n debug information. This is used for emitting the CodeView S_OBJNAME\n record."]
    pub ObjectFilenameForDebug: std_string,
}
#[test]
fn bindgen_test_layout_llvm_TargetOptions() {
    const UNINIT: ::std::mem::MaybeUninit<llvm_TargetOptions> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<llvm_TargetOptions>(),
        360usize,
        concat!("Size of: ", stringify!(llvm_TargetOptions))
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_TargetOptions>(),
        8usize,
        concat!("Alignment of ", stringify!(llvm_TargetOptions))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).BinutilsVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_TargetOptions),
            "::",
            stringify!(BinutilsVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).GlobalISelAbort) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_TargetOptions),
            "::",
            stringify!(GlobalISelAbort)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).SwiftAsyncFramePointer) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_TargetOptions),
            "::",
            stringify!(SwiftAsyncFramePointer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).BBSections) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_TargetOptions),
            "::",
            stringify!(BBSections)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).BBSectionsFuncListBuf) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_TargetOptions),
            "::",
            stringify!(BBSectionsFuncListBuf)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).StackUsageOutput) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_TargetOptions),
            "::",
            stringify!(StackUsageOutput)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LoopAlignment) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_TargetOptions),
            "::",
            stringify!(LoopAlignment)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).FloatABIType) as usize - ptr as usize },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_TargetOptions),
            "::",
            stringify!(FloatABIType)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).AllowFPOpFusion) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_TargetOptions),
            "::",
            stringify!(AllowFPOpFusion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ThreadModel) as usize - ptr as usize },
        100usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_TargetOptions),
            "::",
            stringify!(ThreadModel)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).EABIVersion) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_TargetOptions),
            "::",
            stringify!(EABIVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).DebuggerTuning) as usize - ptr as usize },
        108usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_TargetOptions),
            "::",
            stringify!(DebuggerTuning)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).FPDenormalMode) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_TargetOptions),
            "::",
            stringify!(FPDenormalMode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).FP32DenormalMode) as usize - ptr as usize },
        114usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_TargetOptions),
            "::",
            stringify!(FP32DenormalMode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ExceptionModel) as usize - ptr as usize },
        116usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_TargetOptions),
            "::",
            stringify!(ExceptionModel)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).MCOptions) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_TargetOptions),
            "::",
            stringify!(MCOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ObjectFilenameForDebug) as usize - ptr as usize },
        328usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_TargetOptions),
            "::",
            stringify!(ObjectFilenameForDebug)
        )
    );
}
extern "C" {
    #[doc = " DisableFramePointerElim - This returns true if frame pointer elimination\n optimization should be disabled for the given machine function."]
    #[link_name = "\u{1}_ZNK4llvm13TargetOptions23DisableFramePointerElimERKNS_15MachineFunctionE"]
    pub fn llvm_TargetOptions_DisableFramePointerElim(
        this: *const llvm_TargetOptions,
        MF: *const llvm_MachineFunction,
    ) -> bool;
}
extern "C" {
    #[doc = " FramePointerIsReserved - This returns true if the frame pointer must\n always either point to a new frame record or be un-modified in the given\n function."]
    #[link_name = "\u{1}_ZNK4llvm13TargetOptions22FramePointerIsReservedERKNS_15MachineFunctionE"]
    pub fn llvm_TargetOptions_FramePointerIsReserved(
        this: *const llvm_TargetOptions,
        MF: *const llvm_MachineFunction,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4llvm13TargetOptions32HonorSignDependentRoundingFPMathEv"]
    pub fn llvm_TargetOptions_HonorSignDependentRoundingFPMath(
        this: *const llvm_TargetOptions,
    ) -> bool;
}
extern "C" {
    #[doc = " NOTE: There are targets that still do not support the debug entry values\n production."]
    #[link_name = "\u{1}_ZNK4llvm13TargetOptions26ShouldEmitDebugEntryValuesEv"]
    pub fn llvm_TargetOptions_ShouldEmitDebugEntryValues(this: *const llvm_TargetOptions) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4llvm13TargetOptions15getDenormalModeERKNS_12fltSemanticsE"]
    pub fn llvm_TargetOptions_getDenormalMode(
        this: *const llvm_TargetOptions,
        FPType: *const llvm_fltSemantics,
    ) -> llvm_DenormalMode;
}
impl llvm_TargetOptions {
    #[inline]
    pub fn UnsafeFPMath(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_UnsafeFPMath(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn NoInfsFPMath(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_NoInfsFPMath(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn NoNaNsFPMath(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_NoNaNsFPMath(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn NoTrappingFPMath(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_NoTrappingFPMath(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn NoSignedZerosFPMath(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_NoSignedZerosFPMath(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ApproxFuncFPMath(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ApproxFuncFPMath(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn EnableAIXExtendedAltivecABI(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_EnableAIXExtendedAltivecABI(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn HonorSignDependentRoundingFPMathOption(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_HonorSignDependentRoundingFPMathOption(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn NoZerosInBSS(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_NoZerosInBSS(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn GuaranteedTailCallOpt(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_GuaranteedTailCallOpt(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn StackSymbolOrdering(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_StackSymbolOrdering(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn EnableFastISel(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_EnableFastISel(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn EnableGlobalISel(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_EnableGlobalISel(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        UnsafeFPMath: ::std::os::raw::c_uint,
        NoInfsFPMath: ::std::os::raw::c_uint,
        NoNaNsFPMath: ::std::os::raw::c_uint,
        NoTrappingFPMath: ::std::os::raw::c_uint,
        NoSignedZerosFPMath: ::std::os::raw::c_uint,
        ApproxFuncFPMath: ::std::os::raw::c_uint,
        EnableAIXExtendedAltivecABI: ::std::os::raw::c_uint,
        HonorSignDependentRoundingFPMathOption: ::std::os::raw::c_uint,
        NoZerosInBSS: ::std::os::raw::c_uint,
        GuaranteedTailCallOpt: ::std::os::raw::c_uint,
        StackSymbolOrdering: ::std::os::raw::c_uint,
        EnableFastISel: ::std::os::raw::c_uint,
        EnableGlobalISel: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let UnsafeFPMath: u32 = unsafe { ::std::mem::transmute(UnsafeFPMath) };
            UnsafeFPMath as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let NoInfsFPMath: u32 = unsafe { ::std::mem::transmute(NoInfsFPMath) };
            NoInfsFPMath as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let NoNaNsFPMath: u32 = unsafe { ::std::mem::transmute(NoNaNsFPMath) };
            NoNaNsFPMath as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let NoTrappingFPMath: u32 = unsafe { ::std::mem::transmute(NoTrappingFPMath) };
            NoTrappingFPMath as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let NoSignedZerosFPMath: u32 = unsafe { ::std::mem::transmute(NoSignedZerosFPMath) };
            NoSignedZerosFPMath as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let ApproxFuncFPMath: u32 = unsafe { ::std::mem::transmute(ApproxFuncFPMath) };
            ApproxFuncFPMath as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let EnableAIXExtendedAltivecABI: u32 =
                unsafe { ::std::mem::transmute(EnableAIXExtendedAltivecABI) };
            EnableAIXExtendedAltivecABI as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let HonorSignDependentRoundingFPMathOption: u32 =
                unsafe { ::std::mem::transmute(HonorSignDependentRoundingFPMathOption) };
            HonorSignDependentRoundingFPMathOption as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let NoZerosInBSS: u32 = unsafe { ::std::mem::transmute(NoZerosInBSS) };
            NoZerosInBSS as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let GuaranteedTailCallOpt: u32 =
                unsafe { ::std::mem::transmute(GuaranteedTailCallOpt) };
            GuaranteedTailCallOpt as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let StackSymbolOrdering: u32 = unsafe { ::std::mem::transmute(StackSymbolOrdering) };
            StackSymbolOrdering as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let EnableFastISel: u32 = unsafe { ::std::mem::transmute(EnableFastISel) };
            EnableFastISel as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let EnableGlobalISel: u32 = unsafe { ::std::mem::transmute(EnableGlobalISel) };
            EnableGlobalISel as u64
        });
        __bindgen_bitfield_unit
    }
    #[inline]
    pub fn UseInitArray(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_2.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_UseInitArray(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_2.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DisableIntegratedAS(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_2.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_DisableIntegratedAS(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_2.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn FunctionSections(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_2.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_FunctionSections(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_2.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DataSections(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_2.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_DataSections(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_2.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn IgnoreXCOFFVisibility(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_2.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_IgnoreXCOFFVisibility(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_2.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn XCOFFTracebackTable(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_2.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_XCOFFTracebackTable(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_2.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn UniqueSectionNames(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_2.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_UniqueSectionNames(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_2.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn UniqueBasicBlockSectionNames(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_2.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_UniqueBasicBlockSectionNames(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_2.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SeparateNamedSections(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_2.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_SeparateNamedSections(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_2.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn TrapUnreachable(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_2.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_TrapUnreachable(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_2.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn NoTrapAfterNoreturn(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_2.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_NoTrapAfterNoreturn(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_2.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn TLSSize(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_2.get(11usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_TLSSize(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_2.set(11usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn EmulatedTLS(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_2.get(19usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_EmulatedTLS(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_2.set(19usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn EnableTLSDESC(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_2.get(20usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_EnableTLSDESC(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_2.set(20usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn EnableIPRA(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_2.get(21usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_EnableIPRA(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_2.set(21usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn EmitStackSizeSection(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_2.get(22usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_EmitStackSizeSection(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_2.set(22usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn EnableMachineOutliner(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_2.get(23usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_EnableMachineOutliner(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_2.set(23usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn EnableMachineFunctionSplitter(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_2.get(24usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_EnableMachineFunctionSplitter(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_2.set(24usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SupportsDefaultOutlining(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_2.get(25usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_SupportsDefaultOutlining(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_2.set(25usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn EmitAddrsig(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_2.get(26usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_EmitAddrsig(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_2.set(26usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn BBAddrMap(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_2.get(27usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_BBAddrMap(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_2.set(27usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_2(
        UseInitArray: ::std::os::raw::c_uint,
        DisableIntegratedAS: ::std::os::raw::c_uint,
        FunctionSections: ::std::os::raw::c_uint,
        DataSections: ::std::os::raw::c_uint,
        IgnoreXCOFFVisibility: ::std::os::raw::c_uint,
        XCOFFTracebackTable: ::std::os::raw::c_uint,
        UniqueSectionNames: ::std::os::raw::c_uint,
        UniqueBasicBlockSectionNames: ::std::os::raw::c_uint,
        SeparateNamedSections: ::std::os::raw::c_uint,
        TrapUnreachable: ::std::os::raw::c_uint,
        NoTrapAfterNoreturn: ::std::os::raw::c_uint,
        TLSSize: ::std::os::raw::c_uint,
        EmulatedTLS: ::std::os::raw::c_uint,
        EnableTLSDESC: ::std::os::raw::c_uint,
        EnableIPRA: ::std::os::raw::c_uint,
        EmitStackSizeSection: ::std::os::raw::c_uint,
        EnableMachineOutliner: ::std::os::raw::c_uint,
        EnableMachineFunctionSplitter: ::std::os::raw::c_uint,
        SupportsDefaultOutlining: ::std::os::raw::c_uint,
        EmitAddrsig: ::std::os::raw::c_uint,
        BBAddrMap: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let UseInitArray: u32 = unsafe { ::std::mem::transmute(UseInitArray) };
            UseInitArray as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let DisableIntegratedAS: u32 = unsafe { ::std::mem::transmute(DisableIntegratedAS) };
            DisableIntegratedAS as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let FunctionSections: u32 = unsafe { ::std::mem::transmute(FunctionSections) };
            FunctionSections as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let DataSections: u32 = unsafe { ::std::mem::transmute(DataSections) };
            DataSections as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let IgnoreXCOFFVisibility: u32 =
                unsafe { ::std::mem::transmute(IgnoreXCOFFVisibility) };
            IgnoreXCOFFVisibility as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let XCOFFTracebackTable: u32 = unsafe { ::std::mem::transmute(XCOFFTracebackTable) };
            XCOFFTracebackTable as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let UniqueSectionNames: u32 = unsafe { ::std::mem::transmute(UniqueSectionNames) };
            UniqueSectionNames as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let UniqueBasicBlockSectionNames: u32 =
                unsafe { ::std::mem::transmute(UniqueBasicBlockSectionNames) };
            UniqueBasicBlockSectionNames as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let SeparateNamedSections: u32 =
                unsafe { ::std::mem::transmute(SeparateNamedSections) };
            SeparateNamedSections as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let TrapUnreachable: u32 = unsafe { ::std::mem::transmute(TrapUnreachable) };
            TrapUnreachable as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let NoTrapAfterNoreturn: u32 = unsafe { ::std::mem::transmute(NoTrapAfterNoreturn) };
            NoTrapAfterNoreturn as u64
        });
        __bindgen_bitfield_unit.set(11usize, 8u8, {
            let TLSSize: u32 = unsafe { ::std::mem::transmute(TLSSize) };
            TLSSize as u64
        });
        __bindgen_bitfield_unit.set(19usize, 1u8, {
            let EmulatedTLS: u32 = unsafe { ::std::mem::transmute(EmulatedTLS) };
            EmulatedTLS as u64
        });
        __bindgen_bitfield_unit.set(20usize, 1u8, {
            let EnableTLSDESC: u32 = unsafe { ::std::mem::transmute(EnableTLSDESC) };
            EnableTLSDESC as u64
        });
        __bindgen_bitfield_unit.set(21usize, 1u8, {
            let EnableIPRA: u32 = unsafe { ::std::mem::transmute(EnableIPRA) };
            EnableIPRA as u64
        });
        __bindgen_bitfield_unit.set(22usize, 1u8, {
            let EmitStackSizeSection: u32 = unsafe { ::std::mem::transmute(EmitStackSizeSection) };
            EmitStackSizeSection as u64
        });
        __bindgen_bitfield_unit.set(23usize, 1u8, {
            let EnableMachineOutliner: u32 =
                unsafe { ::std::mem::transmute(EnableMachineOutliner) };
            EnableMachineOutliner as u64
        });
        __bindgen_bitfield_unit.set(24usize, 1u8, {
            let EnableMachineFunctionSplitter: u32 =
                unsafe { ::std::mem::transmute(EnableMachineFunctionSplitter) };
            EnableMachineFunctionSplitter as u64
        });
        __bindgen_bitfield_unit.set(25usize, 1u8, {
            let SupportsDefaultOutlining: u32 =
                unsafe { ::std::mem::transmute(SupportsDefaultOutlining) };
            SupportsDefaultOutlining as u64
        });
        __bindgen_bitfield_unit.set(26usize, 1u8, {
            let EmitAddrsig: u32 = unsafe { ::std::mem::transmute(EmitAddrsig) };
            EmitAddrsig as u64
        });
        __bindgen_bitfield_unit.set(27usize, 1u8, {
            let BBAddrMap: u32 = unsafe { ::std::mem::transmute(BBAddrMap) };
            BBAddrMap as u64
        });
        __bindgen_bitfield_unit
    }
    #[inline]
    pub fn EmitCallSiteInfo(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_3.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_EmitCallSiteInfo(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_3.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SupportsDebugEntryValues(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_3.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_SupportsDebugEntryValues(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_3.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn EnableDebugEntryValues(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_3.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_EnableDebugEntryValues(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_3.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ValueTrackingVariableLocations(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_3.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ValueTrackingVariableLocations(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_3.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ForceDwarfFrameSection(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_3.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ForceDwarfFrameSection(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_3.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn XRayFunctionIndex(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_3.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_XRayFunctionIndex(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_3.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DebugStrictDwarf(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_3.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_DebugStrictDwarf(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_3.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Hotpatch(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_3.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Hotpatch(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_3.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PPCGenScalarMASSEntries(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_3.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_PPCGenScalarMASSEntries(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_3.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn JMCInstrument(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_3.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_JMCInstrument(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_3.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn EnableCFIFixup(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_3.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_EnableCFIFixup(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_3.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn MisExpect(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_3.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_MisExpect(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_3.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn XCOFFReadOnlyPointers(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_3.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_XCOFFReadOnlyPointers(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_3.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_3(
        EmitCallSiteInfo: ::std::os::raw::c_uint,
        SupportsDebugEntryValues: ::std::os::raw::c_uint,
        EnableDebugEntryValues: ::std::os::raw::c_uint,
        ValueTrackingVariableLocations: ::std::os::raw::c_uint,
        ForceDwarfFrameSection: ::std::os::raw::c_uint,
        XRayFunctionIndex: ::std::os::raw::c_uint,
        DebugStrictDwarf: ::std::os::raw::c_uint,
        Hotpatch: ::std::os::raw::c_uint,
        PPCGenScalarMASSEntries: ::std::os::raw::c_uint,
        JMCInstrument: ::std::os::raw::c_uint,
        EnableCFIFixup: ::std::os::raw::c_uint,
        MisExpect: ::std::os::raw::c_uint,
        XCOFFReadOnlyPointers: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let EmitCallSiteInfo: u32 = unsafe { ::std::mem::transmute(EmitCallSiteInfo) };
            EmitCallSiteInfo as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let SupportsDebugEntryValues: u32 =
                unsafe { ::std::mem::transmute(SupportsDebugEntryValues) };
            SupportsDebugEntryValues as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let EnableDebugEntryValues: u32 =
                unsafe { ::std::mem::transmute(EnableDebugEntryValues) };
            EnableDebugEntryValues as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let ValueTrackingVariableLocations: u32 =
                unsafe { ::std::mem::transmute(ValueTrackingVariableLocations) };
            ValueTrackingVariableLocations as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let ForceDwarfFrameSection: u32 =
                unsafe { ::std::mem::transmute(ForceDwarfFrameSection) };
            ForceDwarfFrameSection as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let XRayFunctionIndex: u32 = unsafe { ::std::mem::transmute(XRayFunctionIndex) };
            XRayFunctionIndex as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let DebugStrictDwarf: u32 = unsafe { ::std::mem::transmute(DebugStrictDwarf) };
            DebugStrictDwarf as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let Hotpatch: u32 = unsafe { ::std::mem::transmute(Hotpatch) };
            Hotpatch as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let PPCGenScalarMASSEntries: u32 =
                unsafe { ::std::mem::transmute(PPCGenScalarMASSEntries) };
            PPCGenScalarMASSEntries as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let JMCInstrument: u32 = unsafe { ::std::mem::transmute(JMCInstrument) };
            JMCInstrument as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let EnableCFIFixup: u32 = unsafe { ::std::mem::transmute(EnableCFIFixup) };
            EnableCFIFixup as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let MisExpect: u32 = unsafe { ::std::mem::transmute(MisExpect) };
            MisExpect as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let XCOFFReadOnlyPointers: u32 =
                unsafe { ::std::mem::transmute(XCOFFReadOnlyPointers) };
            XCOFFReadOnlyPointers as u64
        });
        __bindgen_bitfield_unit
    }
    #[inline]
    pub unsafe fn DisableFramePointerElim(&self, MF: *const llvm_MachineFunction) -> bool {
        llvm_TargetOptions_DisableFramePointerElim(self, MF)
    }
    #[inline]
    pub unsafe fn FramePointerIsReserved(&self, MF: *const llvm_MachineFunction) -> bool {
        llvm_TargetOptions_FramePointerIsReserved(self, MF)
    }
    #[inline]
    pub unsafe fn HonorSignDependentRoundingFPMath(&self) -> bool {
        llvm_TargetOptions_HonorSignDependentRoundingFPMath(self)
    }
    #[inline]
    pub unsafe fn ShouldEmitDebugEntryValues(&self) -> bool {
        llvm_TargetOptions_ShouldEmitDebugEntryValues(self)
    }
    #[inline]
    pub unsafe fn getDenormalMode(&self, FPType: *const llvm_fltSemantics) -> llvm_DenormalMode {
        llvm_TargetOptions_getDenormalMode(self, FPType)
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_Pass {
    _unused: [u8; 0],
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm6legacy18debugPassSpecifiedEv"]
    pub fn llvm_legacy_debugPassSpecified() -> bool;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_legacy_PassManagerImpl {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_legacy_FunctionPassManagerImpl {
    _unused: [u8; 0],
}
#[repr(C)]
pub struct llvm_legacy_PassManagerBase__bindgen_vtable(::std::os::raw::c_void);
#[doc = " PassManagerBase - An abstract interface to allow code to add passes to\n a pass manager without having to hard-code what kind of pass manager\n it is."]
#[repr(C)]
#[derive(Debug)]
pub struct llvm_legacy_PassManagerBase {
    pub vtable_: *const llvm_legacy_PassManagerBase__bindgen_vtable,
}
#[test]
fn bindgen_test_layout_llvm_legacy_PassManagerBase() {
    assert_eq!(
        ::std::mem::size_of::<llvm_legacy_PassManagerBase>(),
        8usize,
        concat!("Size of: ", stringify!(llvm_legacy_PassManagerBase))
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_legacy_PassManagerBase>(),
        8usize,
        concat!("Alignment of ", stringify!(llvm_legacy_PassManagerBase))
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm6legacy15PassManagerBaseD1Ev"]
    pub fn llvm_legacy_PassManagerBase_PassManagerBase_destructor(
        this: *mut llvm_legacy_PassManagerBase,
    );
}
#[doc = " PassManager manages ModulePassManagers"]
#[repr(C)]
#[derive(Debug)]
pub struct llvm_legacy_PassManager {
    pub _base: llvm_legacy_PassManagerBase,
    #[doc = " PassManagerImpl_New is the actual class. PassManager is just the\n wraper to publish simple pass manager interface"]
    pub PM: *mut llvm_legacy_PassManagerImpl,
}
#[test]
fn bindgen_test_layout_llvm_legacy_PassManager() {
    const UNINIT: ::std::mem::MaybeUninit<llvm_legacy_PassManager> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<llvm_legacy_PassManager>(),
        16usize,
        concat!("Size of: ", stringify!(llvm_legacy_PassManager))
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_legacy_PassManager>(),
        8usize,
        concat!("Alignment of ", stringify!(llvm_legacy_PassManager))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).PM) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_legacy_PassManager),
            "::",
            stringify!(PM)
        )
    );
}
extern "C" {
    #[doc = " run - Execute all of the passes scheduled for execution.  Keep track of\n whether any of the passes modifies the module, and if so, return true."]
    #[link_name = "\u{1}_ZN4llvm6legacy11PassManager3runERNS_6ModuleE"]
    pub fn llvm_legacy_PassManager_run(
        this: *mut llvm_legacy_PassManager,
        M: *mut llvm_Module,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm6legacy11PassManagerC1Ev"]
    pub fn llvm_legacy_PassManager_PassManager(this: *mut llvm_legacy_PassManager);
}
impl llvm_legacy_PassManager {
    #[inline]
    pub unsafe fn run(&mut self, M: *mut llvm_Module) -> bool {
        llvm_legacy_PassManager_run(self, M)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        llvm_legacy_PassManager_PassManager(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm6legacy11PassManagerD1Ev"]
    pub fn llvm_legacy_PassManager_PassManager_destructor(this: *mut llvm_legacy_PassManager);
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm6legacy11PassManager3addEPNS_4PassE"]
    pub fn llvm_legacy_PassManager_add(this: *mut ::std::os::raw::c_void, P: *mut llvm_Pass);
}
#[doc = " FunctionPassManager manages FunctionPasses."]
#[repr(C)]
#[derive(Debug)]
pub struct llvm_legacy_FunctionPassManager {
    pub _base: llvm_legacy_PassManagerBase,
    pub FPM: *mut llvm_legacy_FunctionPassManagerImpl,
    pub M: *mut llvm_Module,
}
#[test]
fn bindgen_test_layout_llvm_legacy_FunctionPassManager() {
    const UNINIT: ::std::mem::MaybeUninit<llvm_legacy_FunctionPassManager> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<llvm_legacy_FunctionPassManager>(),
        24usize,
        concat!("Size of: ", stringify!(llvm_legacy_FunctionPassManager))
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_legacy_FunctionPassManager>(),
        8usize,
        concat!("Alignment of ", stringify!(llvm_legacy_FunctionPassManager))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).FPM) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_legacy_FunctionPassManager),
            "::",
            stringify!(FPM)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).M) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_legacy_FunctionPassManager),
            "::",
            stringify!(M)
        )
    );
}
extern "C" {
    #[doc = " run - Execute all of the passes scheduled for execution.  Keep\n track of whether any of the passes modifies the function, and if\n so, return true.\n"]
    #[link_name = "\u{1}_ZN4llvm6legacy19FunctionPassManager3runERNS_8FunctionE"]
    pub fn llvm_legacy_FunctionPassManager_run(
        this: *mut llvm_legacy_FunctionPassManager,
        F: *mut llvm_Function,
    ) -> bool;
}
extern "C" {
    #[doc = " doInitialization - Run all of the initializers for the function passes.\n"]
    #[link_name = "\u{1}_ZN4llvm6legacy19FunctionPassManager16doInitializationEv"]
    pub fn llvm_legacy_FunctionPassManager_doInitialization(
        this: *mut llvm_legacy_FunctionPassManager,
    ) -> bool;
}
extern "C" {
    #[doc = " doFinalization - Run all of the finalizers for the function passes.\n"]
    #[link_name = "\u{1}_ZN4llvm6legacy19FunctionPassManager14doFinalizationEv"]
    pub fn llvm_legacy_FunctionPassManager_doFinalization(
        this: *mut llvm_legacy_FunctionPassManager,
    ) -> bool;
}
extern "C" {
    #[doc = " FunctionPassManager ctor - This initializes the pass manager.  It needs,\n but does not take ownership of, the specified Module."]
    #[link_name = "\u{1}_ZN4llvm6legacy19FunctionPassManagerC1EPNS_6ModuleE"]
    pub fn llvm_legacy_FunctionPassManager_FunctionPassManager(
        this: *mut llvm_legacy_FunctionPassManager,
        M: *mut llvm_Module,
    );
}
impl llvm_legacy_FunctionPassManager {
    #[inline]
    pub unsafe fn run(&mut self, F: *mut llvm_Function) -> bool {
        llvm_legacy_FunctionPassManager_run(self, F)
    }
    #[inline]
    pub unsafe fn doInitialization(&mut self) -> bool {
        llvm_legacy_FunctionPassManager_doInitialization(self)
    }
    #[inline]
    pub unsafe fn doFinalization(&mut self) -> bool {
        llvm_legacy_FunctionPassManager_doFinalization(self)
    }
    #[inline]
    pub unsafe fn new(M: *mut llvm_Module) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        llvm_legacy_FunctionPassManager_FunctionPassManager(__bindgen_tmp.as_mut_ptr(), M);
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm6legacy19FunctionPassManagerD1Ev"]
    pub fn llvm_legacy_FunctionPassManager_FunctionPassManager_destructor(
        this: *mut llvm_legacy_FunctionPassManager,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm6legacy19FunctionPassManager3addEPNS_4PassE"]
    pub fn llvm_legacy_FunctionPassManager_add(
        this: *mut ::std::os::raw::c_void,
        P: *mut llvm_Pass,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_format_provider {
    pub _address: u8,
}
pub const llvm_FloatStyle_Exponent: llvm_FloatStyle = 0;
pub const llvm_FloatStyle_ExponentUpper: llvm_FloatStyle = 1;
pub const llvm_FloatStyle_Fixed: llvm_FloatStyle = 2;
pub const llvm_FloatStyle_Percent: llvm_FloatStyle = 3;
pub type llvm_FloatStyle = ::std::os::raw::c_int;
pub const llvm_IntegerStyle_Integer: llvm_IntegerStyle = 0;
pub const llvm_IntegerStyle_Number: llvm_IntegerStyle = 1;
pub type llvm_IntegerStyle = ::std::os::raw::c_int;
pub const llvm_HexPrintStyle_Upper: llvm_HexPrintStyle = 0;
pub const llvm_HexPrintStyle_Lower: llvm_HexPrintStyle = 1;
pub const llvm_HexPrintStyle_PrefixUpper: llvm_HexPrintStyle = 2;
pub const llvm_HexPrintStyle_PrefixLower: llvm_HexPrintStyle = 3;
pub type llvm_HexPrintStyle = ::std::os::raw::c_int;
extern "C" {
    #[link_name = "\u{1}_ZN4llvm19getDefaultPrecisionENS_10FloatStyleE"]
    pub fn llvm_getDefaultPrecision(Style: llvm_FloatStyle) -> usize;
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm18isPrefixedHexStyleENS_13HexPrintStyleE"]
    pub fn llvm_isPrefixedHexStyle(S: llvm_HexPrintStyle) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm13write_integerERNS_11raw_ostreamEjmNS_12IntegerStyleE"]
    pub fn llvm_write_integer(
        S: *mut llvm_raw_ostream,
        N: ::std::os::raw::c_uint,
        MinDigits: usize,
        Style: llvm_IntegerStyle,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm13write_integerERNS_11raw_ostreamEimNS_12IntegerStyleE"]
    pub fn llvm_write_integer1(
        S: *mut llvm_raw_ostream,
        N: ::std::os::raw::c_int,
        MinDigits: usize,
        Style: llvm_IntegerStyle,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm13write_integerERNS_11raw_ostreamEmmNS_12IntegerStyleE"]
    pub fn llvm_write_integer2(
        S: *mut llvm_raw_ostream,
        N: ::std::os::raw::c_ulong,
        MinDigits: usize,
        Style: llvm_IntegerStyle,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm13write_integerERNS_11raw_ostreamElmNS_12IntegerStyleE"]
    pub fn llvm_write_integer3(
        S: *mut llvm_raw_ostream,
        N: ::std::os::raw::c_long,
        MinDigits: usize,
        Style: llvm_IntegerStyle,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm13write_integerERNS_11raw_ostreamEymNS_12IntegerStyleE"]
    pub fn llvm_write_integer4(
        S: *mut llvm_raw_ostream,
        N: ::std::os::raw::c_ulonglong,
        MinDigits: usize,
        Style: llvm_IntegerStyle,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm13write_integerERNS_11raw_ostreamExmNS_12IntegerStyleE"]
    pub fn llvm_write_integer5(
        S: *mut llvm_raw_ostream,
        N: ::std::os::raw::c_longlong,
        MinDigits: usize,
        Style: llvm_IntegerStyle,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm9write_hexERNS_11raw_ostreamEmNS_13HexPrintStyleESt8optionalImE"]
    pub fn llvm_write_hex(
        S: *mut llvm_raw_ostream,
        N: u64,
        Style: llvm_HexPrintStyle,
        Width: std_optional,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm12write_doubleERNS_11raw_ostreamEdNS_10FloatStyleESt8optionalImE"]
    pub fn llvm_write_double(
        S: *mut llvm_raw_ostream,
        D: f64,
        Style: llvm_FloatStyle,
        Precision: std_optional,
    );
}
#[test]
fn __bindgen_test_layout_llvm_format_provider_open0_llvm_Twine_void_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<llvm_format_provider>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_format_provider)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_format_provider>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_format_provider)
        )
    );
}
#[test]
fn __bindgen_test_layout_llvm_format_provider_open0_bool__void_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<llvm_format_provider>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_format_provider)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_format_provider>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_format_provider)
        )
    );
}
#[test]
fn __bindgen_test_layout_llvm_format_provider_open0_std_chrono_time_point_open1_std_chrono__V2_system_clock_std_chrono_duration_open2_long_std_ratio_open3_close3_close2_close1_void_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<llvm_format_provider>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_format_provider)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_format_provider>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_format_provider)
        )
    );
}
#[test]
fn __bindgen_test_layout_llvm_format_provider_open0_std_chrono_time_point_open1_llvm_sys_UtcClock_std_chrono_duration_open2_long_std_ratio_open3_close3_close2_close1_void_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<llvm_format_provider>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_format_provider)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_format_provider>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_format_provider)
        )
    );
}
#[test]
fn __bindgen_test_layout_llvm_DenseMapInfo_open0_llvm_sys_fs_UniqueID_void_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<llvm_DenseMapInfo>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_DenseMapInfo)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_DenseMapInfo>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_DenseMapInfo)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_MD5 {
    pub InternalState: llvm_MD5__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_MD5_MD5Result {
    pub _base: [u8; 16usize],
}
#[test]
fn bindgen_test_layout_llvm_MD5_MD5Result() {
    assert_eq!(
        ::std::mem::size_of::<llvm_MD5_MD5Result>(),
        16usize,
        concat!("Size of: ", stringify!(llvm_MD5_MD5Result))
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_MD5_MD5Result>(),
        1usize,
        concat!("Alignment of ", stringify!(llvm_MD5_MD5Result))
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK4llvm3MD59MD5Result6digestEv"]
    pub fn llvm_MD5_MD5Result_digest(this: *const llvm_MD5_MD5Result) -> [u64; 7usize];
}
impl llvm_MD5_MD5Result {
    #[inline]
    pub unsafe fn digest(&self) -> [u64; 7usize] {
        llvm_MD5_MD5Result_digest(self)
    }
}
pub type llvm_MD5_MD5_u32plus = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_MD5__bindgen_ty_1 {
    pub a: llvm_MD5_MD5_u32plus,
    pub b: llvm_MD5_MD5_u32plus,
    pub c: llvm_MD5_MD5_u32plus,
    pub d: llvm_MD5_MD5_u32plus,
    pub hi: llvm_MD5_MD5_u32plus,
    pub lo: llvm_MD5_MD5_u32plus,
    pub buffer: [u8; 64usize],
    pub block: [llvm_MD5_MD5_u32plus; 16usize],
}
#[test]
fn bindgen_test_layout_llvm_MD5__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<llvm_MD5__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<llvm_MD5__bindgen_ty_1>(),
        152usize,
        concat!("Size of: ", stringify!(llvm_MD5__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_MD5__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(llvm_MD5__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).a) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_MD5__bindgen_ty_1),
            "::",
            stringify!(a)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).b) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_MD5__bindgen_ty_1),
            "::",
            stringify!(b)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).c) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_MD5__bindgen_ty_1),
            "::",
            stringify!(c)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).d) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_MD5__bindgen_ty_1),
            "::",
            stringify!(d)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hi) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_MD5__bindgen_ty_1),
            "::",
            stringify!(hi)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).lo) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_MD5__bindgen_ty_1),
            "::",
            stringify!(lo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).buffer) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_MD5__bindgen_ty_1),
            "::",
            stringify!(buffer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).block) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_MD5__bindgen_ty_1),
            "::",
            stringify!(block)
        )
    );
}
#[test]
fn bindgen_test_layout_llvm_MD5() {
    const UNINIT: ::std::mem::MaybeUninit<llvm_MD5> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<llvm_MD5>(),
        152usize,
        concat!("Size of: ", stringify!(llvm_MD5))
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_MD5>(),
        4usize,
        concat!("Alignment of ", stringify!(llvm_MD5))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).InternalState) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_MD5),
            "::",
            stringify!(InternalState)
        )
    );
}
extern "C" {
    #[doc = " Updates the hash for the byte stream provided."]
    #[link_name = "\u{1}_ZN4llvm3MD56updateENS_8ArrayRefIhEE"]
    pub fn llvm_MD5_update(this: *mut llvm_MD5, Data: llvm_ArrayRef<u8>);
}
extern "C" {
    #[doc = " Updates the hash for the StringRef provided."]
    #[link_name = "\u{1}_ZN4llvm3MD56updateENS_9StringRefE"]
    pub fn llvm_MD5_update1(this: *mut llvm_MD5, Str: llvm_StringRef);
}
extern "C" {
    #[doc = " Finishes off the hash and puts the result in result."]
    #[link_name = "\u{1}_ZN4llvm3MD55finalERNS0_9MD5ResultE"]
    pub fn llvm_MD5_final(this: *mut llvm_MD5, Result: *mut llvm_MD5_MD5Result);
}
extern "C" {
    #[doc = " Finishes off the hash, and returns the 16-byte hash data."]
    #[link_name = "\u{1}_ZN4llvm3MD55finalEv"]
    pub fn llvm_MD5_final1(this: *mut llvm_MD5) -> llvm_MD5_MD5Result;
}
extern "C" {
    #[doc = " Finishes off the hash, and returns the 16-byte hash data.\n This is suitable for getting the MD5 at any time without invalidating the\n internal state, so that more calls can be made into `update`."]
    #[link_name = "\u{1}_ZN4llvm3MD56resultEv"]
    pub fn llvm_MD5_result(this: *mut llvm_MD5) -> llvm_MD5_MD5Result;
}
extern "C" {
    #[doc = " Translates the bytes in \\p Res to a hex string that is\n deposited into \\p Str. The result will be of length 32."]
    #[link_name = "\u{1}_ZN4llvm3MD515stringifyResultERNS0_9MD5ResultERNS_15SmallVectorImplIcEE"]
    pub fn llvm_MD5_stringifyResult(
        Result: *mut llvm_MD5_MD5Result,
        Str: *mut llvm_SmallVectorImpl,
    );
}
extern "C" {
    #[doc = " Computes the hash for a given bytes."]
    #[link_name = "\u{1}_ZN4llvm3MD54hashENS_8ArrayRefIhEE"]
    pub fn llvm_MD5_hash(Data: llvm_ArrayRef<u8>) -> llvm_MD5_MD5Result;
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm3MD5C1Ev"]
    pub fn llvm_MD5_MD5(this: *mut llvm_MD5);
}
impl llvm_MD5 {
    #[inline]
    pub unsafe fn update(&mut self, Data: llvm_ArrayRef<u8>) {
        llvm_MD5_update(self, Data)
    }
    #[inline]
    pub unsafe fn update1(&mut self, Str: llvm_StringRef) {
        llvm_MD5_update1(self, Str)
    }
    #[inline]
    pub unsafe fn final_(&mut self, Result: *mut llvm_MD5_MD5Result) {
        llvm_MD5_final(self, Result)
    }
    #[inline]
    pub unsafe fn final1(&mut self) -> llvm_MD5_MD5Result {
        llvm_MD5_final1(self)
    }
    #[inline]
    pub unsafe fn result(&mut self) -> llvm_MD5_MD5Result {
        llvm_MD5_result(self)
    }
    #[inline]
    pub unsafe fn stringifyResult(Result: *mut llvm_MD5_MD5Result, Str: *mut llvm_SmallVectorImpl) {
        llvm_MD5_stringifyResult(Result, Str)
    }
    #[inline]
    pub unsafe fn hash(Data: llvm_ArrayRef<u8>) -> llvm_MD5_MD5Result {
        llvm_MD5_hash(Data)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        llvm_MD5_MD5(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
}
pub const llvm_binaryformat_Swift5ReflectionSectionKind_fieldmd:
    llvm_binaryformat_Swift5ReflectionSectionKind = 0;
pub const llvm_binaryformat_Swift5ReflectionSectionKind_assocty:
    llvm_binaryformat_Swift5ReflectionSectionKind = 1;
pub const llvm_binaryformat_Swift5ReflectionSectionKind_builtin:
    llvm_binaryformat_Swift5ReflectionSectionKind = 2;
pub const llvm_binaryformat_Swift5ReflectionSectionKind_capture:
    llvm_binaryformat_Swift5ReflectionSectionKind = 3;
pub const llvm_binaryformat_Swift5ReflectionSectionKind_typeref:
    llvm_binaryformat_Swift5ReflectionSectionKind = 4;
pub const llvm_binaryformat_Swift5ReflectionSectionKind_reflstr:
    llvm_binaryformat_Swift5ReflectionSectionKind = 5;
pub const llvm_binaryformat_Swift5ReflectionSectionKind_conform:
    llvm_binaryformat_Swift5ReflectionSectionKind = 6;
pub const llvm_binaryformat_Swift5ReflectionSectionKind_protocs:
    llvm_binaryformat_Swift5ReflectionSectionKind = 7;
pub const llvm_binaryformat_Swift5ReflectionSectionKind_acfuncs:
    llvm_binaryformat_Swift5ReflectionSectionKind = 8;
pub const llvm_binaryformat_Swift5ReflectionSectionKind_mpenum:
    llvm_binaryformat_Swift5ReflectionSectionKind = 9;
pub const llvm_binaryformat_Swift5ReflectionSectionKind_swiftast:
    llvm_binaryformat_Swift5ReflectionSectionKind = 10;
pub const llvm_binaryformat_Swift5ReflectionSectionKind_unknown:
    llvm_binaryformat_Swift5ReflectionSectionKind = 11;
pub const llvm_binaryformat_Swift5ReflectionSectionKind_last:
    llvm_binaryformat_Swift5ReflectionSectionKind = 11;
pub type llvm_binaryformat_Swift5ReflectionSectionKind = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_MCExpr {
    _unused: [u8; 0],
}
#[doc = "< A no-op fixup."]
pub const llvm_MCFixupKind_FK_NONE: llvm_MCFixupKind = 0;
#[doc = "< A one-byte fixup."]
pub const llvm_MCFixupKind_FK_Data_1: llvm_MCFixupKind = 1;
#[doc = "< A two-byte fixup."]
pub const llvm_MCFixupKind_FK_Data_2: llvm_MCFixupKind = 2;
#[doc = "< A four-byte fixup."]
pub const llvm_MCFixupKind_FK_Data_4: llvm_MCFixupKind = 3;
#[doc = "< A eight-byte fixup."]
pub const llvm_MCFixupKind_FK_Data_8: llvm_MCFixupKind = 4;
#[doc = "< A leb128 fixup."]
pub const llvm_MCFixupKind_FK_Data_leb128: llvm_MCFixupKind = 5;
#[doc = "< A one-byte pc relative fixup."]
pub const llvm_MCFixupKind_FK_PCRel_1: llvm_MCFixupKind = 6;
#[doc = "< A two-byte pc relative fixup."]
pub const llvm_MCFixupKind_FK_PCRel_2: llvm_MCFixupKind = 7;
#[doc = "< A four-byte pc relative fixup."]
pub const llvm_MCFixupKind_FK_PCRel_4: llvm_MCFixupKind = 8;
#[doc = "< A eight-byte pc relative fixup."]
pub const llvm_MCFixupKind_FK_PCRel_8: llvm_MCFixupKind = 9;
#[doc = "< A one-byte gp relative fixup."]
pub const llvm_MCFixupKind_FK_GPRel_1: llvm_MCFixupKind = 10;
#[doc = "< A two-byte gp relative fixup."]
pub const llvm_MCFixupKind_FK_GPRel_2: llvm_MCFixupKind = 11;
#[doc = "< A four-byte gp relative fixup."]
pub const llvm_MCFixupKind_FK_GPRel_4: llvm_MCFixupKind = 12;
#[doc = "< A eight-byte gp relative fixup."]
pub const llvm_MCFixupKind_FK_GPRel_8: llvm_MCFixupKind = 13;
#[doc = "< A four-byte dtp relative fixup."]
pub const llvm_MCFixupKind_FK_DTPRel_4: llvm_MCFixupKind = 14;
#[doc = "< A eight-byte dtp relative fixup."]
pub const llvm_MCFixupKind_FK_DTPRel_8: llvm_MCFixupKind = 15;
#[doc = "< A four-byte tp relative fixup."]
pub const llvm_MCFixupKind_FK_TPRel_4: llvm_MCFixupKind = 16;
#[doc = "< A eight-byte tp relative fixup."]
pub const llvm_MCFixupKind_FK_TPRel_8: llvm_MCFixupKind = 17;
#[doc = "< A one-byte section relative fixup."]
pub const llvm_MCFixupKind_FK_SecRel_1: llvm_MCFixupKind = 18;
#[doc = "< A two-byte section relative fixup."]
pub const llvm_MCFixupKind_FK_SecRel_2: llvm_MCFixupKind = 19;
#[doc = "< A four-byte section relative fixup."]
pub const llvm_MCFixupKind_FK_SecRel_4: llvm_MCFixupKind = 20;
#[doc = "< A eight-byte section relative fixup."]
pub const llvm_MCFixupKind_FK_SecRel_8: llvm_MCFixupKind = 21;
pub const llvm_MCFixupKind_FirstTargetFixupKind: llvm_MCFixupKind = 128;
#[doc = " The range [FirstLiteralRelocationKind, MaxTargetFixupKind) is used for\n relocations coming from .reloc directive. Fixup kind\n FirstLiteralRelocationKind+V represents the relocation type with number V."]
pub const llvm_MCFixupKind_FirstLiteralRelocationKind: llvm_MCFixupKind = 256;
#[doc = " Set limit to accommodate the highest reloc type in use for all Targets,\n currently R_AARCH64_IRELATIVE at 1032, including room for expansion."]
pub const llvm_MCFixupKind_MaxFixupKind: llvm_MCFixupKind = 1320;
#[doc = " Extensible enumeration to represent the type of a fixup."]
pub type llvm_MCFixupKind = ::std::os::raw::c_uint;
#[doc = " Encode information on a single operation to perform on a byte\n sequence (e.g., an encoded instruction) which requires assemble- or run-\n time patching.\n\n Fixups are used any time the target instruction encoder needs to represent\n some value in an instruction which is not yet concrete. The encoder will\n encode the instruction assuming the value is 0, and emit a fixup which\n communicates to the assembler backend how it should rewrite the encoded\n value.\n\n During the process of relaxation, the assembler will apply fixups as\n symbolic values become concrete. When relaxation is complete, any remaining\n fixups become relocations in the object file (or errors, if the fixup cannot\n be encoded on the target)."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_MCFixup {
    #[doc = " The value to put into the fixup location. The exact interpretation of the\n expression is target dependent, usually it will be one of the operands to\n an instruction or an assembler directive."]
    pub Value: *const llvm_MCExpr,
    #[doc = " The byte index of start of the relocation inside the MCFragment."]
    pub Offset: u32,
    #[doc = " The target dependent kind of fixup item this is. The kind is used to\n determine how the operand value should be encoded into the instruction."]
    pub Kind: llvm_MCFixupKind,
    #[doc = " The source location which gave rise to the fixup, if any."]
    pub Loc: llvm_SMLoc,
}
#[test]
fn bindgen_test_layout_llvm_MCFixup() {
    const UNINIT: ::std::mem::MaybeUninit<llvm_MCFixup> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<llvm_MCFixup>(),
        24usize,
        concat!("Size of: ", stringify!(llvm_MCFixup))
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_MCFixup>(),
        8usize,
        concat!("Alignment of ", stringify!(llvm_MCFixup))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Value) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_MCFixup),
            "::",
            stringify!(Value)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Offset) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_MCFixup),
            "::",
            stringify!(Offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Kind) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_MCFixup),
            "::",
            stringify!(Kind)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Loc) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_MCFixup),
            "::",
            stringify!(Loc)
        )
    );
}
#[doc = " An unsigned integer type large enough to represent all physical registers,\n but not necessarily virtual registers."]
pub type llvm_MCPhysReg = u16;
#[doc = " Register units are used to compute register aliasing. Every register has at\n least one register unit, but it can have more. Two registers overlap if and\n only if they have a common register unit.\n\n A target with a complicated sub-register structure will typically have many\n fewer register units than actual registers. MCRI::getNumRegUnits() returns\n the number of register units in the target."]
pub type llvm_MCRegUnit = ::std::os::raw::c_uint;
#[doc = " Wrapper class representing physical registers. Should be passed by value."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_MCRegister {
    pub Reg: ::std::os::raw::c_uint,
}
pub const llvm_MCRegister_NoRegister: ::std::os::raw::c_uint = 0;
pub const llvm_MCRegister_FirstPhysicalReg: ::std::os::raw::c_uint = 1;
pub const llvm_MCRegister_FirstStackSlot: ::std::os::raw::c_uint = 1073741824;
pub const llvm_MCRegister_VirtualRegFlag: ::std::os::raw::c_uint = 2147483648;
#[test]
fn bindgen_test_layout_llvm_MCRegister() {
    const UNINIT: ::std::mem::MaybeUninit<llvm_MCRegister> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<llvm_MCRegister>(),
        4usize,
        concat!("Size of: ", stringify!(llvm_MCRegister))
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_MCRegister>(),
        4usize,
        concat!("Alignment of ", stringify!(llvm_MCRegister))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_MCRegister),
            "::",
            stringify!(Reg)
        )
    );
}
#[test]
fn __bindgen_test_layout_llvm_DenseMapInfo_open0_llvm_MCRegister_void_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<llvm_DenseMapInfo>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_DenseMapInfo)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_DenseMapInfo>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_DenseMapInfo)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_MCInstPrinter {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_MCRegisterInfo {
    _unused: [u8; 0],
}
#[doc = " Instances of this class represent operands of the MCInst class.\n This is a simple discriminated union."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct llvm_MCOperand {
    pub Kind: llvm_MCOperand_MachineOperandType,
    pub __bindgen_anon_1: llvm_MCOperand__bindgen_ty_1,
}
#[doc = "< Uninitialized."]
pub const llvm_MCOperand_MachineOperandType_kInvalid: llvm_MCOperand_MachineOperandType = 0;
#[doc = "< Register operand."]
pub const llvm_MCOperand_MachineOperandType_kRegister: llvm_MCOperand_MachineOperandType = 1;
#[doc = "< Immediate operand."]
pub const llvm_MCOperand_MachineOperandType_kImmediate: llvm_MCOperand_MachineOperandType = 2;
#[doc = "< Single-floating-point immediate operand."]
pub const llvm_MCOperand_MachineOperandType_kSFPImmediate: llvm_MCOperand_MachineOperandType = 3;
#[doc = "< Double-Floating-point immediate operand."]
pub const llvm_MCOperand_MachineOperandType_kDFPImmediate: llvm_MCOperand_MachineOperandType = 4;
#[doc = "< Relocatable immediate operand."]
pub const llvm_MCOperand_MachineOperandType_kExpr: llvm_MCOperand_MachineOperandType = 5;
#[doc = "< Sub-instruction operand."]
pub const llvm_MCOperand_MachineOperandType_kInst: llvm_MCOperand_MachineOperandType = 6;
pub type llvm_MCOperand_MachineOperandType = ::std::os::raw::c_uchar;
#[repr(C)]
#[derive(Copy, Clone)]
pub union llvm_MCOperand__bindgen_ty_1 {
    pub RegVal: ::std::os::raw::c_uint,
    pub ImmVal: i64,
    pub SFPImmVal: u32,
    pub FPImmVal: u64,
    pub ExprVal: *const llvm_MCExpr,
    pub InstVal: *const llvm_MCInst,
}
#[test]
fn bindgen_test_layout_llvm_MCOperand__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<llvm_MCOperand__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<llvm_MCOperand__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(llvm_MCOperand__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_MCOperand__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(llvm_MCOperand__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).RegVal) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_MCOperand__bindgen_ty_1),
            "::",
            stringify!(RegVal)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ImmVal) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_MCOperand__bindgen_ty_1),
            "::",
            stringify!(ImmVal)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).SFPImmVal) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_MCOperand__bindgen_ty_1),
            "::",
            stringify!(SFPImmVal)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).FPImmVal) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_MCOperand__bindgen_ty_1),
            "::",
            stringify!(FPImmVal)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ExprVal) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_MCOperand__bindgen_ty_1),
            "::",
            stringify!(ExprVal)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).InstVal) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_MCOperand__bindgen_ty_1),
            "::",
            stringify!(InstVal)
        )
    );
}
#[test]
fn bindgen_test_layout_llvm_MCOperand() {
    const UNINIT: ::std::mem::MaybeUninit<llvm_MCOperand> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<llvm_MCOperand>(),
        16usize,
        concat!("Size of: ", stringify!(llvm_MCOperand))
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_MCOperand>(),
        8usize,
        concat!("Alignment of ", stringify!(llvm_MCOperand))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Kind) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_MCOperand),
            "::",
            stringify!(Kind)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK4llvm9MCOperand5printERNS_11raw_ostreamEPKNS_14MCRegisterInfoE"]
    pub fn llvm_MCOperand_print(
        this: *const llvm_MCOperand,
        OS: *mut llvm_raw_ostream,
        RegInfo: *const llvm_MCRegisterInfo,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK4llvm9MCOperand4dumpEv"]
    pub fn llvm_MCOperand_dump(this: *const llvm_MCOperand);
}
extern "C" {
    #[link_name = "\u{1}_ZNK4llvm9MCOperand15isBareSymbolRefEv"]
    pub fn llvm_MCOperand_isBareSymbolRef(this: *const llvm_MCOperand) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4llvm9MCOperand21evaluateAsConstantImmERl"]
    pub fn llvm_MCOperand_evaluateAsConstantImm(this: *const llvm_MCOperand, Imm: *mut i64)
        -> bool;
}
impl llvm_MCOperand {
    #[inline]
    pub unsafe fn print(&self, OS: *mut llvm_raw_ostream, RegInfo: *const llvm_MCRegisterInfo) {
        llvm_MCOperand_print(self, OS, RegInfo)
    }
    #[inline]
    pub unsafe fn dump(&self) {
        llvm_MCOperand_dump(self)
    }
    #[inline]
    pub unsafe fn isBareSymbolRef(&self) -> bool {
        llvm_MCOperand_isBareSymbolRef(self)
    }
    #[inline]
    pub unsafe fn evaluateAsConstantImm(&self, Imm: *mut i64) -> bool {
        llvm_MCOperand_evaluateAsConstantImm(self, Imm)
    }
}
#[doc = " Instances of this class represent a single low-level machine\n instruction."]
#[repr(C)]
#[derive(Debug)]
pub struct llvm_MCInst {
    pub Opcode: ::std::os::raw::c_uint,
    pub Flags: ::std::os::raw::c_uint,
    pub Loc: llvm_SMLoc,
    pub Operands: [u64; 14usize],
}
pub type llvm_MCInst_iterator = iterator;
pub type llvm_MCInst_const_iterator = const_iterator;
#[test]
fn bindgen_test_layout_llvm_MCInst() {
    const UNINIT: ::std::mem::MaybeUninit<llvm_MCInst> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<llvm_MCInst>(),
        128usize,
        concat!("Size of: ", stringify!(llvm_MCInst))
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_MCInst>(),
        8usize,
        concat!("Alignment of ", stringify!(llvm_MCInst))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Opcode) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_MCInst),
            "::",
            stringify!(Opcode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Flags) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_MCInst),
            "::",
            stringify!(Flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Loc) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_MCInst),
            "::",
            stringify!(Loc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Operands) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_MCInst),
            "::",
            stringify!(Operands)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK4llvm6MCInst5printERNS_11raw_ostreamEPKNS_14MCRegisterInfoE"]
    pub fn llvm_MCInst_print(
        this: *const llvm_MCInst,
        OS: *mut llvm_raw_ostream,
        RegInfo: *const llvm_MCRegisterInfo,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK4llvm6MCInst4dumpEv"]
    pub fn llvm_MCInst_dump(this: *const llvm_MCInst);
}
extern "C" {
    #[doc = " Dump the MCInst as prettily as possible using the additional MC\n structures, if given. Operators are separated by the \\p Separator\n string."]
    #[link_name = "\u{1}_ZNK4llvm6MCInst11dump_prettyERNS_11raw_ostreamEPKNS_13MCInstPrinterENS_9StringRefEPKNS_14MCRegisterInfoE"]
    pub fn llvm_MCInst_dump_pretty(
        this: *const llvm_MCInst,
        OS: *mut llvm_raw_ostream,
        Printer: *const llvm_MCInstPrinter,
        Separator: llvm_StringRef,
        RegInfo: *const llvm_MCRegisterInfo,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK4llvm6MCInst11dump_prettyERNS_11raw_ostreamENS_9StringRefES3_PKNS_14MCRegisterInfoE"]
    pub fn llvm_MCInst_dump_pretty1(
        this: *const llvm_MCInst,
        OS: *mut llvm_raw_ostream,
        Name: llvm_StringRef,
        Separator: llvm_StringRef,
        RegInfo: *const llvm_MCRegisterInfo,
    );
}
impl llvm_MCInst {
    #[inline]
    pub unsafe fn print(&self, OS: *mut llvm_raw_ostream, RegInfo: *const llvm_MCRegisterInfo) {
        llvm_MCInst_print(self, OS, RegInfo)
    }
    #[inline]
    pub unsafe fn dump(&self) {
        llvm_MCInst_dump(self)
    }
    #[inline]
    pub unsafe fn dump_pretty(
        &self,
        OS: *mut llvm_raw_ostream,
        Printer: *const llvm_MCInstPrinter,
        Separator: llvm_StringRef,
        RegInfo: *const llvm_MCRegisterInfo,
    ) {
        llvm_MCInst_dump_pretty(self, OS, Printer, Separator, RegInfo)
    }
    #[inline]
    pub unsafe fn dump_pretty1(
        &self,
        OS: *mut llvm_raw_ostream,
        Name: llvm_StringRef,
        Separator: llvm_StringRef,
        RegInfo: *const llvm_MCRegisterInfo,
    ) {
        llvm_MCInst_dump_pretty1(self, OS, Name, Separator, RegInfo)
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_MCAssembler {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_MCObjectStreamer {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_MCSubtargetInfo {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_MCSymbol {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_MCFragment {
    pub Next: *mut llvm_MCFragment,
    #[doc = " The data for the section this fragment is in."]
    pub Parent: *mut llvm_MCSection,
    #[doc = " The offset of this fragment in its section."]
    pub Offset: u64,
    #[doc = " The layout order of this fragment."]
    pub LayoutOrder: ::std::os::raw::c_uint,
    pub Kind: llvm_MCFragment_FragmentType,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: u16,
}
pub const llvm_MCFragment_FragmentType_FT_Align: llvm_MCFragment_FragmentType = 0;
pub const llvm_MCFragment_FragmentType_FT_Data: llvm_MCFragment_FragmentType = 1;
pub const llvm_MCFragment_FragmentType_FT_Fill: llvm_MCFragment_FragmentType = 2;
pub const llvm_MCFragment_FragmentType_FT_Nops: llvm_MCFragment_FragmentType = 3;
pub const llvm_MCFragment_FragmentType_FT_Relaxable: llvm_MCFragment_FragmentType = 4;
pub const llvm_MCFragment_FragmentType_FT_Org: llvm_MCFragment_FragmentType = 5;
pub const llvm_MCFragment_FragmentType_FT_Dwarf: llvm_MCFragment_FragmentType = 6;
pub const llvm_MCFragment_FragmentType_FT_DwarfFrame: llvm_MCFragment_FragmentType = 7;
pub const llvm_MCFragment_FragmentType_FT_LEB: llvm_MCFragment_FragmentType = 8;
pub const llvm_MCFragment_FragmentType_FT_BoundaryAlign: llvm_MCFragment_FragmentType = 9;
pub const llvm_MCFragment_FragmentType_FT_SymbolId: llvm_MCFragment_FragmentType = 10;
pub const llvm_MCFragment_FragmentType_FT_CVInlineLines: llvm_MCFragment_FragmentType = 11;
pub const llvm_MCFragment_FragmentType_FT_CVDefRange: llvm_MCFragment_FragmentType = 12;
pub const llvm_MCFragment_FragmentType_FT_PseudoProbe: llvm_MCFragment_FragmentType = 13;
pub const llvm_MCFragment_FragmentType_FT_Dummy: llvm_MCFragment_FragmentType = 14;
pub type llvm_MCFragment_FragmentType = u8;
#[test]
fn bindgen_test_layout_llvm_MCFragment() {
    const UNINIT: ::std::mem::MaybeUninit<llvm_MCFragment> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<llvm_MCFragment>(),
        32usize,
        concat!("Size of: ", stringify!(llvm_MCFragment))
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_MCFragment>(),
        8usize,
        concat!("Alignment of ", stringify!(llvm_MCFragment))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Next) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_MCFragment),
            "::",
            stringify!(Next)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Parent) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_MCFragment),
            "::",
            stringify!(Parent)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Offset) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_MCFragment),
            "::",
            stringify!(Offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LayoutOrder) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_MCFragment),
            "::",
            stringify!(LayoutOrder)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Kind) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_MCFragment),
            "::",
            stringify!(Kind)
        )
    );
}
extern "C" {
    #[doc = " Destroys the current fragment.\n\n This must be used instead of delete as MCFragment is non-virtual.\n This method will dispatch to the appropriate subclass."]
    #[link_name = "\u{1}_ZN4llvm10MCFragment7destroyEv"]
    pub fn llvm_MCFragment_destroy(this: *mut llvm_MCFragment);
}
extern "C" {
    #[link_name = "\u{1}_ZNK4llvm10MCFragment7getAtomEv"]
    pub fn llvm_MCFragment_getAtom(this: *const llvm_MCFragment) -> *const llvm_MCSymbol;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4llvm10MCFragment4dumpEv"]
    pub fn llvm_MCFragment_dump(this: *const llvm_MCFragment);
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm10MCFragmentC1ENS0_12FragmentTypeEb"]
    pub fn llvm_MCFragment_MCFragment(
        this: *mut llvm_MCFragment,
        Kind: llvm_MCFragment_FragmentType,
        HasInstructions: bool,
    );
}
impl llvm_MCFragment {
    #[inline]
    pub fn HasInstructions(&self) -> bool {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_HasInstructions(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn AlignToBundleEnd(&self) -> bool {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_AlignToBundleEnd(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn LinkerRelaxable(&self) -> bool {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_LinkerRelaxable(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn AllowAutoPadding(&self) -> bool {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_AllowAutoPadding(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        HasInstructions: bool,
        AlignToBundleEnd: bool,
        LinkerRelaxable: bool,
        AllowAutoPadding: bool,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let HasInstructions: u8 = unsafe { ::std::mem::transmute(HasInstructions) };
            HasInstructions as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let AlignToBundleEnd: u8 = unsafe { ::std::mem::transmute(AlignToBundleEnd) };
            AlignToBundleEnd as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let LinkerRelaxable: u8 = unsafe { ::std::mem::transmute(LinkerRelaxable) };
            LinkerRelaxable as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let AllowAutoPadding: u8 = unsafe { ::std::mem::transmute(AllowAutoPadding) };
            AllowAutoPadding as u64
        });
        __bindgen_bitfield_unit
    }
    #[inline]
    pub unsafe fn destroy(&mut self) {
        llvm_MCFragment_destroy(self)
    }
    #[inline]
    pub unsafe fn getAtom(&self) -> *const llvm_MCSymbol {
        llvm_MCFragment_getAtom(self)
    }
    #[inline]
    pub unsafe fn dump(&self) {
        llvm_MCFragment_dump(self)
    }
    #[inline]
    pub unsafe fn new(Kind: llvm_MCFragment_FragmentType, HasInstructions: bool) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        llvm_MCFragment_MCFragment(__bindgen_tmp.as_mut_ptr(), Kind, HasInstructions);
        __bindgen_tmp.assume_init()
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_MCDummyFragment {
    pub _base: llvm_MCFragment,
}
#[test]
fn bindgen_test_layout_llvm_MCDummyFragment() {
    assert_eq!(
        ::std::mem::size_of::<llvm_MCDummyFragment>(),
        32usize,
        concat!("Size of: ", stringify!(llvm_MCDummyFragment))
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_MCDummyFragment>(),
        8usize,
        concat!("Alignment of ", stringify!(llvm_MCDummyFragment))
    );
}
#[doc = " Interface implemented by fragments that contain encoded instructions and/or\n data.\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_MCEncodedFragment {
    pub _base: llvm_MCFragment,
    pub BundlePadding: u8,
    #[doc = " The MCSubtargetInfo in effect when the instruction was encoded.\n It must be non-null for instructions."]
    pub STI: *const llvm_MCSubtargetInfo,
}
#[test]
fn bindgen_test_layout_llvm_MCEncodedFragment() {
    const UNINIT: ::std::mem::MaybeUninit<llvm_MCEncodedFragment> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<llvm_MCEncodedFragment>(),
        40usize,
        concat!("Size of: ", stringify!(llvm_MCEncodedFragment))
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_MCEncodedFragment>(),
        8usize,
        concat!("Alignment of ", stringify!(llvm_MCEncodedFragment))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).BundlePadding) as usize - ptr as usize },
        30usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_MCEncodedFragment),
            "::",
            stringify!(BundlePadding)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).STI) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_MCEncodedFragment),
            "::",
            stringify!(STI)
        )
    );
}
pub type llvm_MCEncodedFragmentWithFixups_const_fixup_iterator = const_iterator;
pub type llvm_MCEncodedFragmentWithFixups_fixup_iterator = iterator;
#[doc = " Fragment for data and encoded instructions.\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_MCDataFragment {
    pub _base: [u64; 26usize],
}
#[test]
fn bindgen_test_layout_llvm_MCDataFragment() {
    assert_eq!(
        ::std::mem::size_of::<llvm_MCDataFragment>(),
        208usize,
        concat!("Size of: ", stringify!(llvm_MCDataFragment))
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_MCDataFragment>(),
        8usize,
        concat!("Alignment of ", stringify!(llvm_MCDataFragment))
    );
}
#[doc = " A relaxable fragment holds on to its MCInst, since it may need to be\n relaxed during the assembler layout and relaxation stage.\n"]
#[repr(C)]
#[derive(Debug)]
pub struct llvm_MCRelaxableFragment {
    pub _base: [u64; 14usize],
    #[doc = " The instruction this is a fragment for."]
    pub Inst: llvm_MCInst,
}
#[test]
fn bindgen_test_layout_llvm_MCRelaxableFragment() {
    const UNINIT: ::std::mem::MaybeUninit<llvm_MCRelaxableFragment> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<llvm_MCRelaxableFragment>(),
        240usize,
        concat!("Size of: ", stringify!(llvm_MCRelaxableFragment))
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_MCRelaxableFragment>(),
        8usize,
        concat!("Alignment of ", stringify!(llvm_MCRelaxableFragment))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Inst) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_MCRelaxableFragment),
            "::",
            stringify!(Inst)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_MCAlignFragment {
    pub _base: llvm_MCFragment,
    #[doc = " The alignment to ensure, in bytes."]
    pub Alignment: llvm_Align,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    #[doc = " Value to use for filling padding bytes."]
    pub Value: i64,
    #[doc = " The size of the integer (in bytes) of \\p Value."]
    pub ValueSize: ::std::os::raw::c_uint,
    #[doc = " The maximum number of bytes to emit; if the alignment\n cannot be satisfied in this width then this fragment is ignored."]
    pub MaxBytesToEmit: ::std::os::raw::c_uint,
    #[doc = " When emitting Nops some subtargets have specific nop encodings."]
    pub STI: *const llvm_MCSubtargetInfo,
}
#[test]
fn bindgen_test_layout_llvm_MCAlignFragment() {
    const UNINIT: ::std::mem::MaybeUninit<llvm_MCAlignFragment> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<llvm_MCAlignFragment>(),
        56usize,
        concat!("Size of: ", stringify!(llvm_MCAlignFragment))
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_MCAlignFragment>(),
        8usize,
        concat!("Alignment of ", stringify!(llvm_MCAlignFragment))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Alignment) as usize - ptr as usize },
        30usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_MCAlignFragment),
            "::",
            stringify!(Alignment)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Value) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_MCAlignFragment),
            "::",
            stringify!(Value)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ValueSize) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_MCAlignFragment),
            "::",
            stringify!(ValueSize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).MaxBytesToEmit) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_MCAlignFragment),
            "::",
            stringify!(MaxBytesToEmit)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).STI) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_MCAlignFragment),
            "::",
            stringify!(STI)
        )
    );
}
impl llvm_MCAlignFragment {
    #[inline]
    pub fn EmitNops(&self) -> bool {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_EmitNops(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(EmitNops: bool) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let EmitNops: u8 = unsafe { ::std::mem::transmute(EmitNops) };
            EmitNops as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_MCFillFragment {
    pub _base: llvm_MCFragment,
    pub ValueSize: u8,
    #[doc = " Value to use for filling bytes."]
    pub Value: u64,
    #[doc = " The number of bytes to insert."]
    pub NumValues: *const llvm_MCExpr,
    #[doc = " Source location of the directive that this fragment was created for."]
    pub Loc: llvm_SMLoc,
}
#[test]
fn bindgen_test_layout_llvm_MCFillFragment() {
    const UNINIT: ::std::mem::MaybeUninit<llvm_MCFillFragment> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<llvm_MCFillFragment>(),
        56usize,
        concat!("Size of: ", stringify!(llvm_MCFillFragment))
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_MCFillFragment>(),
        8usize,
        concat!("Alignment of ", stringify!(llvm_MCFillFragment))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ValueSize) as usize - ptr as usize },
        30usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_MCFillFragment),
            "::",
            stringify!(ValueSize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Value) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_MCFillFragment),
            "::",
            stringify!(Value)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).NumValues) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_MCFillFragment),
            "::",
            stringify!(NumValues)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Loc) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_MCFillFragment),
            "::",
            stringify!(Loc)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_MCNopsFragment {
    pub _base: llvm_MCFragment,
    #[doc = " The number of bytes to insert."]
    pub Size: i64,
    #[doc = " Maximum number of bytes allowed in each NOP instruction."]
    pub ControlledNopLength: i64,
    #[doc = " Source location of the directive that this fragment was created for."]
    pub Loc: llvm_SMLoc,
    #[doc = " When emitting Nops some subtargets have specific nop encodings."]
    pub STI: *const llvm_MCSubtargetInfo,
}
#[test]
fn bindgen_test_layout_llvm_MCNopsFragment() {
    const UNINIT: ::std::mem::MaybeUninit<llvm_MCNopsFragment> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<llvm_MCNopsFragment>(),
        64usize,
        concat!("Size of: ", stringify!(llvm_MCNopsFragment))
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_MCNopsFragment>(),
        8usize,
        concat!("Alignment of ", stringify!(llvm_MCNopsFragment))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Size) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_MCNopsFragment),
            "::",
            stringify!(Size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ControlledNopLength) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_MCNopsFragment),
            "::",
            stringify!(ControlledNopLength)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Loc) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_MCNopsFragment),
            "::",
            stringify!(Loc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).STI) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_MCNopsFragment),
            "::",
            stringify!(STI)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_MCOrgFragment {
    pub _base: llvm_MCFragment,
    #[doc = " Value to use for filling bytes."]
    pub Value: i8,
    #[doc = " The offset this fragment should start at."]
    pub Offset: *const llvm_MCExpr,
    #[doc = " Source location of the directive that this fragment was created for."]
    pub Loc: llvm_SMLoc,
}
#[test]
fn bindgen_test_layout_llvm_MCOrgFragment() {
    const UNINIT: ::std::mem::MaybeUninit<llvm_MCOrgFragment> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<llvm_MCOrgFragment>(),
        48usize,
        concat!("Size of: ", stringify!(llvm_MCOrgFragment))
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_MCOrgFragment>(),
        8usize,
        concat!("Alignment of ", stringify!(llvm_MCOrgFragment))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Value) as usize - ptr as usize },
        30usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_MCOrgFragment),
            "::",
            stringify!(Value)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Offset) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_MCOrgFragment),
            "::",
            stringify!(Offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Loc) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_MCOrgFragment),
            "::",
            stringify!(Loc)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_MCLEBFragment {
    pub _base: [u64; 11usize],
    #[doc = " True if this is a sleb128, false if uleb128."]
    pub IsSigned: bool,
    #[doc = " The value this fragment should contain."]
    pub Value: *const llvm_MCExpr,
}
#[test]
fn bindgen_test_layout_llvm_MCLEBFragment() {
    const UNINIT: ::std::mem::MaybeUninit<llvm_MCLEBFragment> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<llvm_MCLEBFragment>(),
        104usize,
        concat!("Size of: ", stringify!(llvm_MCLEBFragment))
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_MCLEBFragment>(),
        8usize,
        concat!("Alignment of ", stringify!(llvm_MCLEBFragment))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).IsSigned) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_MCLEBFragment),
            "::",
            stringify!(IsSigned)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Value) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_MCLEBFragment),
            "::",
            stringify!(Value)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_MCDwarfLineAddrFragment {
    pub _base: [u64; 14usize],
    #[doc = " The value of the difference between the two line numbers\n between two .loc dwarf directives."]
    pub LineDelta: i64,
    #[doc = " The expression for the difference of the two symbols that\n make up the address delta between two .loc dwarf directives."]
    pub AddrDelta: *const llvm_MCExpr,
}
#[test]
fn bindgen_test_layout_llvm_MCDwarfLineAddrFragment() {
    const UNINIT: ::std::mem::MaybeUninit<llvm_MCDwarfLineAddrFragment> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<llvm_MCDwarfLineAddrFragment>(),
        128usize,
        concat!("Size of: ", stringify!(llvm_MCDwarfLineAddrFragment))
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_MCDwarfLineAddrFragment>(),
        8usize,
        concat!("Alignment of ", stringify!(llvm_MCDwarfLineAddrFragment))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LineDelta) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_MCDwarfLineAddrFragment),
            "::",
            stringify!(LineDelta)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).AddrDelta) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_MCDwarfLineAddrFragment),
            "::",
            stringify!(AddrDelta)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_MCDwarfCallFrameFragment {
    pub _base: [u64; 14usize],
    #[doc = " The expression for the difference of the two symbols that\n make up the address delta between two .cfi_* dwarf directives."]
    pub AddrDelta: *const llvm_MCExpr,
}
#[test]
fn bindgen_test_layout_llvm_MCDwarfCallFrameFragment() {
    const UNINIT: ::std::mem::MaybeUninit<llvm_MCDwarfCallFrameFragment> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<llvm_MCDwarfCallFrameFragment>(),
        120usize,
        concat!("Size of: ", stringify!(llvm_MCDwarfCallFrameFragment))
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_MCDwarfCallFrameFragment>(),
        8usize,
        concat!("Alignment of ", stringify!(llvm_MCDwarfCallFrameFragment))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).AddrDelta) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_MCDwarfCallFrameFragment),
            "::",
            stringify!(AddrDelta)
        )
    );
}
#[doc = " Represents a symbol table index fragment."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_MCSymbolIdFragment {
    pub _base: llvm_MCFragment,
    pub Sym: *const llvm_MCSymbol,
}
#[test]
fn bindgen_test_layout_llvm_MCSymbolIdFragment() {
    const UNINIT: ::std::mem::MaybeUninit<llvm_MCSymbolIdFragment> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<llvm_MCSymbolIdFragment>(),
        40usize,
        concat!("Size of: ", stringify!(llvm_MCSymbolIdFragment))
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_MCSymbolIdFragment>(),
        8usize,
        concat!("Alignment of ", stringify!(llvm_MCSymbolIdFragment))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Sym) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_MCSymbolIdFragment),
            "::",
            stringify!(Sym)
        )
    );
}
#[doc = " Fragment representing the binary annotations produced by the\n .cv_inline_linetable directive."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_MCCVInlineLineTableFragment {
    pub _base: llvm_MCFragment,
    pub SiteFuncId: ::std::os::raw::c_uint,
    pub StartFileId: ::std::os::raw::c_uint,
    pub StartLineNum: ::std::os::raw::c_uint,
    pub FnStartSym: *const llvm_MCSymbol,
    pub FnEndSym: *const llvm_MCSymbol,
    pub Contents: [u64; 4usize],
}
#[test]
fn bindgen_test_layout_llvm_MCCVInlineLineTableFragment() {
    const UNINIT: ::std::mem::MaybeUninit<llvm_MCCVInlineLineTableFragment> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<llvm_MCCVInlineLineTableFragment>(),
        96usize,
        concat!("Size of: ", stringify!(llvm_MCCVInlineLineTableFragment))
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_MCCVInlineLineTableFragment>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(llvm_MCCVInlineLineTableFragment)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).SiteFuncId) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_MCCVInlineLineTableFragment),
            "::",
            stringify!(SiteFuncId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).StartFileId) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_MCCVInlineLineTableFragment),
            "::",
            stringify!(StartFileId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).StartLineNum) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_MCCVInlineLineTableFragment),
            "::",
            stringify!(StartLineNum)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).FnStartSym) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_MCCVInlineLineTableFragment),
            "::",
            stringify!(FnStartSym)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).FnEndSym) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_MCCVInlineLineTableFragment),
            "::",
            stringify!(FnEndSym)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Contents) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_MCCVInlineLineTableFragment),
            "::",
            stringify!(Contents)
        )
    );
}
#[doc = " Fragment representing the .cv_def_range directive."]
#[repr(C)]
#[derive(Debug)]
pub struct llvm_MCCVDefRangeFragment {
    pub _base: [u64; 26usize],
    pub Ranges: [u64; 6usize],
    pub FixedSizePortion: [u64; 7usize],
}
#[test]
fn bindgen_test_layout_llvm_MCCVDefRangeFragment() {
    const UNINIT: ::std::mem::MaybeUninit<llvm_MCCVDefRangeFragment> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<llvm_MCCVDefRangeFragment>(),
        312usize,
        concat!("Size of: ", stringify!(llvm_MCCVDefRangeFragment))
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_MCCVDefRangeFragment>(),
        8usize,
        concat!("Alignment of ", stringify!(llvm_MCCVDefRangeFragment))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Ranges) as usize - ptr as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_MCCVDefRangeFragment),
            "::",
            stringify!(Ranges)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).FixedSizePortion) as usize - ptr as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_MCCVDefRangeFragment),
            "::",
            stringify!(FixedSizePortion)
        )
    );
}
#[doc = " Represents required padding such that a particular other set of fragments\n does not cross a particular power-of-two boundary. The other fragments must\n follow this one within the same section."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_MCBoundaryAlignFragment {
    pub _base: llvm_MCFragment,
    #[doc = " The alignment requirement of the branch to be aligned."]
    pub AlignBoundary: llvm_Align,
    #[doc = " The last fragment in the set of fragments to be aligned."]
    pub LastFragment: *const llvm_MCFragment,
    #[doc = " The size of the fragment.  The size is lazily set during relaxation, and\n is not meaningful before that."]
    pub Size: u64,
    #[doc = " When emitting Nops some subtargets have specific nop encodings."]
    pub STI: *const llvm_MCSubtargetInfo,
}
#[test]
fn bindgen_test_layout_llvm_MCBoundaryAlignFragment() {
    const UNINIT: ::std::mem::MaybeUninit<llvm_MCBoundaryAlignFragment> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<llvm_MCBoundaryAlignFragment>(),
        56usize,
        concat!("Size of: ", stringify!(llvm_MCBoundaryAlignFragment))
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_MCBoundaryAlignFragment>(),
        8usize,
        concat!("Alignment of ", stringify!(llvm_MCBoundaryAlignFragment))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).AlignBoundary) as usize - ptr as usize },
        30usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_MCBoundaryAlignFragment),
            "::",
            stringify!(AlignBoundary)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LastFragment) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_MCBoundaryAlignFragment),
            "::",
            stringify!(LastFragment)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Size) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_MCBoundaryAlignFragment),
            "::",
            stringify!(Size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).STI) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_MCBoundaryAlignFragment),
            "::",
            stringify!(STI)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_MCPseudoProbeAddrFragment {
    pub _base: [u64; 14usize],
    #[doc = " The expression for the difference of the two symbols that\n make up the address delta between two .pseudoprobe directives."]
    pub AddrDelta: *const llvm_MCExpr,
}
#[test]
fn bindgen_test_layout_llvm_MCPseudoProbeAddrFragment() {
    const UNINIT: ::std::mem::MaybeUninit<llvm_MCPseudoProbeAddrFragment> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<llvm_MCPseudoProbeAddrFragment>(),
        120usize,
        concat!("Size of: ", stringify!(llvm_MCPseudoProbeAddrFragment))
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_MCPseudoProbeAddrFragment>(),
        8usize,
        concat!("Alignment of ", stringify!(llvm_MCPseudoProbeAddrFragment))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).AddrDelta) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_MCPseudoProbeAddrFragment),
            "::",
            stringify!(AddrDelta)
        )
    );
}
#[doc = " SectionKind - This is a simple POD value that classifies the properties of\n a section.  A section is classified into the deepest possible\n classification, and then the target maps them onto their sections based on\n what capabilities they have.\n\n The comments below describe these as if they were an inheritance hierarchy\n in order to explain the predicates below.\n"]
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct llvm_SectionKind {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: [u8; 3usize],
}
#[doc = " Metadata - Debug info sections or other metadata."]
pub const llvm_SectionKind_Kind_Metadata: llvm_SectionKind_Kind = 0;
#[doc = " Exclude - This section will be excluded from the final executable or\n shared library. Only valid for ELF / COFF targets."]
pub const llvm_SectionKind_Kind_Exclude: llvm_SectionKind_Kind = 1;
#[doc = " Text - Text section, used for functions and other executable code."]
pub const llvm_SectionKind_Kind_Text: llvm_SectionKind_Kind = 2;
#[doc = " ExecuteOnly, Text section that is not readable."]
pub const llvm_SectionKind_Kind_ExecuteOnly: llvm_SectionKind_Kind = 3;
#[doc = " ReadOnly - Data that is never written to at program runtime by the\n program or the dynamic linker.  Things in the top-level readonly\n SectionKind are not mergeable."]
pub const llvm_SectionKind_Kind_ReadOnly: llvm_SectionKind_Kind = 4;
#[doc = " Mergeable1ByteCString - 1 byte mergable, null terminated, string."]
pub const llvm_SectionKind_Kind_Mergeable1ByteCString: llvm_SectionKind_Kind = 5;
#[doc = " Mergeable2ByteCString - 2 byte mergable, null terminated, string."]
pub const llvm_SectionKind_Kind_Mergeable2ByteCString: llvm_SectionKind_Kind = 6;
#[doc = " Mergeable4ByteCString - 4 byte mergable, null terminated, string."]
pub const llvm_SectionKind_Kind_Mergeable4ByteCString: llvm_SectionKind_Kind = 7;
#[doc = " MergeableConst4 - This is a section used by 4-byte constants,\n for example, floats."]
pub const llvm_SectionKind_Kind_MergeableConst4: llvm_SectionKind_Kind = 8;
#[doc = " MergeableConst8 - This is a section used by 8-byte constants,\n for example, doubles."]
pub const llvm_SectionKind_Kind_MergeableConst8: llvm_SectionKind_Kind = 9;
#[doc = " MergeableConst16 - This is a section used by 16-byte constants,\n for example, vectors."]
pub const llvm_SectionKind_Kind_MergeableConst16: llvm_SectionKind_Kind = 10;
#[doc = " MergeableConst32 - This is a section used by 32-byte constants,\n for example, vectors."]
pub const llvm_SectionKind_Kind_MergeableConst32: llvm_SectionKind_Kind = 11;
#[doc = " ThreadBSS - Zero-initialized TLS data objects."]
pub const llvm_SectionKind_Kind_ThreadBSS: llvm_SectionKind_Kind = 12;
#[doc = " ThreadData - Initialized TLS data objects."]
pub const llvm_SectionKind_Kind_ThreadData: llvm_SectionKind_Kind = 13;
#[doc = " ThreadBSSLocal - Zero-initialized TLS data objects with local linkage."]
pub const llvm_SectionKind_Kind_ThreadBSSLocal: llvm_SectionKind_Kind = 14;
#[doc = " BSS - Zero initialized writeable data."]
pub const llvm_SectionKind_Kind_BSS: llvm_SectionKind_Kind = 15;
#[doc = " BSSLocal - This is BSS (zero initialized and writable) data\n which has local linkage."]
pub const llvm_SectionKind_Kind_BSSLocal: llvm_SectionKind_Kind = 16;
#[doc = " BSSExtern - This is BSS data with normal external linkage."]
pub const llvm_SectionKind_Kind_BSSExtern: llvm_SectionKind_Kind = 17;
#[doc = " Common - Data with common linkage.  These represent tentative\n definitions, which always have a zero initializer and are never\n marked 'constant'."]
pub const llvm_SectionKind_Kind_Common: llvm_SectionKind_Kind = 18;
#[doc = " This is writeable data that has a non-zero initializer."]
pub const llvm_SectionKind_Kind_Data: llvm_SectionKind_Kind = 19;
#[doc = " ReadOnlyWithRel - These are global variables that are never\n written to by the program, but that have relocations, so they\n must be stuck in a writeable section so that the dynamic linker\n can write to them.  If it chooses to, the dynamic linker can\n mark the pages these globals end up on as read-only after it is\n done with its relocation phase."]
pub const llvm_SectionKind_Kind_ReadOnlyWithRel: llvm_SectionKind_Kind = 20;
pub type llvm_SectionKind_Kind = ::std::os::raw::c_uint;
#[test]
fn bindgen_test_layout_llvm_SectionKind() {
    assert_eq!(
        ::std::mem::size_of::<llvm_SectionKind>(),
        4usize,
        concat!("Size of: ", stringify!(llvm_SectionKind))
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_SectionKind>(),
        4usize,
        concat!("Alignment of ", stringify!(llvm_SectionKind))
    );
}
impl llvm_SectionKind {
    #[inline]
    pub fn K(&self) -> llvm_SectionKind_Kind {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_K(&mut self, val: llvm_SectionKind_Kind) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(K: llvm_SectionKind_Kind) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let K: u32 = unsafe { ::std::mem::transmute(K) };
            K as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_MCAsmInfo {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_MCContext {
    _unused: [u8; 0],
}
#[repr(C)]
pub struct llvm_MCSection__bindgen_vtable(::std::os::raw::c_void);
#[doc = " Instances of this class represent a uniqued identifier for a section in the\n current translation unit.  The MCContext class uniques and creates these."]
#[repr(C)]
#[derive(Debug)]
pub struct llvm_MCSection {
    pub vtable_: *const llvm_MCSection__bindgen_vtable,
    pub CurFragList: *mut llvm_MCSection_FragList,
    pub Begin: *mut llvm_MCSymbol,
    pub End: *mut llvm_MCSymbol,
    #[doc = " The alignment requirement of this section."]
    pub Alignment: llvm_Align,
    #[doc = " The section index in the assemblers section list."]
    pub Ordinal: ::std::os::raw::c_uint,
    #[doc = " Keeping track of bundle-locked state."]
    pub BundleLockState: llvm_MCSection_BundleLockStateType,
    #[doc = " Current nesting depth of bundle_lock directives."]
    pub BundleLockNestingDepth: ::std::os::raw::c_uint,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub DummyFragment: llvm_MCDummyFragment,
    pub Subsections: [u64; 5usize],
    pub Name: llvm_StringRef,
    pub Variant: llvm_MCSection_SectionVariant,
}
pub const llvm_MCSection_SectionVariant_SV_COFF: llvm_MCSection_SectionVariant = 0;
pub const llvm_MCSection_SectionVariant_SV_ELF: llvm_MCSection_SectionVariant = 1;
pub const llvm_MCSection_SectionVariant_SV_GOFF: llvm_MCSection_SectionVariant = 2;
pub const llvm_MCSection_SectionVariant_SV_MachO: llvm_MCSection_SectionVariant = 3;
pub const llvm_MCSection_SectionVariant_SV_Wasm: llvm_MCSection_SectionVariant = 4;
pub const llvm_MCSection_SectionVariant_SV_XCOFF: llvm_MCSection_SectionVariant = 5;
pub const llvm_MCSection_SectionVariant_SV_SPIRV: llvm_MCSection_SectionVariant = 6;
pub const llvm_MCSection_SectionVariant_SV_DXContainer: llvm_MCSection_SectionVariant = 7;
pub type llvm_MCSection_SectionVariant = ::std::os::raw::c_uint;
pub const llvm_MCSection_BundleLockStateType_NotBundleLocked: llvm_MCSection_BundleLockStateType =
    0;
pub const llvm_MCSection_BundleLockStateType_BundleLocked: llvm_MCSection_BundleLockStateType = 1;
pub const llvm_MCSection_BundleLockStateType_BundleLockedAlignToEnd:
    llvm_MCSection_BundleLockStateType = 2;
#[doc = " Express the state of bundle locked groups while emitting code."]
pub type llvm_MCSection_BundleLockStateType = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_MCSection_iterator {
    pub F: *mut llvm_MCFragment,
}
#[test]
fn bindgen_test_layout_llvm_MCSection_iterator() {
    const UNINIT: ::std::mem::MaybeUninit<llvm_MCSection_iterator> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<llvm_MCSection_iterator>(),
        8usize,
        concat!("Size of: ", stringify!(llvm_MCSection_iterator))
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_MCSection_iterator>(),
        8usize,
        concat!("Alignment of ", stringify!(llvm_MCSection_iterator))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).F) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_MCSection_iterator),
            "::",
            stringify!(F)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_MCSection_FragList {
    pub Head: *mut llvm_MCFragment,
    pub Tail: *mut llvm_MCFragment,
}
#[test]
fn bindgen_test_layout_llvm_MCSection_FragList() {
    const UNINIT: ::std::mem::MaybeUninit<llvm_MCSection_FragList> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<llvm_MCSection_FragList>(),
        16usize,
        concat!("Size of: ", stringify!(llvm_MCSection_FragList))
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_MCSection_FragList>(),
        8usize,
        concat!("Alignment of ", stringify!(llvm_MCSection_FragList))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Head) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_MCSection_FragList),
            "::",
            stringify!(Head)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Tail) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_MCSection_FragList),
            "::",
            stringify!(Tail)
        )
    );
}
pub const llvm_MCSection_NonUniqueID: ::std::os::raw::c_uint = 4294967295;
#[test]
fn bindgen_test_layout_llvm_MCSection() {
    const UNINIT: ::std::mem::MaybeUninit<llvm_MCSection> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<llvm_MCSection>(),
        152usize,
        concat!("Size of: ", stringify!(llvm_MCSection))
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_MCSection>(),
        8usize,
        concat!("Alignment of ", stringify!(llvm_MCSection))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).CurFragList) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_MCSection),
            "::",
            stringify!(CurFragList)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Begin) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_MCSection),
            "::",
            stringify!(Begin)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).End) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_MCSection),
            "::",
            stringify!(End)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Alignment) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_MCSection),
            "::",
            stringify!(Alignment)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Ordinal) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_MCSection),
            "::",
            stringify!(Ordinal)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).BundleLockState) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_MCSection),
            "::",
            stringify!(BundleLockState)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).BundleLockNestingDepth) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_MCSection),
            "::",
            stringify!(BundleLockNestingDepth)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).DummyFragment) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_MCSection),
            "::",
            stringify!(DummyFragment)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Subsections) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_MCSection),
            "::",
            stringify!(Subsections)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Name) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_MCSection),
            "::",
            stringify!(Name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Variant) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_MCSection),
            "::",
            stringify!(Variant)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm9MCSection12getEndSymbolERNS_9MCContextE"]
    pub fn llvm_MCSection_getEndSymbol(
        this: *mut llvm_MCSection,
        Ctx: *mut llvm_MCContext,
    ) -> *mut llvm_MCSymbol;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4llvm9MCSection8hasEndedEv"]
    pub fn llvm_MCSection_hasEnded(this: *const llvm_MCSection) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm9MCSection18setBundleLockStateENS0_19BundleLockStateTypeE"]
    pub fn llvm_MCSection_setBundleLockState(
        this: *mut llvm_MCSection,
        NewState: llvm_MCSection_BundleLockStateType,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK4llvm9MCSection4dumpEv"]
    pub fn llvm_MCSection_dump(this: *const llvm_MCSection);
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm9MCSectionC2ENS0_14SectionVariantENS_9StringRefEbbPNS_8MCSymbolE"]
    pub fn llvm_MCSection_MCSection(
        this: *mut llvm_MCSection,
        V: llvm_MCSection_SectionVariant,
        Name: llvm_StringRef,
        IsText: bool,
        IsVirtual: bool,
        Begin: *mut llvm_MCSymbol,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm9MCSectionD1Ev"]
    pub fn llvm_MCSection_MCSection_destructor(this: *mut llvm_MCSection);
}
impl llvm_MCSection {
    #[inline]
    pub fn BundleGroupBeforeFirstInst(&self) -> bool {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_BundleGroupBeforeFirstInst(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn HasInstructions(&self) -> bool {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_HasInstructions(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn HasLayout(&self) -> bool {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_HasLayout(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn IsRegistered(&self) -> bool {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_IsRegistered(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn IsText(&self) -> bool {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_IsText(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn IsVirtual(&self) -> bool {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_IsVirtual(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        BundleGroupBeforeFirstInst: bool,
        HasInstructions: bool,
        HasLayout: bool,
        IsRegistered: bool,
        IsText: bool,
        IsVirtual: bool,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let BundleGroupBeforeFirstInst: u8 =
                unsafe { ::std::mem::transmute(BundleGroupBeforeFirstInst) };
            BundleGroupBeforeFirstInst as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let HasInstructions: u8 = unsafe { ::std::mem::transmute(HasInstructions) };
            HasInstructions as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let HasLayout: u8 = unsafe { ::std::mem::transmute(HasLayout) };
            HasLayout as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let IsRegistered: u8 = unsafe { ::std::mem::transmute(IsRegistered) };
            IsRegistered as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let IsText: u8 = unsafe { ::std::mem::transmute(IsText) };
            IsText as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let IsVirtual: u8 = unsafe { ::std::mem::transmute(IsVirtual) };
            IsVirtual as u64
        });
        __bindgen_bitfield_unit
    }
    #[inline]
    pub unsafe fn getEndSymbol(&mut self, Ctx: *mut llvm_MCContext) -> *mut llvm_MCSymbol {
        llvm_MCSection_getEndSymbol(self, Ctx)
    }
    #[inline]
    pub unsafe fn hasEnded(&self) -> bool {
        llvm_MCSection_hasEnded(self)
    }
    #[inline]
    pub unsafe fn setBundleLockState(&mut self, NewState: llvm_MCSection_BundleLockStateType) {
        llvm_MCSection_setBundleLockState(self, NewState)
    }
    #[inline]
    pub unsafe fn dump(&self) {
        llvm_MCSection_dump(self)
    }
    #[inline]
    pub unsafe fn new(
        V: llvm_MCSection_SectionVariant,
        Name: llvm_StringRef,
        IsText: bool,
        IsVirtual: bool,
        Begin: *mut llvm_MCSymbol,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        llvm_MCSection_MCSection(
            __bindgen_tmp.as_mut_ptr(),
            V,
            Name,
            IsText,
            IsVirtual,
            Begin,
        );
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn destruct(&mut self) {
        llvm_MCSection_MCSection_destructor(self)
    }
}
extern "C" {
    #[link_name = "\u{1}_ZNK4llvm9MCSection21getVirtualSectionKindEv"]
    pub fn llvm_MCSection_getVirtualSectionKind(
        this: *mut ::std::os::raw::c_void,
    ) -> llvm_StringRef;
}
#[doc = " Represents a version number in the form major[.minor[.subminor[.build]]]."]
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct llvm_VersionTuple {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 16usize]>,
}
#[test]
fn bindgen_test_layout_llvm_VersionTuple() {
    assert_eq!(
        ::std::mem::size_of::<llvm_VersionTuple>(),
        16usize,
        concat!("Size of: ", stringify!(llvm_VersionTuple))
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_VersionTuple>(),
        4usize,
        concat!("Alignment of ", stringify!(llvm_VersionTuple))
    );
}
extern "C" {
    #[doc = " Retrieve a string representation of the version number."]
    #[link_name = "\u{1}_ZNK4llvm12VersionTuple11getAsStringB5cxx11Ev"]
    pub fn llvm_VersionTuple_getAsString(this: *const llvm_VersionTuple) -> std_string;
}
extern "C" {
    #[doc = " Try to parse the given string as a version number.\n \\returns \\c true if the string does not match the regular expression\n   [0-9]+(\\.[0-9]+){0,3}"]
    #[link_name = "\u{1}_ZN4llvm12VersionTuple8tryParseENS_9StringRefE"]
    pub fn llvm_VersionTuple_tryParse(this: *mut llvm_VersionTuple, string: llvm_StringRef)
        -> bool;
}
impl llvm_VersionTuple {
    #[inline]
    pub fn Major(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 32u8) as u32) }
    }
    #[inline]
    pub fn set_Major(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 32u8, val as u64)
        }
    }
    #[inline]
    pub fn Minor(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(32usize, 31u8) as u32) }
    }
    #[inline]
    pub fn set_Minor(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(32usize, 31u8, val as u64)
        }
    }
    #[inline]
    pub fn HasMinor(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(63usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_HasMinor(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(63usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Subminor(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(64usize, 31u8) as u32) }
    }
    #[inline]
    pub fn set_Subminor(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(64usize, 31u8, val as u64)
        }
    }
    #[inline]
    pub fn HasSubminor(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(95usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_HasSubminor(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(95usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Build(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(96usize, 31u8) as u32) }
    }
    #[inline]
    pub fn set_Build(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(96usize, 31u8, val as u64)
        }
    }
    #[inline]
    pub fn HasBuild(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(127usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_HasBuild(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(127usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        Major: ::std::os::raw::c_uint,
        Minor: ::std::os::raw::c_uint,
        HasMinor: ::std::os::raw::c_uint,
        Subminor: ::std::os::raw::c_uint,
        HasSubminor: ::std::os::raw::c_uint,
        Build: ::std::os::raw::c_uint,
        HasBuild: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 16usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 16usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 32u8, {
            let Major: u32 = unsafe { ::std::mem::transmute(Major) };
            Major as u64
        });
        __bindgen_bitfield_unit.set(32usize, 31u8, {
            let Minor: u32 = unsafe { ::std::mem::transmute(Minor) };
            Minor as u64
        });
        __bindgen_bitfield_unit.set(63usize, 1u8, {
            let HasMinor: u32 = unsafe { ::std::mem::transmute(HasMinor) };
            HasMinor as u64
        });
        __bindgen_bitfield_unit.set(64usize, 31u8, {
            let Subminor: u32 = unsafe { ::std::mem::transmute(Subminor) };
            Subminor as u64
        });
        __bindgen_bitfield_unit.set(95usize, 1u8, {
            let HasSubminor: u32 = unsafe { ::std::mem::transmute(HasSubminor) };
            HasSubminor as u64
        });
        __bindgen_bitfield_unit.set(96usize, 31u8, {
            let Build: u32 = unsafe { ::std::mem::transmute(Build) };
            Build as u64
        });
        __bindgen_bitfield_unit.set(127usize, 1u8, {
            let HasBuild: u32 = unsafe { ::std::mem::transmute(HasBuild) };
            HasBuild as u64
        });
        __bindgen_bitfield_unit
    }
    #[inline]
    pub unsafe fn getAsString(&self) -> std_string {
        llvm_VersionTuple_getAsString(self)
    }
    #[inline]
    pub unsafe fn tryParse(&mut self, string: llvm_StringRef) -> bool {
        llvm_VersionTuple_tryParse(self, string)
    }
}
#[test]
fn __bindgen_test_layout_llvm_DenseMapInfo_open0_llvm_VersionTuple_void_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<llvm_DenseMapInfo>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_DenseMapInfo)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_DenseMapInfo>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_DenseMapInfo)
        )
    );
}
#[doc = " Triple - Helper class for working with autoconf configuration names. For\n historical reasons, we also call these 'triples' (they used to contain\n exactly three fields).\n\n Configuration names are strings in the canonical form:\n   ARCHITECTURE-VENDOR-OPERATING_SYSTEM\n or\n   ARCHITECTURE-VENDOR-OPERATING_SYSTEM-ENVIRONMENT\n\n This class is used for clients which want to support arbitrary\n configuration names, but also want to implement certain special\n behavior for particular configurations. This class isolates the mapping\n from the components of the configuration name to well known IDs.\n\n At its core the Triple class is designed to be a wrapper for a triple\n string; the constructor does not change or normalize the triple string.\n Clients that need to handle the non-canonical triples that users often\n specify should use the normalize method.\n\n See autoconf/config.guess for a glimpse into what configuration names\n look like in practice."]
#[repr(C)]
pub struct llvm_Triple {
    pub Data: std_string,
    #[doc = " The parsed arch type."]
    pub Arch: llvm_Triple_ArchType,
    #[doc = " The parsed subarchitecture type."]
    pub SubArch: llvm_Triple_SubArchType,
    #[doc = " The parsed vendor type."]
    pub Vendor: llvm_Triple_VendorType,
    #[doc = " The parsed OS type."]
    pub OS: llvm_Triple_OSType,
    #[doc = " The parsed Environment type."]
    pub Environment: llvm_Triple_EnvironmentType,
    #[doc = " The object format type."]
    pub ObjectFormat: llvm_Triple_ObjectFormatType,
}
pub const llvm_Triple_ArchType_UnknownArch: llvm_Triple_ArchType = 0;
pub const llvm_Triple_ArchType_arm: llvm_Triple_ArchType = 1;
pub const llvm_Triple_ArchType_armeb: llvm_Triple_ArchType = 2;
pub const llvm_Triple_ArchType_aarch64: llvm_Triple_ArchType = 3;
pub const llvm_Triple_ArchType_aarch64_be: llvm_Triple_ArchType = 4;
pub const llvm_Triple_ArchType_aarch64_32: llvm_Triple_ArchType = 5;
pub const llvm_Triple_ArchType_arc: llvm_Triple_ArchType = 6;
pub const llvm_Triple_ArchType_avr: llvm_Triple_ArchType = 7;
pub const llvm_Triple_ArchType_bpfel: llvm_Triple_ArchType = 8;
pub const llvm_Triple_ArchType_bpfeb: llvm_Triple_ArchType = 9;
pub const llvm_Triple_ArchType_csky: llvm_Triple_ArchType = 10;
pub const llvm_Triple_ArchType_dxil: llvm_Triple_ArchType = 11;
pub const llvm_Triple_ArchType_hexagon: llvm_Triple_ArchType = 12;
pub const llvm_Triple_ArchType_loongarch32: llvm_Triple_ArchType = 13;
pub const llvm_Triple_ArchType_loongarch64: llvm_Triple_ArchType = 14;
pub const llvm_Triple_ArchType_m68k: llvm_Triple_ArchType = 15;
pub const llvm_Triple_ArchType_mips: llvm_Triple_ArchType = 16;
pub const llvm_Triple_ArchType_mipsel: llvm_Triple_ArchType = 17;
pub const llvm_Triple_ArchType_mips64: llvm_Triple_ArchType = 18;
pub const llvm_Triple_ArchType_mips64el: llvm_Triple_ArchType = 19;
pub const llvm_Triple_ArchType_msp430: llvm_Triple_ArchType = 20;
pub const llvm_Triple_ArchType_ppc: llvm_Triple_ArchType = 21;
pub const llvm_Triple_ArchType_ppcle: llvm_Triple_ArchType = 22;
pub const llvm_Triple_ArchType_ppc64: llvm_Triple_ArchType = 23;
pub const llvm_Triple_ArchType_ppc64le: llvm_Triple_ArchType = 24;
pub const llvm_Triple_ArchType_r600: llvm_Triple_ArchType = 25;
pub const llvm_Triple_ArchType_amdgcn: llvm_Triple_ArchType = 26;
pub const llvm_Triple_ArchType_riscv32: llvm_Triple_ArchType = 27;
pub const llvm_Triple_ArchType_riscv64: llvm_Triple_ArchType = 28;
pub const llvm_Triple_ArchType_sparc: llvm_Triple_ArchType = 29;
pub const llvm_Triple_ArchType_sparcv9: llvm_Triple_ArchType = 30;
pub const llvm_Triple_ArchType_sparcel: llvm_Triple_ArchType = 31;
pub const llvm_Triple_ArchType_systemz: llvm_Triple_ArchType = 32;
pub const llvm_Triple_ArchType_tce: llvm_Triple_ArchType = 33;
pub const llvm_Triple_ArchType_tcele: llvm_Triple_ArchType = 34;
pub const llvm_Triple_ArchType_thumb: llvm_Triple_ArchType = 35;
pub const llvm_Triple_ArchType_thumbeb: llvm_Triple_ArchType = 36;
pub const llvm_Triple_ArchType_x86: llvm_Triple_ArchType = 37;
pub const llvm_Triple_ArchType_x86_64: llvm_Triple_ArchType = 38;
pub const llvm_Triple_ArchType_xcore: llvm_Triple_ArchType = 39;
pub const llvm_Triple_ArchType_xtensa: llvm_Triple_ArchType = 40;
pub const llvm_Triple_ArchType_nvptx: llvm_Triple_ArchType = 41;
pub const llvm_Triple_ArchType_nvptx64: llvm_Triple_ArchType = 42;
pub const llvm_Triple_ArchType_amdil: llvm_Triple_ArchType = 43;
pub const llvm_Triple_ArchType_amdil64: llvm_Triple_ArchType = 44;
pub const llvm_Triple_ArchType_hsail: llvm_Triple_ArchType = 45;
pub const llvm_Triple_ArchType_hsail64: llvm_Triple_ArchType = 46;
pub const llvm_Triple_ArchType_spir: llvm_Triple_ArchType = 47;
pub const llvm_Triple_ArchType_spir64: llvm_Triple_ArchType = 48;
pub const llvm_Triple_ArchType_spirv: llvm_Triple_ArchType = 49;
pub const llvm_Triple_ArchType_spirv32: llvm_Triple_ArchType = 50;
pub const llvm_Triple_ArchType_spirv64: llvm_Triple_ArchType = 51;
pub const llvm_Triple_ArchType_kalimba: llvm_Triple_ArchType = 52;
pub const llvm_Triple_ArchType_shave: llvm_Triple_ArchType = 53;
pub const llvm_Triple_ArchType_lanai: llvm_Triple_ArchType = 54;
pub const llvm_Triple_ArchType_wasm32: llvm_Triple_ArchType = 55;
pub const llvm_Triple_ArchType_wasm64: llvm_Triple_ArchType = 56;
pub const llvm_Triple_ArchType_renderscript32: llvm_Triple_ArchType = 57;
pub const llvm_Triple_ArchType_renderscript64: llvm_Triple_ArchType = 58;
pub const llvm_Triple_ArchType_ve: llvm_Triple_ArchType = 59;
pub const llvm_Triple_ArchType_LastArchType: llvm_Triple_ArchType = 59;
pub type llvm_Triple_ArchType = ::std::os::raw::c_uint;
pub const llvm_Triple_SubArchType_NoSubArch: llvm_Triple_SubArchType = 0;
pub const llvm_Triple_SubArchType_ARMSubArch_v9_5a: llvm_Triple_SubArchType = 1;
pub const llvm_Triple_SubArchType_ARMSubArch_v9_4a: llvm_Triple_SubArchType = 2;
pub const llvm_Triple_SubArchType_ARMSubArch_v9_3a: llvm_Triple_SubArchType = 3;
pub const llvm_Triple_SubArchType_ARMSubArch_v9_2a: llvm_Triple_SubArchType = 4;
pub const llvm_Triple_SubArchType_ARMSubArch_v9_1a: llvm_Triple_SubArchType = 5;
pub const llvm_Triple_SubArchType_ARMSubArch_v9: llvm_Triple_SubArchType = 6;
pub const llvm_Triple_SubArchType_ARMSubArch_v8_9a: llvm_Triple_SubArchType = 7;
pub const llvm_Triple_SubArchType_ARMSubArch_v8_8a: llvm_Triple_SubArchType = 8;
pub const llvm_Triple_SubArchType_ARMSubArch_v8_7a: llvm_Triple_SubArchType = 9;
pub const llvm_Triple_SubArchType_ARMSubArch_v8_6a: llvm_Triple_SubArchType = 10;
pub const llvm_Triple_SubArchType_ARMSubArch_v8_5a: llvm_Triple_SubArchType = 11;
pub const llvm_Triple_SubArchType_ARMSubArch_v8_4a: llvm_Triple_SubArchType = 12;
pub const llvm_Triple_SubArchType_ARMSubArch_v8_3a: llvm_Triple_SubArchType = 13;
pub const llvm_Triple_SubArchType_ARMSubArch_v8_2a: llvm_Triple_SubArchType = 14;
pub const llvm_Triple_SubArchType_ARMSubArch_v8_1a: llvm_Triple_SubArchType = 15;
pub const llvm_Triple_SubArchType_ARMSubArch_v8: llvm_Triple_SubArchType = 16;
pub const llvm_Triple_SubArchType_ARMSubArch_v8r: llvm_Triple_SubArchType = 17;
pub const llvm_Triple_SubArchType_ARMSubArch_v8m_baseline: llvm_Triple_SubArchType = 18;
pub const llvm_Triple_SubArchType_ARMSubArch_v8m_mainline: llvm_Triple_SubArchType = 19;
pub const llvm_Triple_SubArchType_ARMSubArch_v8_1m_mainline: llvm_Triple_SubArchType = 20;
pub const llvm_Triple_SubArchType_ARMSubArch_v7: llvm_Triple_SubArchType = 21;
pub const llvm_Triple_SubArchType_ARMSubArch_v7em: llvm_Triple_SubArchType = 22;
pub const llvm_Triple_SubArchType_ARMSubArch_v7m: llvm_Triple_SubArchType = 23;
pub const llvm_Triple_SubArchType_ARMSubArch_v7s: llvm_Triple_SubArchType = 24;
pub const llvm_Triple_SubArchType_ARMSubArch_v7k: llvm_Triple_SubArchType = 25;
pub const llvm_Triple_SubArchType_ARMSubArch_v7ve: llvm_Triple_SubArchType = 26;
pub const llvm_Triple_SubArchType_ARMSubArch_v6: llvm_Triple_SubArchType = 27;
pub const llvm_Triple_SubArchType_ARMSubArch_v6m: llvm_Triple_SubArchType = 28;
pub const llvm_Triple_SubArchType_ARMSubArch_v6k: llvm_Triple_SubArchType = 29;
pub const llvm_Triple_SubArchType_ARMSubArch_v6t2: llvm_Triple_SubArchType = 30;
pub const llvm_Triple_SubArchType_ARMSubArch_v5: llvm_Triple_SubArchType = 31;
pub const llvm_Triple_SubArchType_ARMSubArch_v5te: llvm_Triple_SubArchType = 32;
pub const llvm_Triple_SubArchType_ARMSubArch_v4t: llvm_Triple_SubArchType = 33;
pub const llvm_Triple_SubArchType_AArch64SubArch_arm64e: llvm_Triple_SubArchType = 34;
pub const llvm_Triple_SubArchType_AArch64SubArch_arm64ec: llvm_Triple_SubArchType = 35;
pub const llvm_Triple_SubArchType_KalimbaSubArch_v3: llvm_Triple_SubArchType = 36;
pub const llvm_Triple_SubArchType_KalimbaSubArch_v4: llvm_Triple_SubArchType = 37;
pub const llvm_Triple_SubArchType_KalimbaSubArch_v5: llvm_Triple_SubArchType = 38;
pub const llvm_Triple_SubArchType_MipsSubArch_r6: llvm_Triple_SubArchType = 39;
pub const llvm_Triple_SubArchType_PPCSubArch_spe: llvm_Triple_SubArchType = 40;
pub const llvm_Triple_SubArchType_SPIRVSubArch_v10: llvm_Triple_SubArchType = 41;
pub const llvm_Triple_SubArchType_SPIRVSubArch_v11: llvm_Triple_SubArchType = 42;
pub const llvm_Triple_SubArchType_SPIRVSubArch_v12: llvm_Triple_SubArchType = 43;
pub const llvm_Triple_SubArchType_SPIRVSubArch_v13: llvm_Triple_SubArchType = 44;
pub const llvm_Triple_SubArchType_SPIRVSubArch_v14: llvm_Triple_SubArchType = 45;
pub const llvm_Triple_SubArchType_SPIRVSubArch_v15: llvm_Triple_SubArchType = 46;
pub const llvm_Triple_SubArchType_SPIRVSubArch_v16: llvm_Triple_SubArchType = 47;
pub const llvm_Triple_SubArchType_DXILSubArch_v1_0: llvm_Triple_SubArchType = 48;
pub const llvm_Triple_SubArchType_DXILSubArch_v1_1: llvm_Triple_SubArchType = 49;
pub const llvm_Triple_SubArchType_DXILSubArch_v1_2: llvm_Triple_SubArchType = 50;
pub const llvm_Triple_SubArchType_DXILSubArch_v1_3: llvm_Triple_SubArchType = 51;
pub const llvm_Triple_SubArchType_DXILSubArch_v1_4: llvm_Triple_SubArchType = 52;
pub const llvm_Triple_SubArchType_DXILSubArch_v1_5: llvm_Triple_SubArchType = 53;
pub const llvm_Triple_SubArchType_DXILSubArch_v1_6: llvm_Triple_SubArchType = 54;
pub const llvm_Triple_SubArchType_DXILSubArch_v1_7: llvm_Triple_SubArchType = 55;
pub const llvm_Triple_SubArchType_DXILSubArch_v1_8: llvm_Triple_SubArchType = 56;
pub const llvm_Triple_SubArchType_LatestDXILSubArch: llvm_Triple_SubArchType = 56;
pub type llvm_Triple_SubArchType = ::std::os::raw::c_uint;
pub const llvm_Triple_VendorType_UnknownVendor: llvm_Triple_VendorType = 0;
pub const llvm_Triple_VendorType_Apple: llvm_Triple_VendorType = 1;
pub const llvm_Triple_VendorType_PC: llvm_Triple_VendorType = 2;
pub const llvm_Triple_VendorType_SCEI: llvm_Triple_VendorType = 3;
pub const llvm_Triple_VendorType_Freescale: llvm_Triple_VendorType = 4;
pub const llvm_Triple_VendorType_IBM: llvm_Triple_VendorType = 5;
pub const llvm_Triple_VendorType_ImaginationTechnologies: llvm_Triple_VendorType = 6;
pub const llvm_Triple_VendorType_MipsTechnologies: llvm_Triple_VendorType = 7;
pub const llvm_Triple_VendorType_NVIDIA: llvm_Triple_VendorType = 8;
pub const llvm_Triple_VendorType_CSR: llvm_Triple_VendorType = 9;
pub const llvm_Triple_VendorType_AMD: llvm_Triple_VendorType = 10;
pub const llvm_Triple_VendorType_Mesa: llvm_Triple_VendorType = 11;
pub const llvm_Triple_VendorType_SUSE: llvm_Triple_VendorType = 12;
pub const llvm_Triple_VendorType_OpenEmbedded: llvm_Triple_VendorType = 13;
pub const llvm_Triple_VendorType_LastVendorType: llvm_Triple_VendorType = 13;
pub type llvm_Triple_VendorType = ::std::os::raw::c_uint;
pub const llvm_Triple_OSType_UnknownOS: llvm_Triple_OSType = 0;
pub const llvm_Triple_OSType_Darwin: llvm_Triple_OSType = 1;
pub const llvm_Triple_OSType_DragonFly: llvm_Triple_OSType = 2;
pub const llvm_Triple_OSType_FreeBSD: llvm_Triple_OSType = 3;
pub const llvm_Triple_OSType_Fuchsia: llvm_Triple_OSType = 4;
pub const llvm_Triple_OSType_IOS: llvm_Triple_OSType = 5;
pub const llvm_Triple_OSType_KFreeBSD: llvm_Triple_OSType = 6;
pub const llvm_Triple_OSType_Linux: llvm_Triple_OSType = 7;
pub const llvm_Triple_OSType_Lv2: llvm_Triple_OSType = 8;
pub const llvm_Triple_OSType_MacOSX: llvm_Triple_OSType = 9;
pub const llvm_Triple_OSType_NetBSD: llvm_Triple_OSType = 10;
pub const llvm_Triple_OSType_OpenBSD: llvm_Triple_OSType = 11;
pub const llvm_Triple_OSType_Solaris: llvm_Triple_OSType = 12;
pub const llvm_Triple_OSType_UEFI: llvm_Triple_OSType = 13;
pub const llvm_Triple_OSType_Win32: llvm_Triple_OSType = 14;
pub const llvm_Triple_OSType_ZOS: llvm_Triple_OSType = 15;
pub const llvm_Triple_OSType_Haiku: llvm_Triple_OSType = 16;
pub const llvm_Triple_OSType_RTEMS: llvm_Triple_OSType = 17;
pub const llvm_Triple_OSType_NaCl: llvm_Triple_OSType = 18;
pub const llvm_Triple_OSType_AIX: llvm_Triple_OSType = 19;
pub const llvm_Triple_OSType_CUDA: llvm_Triple_OSType = 20;
pub const llvm_Triple_OSType_NVCL: llvm_Triple_OSType = 21;
pub const llvm_Triple_OSType_AMDHSA: llvm_Triple_OSType = 22;
pub const llvm_Triple_OSType_PS4: llvm_Triple_OSType = 23;
pub const llvm_Triple_OSType_PS5: llvm_Triple_OSType = 24;
pub const llvm_Triple_OSType_ELFIAMCU: llvm_Triple_OSType = 25;
pub const llvm_Triple_OSType_TvOS: llvm_Triple_OSType = 26;
pub const llvm_Triple_OSType_WatchOS: llvm_Triple_OSType = 27;
pub const llvm_Triple_OSType_BridgeOS: llvm_Triple_OSType = 28;
pub const llvm_Triple_OSType_DriverKit: llvm_Triple_OSType = 29;
pub const llvm_Triple_OSType_XROS: llvm_Triple_OSType = 30;
pub const llvm_Triple_OSType_Mesa3D: llvm_Triple_OSType = 31;
pub const llvm_Triple_OSType_AMDPAL: llvm_Triple_OSType = 32;
pub const llvm_Triple_OSType_HermitCore: llvm_Triple_OSType = 33;
pub const llvm_Triple_OSType_Hurd: llvm_Triple_OSType = 34;
pub const llvm_Triple_OSType_WASI: llvm_Triple_OSType = 35;
pub const llvm_Triple_OSType_Emscripten: llvm_Triple_OSType = 36;
pub const llvm_Triple_OSType_ShaderModel: llvm_Triple_OSType = 37;
pub const llvm_Triple_OSType_LiteOS: llvm_Triple_OSType = 38;
pub const llvm_Triple_OSType_Serenity: llvm_Triple_OSType = 39;
pub const llvm_Triple_OSType_Vulkan: llvm_Triple_OSType = 40;
pub const llvm_Triple_OSType_LastOSType: llvm_Triple_OSType = 40;
pub type llvm_Triple_OSType = ::std::os::raw::c_uint;
pub const llvm_Triple_EnvironmentType_UnknownEnvironment: llvm_Triple_EnvironmentType = 0;
pub const llvm_Triple_EnvironmentType_GNU: llvm_Triple_EnvironmentType = 1;
pub const llvm_Triple_EnvironmentType_GNUABIN32: llvm_Triple_EnvironmentType = 2;
pub const llvm_Triple_EnvironmentType_GNUABI64: llvm_Triple_EnvironmentType = 3;
pub const llvm_Triple_EnvironmentType_GNUEABI: llvm_Triple_EnvironmentType = 4;
pub const llvm_Triple_EnvironmentType_GNUEABIHF: llvm_Triple_EnvironmentType = 5;
pub const llvm_Triple_EnvironmentType_GNUF32: llvm_Triple_EnvironmentType = 6;
pub const llvm_Triple_EnvironmentType_GNUF64: llvm_Triple_EnvironmentType = 7;
pub const llvm_Triple_EnvironmentType_GNUSF: llvm_Triple_EnvironmentType = 8;
pub const llvm_Triple_EnvironmentType_GNUX32: llvm_Triple_EnvironmentType = 9;
pub const llvm_Triple_EnvironmentType_GNUILP32: llvm_Triple_EnvironmentType = 10;
pub const llvm_Triple_EnvironmentType_CODE16: llvm_Triple_EnvironmentType = 11;
pub const llvm_Triple_EnvironmentType_EABI: llvm_Triple_EnvironmentType = 12;
pub const llvm_Triple_EnvironmentType_EABIHF: llvm_Triple_EnvironmentType = 13;
pub const llvm_Triple_EnvironmentType_Android: llvm_Triple_EnvironmentType = 14;
pub const llvm_Triple_EnvironmentType_Musl: llvm_Triple_EnvironmentType = 15;
pub const llvm_Triple_EnvironmentType_MuslEABI: llvm_Triple_EnvironmentType = 16;
pub const llvm_Triple_EnvironmentType_MuslEABIHF: llvm_Triple_EnvironmentType = 17;
pub const llvm_Triple_EnvironmentType_MuslX32: llvm_Triple_EnvironmentType = 18;
pub const llvm_Triple_EnvironmentType_MSVC: llvm_Triple_EnvironmentType = 19;
pub const llvm_Triple_EnvironmentType_Itanium: llvm_Triple_EnvironmentType = 20;
pub const llvm_Triple_EnvironmentType_Cygnus: llvm_Triple_EnvironmentType = 21;
pub const llvm_Triple_EnvironmentType_CoreCLR: llvm_Triple_EnvironmentType = 22;
pub const llvm_Triple_EnvironmentType_Simulator: llvm_Triple_EnvironmentType = 23;
pub const llvm_Triple_EnvironmentType_MacABI: llvm_Triple_EnvironmentType = 24;
pub const llvm_Triple_EnvironmentType_Pixel: llvm_Triple_EnvironmentType = 25;
pub const llvm_Triple_EnvironmentType_Vertex: llvm_Triple_EnvironmentType = 26;
pub const llvm_Triple_EnvironmentType_Geometry: llvm_Triple_EnvironmentType = 27;
pub const llvm_Triple_EnvironmentType_Hull: llvm_Triple_EnvironmentType = 28;
pub const llvm_Triple_EnvironmentType_Domain: llvm_Triple_EnvironmentType = 29;
pub const llvm_Triple_EnvironmentType_Compute: llvm_Triple_EnvironmentType = 30;
pub const llvm_Triple_EnvironmentType_Library: llvm_Triple_EnvironmentType = 31;
pub const llvm_Triple_EnvironmentType_RayGeneration: llvm_Triple_EnvironmentType = 32;
pub const llvm_Triple_EnvironmentType_Intersection: llvm_Triple_EnvironmentType = 33;
pub const llvm_Triple_EnvironmentType_AnyHit: llvm_Triple_EnvironmentType = 34;
pub const llvm_Triple_EnvironmentType_ClosestHit: llvm_Triple_EnvironmentType = 35;
pub const llvm_Triple_EnvironmentType_Miss: llvm_Triple_EnvironmentType = 36;
pub const llvm_Triple_EnvironmentType_Callable: llvm_Triple_EnvironmentType = 37;
pub const llvm_Triple_EnvironmentType_Mesh: llvm_Triple_EnvironmentType = 38;
pub const llvm_Triple_EnvironmentType_Amplification: llvm_Triple_EnvironmentType = 39;
pub const llvm_Triple_EnvironmentType_OpenCL: llvm_Triple_EnvironmentType = 40;
pub const llvm_Triple_EnvironmentType_OpenHOS: llvm_Triple_EnvironmentType = 41;
pub const llvm_Triple_EnvironmentType_PAuthTest: llvm_Triple_EnvironmentType = 42;
pub const llvm_Triple_EnvironmentType_LastEnvironmentType: llvm_Triple_EnvironmentType = 42;
pub type llvm_Triple_EnvironmentType = ::std::os::raw::c_uint;
pub const llvm_Triple_ObjectFormatType_UnknownObjectFormat: llvm_Triple_ObjectFormatType = 0;
pub const llvm_Triple_ObjectFormatType_COFF: llvm_Triple_ObjectFormatType = 1;
pub const llvm_Triple_ObjectFormatType_DXContainer: llvm_Triple_ObjectFormatType = 2;
pub const llvm_Triple_ObjectFormatType_ELF: llvm_Triple_ObjectFormatType = 3;
pub const llvm_Triple_ObjectFormatType_GOFF: llvm_Triple_ObjectFormatType = 4;
pub const llvm_Triple_ObjectFormatType_MachO: llvm_Triple_ObjectFormatType = 5;
pub const llvm_Triple_ObjectFormatType_SPIRV: llvm_Triple_ObjectFormatType = 6;
pub const llvm_Triple_ObjectFormatType_Wasm: llvm_Triple_ObjectFormatType = 7;
pub const llvm_Triple_ObjectFormatType_XCOFF: llvm_Triple_ObjectFormatType = 8;
pub type llvm_Triple_ObjectFormatType = ::std::os::raw::c_uint;
#[test]
fn bindgen_test_layout_llvm_Triple() {
    const UNINIT: ::std::mem::MaybeUninit<llvm_Triple> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<llvm_Triple>(),
        56usize,
        concat!("Size of: ", stringify!(llvm_Triple))
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_Triple>(),
        8usize,
        concat!("Alignment of ", stringify!(llvm_Triple))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_Triple),
            "::",
            stringify!(Data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Arch) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_Triple),
            "::",
            stringify!(Arch)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).SubArch) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_Triple),
            "::",
            stringify!(SubArch)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Vendor) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_Triple),
            "::",
            stringify!(Vendor)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).OS) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_Triple),
            "::",
            stringify!(OS)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Environment) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_Triple),
            "::",
            stringify!(Environment)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ObjectFormat) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_Triple),
            "::",
            stringify!(ObjectFormat)
        )
    );
}
extern "C" {
    #[doc = " Turn an arbitrary machine specification into the canonical triple form (or\n something sensible that the Triple class understands if nothing better can\n reasonably be done).  In particular, it handles the common case in which\n otherwise valid components are in the wrong order."]
    #[link_name = "\u{1}_ZN4llvm6Triple9normalizeB5cxx11ENS_9StringRefE"]
    pub fn llvm_Triple_normalize(Str: llvm_StringRef) -> std_string;
}
extern "C" {
    #[doc = " Parse the version number from the OS name component of the\n triple, if present.\n\n For example, \"fooos1.2.3\" would return (1, 2, 3)."]
    #[link_name = "\u{1}_ZNK4llvm6Triple21getEnvironmentVersionEv"]
    pub fn llvm_Triple_getEnvironmentVersion(this: *const llvm_Triple) -> llvm_VersionTuple;
}
extern "C" {
    #[doc = " Parse the version number from the OS name component of the triple, if\n present.\n\n For example, \"fooos1.2.3\" would return (1, 2, 3)."]
    #[link_name = "\u{1}_ZNK4llvm6Triple12getOSVersionEv"]
    pub fn llvm_Triple_getOSVersion(this: *const llvm_Triple) -> llvm_VersionTuple;
}
extern "C" {
    #[doc = " Parse the version number as with getOSVersion and then translate generic\n \"darwin\" versions to the corresponding OS X versions.  This may also be\n called with IOS triples but the OS X version number is just set to a\n constant 10.4.0 in that case.  Returns true if successful."]
    #[link_name = "\u{1}_ZNK4llvm6Triple16getMacOSXVersionERNS_12VersionTupleE"]
    pub fn llvm_Triple_getMacOSXVersion(
        this: *const llvm_Triple,
        Version: *mut llvm_VersionTuple,
    ) -> bool;
}
extern "C" {
    #[doc = " Parse the version number as with getOSVersion.  This should only be called\n with IOS or generic triples."]
    #[link_name = "\u{1}_ZNK4llvm6Triple13getiOSVersionEv"]
    pub fn llvm_Triple_getiOSVersion(this: *const llvm_Triple) -> llvm_VersionTuple;
}
extern "C" {
    #[doc = " Parse the version number as with getOSVersion.  This should only be called\n with WatchOS or generic triples."]
    #[link_name = "\u{1}_ZNK4llvm6Triple17getWatchOSVersionEv"]
    pub fn llvm_Triple_getWatchOSVersion(this: *const llvm_Triple) -> llvm_VersionTuple;
}
extern "C" {
    #[doc = " Parse the version number as with getOSVersion."]
    #[link_name = "\u{1}_ZNK4llvm6Triple19getDriverKitVersionEv"]
    pub fn llvm_Triple_getDriverKitVersion(this: *const llvm_Triple) -> llvm_VersionTuple;
}
extern "C" {
    #[doc = " Parse the Vulkan version number from the OSVersion and SPIR-V version\n (SubArch).  This should only be called with Vulkan SPIR-V triples."]
    #[link_name = "\u{1}_ZNK4llvm6Triple16getVulkanVersionEv"]
    pub fn llvm_Triple_getVulkanVersion(this: *const llvm_Triple) -> llvm_VersionTuple;
}
extern "C" {
    #[doc = " Parse the DXIL version number from the OSVersion and DXIL version\n (SubArch).  This should only be called with DXIL triples."]
    #[link_name = "\u{1}_ZNK4llvm6Triple14getDXILVersionEv"]
    pub fn llvm_Triple_getDXILVersion(this: *const llvm_Triple) -> llvm_VersionTuple;
}
extern "C" {
    #[doc = " Get the architecture (first) component of the triple."]
    #[link_name = "\u{1}_ZNK4llvm6Triple11getArchNameEv"]
    pub fn llvm_Triple_getArchName(this: *const llvm_Triple) -> llvm_StringRef;
}
extern "C" {
    #[doc = " Get the vendor (second) component of the triple."]
    #[link_name = "\u{1}_ZNK4llvm6Triple13getVendorNameEv"]
    pub fn llvm_Triple_getVendorName(this: *const llvm_Triple) -> llvm_StringRef;
}
extern "C" {
    #[doc = " Get the operating system (third) component of the triple."]
    #[link_name = "\u{1}_ZNK4llvm6Triple9getOSNameEv"]
    pub fn llvm_Triple_getOSName(this: *const llvm_Triple) -> llvm_StringRef;
}
extern "C" {
    #[doc = " Get the optional environment (fourth) component of the triple, or \"\" if\n empty."]
    #[link_name = "\u{1}_ZNK4llvm6Triple18getEnvironmentNameEv"]
    pub fn llvm_Triple_getEnvironmentName(this: *const llvm_Triple) -> llvm_StringRef;
}
extern "C" {
    #[doc = " Get the operating system and optional environment components as a single\n string (separated by a '-' if the environment component is present)."]
    #[link_name = "\u{1}_ZNK4llvm6Triple23getOSAndEnvironmentNameEv"]
    pub fn llvm_Triple_getOSAndEnvironmentName(this: *const llvm_Triple) -> llvm_StringRef;
}
extern "C" {
    #[doc = " Get the version component of the environment component as a single\n string (the version after the environment).\n\n For example, \"fooos1.2.3\" would return \"1.2.3\"."]
    #[link_name = "\u{1}_ZNK4llvm6Triple27getEnvironmentVersionStringEv"]
    pub fn llvm_Triple_getEnvironmentVersionString(this: *const llvm_Triple) -> llvm_StringRef;
}
extern "C" {
    #[doc = " Returns the pointer width of this architecture."]
    #[link_name = "\u{1}_ZN4llvm6Triple22getArchPointerBitWidthENS0_8ArchTypeE"]
    pub fn llvm_Triple_getArchPointerBitWidth(Arch: llvm_Triple_ArchType)
        -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " Test whether the architecture is 64-bit\n\n Note that this tests for 64-bit pointer width, and nothing else. Note\n that we intentionally expose only three predicates, 64-bit, 32-bit, and\n 16-bit. The inner details of pointer width for particular architectures\n is not summed up in the triple, and so only a coarse grained predicate\n system is provided."]
    #[link_name = "\u{1}_ZNK4llvm6Triple11isArch64BitEv"]
    pub fn llvm_Triple_isArch64Bit(this: *const llvm_Triple) -> bool;
}
extern "C" {
    #[doc = " Test whether the architecture is 32-bit\n\n Note that this tests for 32-bit pointer width, and nothing else."]
    #[link_name = "\u{1}_ZNK4llvm6Triple11isArch32BitEv"]
    pub fn llvm_Triple_isArch32Bit(this: *const llvm_Triple) -> bool;
}
extern "C" {
    #[doc = " Test whether the architecture is 16-bit\n\n Note that this tests for 16-bit pointer width, and nothing else."]
    #[link_name = "\u{1}_ZNK4llvm6Triple11isArch16BitEv"]
    pub fn llvm_Triple_isArch16Bit(this: *const llvm_Triple) -> bool;
}
extern "C" {
    #[doc = " Comparison function for checking OS X version compatibility, which handles\n supporting skewed version numbering schemes used by the \"darwin\" triples."]
    #[link_name = "\u{1}_ZNK4llvm6Triple17isMacOSXVersionLTEjjj"]
    pub fn llvm_Triple_isMacOSXVersionLT(
        this: *const llvm_Triple,
        Major: ::std::os::raw::c_uint,
        Minor: ::std::os::raw::c_uint,
        Micro: ::std::os::raw::c_uint,
    ) -> bool;
}
extern "C" {
    #[doc = " Set the architecture (first) component of the triple to a known type."]
    #[link_name = "\u{1}_ZN4llvm6Triple7setArchENS0_8ArchTypeENS0_11SubArchTypeE"]
    pub fn llvm_Triple_setArch(
        this: *mut llvm_Triple,
        Kind: llvm_Triple_ArchType,
        SubArch: llvm_Triple_SubArchType,
    );
}
extern "C" {
    #[doc = " Set the vendor (second) component of the triple to a known type."]
    #[link_name = "\u{1}_ZN4llvm6Triple9setVendorENS0_10VendorTypeE"]
    pub fn llvm_Triple_setVendor(this: *mut llvm_Triple, Kind: llvm_Triple_VendorType);
}
extern "C" {
    #[doc = " Set the operating system (third) component of the triple to a known type."]
    #[link_name = "\u{1}_ZN4llvm6Triple5setOSENS0_6OSTypeE"]
    pub fn llvm_Triple_setOS(this: *mut llvm_Triple, Kind: llvm_Triple_OSType);
}
extern "C" {
    #[doc = " Set the environment (fourth) component of the triple to a known type."]
    #[link_name = "\u{1}_ZN4llvm6Triple14setEnvironmentENS0_15EnvironmentTypeE"]
    pub fn llvm_Triple_setEnvironment(this: *mut llvm_Triple, Kind: llvm_Triple_EnvironmentType);
}
extern "C" {
    #[doc = " Set the object file format."]
    #[link_name = "\u{1}_ZN4llvm6Triple15setObjectFormatENS0_16ObjectFormatTypeE"]
    pub fn llvm_Triple_setObjectFormat(this: *mut llvm_Triple, Kind: llvm_Triple_ObjectFormatType);
}
extern "C" {
    #[doc = " Set all components to the new triple \\p Str."]
    #[link_name = "\u{1}_ZN4llvm6Triple9setTripleERKNS_5TwineE"]
    pub fn llvm_Triple_setTriple(this: *mut llvm_Triple, Str: *const llvm_Twine);
}
extern "C" {
    #[doc = " Set the architecture (first) component of the triple by name."]
    #[link_name = "\u{1}_ZN4llvm6Triple11setArchNameENS_9StringRefE"]
    pub fn llvm_Triple_setArchName(this: *mut llvm_Triple, Str: llvm_StringRef);
}
extern "C" {
    #[doc = " Set the vendor (second) component of the triple by name."]
    #[link_name = "\u{1}_ZN4llvm6Triple13setVendorNameENS_9StringRefE"]
    pub fn llvm_Triple_setVendorName(this: *mut llvm_Triple, Str: llvm_StringRef);
}
extern "C" {
    #[doc = " Set the operating system (third) component of the triple by name."]
    #[link_name = "\u{1}_ZN4llvm6Triple9setOSNameENS_9StringRefE"]
    pub fn llvm_Triple_setOSName(this: *mut llvm_Triple, Str: llvm_StringRef);
}
extern "C" {
    #[doc = " Set the optional environment (fourth) component of the triple by name."]
    #[link_name = "\u{1}_ZN4llvm6Triple18setEnvironmentNameENS_9StringRefE"]
    pub fn llvm_Triple_setEnvironmentName(this: *mut llvm_Triple, Str: llvm_StringRef);
}
extern "C" {
    #[doc = " Set the operating system and optional environment components with a single\n string."]
    #[link_name = "\u{1}_ZN4llvm6Triple23setOSAndEnvironmentNameENS_9StringRefE"]
    pub fn llvm_Triple_setOSAndEnvironmentName(this: *mut llvm_Triple, Str: llvm_StringRef);
}
extern "C" {
    #[doc = " Form a triple with a 32-bit variant of the current architecture.\n\n This can be used to move across \"families\" of architectures where useful.\n\n \\returns A new triple with a 32-bit architecture or an unknown\n          architecture if no such variant can be found."]
    #[link_name = "\u{1}_ZNK4llvm6Triple19get32BitArchVariantEv"]
    pub fn llvm_Triple_get32BitArchVariant(this: *const llvm_Triple) -> llvm_Triple;
}
extern "C" {
    #[doc = " Form a triple with a 64-bit variant of the current architecture.\n\n This can be used to move across \"families\" of architectures where useful.\n\n \\returns A new triple with a 64-bit architecture or an unknown\n          architecture if no such variant can be found."]
    #[link_name = "\u{1}_ZNK4llvm6Triple19get64BitArchVariantEv"]
    pub fn llvm_Triple_get64BitArchVariant(this: *const llvm_Triple) -> llvm_Triple;
}
extern "C" {
    #[doc = " Form a triple with a big endian variant of the current architecture.\n\n This can be used to move across \"families\" of architectures where useful.\n\n \\returns A new triple with a big endian architecture or an unknown\n          architecture if no such variant can be found."]
    #[link_name = "\u{1}_ZNK4llvm6Triple23getBigEndianArchVariantEv"]
    pub fn llvm_Triple_getBigEndianArchVariant(this: *const llvm_Triple) -> llvm_Triple;
}
extern "C" {
    #[doc = " Form a triple with a little endian variant of the current architecture.\n\n This can be used to move across \"families\" of architectures where useful.\n\n \\returns A new triple with a little endian architecture or an unknown\n          architecture if no such variant can be found."]
    #[link_name = "\u{1}_ZNK4llvm6Triple26getLittleEndianArchVariantEv"]
    pub fn llvm_Triple_getLittleEndianArchVariant(this: *const llvm_Triple) -> llvm_Triple;
}
extern "C" {
    #[doc = " Tests whether the target triple is little endian.\n\n \\returns true if the triple is little endian, false otherwise."]
    #[link_name = "\u{1}_ZNK4llvm6Triple14isLittleEndianEv"]
    pub fn llvm_Triple_isLittleEndian(this: *const llvm_Triple) -> bool;
}
extern "C" {
    #[doc = " Test whether target triples are compatible."]
    #[link_name = "\u{1}_ZNK4llvm6Triple16isCompatibleWithERKS0_"]
    pub fn llvm_Triple_isCompatibleWith(
        this: *const llvm_Triple,
        Other: *const llvm_Triple,
    ) -> bool;
}
extern "C" {
    #[doc = " Merge target triples."]
    #[link_name = "\u{1}_ZNK4llvm6Triple5mergeB5cxx11ERKS0_"]
    pub fn llvm_Triple_merge(this: *const llvm_Triple, Other: *const llvm_Triple) -> std_string;
}
extern "C" {
    #[doc = " Some platforms have different minimum supported OS versions that\n varies by the architecture specified in the triple. This function\n returns the minimum supported OS version for this triple if one an exists,\n or an invalid version tuple if this triple doesn't have one."]
    #[link_name = "\u{1}_ZNK4llvm6Triple28getMinimumSupportedOSVersionEv"]
    pub fn llvm_Triple_getMinimumSupportedOSVersion(this: *const llvm_Triple) -> llvm_VersionTuple;
}
extern "C" {
    #[doc = " Get the canonical name for the \\p Kind architecture."]
    #[link_name = "\u{1}_ZN4llvm6Triple15getArchTypeNameENS0_8ArchTypeE"]
    pub fn llvm_Triple_getArchTypeName(Kind: llvm_Triple_ArchType) -> llvm_StringRef;
}
extern "C" {
    #[doc = " Get the architecture name based on \\p Kind and \\p SubArch."]
    #[link_name = "\u{1}_ZN4llvm6Triple11getArchNameENS0_8ArchTypeENS0_11SubArchTypeE"]
    pub fn llvm_Triple_getArchName1(
        Kind: llvm_Triple_ArchType,
        SubArch: llvm_Triple_SubArchType,
    ) -> llvm_StringRef;
}
extern "C" {
    #[doc = " Get the \"prefix\" canonical name for the \\p Kind architecture. This is the\n prefix used by the architecture specific builtins, and is suitable for\n passing to \\see Intrinsic::getIntrinsicForClangBuiltin().\n\n \\return - The architecture prefix, or 0 if none is defined."]
    #[link_name = "\u{1}_ZN4llvm6Triple17getArchTypePrefixENS0_8ArchTypeE"]
    pub fn llvm_Triple_getArchTypePrefix(Kind: llvm_Triple_ArchType) -> llvm_StringRef;
}
extern "C" {
    #[doc = " Get the canonical name for the \\p Kind vendor."]
    #[link_name = "\u{1}_ZN4llvm6Triple17getVendorTypeNameENS0_10VendorTypeE"]
    pub fn llvm_Triple_getVendorTypeName(Kind: llvm_Triple_VendorType) -> llvm_StringRef;
}
extern "C" {
    #[doc = " Get the canonical name for the \\p Kind operating system."]
    #[link_name = "\u{1}_ZN4llvm6Triple13getOSTypeNameENS0_6OSTypeE"]
    pub fn llvm_Triple_getOSTypeName(Kind: llvm_Triple_OSType) -> llvm_StringRef;
}
extern "C" {
    #[doc = " Get the canonical name for the \\p Kind environment."]
    #[link_name = "\u{1}_ZN4llvm6Triple22getEnvironmentTypeNameENS0_15EnvironmentTypeE"]
    pub fn llvm_Triple_getEnvironmentTypeName(Kind: llvm_Triple_EnvironmentType) -> llvm_StringRef;
}
extern "C" {
    #[doc = " Get the name for the \\p Object format."]
    #[link_name = "\u{1}_ZN4llvm6Triple23getObjectFormatTypeNameENS0_16ObjectFormatTypeE"]
    pub fn llvm_Triple_getObjectFormatTypeName(
        ObjectFormat: llvm_Triple_ObjectFormatType,
    ) -> llvm_StringRef;
}
extern "C" {
    #[doc = " The canonical type for the given LLVM architecture name (e.g., \"x86\")."]
    #[link_name = "\u{1}_ZN4llvm6Triple22getArchTypeForLLVMNameENS_9StringRefE"]
    pub fn llvm_Triple_getArchTypeForLLVMName(Str: llvm_StringRef) -> llvm_Triple_ArchType;
}
extern "C" {
    #[doc = " Returns a canonicalized OS version number for the specified OS."]
    #[link_name = "\u{1}_ZN4llvm6Triple24getCanonicalVersionForOSENS0_6OSTypeERKNS_12VersionTupleE"]
    pub fn llvm_Triple_getCanonicalVersionForOS(
        OSKind: llvm_Triple_OSType,
        Version: *const llvm_VersionTuple,
    ) -> llvm_VersionTuple;
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm6TripleC1ERKNS_5TwineE"]
    pub fn llvm_Triple_Triple(this: *mut llvm_Triple, Str: *const llvm_Twine);
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm6TripleC1ERKNS_5TwineES3_S3_"]
    pub fn llvm_Triple_Triple1(
        this: *mut llvm_Triple,
        ArchStr: *const llvm_Twine,
        VendorStr: *const llvm_Twine,
        OSStr: *const llvm_Twine,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm6TripleC1ERKNS_5TwineES3_S3_S3_"]
    pub fn llvm_Triple_Triple2(
        this: *mut llvm_Triple,
        ArchStr: *const llvm_Twine,
        VendorStr: *const llvm_Twine,
        OSStr: *const llvm_Twine,
        EnvironmentStr: *const llvm_Twine,
    );
}
impl llvm_Triple {
    #[inline]
    pub unsafe fn normalize(Str: llvm_StringRef) -> std_string {
        llvm_Triple_normalize(Str)
    }
    #[inline]
    pub unsafe fn getEnvironmentVersion(&self) -> llvm_VersionTuple {
        llvm_Triple_getEnvironmentVersion(self)
    }
    #[inline]
    pub unsafe fn getOSVersion(&self) -> llvm_VersionTuple {
        llvm_Triple_getOSVersion(self)
    }
    #[inline]
    pub unsafe fn getMacOSXVersion(&self, Version: *mut llvm_VersionTuple) -> bool {
        llvm_Triple_getMacOSXVersion(self, Version)
    }
    #[inline]
    pub unsafe fn getiOSVersion(&self) -> llvm_VersionTuple {
        llvm_Triple_getiOSVersion(self)
    }
    #[inline]
    pub unsafe fn getWatchOSVersion(&self) -> llvm_VersionTuple {
        llvm_Triple_getWatchOSVersion(self)
    }
    #[inline]
    pub unsafe fn getDriverKitVersion(&self) -> llvm_VersionTuple {
        llvm_Triple_getDriverKitVersion(self)
    }
    #[inline]
    pub unsafe fn getVulkanVersion(&self) -> llvm_VersionTuple {
        llvm_Triple_getVulkanVersion(self)
    }
    #[inline]
    pub unsafe fn getDXILVersion(&self) -> llvm_VersionTuple {
        llvm_Triple_getDXILVersion(self)
    }
    #[inline]
    pub unsafe fn getArchName(&self) -> llvm_StringRef {
        llvm_Triple_getArchName(self)
    }
    #[inline]
    pub unsafe fn getVendorName(&self) -> llvm_StringRef {
        llvm_Triple_getVendorName(self)
    }
    #[inline]
    pub unsafe fn getOSName(&self) -> llvm_StringRef {
        llvm_Triple_getOSName(self)
    }
    #[inline]
    pub unsafe fn getEnvironmentName(&self) -> llvm_StringRef {
        llvm_Triple_getEnvironmentName(self)
    }
    #[inline]
    pub unsafe fn getOSAndEnvironmentName(&self) -> llvm_StringRef {
        llvm_Triple_getOSAndEnvironmentName(self)
    }
    #[inline]
    pub unsafe fn getEnvironmentVersionString(&self) -> llvm_StringRef {
        llvm_Triple_getEnvironmentVersionString(self)
    }
    #[inline]
    pub unsafe fn getArchPointerBitWidth(Arch: llvm_Triple_ArchType) -> ::std::os::raw::c_uint {
        llvm_Triple_getArchPointerBitWidth(Arch)
    }
    #[inline]
    pub unsafe fn isArch64Bit(&self) -> bool {
        llvm_Triple_isArch64Bit(self)
    }
    #[inline]
    pub unsafe fn isArch32Bit(&self) -> bool {
        llvm_Triple_isArch32Bit(self)
    }
    #[inline]
    pub unsafe fn isArch16Bit(&self) -> bool {
        llvm_Triple_isArch16Bit(self)
    }
    #[inline]
    pub unsafe fn isMacOSXVersionLT(
        &self,
        Major: ::std::os::raw::c_uint,
        Minor: ::std::os::raw::c_uint,
        Micro: ::std::os::raw::c_uint,
    ) -> bool {
        llvm_Triple_isMacOSXVersionLT(self, Major, Minor, Micro)
    }
    #[inline]
    pub unsafe fn setArch(&mut self, Kind: llvm_Triple_ArchType, SubArch: llvm_Triple_SubArchType) {
        llvm_Triple_setArch(self, Kind, SubArch)
    }
    #[inline]
    pub unsafe fn setVendor(&mut self, Kind: llvm_Triple_VendorType) {
        llvm_Triple_setVendor(self, Kind)
    }
    #[inline]
    pub unsafe fn setOS(&mut self, Kind: llvm_Triple_OSType) {
        llvm_Triple_setOS(self, Kind)
    }
    #[inline]
    pub unsafe fn setEnvironment(&mut self, Kind: llvm_Triple_EnvironmentType) {
        llvm_Triple_setEnvironment(self, Kind)
    }
    #[inline]
    pub unsafe fn setObjectFormat(&mut self, Kind: llvm_Triple_ObjectFormatType) {
        llvm_Triple_setObjectFormat(self, Kind)
    }
    #[inline]
    pub unsafe fn setTriple(&mut self, Str: *const llvm_Twine) {
        llvm_Triple_setTriple(self, Str)
    }
    #[inline]
    pub unsafe fn setArchName(&mut self, Str: llvm_StringRef) {
        llvm_Triple_setArchName(self, Str)
    }
    #[inline]
    pub unsafe fn setVendorName(&mut self, Str: llvm_StringRef) {
        llvm_Triple_setVendorName(self, Str)
    }
    #[inline]
    pub unsafe fn setOSName(&mut self, Str: llvm_StringRef) {
        llvm_Triple_setOSName(self, Str)
    }
    #[inline]
    pub unsafe fn setEnvironmentName(&mut self, Str: llvm_StringRef) {
        llvm_Triple_setEnvironmentName(self, Str)
    }
    #[inline]
    pub unsafe fn setOSAndEnvironmentName(&mut self, Str: llvm_StringRef) {
        llvm_Triple_setOSAndEnvironmentName(self, Str)
    }
    #[inline]
    pub unsafe fn get32BitArchVariant(&self) -> llvm_Triple {
        llvm_Triple_get32BitArchVariant(self)
    }
    #[inline]
    pub unsafe fn get64BitArchVariant(&self) -> llvm_Triple {
        llvm_Triple_get64BitArchVariant(self)
    }
    #[inline]
    pub unsafe fn getBigEndianArchVariant(&self) -> llvm_Triple {
        llvm_Triple_getBigEndianArchVariant(self)
    }
    #[inline]
    pub unsafe fn getLittleEndianArchVariant(&self) -> llvm_Triple {
        llvm_Triple_getLittleEndianArchVariant(self)
    }
    #[inline]
    pub unsafe fn isLittleEndian(&self) -> bool {
        llvm_Triple_isLittleEndian(self)
    }
    #[inline]
    pub unsafe fn isCompatibleWith(&self, Other: *const llvm_Triple) -> bool {
        llvm_Triple_isCompatibleWith(self, Other)
    }
    #[inline]
    pub unsafe fn merge(&self, Other: *const llvm_Triple) -> std_string {
        llvm_Triple_merge(self, Other)
    }
    #[inline]
    pub unsafe fn getMinimumSupportedOSVersion(&self) -> llvm_VersionTuple {
        llvm_Triple_getMinimumSupportedOSVersion(self)
    }
    #[inline]
    pub unsafe fn getArchTypeName(Kind: llvm_Triple_ArchType) -> llvm_StringRef {
        llvm_Triple_getArchTypeName(Kind)
    }
    #[inline]
    pub unsafe fn getArchName1(
        Kind: llvm_Triple_ArchType,
        SubArch: llvm_Triple_SubArchType,
    ) -> llvm_StringRef {
        llvm_Triple_getArchName1(Kind, SubArch)
    }
    #[inline]
    pub unsafe fn getArchTypePrefix(Kind: llvm_Triple_ArchType) -> llvm_StringRef {
        llvm_Triple_getArchTypePrefix(Kind)
    }
    #[inline]
    pub unsafe fn getVendorTypeName(Kind: llvm_Triple_VendorType) -> llvm_StringRef {
        llvm_Triple_getVendorTypeName(Kind)
    }
    #[inline]
    pub unsafe fn getOSTypeName(Kind: llvm_Triple_OSType) -> llvm_StringRef {
        llvm_Triple_getOSTypeName(Kind)
    }
    #[inline]
    pub unsafe fn getEnvironmentTypeName(Kind: llvm_Triple_EnvironmentType) -> llvm_StringRef {
        llvm_Triple_getEnvironmentTypeName(Kind)
    }
    #[inline]
    pub unsafe fn getObjectFormatTypeName(
        ObjectFormat: llvm_Triple_ObjectFormatType,
    ) -> llvm_StringRef {
        llvm_Triple_getObjectFormatTypeName(ObjectFormat)
    }
    #[inline]
    pub unsafe fn getArchTypeForLLVMName(Str: llvm_StringRef) -> llvm_Triple_ArchType {
        llvm_Triple_getArchTypeForLLVMName(Str)
    }
    #[inline]
    pub unsafe fn getCanonicalVersionForOS(
        OSKind: llvm_Triple_OSType,
        Version: *const llvm_VersionTuple,
    ) -> llvm_VersionTuple {
        llvm_Triple_getCanonicalVersionForOS(OSKind, Version)
    }
    #[inline]
    pub unsafe fn new(Str: *const llvm_Twine) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        llvm_Triple_Triple(__bindgen_tmp.as_mut_ptr(), Str);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(
        ArchStr: *const llvm_Twine,
        VendorStr: *const llvm_Twine,
        OSStr: *const llvm_Twine,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        llvm_Triple_Triple1(__bindgen_tmp.as_mut_ptr(), ArchStr, VendorStr, OSStr);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new2(
        ArchStr: *const llvm_Twine,
        VendorStr: *const llvm_Twine,
        OSStr: *const llvm_Twine,
        EnvironmentStr: *const llvm_Twine,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        llvm_Triple_Triple2(
            __bindgen_tmp.as_mut_ptr(),
            ArchStr,
            VendorStr,
            OSStr,
            EnvironmentStr,
        );
        __bindgen_tmp.assume_init()
    }
}
#[repr(C)]
pub struct llvm_MCObjectFileInfo__bindgen_vtable(::std::os::raw::c_void);
#[repr(C)]
#[derive(Debug)]
pub struct llvm_MCObjectFileInfo {
    pub vtable_: *const llvm_MCObjectFileInfo__bindgen_vtable,
    #[doc = " True if target object file supports a weak_definition of constant 0 for an\n omitted EH frame."]
    pub SupportsWeakOmittedEHFrame: bool,
    #[doc = " True if the target object file supports emitting a compact unwind section\n without an associated EH frame section."]
    pub SupportsCompactUnwindWithoutEHFrame: bool,
    #[doc = " OmitDwarfIfHaveCompactUnwind - True if the target object file\n supports having some functions with compact unwind and other with\n dwarf unwind."]
    pub OmitDwarfIfHaveCompactUnwind: bool,
    #[doc = " FDE CFI encoding. Controls the encoding of the begin label in the\n .eh_frame section. Unlike the LSDA encoding, personality encoding, and\n type encodings, this is something that the assembler just \"knows\" about\n its target"]
    pub FDECFIEncoding: ::std::os::raw::c_uint,
    #[doc = " Compact unwind encoding indicating that we should emit only an EH frame."]
    pub CompactUnwindDwarfEHFrameOnly: ::std::os::raw::c_uint,
    #[doc = " Section directive for standard text."]
    pub TextSection: *mut llvm_MCSection,
    #[doc = " Section directive for standard data."]
    pub DataSection: *mut llvm_MCSection,
    #[doc = " Section that is default initialized to zero."]
    pub BSSSection: *mut llvm_MCSection,
    #[doc = " Section that is readonly and can contain arbitrary initialized data.\n Targets are not required to have a readonly section. If they don't,\n various bits of code will fall back to using the data section for\n constants."]
    pub ReadOnlySection: *mut llvm_MCSection,
    #[doc = " If exception handling is supported by the target, this is the section the\n Language Specific Data Area information is emitted to."]
    pub LSDASection: *mut llvm_MCSection,
    #[doc = " If exception handling is supported by the target and the target can\n support a compact representation of the CIE and FDE, this is the section\n to emit them into."]
    pub CompactUnwindSection: *mut llvm_MCSection,
    pub DwarfAbbrevSection: *mut llvm_MCSection,
    pub DwarfInfoSection: *mut llvm_MCSection,
    pub DwarfLineSection: *mut llvm_MCSection,
    pub DwarfLineStrSection: *mut llvm_MCSection,
    pub DwarfFrameSection: *mut llvm_MCSection,
    pub DwarfPubTypesSection: *mut llvm_MCSection,
    pub DwarfDebugInlineSection: *const llvm_MCSection,
    pub DwarfStrSection: *mut llvm_MCSection,
    pub DwarfLocSection: *mut llvm_MCSection,
    pub DwarfARangesSection: *mut llvm_MCSection,
    pub DwarfRangesSection: *mut llvm_MCSection,
    pub DwarfMacinfoSection: *mut llvm_MCSection,
    pub DwarfMacroSection: *mut llvm_MCSection,
    pub DwarfPubNamesSection: *mut llvm_MCSection,
    #[doc = " Accelerator table sections. DwarfDebugNamesSection is the DWARF v5\n accelerator table, while DwarfAccelNamesSection, DwarfAccelObjCSection,\n DwarfAccelNamespaceSection, DwarfAccelTypesSection are pre-DWARF v5\n extensions."]
    pub DwarfDebugNamesSection: *mut llvm_MCSection,
    pub DwarfAccelNamesSection: *mut llvm_MCSection,
    pub DwarfAccelObjCSection: *mut llvm_MCSection,
    pub DwarfAccelNamespaceSection: *mut llvm_MCSection,
    pub DwarfAccelTypesSection: *mut llvm_MCSection,
    pub DwarfInfoDWOSection: *mut llvm_MCSection,
    pub DwarfTypesDWOSection: *mut llvm_MCSection,
    pub DwarfAbbrevDWOSection: *mut llvm_MCSection,
    pub DwarfStrDWOSection: *mut llvm_MCSection,
    pub DwarfLineDWOSection: *mut llvm_MCSection,
    pub DwarfLocDWOSection: *mut llvm_MCSection,
    pub DwarfStrOffDWOSection: *mut llvm_MCSection,
    pub DwarfMacinfoDWOSection: *mut llvm_MCSection,
    pub DwarfMacroDWOSection: *mut llvm_MCSection,
    #[doc = " The DWARF v5 string offset and address table sections."]
    pub DwarfStrOffSection: *mut llvm_MCSection,
    pub DwarfAddrSection: *mut llvm_MCSection,
    #[doc = " The DWARF v5 range list section."]
    pub DwarfRnglistsSection: *mut llvm_MCSection,
    #[doc = " The DWARF v5 locations list section."]
    pub DwarfLoclistsSection: *mut llvm_MCSection,
    #[doc = " The DWARF v5 range and location list sections for fission."]
    pub DwarfRnglistsDWOSection: *mut llvm_MCSection,
    pub DwarfLoclistsDWOSection: *mut llvm_MCSection,
    pub DwarfCUIndexSection: *mut llvm_MCSection,
    pub DwarfTUIndexSection: *mut llvm_MCSection,
    #[doc = " Section for newer gnu pubnames."]
    pub DwarfGnuPubNamesSection: *mut llvm_MCSection,
    #[doc = " Section for newer gnu pubtypes."]
    pub DwarfGnuPubTypesSection: *mut llvm_MCSection,
    pub DwarfSwiftASTSection: *mut llvm_MCSection,
    pub COFFDebugSymbolsSection: *mut llvm_MCSection,
    pub COFFDebugTypesSection: *mut llvm_MCSection,
    pub COFFGlobalTypeHashesSection: *mut llvm_MCSection,
    #[doc = " Extra TLS Variable Data section.\n\n If the target needs to put additional information for a TLS variable,\n it'll go here."]
    pub TLSExtraDataSection: *mut llvm_MCSection,
    #[doc = " Section directive for Thread Local data. ELF, MachO, COFF, and Wasm."]
    pub TLSDataSection: *mut llvm_MCSection,
    #[doc = " Section directive for Thread Local uninitialized data.\n\n Null if this target doesn't support a BSS section. ELF and MachO only."]
    pub TLSBSSSection: *mut llvm_MCSection,
    #[doc = " StackMap section."]
    pub StackMapSection: *mut llvm_MCSection,
    #[doc = " FaultMap section."]
    pub FaultMapSection: *mut llvm_MCSection,
    #[doc = " Remarks section."]
    pub RemarksSection: *mut llvm_MCSection,
    #[doc = " EH frame section.\n\n It is initialized on demand so it can be overwritten (with uniquing)."]
    pub EHFrameSection: *mut llvm_MCSection,
    #[doc = " Section containing metadata on function stack sizes."]
    pub StackSizesSection: *mut llvm_MCSection,
    #[doc = " Section for pseudo probe information used by AutoFDO"]
    pub PseudoProbeSection: *mut llvm_MCSection,
    pub PseudoProbeDescSection: *mut llvm_MCSection,
    pub LLVMStatsSection: *mut llvm_MCSection,
    pub DataRelROSection: *mut llvm_MCSection,
    pub MergeableConst4Section: *mut llvm_MCSection,
    pub MergeableConst8Section: *mut llvm_MCSection,
    pub MergeableConst16Section: *mut llvm_MCSection,
    pub MergeableConst32Section: *mut llvm_MCSection,
    #[doc = " Section for thread local structure information.\n\n Contains the source code name of the variable, visibility and a pointer to\n the initial value (.tdata or .tbss)."]
    pub TLSTLVSection: *mut llvm_MCSection,
    #[doc = " Section for thread local data initialization functions."]
    pub TLSThreadInitSection: *const llvm_MCSection,
    pub CStringSection: *mut llvm_MCSection,
    pub UStringSection: *mut llvm_MCSection,
    pub TextCoalSection: *mut llvm_MCSection,
    pub ConstTextCoalSection: *mut llvm_MCSection,
    pub ConstDataSection: *mut llvm_MCSection,
    pub DataCoalSection: *mut llvm_MCSection,
    pub ConstDataCoalSection: *mut llvm_MCSection,
    pub DataCommonSection: *mut llvm_MCSection,
    pub DataBSSSection: *mut llvm_MCSection,
    pub FourByteConstantSection: *mut llvm_MCSection,
    pub EightByteConstantSection: *mut llvm_MCSection,
    pub SixteenByteConstantSection: *mut llvm_MCSection,
    pub LazySymbolPointerSection: *mut llvm_MCSection,
    pub NonLazySymbolPointerSection: *mut llvm_MCSection,
    pub ThreadLocalPointerSection: *mut llvm_MCSection,
    pub AddrSigSection: *mut llvm_MCSection,
    #[doc = " COFF specific sections."]
    pub DrectveSection: *mut llvm_MCSection,
    pub PDataSection: *mut llvm_MCSection,
    pub XDataSection: *mut llvm_MCSection,
    pub SXDataSection: *mut llvm_MCSection,
    pub GEHContSection: *mut llvm_MCSection,
    pub GFIDsSection: *mut llvm_MCSection,
    pub GIATsSection: *mut llvm_MCSection,
    pub GLJMPSection: *mut llvm_MCSection,
    pub PPA1Section: *mut llvm_MCSection,
    pub PPA2Section: *mut llvm_MCSection,
    pub PPA2ListSection: *mut llvm_MCSection,
    pub ADASection: *mut llvm_MCSection,
    pub IDRLSection: *mut llvm_MCSection,
    pub TOCBaseSection: *mut llvm_MCSection,
    pub ReadOnly8Section: *mut llvm_MCSection,
    pub ReadOnly16Section: *mut llvm_MCSection,
    pub Swift5ReflectionSections: [u64; 11usize],
    pub PositionIndependent: bool,
    pub Ctx: *mut llvm_MCContext,
}
#[test]
fn bindgen_test_layout_llvm_MCObjectFileInfo() {
    const UNINIT: ::std::mem::MaybeUninit<llvm_MCObjectFileInfo> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<llvm_MCObjectFileInfo>(),
        912usize,
        concat!("Size of: ", stringify!(llvm_MCObjectFileInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_MCObjectFileInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(llvm_MCObjectFileInfo))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).SupportsWeakOmittedEHFrame) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_MCObjectFileInfo),
            "::",
            stringify!(SupportsWeakOmittedEHFrame)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).SupportsCompactUnwindWithoutEHFrame) as usize - ptr as usize
        },
        9usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_MCObjectFileInfo),
            "::",
            stringify!(SupportsCompactUnwindWithoutEHFrame)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).OmitDwarfIfHaveCompactUnwind) as usize - ptr as usize
        },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_MCObjectFileInfo),
            "::",
            stringify!(OmitDwarfIfHaveCompactUnwind)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).FDECFIEncoding) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_MCObjectFileInfo),
            "::",
            stringify!(FDECFIEncoding)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).CompactUnwindDwarfEHFrameOnly) as usize - ptr as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_MCObjectFileInfo),
            "::",
            stringify!(CompactUnwindDwarfEHFrameOnly)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).TextSection) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_MCObjectFileInfo),
            "::",
            stringify!(TextSection)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).DataSection) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_MCObjectFileInfo),
            "::",
            stringify!(DataSection)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).BSSSection) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_MCObjectFileInfo),
            "::",
            stringify!(BSSSection)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ReadOnlySection) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_MCObjectFileInfo),
            "::",
            stringify!(ReadOnlySection)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LSDASection) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_MCObjectFileInfo),
            "::",
            stringify!(LSDASection)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).CompactUnwindSection) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_MCObjectFileInfo),
            "::",
            stringify!(CompactUnwindSection)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).DwarfAbbrevSection) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_MCObjectFileInfo),
            "::",
            stringify!(DwarfAbbrevSection)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).DwarfInfoSection) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_MCObjectFileInfo),
            "::",
            stringify!(DwarfInfoSection)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).DwarfLineSection) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_MCObjectFileInfo),
            "::",
            stringify!(DwarfLineSection)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).DwarfLineStrSection) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_MCObjectFileInfo),
            "::",
            stringify!(DwarfLineStrSection)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).DwarfFrameSection) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_MCObjectFileInfo),
            "::",
            stringify!(DwarfFrameSection)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).DwarfPubTypesSection) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_MCObjectFileInfo),
            "::",
            stringify!(DwarfPubTypesSection)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).DwarfDebugInlineSection) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_MCObjectFileInfo),
            "::",
            stringify!(DwarfDebugInlineSection)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).DwarfStrSection) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_MCObjectFileInfo),
            "::",
            stringify!(DwarfStrSection)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).DwarfLocSection) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_MCObjectFileInfo),
            "::",
            stringify!(DwarfLocSection)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).DwarfARangesSection) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_MCObjectFileInfo),
            "::",
            stringify!(DwarfARangesSection)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).DwarfRangesSection) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_MCObjectFileInfo),
            "::",
            stringify!(DwarfRangesSection)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).DwarfMacinfoSection) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_MCObjectFileInfo),
            "::",
            stringify!(DwarfMacinfoSection)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).DwarfMacroSection) as usize - ptr as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_MCObjectFileInfo),
            "::",
            stringify!(DwarfMacroSection)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).DwarfPubNamesSection) as usize - ptr as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_MCObjectFileInfo),
            "::",
            stringify!(DwarfPubNamesSection)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).DwarfDebugNamesSection) as usize - ptr as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_MCObjectFileInfo),
            "::",
            stringify!(DwarfDebugNamesSection)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).DwarfAccelNamesSection) as usize - ptr as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_MCObjectFileInfo),
            "::",
            stringify!(DwarfAccelNamesSection)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).DwarfAccelObjCSection) as usize - ptr as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_MCObjectFileInfo),
            "::",
            stringify!(DwarfAccelObjCSection)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).DwarfAccelNamespaceSection) as usize - ptr as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_MCObjectFileInfo),
            "::",
            stringify!(DwarfAccelNamespaceSection)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).DwarfAccelTypesSection) as usize - ptr as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_MCObjectFileInfo),
            "::",
            stringify!(DwarfAccelTypesSection)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).DwarfInfoDWOSection) as usize - ptr as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_MCObjectFileInfo),
            "::",
            stringify!(DwarfInfoDWOSection)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).DwarfTypesDWOSection) as usize - ptr as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_MCObjectFileInfo),
            "::",
            stringify!(DwarfTypesDWOSection)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).DwarfAbbrevDWOSection) as usize - ptr as usize },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_MCObjectFileInfo),
            "::",
            stringify!(DwarfAbbrevDWOSection)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).DwarfStrDWOSection) as usize - ptr as usize },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_MCObjectFileInfo),
            "::",
            stringify!(DwarfStrDWOSection)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).DwarfLineDWOSection) as usize - ptr as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_MCObjectFileInfo),
            "::",
            stringify!(DwarfLineDWOSection)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).DwarfLocDWOSection) as usize - ptr as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_MCObjectFileInfo),
            "::",
            stringify!(DwarfLocDWOSection)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).DwarfStrOffDWOSection) as usize - ptr as usize },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_MCObjectFileInfo),
            "::",
            stringify!(DwarfStrOffDWOSection)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).DwarfMacinfoDWOSection) as usize - ptr as usize },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_MCObjectFileInfo),
            "::",
            stringify!(DwarfMacinfoDWOSection)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).DwarfMacroDWOSection) as usize - ptr as usize },
        288usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_MCObjectFileInfo),
            "::",
            stringify!(DwarfMacroDWOSection)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).DwarfStrOffSection) as usize - ptr as usize },
        296usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_MCObjectFileInfo),
            "::",
            stringify!(DwarfStrOffSection)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).DwarfAddrSection) as usize - ptr as usize },
        304usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_MCObjectFileInfo),
            "::",
            stringify!(DwarfAddrSection)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).DwarfRnglistsSection) as usize - ptr as usize },
        312usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_MCObjectFileInfo),
            "::",
            stringify!(DwarfRnglistsSection)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).DwarfLoclistsSection) as usize - ptr as usize },
        320usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_MCObjectFileInfo),
            "::",
            stringify!(DwarfLoclistsSection)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).DwarfRnglistsDWOSection) as usize - ptr as usize },
        328usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_MCObjectFileInfo),
            "::",
            stringify!(DwarfRnglistsDWOSection)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).DwarfLoclistsDWOSection) as usize - ptr as usize },
        336usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_MCObjectFileInfo),
            "::",
            stringify!(DwarfLoclistsDWOSection)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).DwarfCUIndexSection) as usize - ptr as usize },
        344usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_MCObjectFileInfo),
            "::",
            stringify!(DwarfCUIndexSection)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).DwarfTUIndexSection) as usize - ptr as usize },
        352usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_MCObjectFileInfo),
            "::",
            stringify!(DwarfTUIndexSection)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).DwarfGnuPubNamesSection) as usize - ptr as usize },
        360usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_MCObjectFileInfo),
            "::",
            stringify!(DwarfGnuPubNamesSection)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).DwarfGnuPubTypesSection) as usize - ptr as usize },
        368usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_MCObjectFileInfo),
            "::",
            stringify!(DwarfGnuPubTypesSection)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).DwarfSwiftASTSection) as usize - ptr as usize },
        376usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_MCObjectFileInfo),
            "::",
            stringify!(DwarfSwiftASTSection)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).COFFDebugSymbolsSection) as usize - ptr as usize },
        384usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_MCObjectFileInfo),
            "::",
            stringify!(COFFDebugSymbolsSection)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).COFFDebugTypesSection) as usize - ptr as usize },
        392usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_MCObjectFileInfo),
            "::",
            stringify!(COFFDebugTypesSection)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).COFFGlobalTypeHashesSection) as usize - ptr as usize },
        400usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_MCObjectFileInfo),
            "::",
            stringify!(COFFGlobalTypeHashesSection)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).TLSExtraDataSection) as usize - ptr as usize },
        408usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_MCObjectFileInfo),
            "::",
            stringify!(TLSExtraDataSection)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).TLSDataSection) as usize - ptr as usize },
        416usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_MCObjectFileInfo),
            "::",
            stringify!(TLSDataSection)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).TLSBSSSection) as usize - ptr as usize },
        424usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_MCObjectFileInfo),
            "::",
            stringify!(TLSBSSSection)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).StackMapSection) as usize - ptr as usize },
        432usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_MCObjectFileInfo),
            "::",
            stringify!(StackMapSection)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).FaultMapSection) as usize - ptr as usize },
        440usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_MCObjectFileInfo),
            "::",
            stringify!(FaultMapSection)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).RemarksSection) as usize - ptr as usize },
        448usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_MCObjectFileInfo),
            "::",
            stringify!(RemarksSection)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).EHFrameSection) as usize - ptr as usize },
        456usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_MCObjectFileInfo),
            "::",
            stringify!(EHFrameSection)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).StackSizesSection) as usize - ptr as usize },
        464usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_MCObjectFileInfo),
            "::",
            stringify!(StackSizesSection)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).PseudoProbeSection) as usize - ptr as usize },
        472usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_MCObjectFileInfo),
            "::",
            stringify!(PseudoProbeSection)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).PseudoProbeDescSection) as usize - ptr as usize },
        480usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_MCObjectFileInfo),
            "::",
            stringify!(PseudoProbeDescSection)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LLVMStatsSection) as usize - ptr as usize },
        488usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_MCObjectFileInfo),
            "::",
            stringify!(LLVMStatsSection)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).DataRelROSection) as usize - ptr as usize },
        496usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_MCObjectFileInfo),
            "::",
            stringify!(DataRelROSection)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).MergeableConst4Section) as usize - ptr as usize },
        504usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_MCObjectFileInfo),
            "::",
            stringify!(MergeableConst4Section)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).MergeableConst8Section) as usize - ptr as usize },
        512usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_MCObjectFileInfo),
            "::",
            stringify!(MergeableConst8Section)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).MergeableConst16Section) as usize - ptr as usize },
        520usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_MCObjectFileInfo),
            "::",
            stringify!(MergeableConst16Section)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).MergeableConst32Section) as usize - ptr as usize },
        528usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_MCObjectFileInfo),
            "::",
            stringify!(MergeableConst32Section)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).TLSTLVSection) as usize - ptr as usize },
        536usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_MCObjectFileInfo),
            "::",
            stringify!(TLSTLVSection)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).TLSThreadInitSection) as usize - ptr as usize },
        544usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_MCObjectFileInfo),
            "::",
            stringify!(TLSThreadInitSection)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).CStringSection) as usize - ptr as usize },
        552usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_MCObjectFileInfo),
            "::",
            stringify!(CStringSection)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).UStringSection) as usize - ptr as usize },
        560usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_MCObjectFileInfo),
            "::",
            stringify!(UStringSection)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).TextCoalSection) as usize - ptr as usize },
        568usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_MCObjectFileInfo),
            "::",
            stringify!(TextCoalSection)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ConstTextCoalSection) as usize - ptr as usize },
        576usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_MCObjectFileInfo),
            "::",
            stringify!(ConstTextCoalSection)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ConstDataSection) as usize - ptr as usize },
        584usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_MCObjectFileInfo),
            "::",
            stringify!(ConstDataSection)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).DataCoalSection) as usize - ptr as usize },
        592usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_MCObjectFileInfo),
            "::",
            stringify!(DataCoalSection)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ConstDataCoalSection) as usize - ptr as usize },
        600usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_MCObjectFileInfo),
            "::",
            stringify!(ConstDataCoalSection)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).DataCommonSection) as usize - ptr as usize },
        608usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_MCObjectFileInfo),
            "::",
            stringify!(DataCommonSection)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).DataBSSSection) as usize - ptr as usize },
        616usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_MCObjectFileInfo),
            "::",
            stringify!(DataBSSSection)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).FourByteConstantSection) as usize - ptr as usize },
        624usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_MCObjectFileInfo),
            "::",
            stringify!(FourByteConstantSection)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).EightByteConstantSection) as usize - ptr as usize },
        632usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_MCObjectFileInfo),
            "::",
            stringify!(EightByteConstantSection)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).SixteenByteConstantSection) as usize - ptr as usize },
        640usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_MCObjectFileInfo),
            "::",
            stringify!(SixteenByteConstantSection)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LazySymbolPointerSection) as usize - ptr as usize },
        648usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_MCObjectFileInfo),
            "::",
            stringify!(LazySymbolPointerSection)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).NonLazySymbolPointerSection) as usize - ptr as usize },
        656usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_MCObjectFileInfo),
            "::",
            stringify!(NonLazySymbolPointerSection)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ThreadLocalPointerSection) as usize - ptr as usize },
        664usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_MCObjectFileInfo),
            "::",
            stringify!(ThreadLocalPointerSection)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).AddrSigSection) as usize - ptr as usize },
        672usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_MCObjectFileInfo),
            "::",
            stringify!(AddrSigSection)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).DrectveSection) as usize - ptr as usize },
        680usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_MCObjectFileInfo),
            "::",
            stringify!(DrectveSection)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).PDataSection) as usize - ptr as usize },
        688usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_MCObjectFileInfo),
            "::",
            stringify!(PDataSection)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).XDataSection) as usize - ptr as usize },
        696usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_MCObjectFileInfo),
            "::",
            stringify!(XDataSection)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).SXDataSection) as usize - ptr as usize },
        704usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_MCObjectFileInfo),
            "::",
            stringify!(SXDataSection)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).GEHContSection) as usize - ptr as usize },
        712usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_MCObjectFileInfo),
            "::",
            stringify!(GEHContSection)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).GFIDsSection) as usize - ptr as usize },
        720usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_MCObjectFileInfo),
            "::",
            stringify!(GFIDsSection)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).GIATsSection) as usize - ptr as usize },
        728usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_MCObjectFileInfo),
            "::",
            stringify!(GIATsSection)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).GLJMPSection) as usize - ptr as usize },
        736usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_MCObjectFileInfo),
            "::",
            stringify!(GLJMPSection)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).PPA1Section) as usize - ptr as usize },
        744usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_MCObjectFileInfo),
            "::",
            stringify!(PPA1Section)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).PPA2Section) as usize - ptr as usize },
        752usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_MCObjectFileInfo),
            "::",
            stringify!(PPA2Section)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).PPA2ListSection) as usize - ptr as usize },
        760usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_MCObjectFileInfo),
            "::",
            stringify!(PPA2ListSection)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ADASection) as usize - ptr as usize },
        768usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_MCObjectFileInfo),
            "::",
            stringify!(ADASection)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).IDRLSection) as usize - ptr as usize },
        776usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_MCObjectFileInfo),
            "::",
            stringify!(IDRLSection)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).TOCBaseSection) as usize - ptr as usize },
        784usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_MCObjectFileInfo),
            "::",
            stringify!(TOCBaseSection)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ReadOnly8Section) as usize - ptr as usize },
        792usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_MCObjectFileInfo),
            "::",
            stringify!(ReadOnly8Section)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ReadOnly16Section) as usize - ptr as usize },
        800usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_MCObjectFileInfo),
            "::",
            stringify!(ReadOnly16Section)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Swift5ReflectionSections) as usize - ptr as usize },
        808usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_MCObjectFileInfo),
            "::",
            stringify!(Swift5ReflectionSections)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).PositionIndependent) as usize - ptr as usize },
        896usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_MCObjectFileInfo),
            "::",
            stringify!(PositionIndependent)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Ctx) as usize - ptr as usize },
        904usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_MCObjectFileInfo),
            "::",
            stringify!(Ctx)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm16MCObjectFileInfo20initMCObjectFileInfoERNS_9MCContextEbb"]
    pub fn llvm_MCObjectFileInfo_initMCObjectFileInfo(
        this: *mut llvm_MCObjectFileInfo,
        MCCtx: *mut llvm_MCContext,
        PIC: bool,
        LargeCodeModel: bool,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK4llvm16MCObjectFileInfo20getStackSizesSectionERKNS_9MCSectionE"]
    pub fn llvm_MCObjectFileInfo_getStackSizesSection(
        this: *const llvm_MCObjectFileInfo,
        TextSec: *const llvm_MCSection,
    ) -> *mut llvm_MCSection;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4llvm16MCObjectFileInfo19getBBAddrMapSectionERKNS_9MCSectionE"]
    pub fn llvm_MCObjectFileInfo_getBBAddrMapSection(
        this: *const llvm_MCObjectFileInfo,
        TextSec: *const llvm_MCSection,
    ) -> *mut llvm_MCSection;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4llvm16MCObjectFileInfo18getKCFITrapSectionERKNS_9MCSectionE"]
    pub fn llvm_MCObjectFileInfo_getKCFITrapSection(
        this: *const llvm_MCObjectFileInfo,
        TextSec: *const llvm_MCSection,
    ) -> *mut llvm_MCSection;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4llvm16MCObjectFileInfo21getPseudoProbeSectionERKNS_9MCSectionE"]
    pub fn llvm_MCObjectFileInfo_getPseudoProbeSection(
        this: *const llvm_MCObjectFileInfo,
        TextSec: *const llvm_MCSection,
    ) -> *mut llvm_MCSection;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4llvm16MCObjectFileInfo25getPseudoProbeDescSectionENS_9StringRefE"]
    pub fn llvm_MCObjectFileInfo_getPseudoProbeDescSection(
        this: *const llvm_MCObjectFileInfo,
        FuncName: llvm_StringRef,
    ) -> *mut llvm_MCSection;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4llvm16MCObjectFileInfo19getLLVMStatsSectionEv"]
    pub fn llvm_MCObjectFileInfo_getLLVMStatsSection(
        this: *const llvm_MCObjectFileInfo,
    ) -> *mut llvm_MCSection;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4llvm16MCObjectFileInfo12getPCSectionENS_9StringRefEPKNS_9MCSectionE"]
    pub fn llvm_MCObjectFileInfo_getPCSection(
        this: *const llvm_MCObjectFileInfo,
        Name: llvm_StringRef,
        TextSec: *const llvm_MCSection,
    ) -> *mut llvm_MCSection;
}
impl llvm_MCObjectFileInfo {
    #[inline]
    pub unsafe fn initMCObjectFileInfo(
        &mut self,
        MCCtx: *mut llvm_MCContext,
        PIC: bool,
        LargeCodeModel: bool,
    ) {
        llvm_MCObjectFileInfo_initMCObjectFileInfo(self, MCCtx, PIC, LargeCodeModel)
    }
    #[inline]
    pub unsafe fn getStackSizesSection(
        &self,
        TextSec: *const llvm_MCSection,
    ) -> *mut llvm_MCSection {
        llvm_MCObjectFileInfo_getStackSizesSection(self, TextSec)
    }
    #[inline]
    pub unsafe fn getBBAddrMapSection(
        &self,
        TextSec: *const llvm_MCSection,
    ) -> *mut llvm_MCSection {
        llvm_MCObjectFileInfo_getBBAddrMapSection(self, TextSec)
    }
    #[inline]
    pub unsafe fn getKCFITrapSection(&self, TextSec: *const llvm_MCSection) -> *mut llvm_MCSection {
        llvm_MCObjectFileInfo_getKCFITrapSection(self, TextSec)
    }
    #[inline]
    pub unsafe fn getPseudoProbeSection(
        &self,
        TextSec: *const llvm_MCSection,
    ) -> *mut llvm_MCSection {
        llvm_MCObjectFileInfo_getPseudoProbeSection(self, TextSec)
    }
    #[inline]
    pub unsafe fn getPseudoProbeDescSection(
        &self,
        FuncName: llvm_StringRef,
    ) -> *mut llvm_MCSection {
        llvm_MCObjectFileInfo_getPseudoProbeDescSection(self, FuncName)
    }
    #[inline]
    pub unsafe fn getLLVMStatsSection(&self) -> *mut llvm_MCSection {
        llvm_MCObjectFileInfo_getLLVMStatsSection(self)
    }
    #[inline]
    pub unsafe fn getPCSection(
        &self,
        Name: llvm_StringRef,
        TextSec: *const llvm_MCSection,
    ) -> *mut llvm_MCSection {
        llvm_MCObjectFileInfo_getPCSection(self, Name, TextSec)
    }
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm16MCObjectFileInfoD1Ev"]
    pub fn llvm_MCObjectFileInfo_MCObjectFileInfo_destructor(this: *mut llvm_MCObjectFileInfo);
}
#[doc = " formatted_raw_ostream - A raw_ostream that wraps another one and keeps track\n of line and column position, allowing padding out to specific column\n boundaries and querying the number of lines written to the stream. This\n assumes that the contents of the stream is valid UTF-8 encoded text. This\n doesn't attempt to handle everything Unicode can do (combining characters,\n right-to-left markers, etc), but should cover the cases likely to appear in\n source code or diagnostic messages."]
#[repr(C)]
#[derive(Debug)]
pub struct llvm_formatted_raw_ostream {
    pub _base: llvm_raw_ostream,
    #[doc = " TheStream - The real stream we output to. We set it to be\n unbuffered, since we're already doing our own buffering.\n"]
    pub TheStream: *mut llvm_raw_ostream,
    #[doc = " Position - The current output column and line of the data that's\n been flushed and the portion of the buffer that's been\n scanned.  The line and column scheme is zero-based.\n"]
    pub Position: std_pair<::std::os::raw::c_uint, ::std::os::raw::c_uint>,
    #[doc = " Scanned - This points to one past the last character in the\n buffer we've scanned.\n"]
    pub Scanned: *const ::std::os::raw::c_char,
    #[doc = " PartialUTF8Char - Either empty or a prefix of a UTF-8 code unit sequence\n for a Unicode scalar value which should be prepended to the buffer for the\n next call to ComputePosition. This is needed when the buffer is flushed\n when it ends part-way through the UTF-8 encoding of a Unicode scalar\n value, so that we can compute the display width of the character once we\n have the rest of it."]
    pub PartialUTF8Char: [u64; 4usize],
    #[doc = " DisableScan - Temporarily disable scanning of output. Used to ignore color\n codes."]
    pub DisableScan: bool,
}
#[repr(C)]
#[derive(Debug)]
pub struct llvm_formatted_raw_ostream_DisableScanScope {
    pub S: *mut llvm_formatted_raw_ostream,
}
#[test]
fn bindgen_test_layout_llvm_formatted_raw_ostream_DisableScanScope() {
    const UNINIT: ::std::mem::MaybeUninit<llvm_formatted_raw_ostream_DisableScanScope> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<llvm_formatted_raw_ostream_DisableScanScope>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(llvm_formatted_raw_ostream_DisableScanScope)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_formatted_raw_ostream_DisableScanScope>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(llvm_formatted_raw_ostream_DisableScanScope)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).S) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_formatted_raw_ostream_DisableScanScope),
            "::",
            stringify!(S)
        )
    );
}
#[test]
fn bindgen_test_layout_llvm_formatted_raw_ostream() {
    const UNINIT: ::std::mem::MaybeUninit<llvm_formatted_raw_ostream> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<llvm_formatted_raw_ostream>(),
        112usize,
        concat!("Size of: ", stringify!(llvm_formatted_raw_ostream))
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_formatted_raw_ostream>(),
        8usize,
        concat!("Alignment of ", stringify!(llvm_formatted_raw_ostream))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).TheStream) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_formatted_raw_ostream),
            "::",
            stringify!(TheStream)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Position) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_formatted_raw_ostream),
            "::",
            stringify!(Position)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Scanned) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_formatted_raw_ostream),
            "::",
            stringify!(Scanned)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).PartialUTF8Char) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_formatted_raw_ostream),
            "::",
            stringify!(PartialUTF8Char)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).DisableScan) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_formatted_raw_ostream),
            "::",
            stringify!(DisableScan)
        )
    );
}
extern "C" {
    #[doc = " PadToColumn - Align the output to some column number.  If the current\n column is already equal to or more than NewCol, PadToColumn inserts one\n space.\n\n \\param NewCol - The column to move to."]
    #[link_name = "\u{1}_ZN4llvm21formatted_raw_ostream11PadToColumnEj"]
    pub fn llvm_formatted_raw_ostream_PadToColumn(
        this: *mut llvm_formatted_raw_ostream,
        NewCol: ::std::os::raw::c_uint,
    ) -> *mut llvm_formatted_raw_ostream;
}
impl llvm_formatted_raw_ostream {
    #[inline]
    pub unsafe fn PadToColumn(
        &mut self,
        NewCol: ::std::os::raw::c_uint,
    ) -> *mut llvm_formatted_raw_ostream {
        llvm_formatted_raw_ostream_PadToColumn(self, NewCol)
    }
}
extern "C" {
    #[doc = " fouts() - This returns a reference to a formatted_raw_ostream for\n standard output.  Use it like: fouts() << \"foo\" << \"bar\";"]
    #[link_name = "\u{1}_ZN4llvm5foutsEv"]
    pub fn llvm_fouts() -> *mut llvm_formatted_raw_ostream;
}
extern "C" {
    #[doc = " ferrs() - This returns a reference to a formatted_raw_ostream for\n standard error.  Use it like: ferrs() << \"foo\" << \"bar\";"]
    #[link_name = "\u{1}_ZN4llvm5ferrsEv"]
    pub fn llvm_ferrs() -> *mut llvm_formatted_raw_ostream;
}
extern "C" {
    #[doc = " fdbgs() - This returns a reference to a formatted_raw_ostream for\n debug output.  Use it like: fdbgs() << \"foo\" << \"bar\";"]
    #[link_name = "\u{1}_ZN4llvm5fdbgsEv"]
    pub fn llvm_fdbgs() -> *mut llvm_formatted_raw_ostream;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_AsmPrinter {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_MCAsmBackend {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_MCAsmParser {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_MCCodeEmitter {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_MCDisassembler {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_MCInstrAnalysis {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_MCInstrInfo {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_MCObjectWriter {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_MCRelocationInfo {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_MCStreamer {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_MCSymbolizer {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_MCTargetAsmParser {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_MCTargetStreamer {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_mca_CustomBehaviour {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_mca_InstrPostProcess {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_mca_InstrumentManager {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_mca_SourceMgr {
    _unused: [u8; 0],
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm18createNullStreamerERNS_9MCContextE"]
    pub fn llvm_createNullStreamer(Ctx: *mut llvm_MCContext) -> *mut llvm_MCStreamer;
}
extern "C" {
    #[doc = " Create a machine code streamer which will print out assembly for the native\n target, suitable for compiling with a native assembler.\n\n \\param InstPrint - If given, the instruction printer to use. If not given\n the MCInst representation will be printed.  This method takes ownership of\n InstPrint.\n\n \\param CE - If given, a code emitter to use to show the instruction\n encoding inline with the assembly. This method takes ownership of \\p CE.\n\n \\param TAB - If given, a target asm backend to use to show the fixup\n information in conjunction with encoding information. This method takes\n ownership of \\p TAB.\n\n \\param ShowInst - Whether to show the MCInst representation inline with\n the assembly."]
    #[link_name = "\u{1}_ZN4llvm17createAsmStreamerERNS_9MCContextESt10unique_ptrINS_21formatted_raw_ostreamESt14default_deleteIS3_EEPNS_13MCInstPrinterEOS2_INS_13MCCodeEmitterES4_IS9_EEOS2_INS_12MCAsmBackendES4_ISD_EE"]
    pub fn llvm_createAsmStreamer(
        Ctx: *mut llvm_MCContext,
        OS: std_unique_ptr,
        InstPrint: *mut llvm_MCInstPrinter,
        CE: *mut std_unique_ptr,
        TAB: *mut std_unique_ptr,
    ) -> *mut llvm_MCStreamer;
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm17createELFStreamerERNS_9MCContextEOSt10unique_ptrINS_12MCAsmBackendESt14default_deleteIS3_EEOS2_INS_14MCObjectWriterES4_IS8_EEOS2_INS_13MCCodeEmitterES4_ISC_EE"]
    pub fn llvm_createELFStreamer(
        Ctx: *mut llvm_MCContext,
        TAB: *mut std_unique_ptr,
        OW: *mut std_unique_ptr,
        CE: *mut std_unique_ptr,
    ) -> *mut llvm_MCStreamer;
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm18createGOFFStreamerERNS_9MCContextEOSt10unique_ptrINS_12MCAsmBackendESt14default_deleteIS3_EEOS2_INS_14MCObjectWriterES4_IS8_EEOS2_INS_13MCCodeEmitterES4_ISC_EE"]
    pub fn llvm_createGOFFStreamer(
        Ctx: *mut llvm_MCContext,
        TAB: *mut std_unique_ptr,
        OW: *mut std_unique_ptr,
        CE: *mut std_unique_ptr,
    ) -> *mut llvm_MCStreamer;
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm19createMachOStreamerERNS_9MCContextEOSt10unique_ptrINS_12MCAsmBackendESt14default_deleteIS3_EEOS2_INS_14MCObjectWriterES4_IS8_EEOS2_INS_13MCCodeEmitterES4_ISC_EEbb"]
    pub fn llvm_createMachOStreamer(
        Ctx: *mut llvm_MCContext,
        TAB: *mut std_unique_ptr,
        OW: *mut std_unique_ptr,
        CE: *mut std_unique_ptr,
        DWARFMustBeAtTheEnd: bool,
        LabelSections: bool,
    ) -> *mut llvm_MCStreamer;
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm18createWasmStreamerERNS_9MCContextEOSt10unique_ptrINS_12MCAsmBackendESt14default_deleteIS3_EEOS2_INS_14MCObjectWriterES4_IS8_EEOS2_INS_13MCCodeEmitterES4_ISC_EE"]
    pub fn llvm_createWasmStreamer(
        Ctx: *mut llvm_MCContext,
        TAB: *mut std_unique_ptr,
        OW: *mut std_unique_ptr,
        CE: *mut std_unique_ptr,
    ) -> *mut llvm_MCStreamer;
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm19createSPIRVStreamerERNS_9MCContextEOSt10unique_ptrINS_12MCAsmBackendESt14default_deleteIS3_EEOS2_INS_14MCObjectWriterES4_IS8_EEOS2_INS_13MCCodeEmitterES4_ISC_EE"]
    pub fn llvm_createSPIRVStreamer(
        Ctx: *mut llvm_MCContext,
        TAB: *mut std_unique_ptr,
        OW: *mut std_unique_ptr,
        CE: *mut std_unique_ptr,
    ) -> *mut llvm_MCStreamer;
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm25createDXContainerStreamerERNS_9MCContextEOSt10unique_ptrINS_12MCAsmBackendESt14default_deleteIS3_EEOS2_INS_14MCObjectWriterES4_IS8_EEOS2_INS_13MCCodeEmitterES4_ISC_EE"]
    pub fn llvm_createDXContainerStreamer(
        Ctx: *mut llvm_MCContext,
        TAB: *mut std_unique_ptr,
        OW: *mut std_unique_ptr,
        CE: *mut std_unique_ptr,
    ) -> *mut llvm_MCStreamer;
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm22createMCRelocationInfoERKNS_6TripleERNS_9MCContextE"]
    pub fn llvm_createMCRelocationInfo(
        TT: *const llvm_Triple,
        Ctx: *mut llvm_MCContext,
    ) -> *mut llvm_MCRelocationInfo;
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm18createMCSymbolizerERKNS_6TripleEPFiPvmmmmiS3_EPFPKcS3_mPmmPS7_ES3_PNS_9MCContextEOSt10unique_ptrINS_16MCRelocationInfoESt14default_deleteISF_EE"]
    pub fn llvm_createMCSymbolizer(
        TT: *const llvm_Triple,
        GetOpInfo: LLVMOpInfoCallback,
        SymbolLookUp: LLVMSymbolLookupCallback,
        DisInfo: *mut ::std::os::raw::c_void,
        Ctx: *mut llvm_MCContext,
        RelInfo: *mut std_unique_ptr,
    ) -> *mut llvm_MCSymbolizer;
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm21createCustomBehaviourERKNS_15MCSubtargetInfoERKNS_3mca9SourceMgrERKNS_11MCInstrInfoE"]
    pub fn llvm_createCustomBehaviour(
        STI: *const llvm_MCSubtargetInfo,
        SrcMgr: *const llvm_mca_SourceMgr,
        MCII: *const llvm_MCInstrInfo,
    ) -> *mut llvm_mca_CustomBehaviour;
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm22createInstrPostProcessERKNS_15MCSubtargetInfoERKNS_11MCInstrInfoE"]
    pub fn llvm_createInstrPostProcess(
        STI: *const llvm_MCSubtargetInfo,
        MCII: *const llvm_MCInstrInfo,
    ) -> *mut llvm_mca_InstrPostProcess;
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm23createInstrumentManagerERKNS_15MCSubtargetInfoERKNS_11MCInstrInfoE"]
    pub fn llvm_createInstrumentManager(
        STI: *const llvm_MCSubtargetInfo,
        MCII: *const llvm_MCInstrInfo,
    ) -> *mut llvm_mca_InstrumentManager;
}
#[doc = " Target - Wrapper for Target specific information.\n\n For registration purposes, this is a POD type so that targets can be\n registered without the use of static constructors.\n\n Targets should implement a single global instance of this class (which\n will be zero initialized), and pass that instance to the TargetRegistry as\n part of their initialization."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_Target {
    #[doc = " Next - The next registered target in the linked list, maintained by the\n TargetRegistry."]
    pub Next: *mut llvm_Target,
    #[doc = " The target function for checking if an architecture is supported."]
    pub ArchMatchFn: llvm_Target_ArchMatchFnTy,
    #[doc = " Name - The target name."]
    pub Name: *const ::std::os::raw::c_char,
    #[doc = " ShortDesc - A short description of the target."]
    pub ShortDesc: *const ::std::os::raw::c_char,
    #[doc = " BackendName - The name of the backend implementation. This must match the\n name of the 'def X : Target ...' in TableGen."]
    pub BackendName: *const ::std::os::raw::c_char,
    #[doc = " HasJIT - Whether this target supports the JIT."]
    pub HasJIT: bool,
    #[doc = " MCAsmInfoCtorFn - Constructor function for this target's MCAsmInfo, if\n registered."]
    pub MCAsmInfoCtorFn: llvm_Target_MCAsmInfoCtorFnTy,
    #[doc = " Constructor function for this target's MCObjectFileInfo, if registered."]
    pub MCObjectFileInfoCtorFn: llvm_Target_MCObjectFileInfoCtorFnTy,
    #[doc = " MCInstrInfoCtorFn - Constructor function for this target's MCInstrInfo,\n if registered."]
    pub MCInstrInfoCtorFn: llvm_Target_MCInstrInfoCtorFnTy,
    #[doc = " MCInstrAnalysisCtorFn - Constructor function for this target's\n MCInstrAnalysis, if registered."]
    pub MCInstrAnalysisCtorFn: llvm_Target_MCInstrAnalysisCtorFnTy,
    #[doc = " MCRegInfoCtorFn - Constructor function for this target's MCRegisterInfo,\n if registered."]
    pub MCRegInfoCtorFn: llvm_Target_MCRegInfoCtorFnTy,
    #[doc = " MCSubtargetInfoCtorFn - Constructor function for this target's\n MCSubtargetInfo, if registered."]
    pub MCSubtargetInfoCtorFn: llvm_Target_MCSubtargetInfoCtorFnTy,
    #[doc = " TargetMachineCtorFn - Construction function for this target's\n TargetMachine, if registered."]
    pub TargetMachineCtorFn: llvm_Target_TargetMachineCtorTy,
    #[doc = " MCAsmBackendCtorFn - Construction function for this target's\n MCAsmBackend, if registered."]
    pub MCAsmBackendCtorFn: llvm_Target_MCAsmBackendCtorTy,
    #[doc = " MCAsmParserCtorFn - Construction function for this target's\n MCTargetAsmParser, if registered."]
    pub MCAsmParserCtorFn: llvm_Target_MCAsmParserCtorTy,
    #[doc = " AsmPrinterCtorFn - Construction function for this target's AsmPrinter,\n if registered."]
    pub AsmPrinterCtorFn: llvm_Target_AsmPrinterCtorTy,
    #[doc = " MCDisassemblerCtorFn - Construction function for this target's\n MCDisassembler, if registered."]
    pub MCDisassemblerCtorFn: llvm_Target_MCDisassemblerCtorTy,
    #[doc = " MCInstPrinterCtorFn - Construction function for this target's\n MCInstPrinter, if registered."]
    pub MCInstPrinterCtorFn: llvm_Target_MCInstPrinterCtorTy,
    #[doc = " MCCodeEmitterCtorFn - Construction function for this target's\n CodeEmitter, if registered."]
    pub MCCodeEmitterCtorFn: llvm_Target_MCCodeEmitterCtorTy,
    pub COFFStreamerCtorFn: llvm_Target_COFFStreamerCtorTy,
    pub MachOStreamerCtorFn: llvm_Target_MachOStreamerCtorTy,
    pub ELFStreamerCtorFn: llvm_Target_ELFStreamerCtorTy,
    pub XCOFFStreamerCtorFn: llvm_Target_XCOFFStreamerCtorTy,
    #[doc = " Construction function for this target's null TargetStreamer, if\n registered (default = nullptr)."]
    pub NullTargetStreamerCtorFn: llvm_Target_NullTargetStreamerCtorTy,
    #[doc = " Construction function for this target's asm TargetStreamer, if\n registered (default = nullptr)."]
    pub AsmTargetStreamerCtorFn: llvm_Target_AsmTargetStreamerCtorTy,
    #[doc = " Construction function for this target's obj TargetStreamer, if\n registered (default = nullptr)."]
    pub ObjectTargetStreamerCtorFn: llvm_Target_ObjectTargetStreamerCtorTy,
    #[doc = " MCRelocationInfoCtorFn - Construction function for this target's\n MCRelocationInfo, if registered (default = llvm::createMCRelocationInfo)"]
    pub MCRelocationInfoCtorFn: llvm_Target_MCRelocationInfoCtorTy,
    #[doc = " MCSymbolizerCtorFn - Construction function for this target's\n MCSymbolizer, if registered (default = llvm::createMCSymbolizer)"]
    pub MCSymbolizerCtorFn: llvm_Target_MCSymbolizerCtorTy,
    #[doc = " CustomBehaviourCtorFn - Construction function for this target's\n CustomBehaviour, if registered (default = nullptr)."]
    pub CustomBehaviourCtorFn: llvm_Target_CustomBehaviourCtorTy,
    #[doc = " InstrPostProcessCtorFn - Construction function for this target's\n InstrPostProcess, if registered (default = nullptr)."]
    pub InstrPostProcessCtorFn: llvm_Target_InstrPostProcessCtorTy,
    #[doc = " InstrumentManagerCtorFn - Construction function for this target's\n InstrumentManager, if registered (default = nullptr)."]
    pub InstrumentManagerCtorFn: llvm_Target_InstrumentManagerCtorTy,
}
pub type llvm_Target_ArchMatchFnTy =
    ::std::option::Option<unsafe extern "C" fn(Arch: llvm_Triple_ArchType) -> bool>;
pub type llvm_Target_MCAsmInfoCtorFnTy = ::std::option::Option<
    unsafe extern "C" fn(
        MRI: *const llvm_MCRegisterInfo,
        TT: *const llvm_Triple,
        Options: *const llvm_MCTargetOptions,
    ) -> *mut llvm_MCAsmInfo,
>;
pub type llvm_Target_MCObjectFileInfoCtorFnTy = ::std::option::Option<
    unsafe extern "C" fn(
        Ctx: *mut llvm_MCContext,
        PIC: bool,
        LargeCodeModel: bool,
    ) -> *mut llvm_MCObjectFileInfo,
>;
pub type llvm_Target_MCInstrInfoCtorFnTy =
    ::std::option::Option<unsafe extern "C" fn() -> *mut llvm_MCInstrInfo>;
pub type llvm_Target_MCInstrAnalysisCtorFnTy = ::std::option::Option<
    unsafe extern "C" fn(Info: *const llvm_MCInstrInfo) -> *mut llvm_MCInstrAnalysis,
>;
pub type llvm_Target_MCRegInfoCtorFnTy =
    ::std::option::Option<unsafe extern "C" fn(TT: *const llvm_Triple) -> *mut llvm_MCRegisterInfo>;
pub type llvm_Target_MCSubtargetInfoCtorFnTy = ::std::option::Option<
    unsafe extern "C" fn(
        TT: *const llvm_Triple,
        CPU: llvm_StringRef,
        Features: llvm_StringRef,
    ) -> *mut llvm_MCSubtargetInfo,
>;
pub type llvm_Target_TargetMachineCtorTy = ::std::option::Option<
    unsafe extern "C" fn(
        T: *const llvm_Target,
        TT: *const llvm_Triple,
        CPU: llvm_StringRef,
        Features: llvm_StringRef,
        Options: *const llvm_TargetOptions,
        RM: std_optional,
        CM: std_optional,
        OL: llvm_CodeGenOptLevel,
        JIT: bool,
    ) -> *mut llvm_TargetMachine,
>;
pub type llvm_Target_AsmPrinterCtorTy = ::std::option::Option<
    unsafe extern "C" fn(
        TM: *mut llvm_TargetMachine,
        Streamer: *mut std_unique_ptr,
    ) -> *mut llvm_AsmPrinter,
>;
pub type llvm_Target_MCAsmBackendCtorTy = ::std::option::Option<
    unsafe extern "C" fn(
        T: *const llvm_Target,
        STI: *const llvm_MCSubtargetInfo,
        MRI: *const llvm_MCRegisterInfo,
        Options: *const llvm_MCTargetOptions,
    ) -> *mut llvm_MCAsmBackend,
>;
pub type llvm_Target_MCAsmParserCtorTy = ::std::option::Option<
    unsafe extern "C" fn(
        STI: *const llvm_MCSubtargetInfo,
        P: *mut llvm_MCAsmParser,
        MII: *const llvm_MCInstrInfo,
        Options: *const llvm_MCTargetOptions,
    ) -> *mut llvm_MCTargetAsmParser,
>;
pub type llvm_Target_MCDisassemblerCtorTy = ::std::option::Option<
    unsafe extern "C" fn(
        T: *const llvm_Target,
        STI: *const llvm_MCSubtargetInfo,
        Ctx: *mut llvm_MCContext,
    ) -> *mut llvm_MCDisassembler,
>;
pub type llvm_Target_MCInstPrinterCtorTy = ::std::option::Option<
    unsafe extern "C" fn(
        T: *const llvm_Triple,
        SyntaxVariant: ::std::os::raw::c_uint,
        MAI: *const llvm_MCAsmInfo,
        MII: *const llvm_MCInstrInfo,
        MRI: *const llvm_MCRegisterInfo,
    ) -> *mut llvm_MCInstPrinter,
>;
pub type llvm_Target_MCCodeEmitterCtorTy = ::std::option::Option<
    unsafe extern "C" fn(
        II: *const llvm_MCInstrInfo,
        Ctx: *mut llvm_MCContext,
    ) -> *mut llvm_MCCodeEmitter,
>;
pub type llvm_Target_ELFStreamerCtorTy = ::std::option::Option<
    unsafe extern "C" fn(
        T: *const llvm_Triple,
        Ctx: *mut llvm_MCContext,
        TAB: *mut std_unique_ptr,
        OW: *mut std_unique_ptr,
        Emitter: *mut std_unique_ptr,
    ) -> *mut llvm_MCStreamer,
>;
pub type llvm_Target_MachOStreamerCtorTy = ::std::option::Option<
    unsafe extern "C" fn(
        Ctx: *mut llvm_MCContext,
        TAB: *mut std_unique_ptr,
        OW: *mut std_unique_ptr,
        Emitter: *mut std_unique_ptr,
    ) -> *mut llvm_MCStreamer,
>;
pub type llvm_Target_COFFStreamerCtorTy = ::std::option::Option<
    unsafe extern "C" fn(
        Ctx: *mut llvm_MCContext,
        TAB: *mut std_unique_ptr,
        OW: *mut std_unique_ptr,
        Emitter: *mut std_unique_ptr,
    ) -> *mut llvm_MCStreamer,
>;
pub type llvm_Target_XCOFFStreamerCtorTy = ::std::option::Option<
    unsafe extern "C" fn(
        T: *const llvm_Triple,
        Ctx: *mut llvm_MCContext,
        TAB: *mut std_unique_ptr,
        OW: *mut std_unique_ptr,
        Emitter: *mut std_unique_ptr,
    ) -> *mut llvm_MCStreamer,
>;
pub type llvm_Target_NullTargetStreamerCtorTy = ::std::option::Option<
    unsafe extern "C" fn(S: *mut llvm_MCStreamer) -> *mut llvm_MCTargetStreamer,
>;
pub type llvm_Target_AsmTargetStreamerCtorTy = ::std::option::Option<
    unsafe extern "C" fn(
        S: *mut llvm_MCStreamer,
        OS: *mut llvm_formatted_raw_ostream,
        InstPrint: *mut llvm_MCInstPrinter,
    ) -> *mut llvm_MCTargetStreamer,
>;
pub type llvm_Target_ObjectTargetStreamerCtorTy = ::std::option::Option<
    unsafe extern "C" fn(
        S: *mut llvm_MCStreamer,
        STI: *const llvm_MCSubtargetInfo,
    ) -> *mut llvm_MCTargetStreamer,
>;
pub type llvm_Target_MCRelocationInfoCtorTy = ::std::option::Option<
    unsafe extern "C" fn(
        TT: *const llvm_Triple,
        Ctx: *mut llvm_MCContext,
    ) -> *mut llvm_MCRelocationInfo,
>;
pub type llvm_Target_MCSymbolizerCtorTy = ::std::option::Option<
    unsafe extern "C" fn(
        TT: *const llvm_Triple,
        GetOpInfo: LLVMOpInfoCallback,
        SymbolLookUp: LLVMSymbolLookupCallback,
        DisInfo: *mut ::std::os::raw::c_void,
        Ctx: *mut llvm_MCContext,
        RelInfo: *mut std_unique_ptr,
    ) -> *mut llvm_MCSymbolizer,
>;
pub type llvm_Target_CustomBehaviourCtorTy = ::std::option::Option<
    unsafe extern "C" fn(
        STI: *const llvm_MCSubtargetInfo,
        SrcMgr: *const llvm_mca_SourceMgr,
        MCII: *const llvm_MCInstrInfo,
    ) -> *mut llvm_mca_CustomBehaviour,
>;
pub type llvm_Target_InstrPostProcessCtorTy = ::std::option::Option<
    unsafe extern "C" fn(
        STI: *const llvm_MCSubtargetInfo,
        MCII: *const llvm_MCInstrInfo,
    ) -> *mut llvm_mca_InstrPostProcess,
>;
pub type llvm_Target_InstrumentManagerCtorTy = ::std::option::Option<
    unsafe extern "C" fn(
        STI: *const llvm_MCSubtargetInfo,
        MCII: *const llvm_MCInstrInfo,
    ) -> *mut llvm_mca_InstrumentManager,
>;
#[test]
fn bindgen_test_layout_llvm_Target() {
    const UNINIT: ::std::mem::MaybeUninit<llvm_Target> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<llvm_Target>(),
        248usize,
        concat!("Size of: ", stringify!(llvm_Target))
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_Target>(),
        8usize,
        concat!("Alignment of ", stringify!(llvm_Target))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Next) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_Target),
            "::",
            stringify!(Next)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ArchMatchFn) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_Target),
            "::",
            stringify!(ArchMatchFn)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Name) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_Target),
            "::",
            stringify!(Name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ShortDesc) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_Target),
            "::",
            stringify!(ShortDesc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).BackendName) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_Target),
            "::",
            stringify!(BackendName)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).HasJIT) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_Target),
            "::",
            stringify!(HasJIT)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).MCAsmInfoCtorFn) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_Target),
            "::",
            stringify!(MCAsmInfoCtorFn)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).MCObjectFileInfoCtorFn) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_Target),
            "::",
            stringify!(MCObjectFileInfoCtorFn)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).MCInstrInfoCtorFn) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_Target),
            "::",
            stringify!(MCInstrInfoCtorFn)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).MCInstrAnalysisCtorFn) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_Target),
            "::",
            stringify!(MCInstrAnalysisCtorFn)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).MCRegInfoCtorFn) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_Target),
            "::",
            stringify!(MCRegInfoCtorFn)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).MCSubtargetInfoCtorFn) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_Target),
            "::",
            stringify!(MCSubtargetInfoCtorFn)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).TargetMachineCtorFn) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_Target),
            "::",
            stringify!(TargetMachineCtorFn)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).MCAsmBackendCtorFn) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_Target),
            "::",
            stringify!(MCAsmBackendCtorFn)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).MCAsmParserCtorFn) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_Target),
            "::",
            stringify!(MCAsmParserCtorFn)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).AsmPrinterCtorFn) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_Target),
            "::",
            stringify!(AsmPrinterCtorFn)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).MCDisassemblerCtorFn) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_Target),
            "::",
            stringify!(MCDisassemblerCtorFn)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).MCInstPrinterCtorFn) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_Target),
            "::",
            stringify!(MCInstPrinterCtorFn)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).MCCodeEmitterCtorFn) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_Target),
            "::",
            stringify!(MCCodeEmitterCtorFn)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).COFFStreamerCtorFn) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_Target),
            "::",
            stringify!(COFFStreamerCtorFn)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).MachOStreamerCtorFn) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_Target),
            "::",
            stringify!(MachOStreamerCtorFn)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ELFStreamerCtorFn) as usize - ptr as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_Target),
            "::",
            stringify!(ELFStreamerCtorFn)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).XCOFFStreamerCtorFn) as usize - ptr as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_Target),
            "::",
            stringify!(XCOFFStreamerCtorFn)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).NullTargetStreamerCtorFn) as usize - ptr as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_Target),
            "::",
            stringify!(NullTargetStreamerCtorFn)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).AsmTargetStreamerCtorFn) as usize - ptr as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_Target),
            "::",
            stringify!(AsmTargetStreamerCtorFn)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ObjectTargetStreamerCtorFn) as usize - ptr as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_Target),
            "::",
            stringify!(ObjectTargetStreamerCtorFn)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).MCRelocationInfoCtorFn) as usize - ptr as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_Target),
            "::",
            stringify!(MCRelocationInfoCtorFn)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).MCSymbolizerCtorFn) as usize - ptr as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_Target),
            "::",
            stringify!(MCSymbolizerCtorFn)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).CustomBehaviourCtorFn) as usize - ptr as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_Target),
            "::",
            stringify!(CustomBehaviourCtorFn)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).InstrPostProcessCtorFn) as usize - ptr as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_Target),
            "::",
            stringify!(InstrPostProcessCtorFn)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).InstrumentManagerCtorFn) as usize - ptr as usize },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_Target),
            "::",
            stringify!(InstrumentManagerCtorFn)
        )
    );
}
extern "C" {
    #[doc = " Create a target specific MCStreamer.\n\n \\param T The target triple.\n \\param Ctx The target context.\n \\param TAB The target assembler backend object. Takes ownership.\n \\param OW The stream object.\n \\param Emitter The target independent assembler object.Takes ownership."]
    #[link_name = "\u{1}_ZNK4llvm6Target22createMCObjectStreamerERKNS_6TripleERNS_9MCContextESt10unique_ptrINS_12MCAsmBackendESt14default_deleteIS7_EES6_INS_14MCObjectWriterES8_ISB_EES6_INS_13MCCodeEmitterES8_ISE_EERKNS_15MCSubtargetInfoE"]
    pub fn llvm_Target_createMCObjectStreamer(
        this: *const llvm_Target,
        T: *const llvm_Triple,
        Ctx: *mut llvm_MCContext,
        TAB: std_unique_ptr,
        OW: std_unique_ptr,
        Emitter: std_unique_ptr,
        STI: *const llvm_MCSubtargetInfo,
    ) -> *mut llvm_MCStreamer;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4llvm6Target22createMCObjectStreamerERKNS_6TripleERNS_9MCContextEOSt10unique_ptrINS_12MCAsmBackendESt14default_deleteIS7_EEOS6_INS_14MCObjectWriterES8_ISC_EEOS6_INS_13MCCodeEmitterES8_ISG_EERKNS_15MCSubtargetInfoEbbb"]
    pub fn llvm_Target_createMCObjectStreamer1(
        this: *const llvm_Target,
        T: *const llvm_Triple,
        Ctx: *mut llvm_MCContext,
        TAB: *mut std_unique_ptr,
        OW: *mut std_unique_ptr,
        Emitter: *mut std_unique_ptr,
        STI: *const llvm_MCSubtargetInfo,
        arg1: bool,
        arg2: bool,
        arg3: bool,
    ) -> *mut llvm_MCStreamer;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4llvm6Target17createAsmStreamerERNS_9MCContextESt10unique_ptrINS_21formatted_raw_ostreamESt14default_deleteIS4_EEPNS_13MCInstPrinterES3_INS_13MCCodeEmitterES5_ISA_EES3_INS_12MCAsmBackendES5_ISD_EE"]
    pub fn llvm_Target_createAsmStreamer(
        this: *const llvm_Target,
        Ctx: *mut llvm_MCContext,
        OS: std_unique_ptr,
        IP: *mut llvm_MCInstPrinter,
        CE: std_unique_ptr,
        TAB: std_unique_ptr,
    ) -> *mut llvm_MCStreamer;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4llvm6Target17createAsmStreamerERNS_9MCContextESt10unique_ptrINS_21formatted_raw_ostreamESt14default_deleteIS4_EEbbPNS_13MCInstPrinterEOS3_INS_13MCCodeEmitterES5_ISA_EEOS3_INS_12MCAsmBackendES5_ISE_EEb"]
    pub fn llvm_Target_createAsmStreamer1(
        this: *const llvm_Target,
        Ctx: *mut llvm_MCContext,
        OS: std_unique_ptr,
        IsVerboseAsm: bool,
        UseDwarfDirectory: bool,
        IP: *mut llvm_MCInstPrinter,
        CE: *mut std_unique_ptr,
        TAB: *mut std_unique_ptr,
        ShowInst: bool,
    ) -> *mut llvm_MCStreamer;
}
impl llvm_Target {
    #[inline]
    pub unsafe fn createMCObjectStreamer(
        &self,
        T: *const llvm_Triple,
        Ctx: *mut llvm_MCContext,
        TAB: std_unique_ptr,
        OW: std_unique_ptr,
        Emitter: std_unique_ptr,
        STI: *const llvm_MCSubtargetInfo,
    ) -> *mut llvm_MCStreamer {
        llvm_Target_createMCObjectStreamer(self, T, Ctx, TAB, OW, Emitter, STI)
    }
    #[inline]
    pub unsafe fn createMCObjectStreamer1(
        &self,
        T: *const llvm_Triple,
        Ctx: *mut llvm_MCContext,
        TAB: *mut std_unique_ptr,
        OW: *mut std_unique_ptr,
        Emitter: *mut std_unique_ptr,
        STI: *const llvm_MCSubtargetInfo,
        arg1: bool,
        arg2: bool,
        arg3: bool,
    ) -> *mut llvm_MCStreamer {
        llvm_Target_createMCObjectStreamer1(self, T, Ctx, TAB, OW, Emitter, STI, arg1, arg2, arg3)
    }
    #[inline]
    pub unsafe fn createAsmStreamer(
        &self,
        Ctx: *mut llvm_MCContext,
        OS: std_unique_ptr,
        IP: *mut llvm_MCInstPrinter,
        CE: std_unique_ptr,
        TAB: std_unique_ptr,
    ) -> *mut llvm_MCStreamer {
        llvm_Target_createAsmStreamer(self, Ctx, OS, IP, CE, TAB)
    }
    #[inline]
    pub unsafe fn createAsmStreamer1(
        &self,
        Ctx: *mut llvm_MCContext,
        OS: std_unique_ptr,
        IsVerboseAsm: bool,
        UseDwarfDirectory: bool,
        IP: *mut llvm_MCInstPrinter,
        CE: *mut std_unique_ptr,
        TAB: *mut std_unique_ptr,
        ShowInst: bool,
    ) -> *mut llvm_MCStreamer {
        llvm_Target_createAsmStreamer1(
            self,
            Ctx,
            OS,
            IsVerboseAsm,
            UseDwarfDirectory,
            IP,
            CE,
            TAB,
            ShowInst,
        )
    }
}
#[doc = " TargetRegistry - Generic interface to target specific features."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_TargetRegistry {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_TargetRegistry_iterator {
    pub Current: *const llvm_Target,
}
pub type llvm_TargetRegistry_iterator_iterator_category = std_forward_iterator_tag;
#[doc = " Target - Wrapper for Target specific information.\n\n For registration purposes, this is a POD type so that targets can be\n registered without the use of static constructors.\n\n Targets should implement a single global instance of this class (which\n will be zero initialized), and pass that instance to the TargetRegistry as\n part of their initialization."]
pub type llvm_TargetRegistry_iterator_value_type = llvm_Target;
pub type llvm_TargetRegistry_iterator_difference_type = isize;
pub type llvm_TargetRegistry_iterator_pointer = *mut llvm_TargetRegistry_iterator_value_type;
pub type llvm_TargetRegistry_iterator_reference = *mut llvm_TargetRegistry_iterator_value_type;
#[test]
fn bindgen_test_layout_llvm_TargetRegistry_iterator() {
    const UNINIT: ::std::mem::MaybeUninit<llvm_TargetRegistry_iterator> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<llvm_TargetRegistry_iterator>(),
        8usize,
        concat!("Size of: ", stringify!(llvm_TargetRegistry_iterator))
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_TargetRegistry_iterator>(),
        8usize,
        concat!("Alignment of ", stringify!(llvm_TargetRegistry_iterator))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Current) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_TargetRegistry_iterator),
            "::",
            stringify!(Current)
        )
    );
}
#[test]
fn bindgen_test_layout_llvm_TargetRegistry() {
    assert_eq!(
        ::std::mem::size_of::<llvm_TargetRegistry>(),
        1usize,
        concat!("Size of: ", stringify!(llvm_TargetRegistry))
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_TargetRegistry>(),
        1usize,
        concat!("Alignment of ", stringify!(llvm_TargetRegistry))
    );
}
extern "C" {
    #[doc = " printRegisteredTargetsForVersion - Print the registered targets\n appropriately for inclusion in a tool's version output."]
    #[link_name = "\u{1}_ZN4llvm14TargetRegistry32printRegisteredTargetsForVersionERNS_11raw_ostreamE"]
    pub fn llvm_TargetRegistry_printRegisteredTargetsForVersion(OS: *mut llvm_raw_ostream);
}
extern "C" {
    #[doc = " @name Registry Access\n @{"]
    #[link_name = "\u{1}_ZN4llvm14TargetRegistry7targetsEv"]
    pub fn llvm_TargetRegistry_targets() -> llvm_iterator_range<llvm_TargetRegistry_iterator>;
}
extern "C" {
    #[doc = " lookupTarget - Lookup a target based on a target triple.\n\n \\param Triple - The triple to use for finding a target.\n \\param Error - On failure, an error string describing why no target was\n found."]
    #[link_name = "\u{1}_ZN4llvm14TargetRegistry12lookupTargetENS_9StringRefERNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE"]
    pub fn llvm_TargetRegistry_lookupTarget(
        Triple: llvm_StringRef,
        Error: *mut std_string,
    ) -> *const llvm_Target;
}
extern "C" {
    #[doc = " lookupTarget - Lookup a target based on an architecture name\n and a target triple.  If the architecture name is non-empty,\n then the lookup is done by architecture.  Otherwise, the target\n triple is used.\n\n \\param ArchName - The architecture to use for finding a target.\n \\param TheTriple - The triple to use for finding a target.  The\n triple is updated with canonical architecture name if a lookup\n by architecture is done.\n \\param Error - On failure, an error string describing why no target was\n found."]
    #[link_name = "\u{1}_ZN4llvm14TargetRegistry12lookupTargetENS_9StringRefERNS_6TripleERNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE"]
    pub fn llvm_TargetRegistry_lookupTarget1(
        ArchName: llvm_StringRef,
        TheTriple: *mut llvm_Triple,
        Error: *mut std_string,
    ) -> *const llvm_Target;
}
extern "C" {
    #[doc = " RegisterTarget - Register the given target. Attempts to register a\n target which has already been registered will be ignored.\n\n Clients are responsible for ensuring that registration doesn't occur\n while another thread is attempting to access the registry. Typically\n this is done by initializing all targets at program startup.\n\n @param T - The target being registered.\n @param Name - The target name. This should be a static string.\n @param ShortDesc - A short target description. This should be a static\n string.\n @param BackendName - The name of the backend. This should be a static\n string that is the same for all targets that share a backend\n implementation and must match the name used in the 'def X : Target ...' in\n TableGen.\n @param ArchMatchFn - The arch match checking function for this target.\n @param HasJIT - Whether the target supports JIT code\n generation."]
    #[link_name = "\u{1}_ZN4llvm14TargetRegistry14RegisterTargetERNS_6TargetEPKcS4_S4_PFbNS_6Triple8ArchTypeEEb"]
    pub fn llvm_TargetRegistry_RegisterTarget(
        T: *mut llvm_Target,
        Name: *const ::std::os::raw::c_char,
        ShortDesc: *const ::std::os::raw::c_char,
        BackendName: *const ::std::os::raw::c_char,
        ArchMatchFn: llvm_Target_ArchMatchFnTy,
        HasJIT: bool,
    );
}
impl llvm_TargetRegistry {
    #[inline]
    pub unsafe fn printRegisteredTargetsForVersion(OS: *mut llvm_raw_ostream) {
        llvm_TargetRegistry_printRegisteredTargetsForVersion(OS)
    }
    #[inline]
    pub unsafe fn targets() -> llvm_iterator_range<llvm_TargetRegistry_iterator> {
        llvm_TargetRegistry_targets()
    }
    #[inline]
    pub unsafe fn lookupTarget(
        Triple: llvm_StringRef,
        Error: *mut std_string,
    ) -> *const llvm_Target {
        llvm_TargetRegistry_lookupTarget(Triple, Error)
    }
    #[inline]
    pub unsafe fn lookupTarget1(
        ArchName: llvm_StringRef,
        TheTriple: *mut llvm_Triple,
        Error: *mut std_string,
    ) -> *const llvm_Target {
        llvm_TargetRegistry_lookupTarget1(ArchName, TheTriple, Error)
    }
    #[inline]
    pub unsafe fn RegisterTarget(
        T: *mut llvm_Target,
        Name: *const ::std::os::raw::c_char,
        ShortDesc: *const ::std::os::raw::c_char,
        BackendName: *const ::std::os::raw::c_char,
        ArchMatchFn: llvm_Target_ArchMatchFnTy,
        HasJIT: bool,
    ) {
        llvm_TargetRegistry_RegisterTarget(T, Name, ShortDesc, BackendName, ArchMatchFn, HasJIT)
    }
}
#[doc = " RegisterMCAsmInfo - Helper template for registering a target assembly info\n implementation.  This invokes the static \"Create\" method on the class to\n actually do the construction.  Usage:\n\n extern \"C\" void LLVMInitializeFooTarget() {\n   extern Target TheFooTarget;\n   RegisterMCAsmInfo<FooMCAsmInfo> X(TheFooTarget);\n }"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_RegisterMCAsmInfo {
    pub _address: u8,
}
#[doc = " RegisterMCAsmInfoFn - Helper template for registering a target assembly info\n implementation.  This invokes the specified function to do the\n construction.  Usage:\n\n extern \"C\" void LLVMInitializeFooTarget() {\n   extern Target TheFooTarget;\n   RegisterMCAsmInfoFn X(TheFooTarget, TheFunction);\n }"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_RegisterMCAsmInfoFn {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_llvm_RegisterMCAsmInfoFn() {
    assert_eq!(
        ::std::mem::size_of::<llvm_RegisterMCAsmInfoFn>(),
        1usize,
        concat!("Size of: ", stringify!(llvm_RegisterMCAsmInfoFn))
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_RegisterMCAsmInfoFn>(),
        1usize,
        concat!("Alignment of ", stringify!(llvm_RegisterMCAsmInfoFn))
    );
}
#[doc = " Helper template for registering a target object file info implementation.\n This invokes the static \"Create\" method on the class to actually do the\n construction.  Usage:\n\n extern \"C\" void LLVMInitializeFooTarget() {\n   extern Target TheFooTarget;\n   RegisterMCObjectFileInfo<FooMCObjectFileInfo> X(TheFooTarget);\n }"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_RegisterMCObjectFileInfo {
    pub _address: u8,
}
#[doc = " Helper template for registering a target object file info implementation.\n This invokes the specified function to do the construction.  Usage:\n\n extern \"C\" void LLVMInitializeFooTarget() {\n   extern Target TheFooTarget;\n   RegisterMCObjectFileInfoFn X(TheFooTarget, TheFunction);\n }"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_RegisterMCObjectFileInfoFn {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_llvm_RegisterMCObjectFileInfoFn() {
    assert_eq!(
        ::std::mem::size_of::<llvm_RegisterMCObjectFileInfoFn>(),
        1usize,
        concat!("Size of: ", stringify!(llvm_RegisterMCObjectFileInfoFn))
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_RegisterMCObjectFileInfoFn>(),
        1usize,
        concat!("Alignment of ", stringify!(llvm_RegisterMCObjectFileInfoFn))
    );
}
#[doc = " RegisterMCInstrInfo - Helper template for registering a target instruction\n info implementation.  This invokes the static \"Create\" method on the class\n to actually do the construction.  Usage:\n\n extern \"C\" void LLVMInitializeFooTarget() {\n   extern Target TheFooTarget;\n   RegisterMCInstrInfo<FooMCInstrInfo> X(TheFooTarget);\n }"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_RegisterMCInstrInfo {
    pub _address: u8,
}
#[doc = " RegisterMCInstrInfoFn - Helper template for registering a target\n instruction info implementation.  This invokes the specified function to\n do the construction.  Usage:\n\n extern \"C\" void LLVMInitializeFooTarget() {\n   extern Target TheFooTarget;\n   RegisterMCInstrInfoFn X(TheFooTarget, TheFunction);\n }"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_RegisterMCInstrInfoFn {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_llvm_RegisterMCInstrInfoFn() {
    assert_eq!(
        ::std::mem::size_of::<llvm_RegisterMCInstrInfoFn>(),
        1usize,
        concat!("Size of: ", stringify!(llvm_RegisterMCInstrInfoFn))
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_RegisterMCInstrInfoFn>(),
        1usize,
        concat!("Alignment of ", stringify!(llvm_RegisterMCInstrInfoFn))
    );
}
#[doc = " RegisterMCInstrAnalysis - Helper template for registering a target\n instruction analyzer implementation.  This invokes the static \"Create\"\n method on the class to actually do the construction.  Usage:\n\n extern \"C\" void LLVMInitializeFooTarget() {\n   extern Target TheFooTarget;\n   RegisterMCInstrAnalysis<FooMCInstrAnalysis> X(TheFooTarget);\n }"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_RegisterMCInstrAnalysis {
    pub _address: u8,
}
#[doc = " RegisterMCInstrAnalysisFn - Helper template for registering a target\n instruction analyzer implementation.  This invokes the specified function\n to do the construction.  Usage:\n\n extern \"C\" void LLVMInitializeFooTarget() {\n   extern Target TheFooTarget;\n   RegisterMCInstrAnalysisFn X(TheFooTarget, TheFunction);\n }"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_RegisterMCInstrAnalysisFn {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_llvm_RegisterMCInstrAnalysisFn() {
    assert_eq!(
        ::std::mem::size_of::<llvm_RegisterMCInstrAnalysisFn>(),
        1usize,
        concat!("Size of: ", stringify!(llvm_RegisterMCInstrAnalysisFn))
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_RegisterMCInstrAnalysisFn>(),
        1usize,
        concat!("Alignment of ", stringify!(llvm_RegisterMCInstrAnalysisFn))
    );
}
#[doc = " RegisterMCRegInfo - Helper template for registering a target register info\n implementation.  This invokes the static \"Create\" method on the class to\n actually do the construction.  Usage:\n\n extern \"C\" void LLVMInitializeFooTarget() {\n   extern Target TheFooTarget;\n   RegisterMCRegInfo<FooMCRegInfo> X(TheFooTarget);\n }"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_RegisterMCRegInfo {
    pub _address: u8,
}
#[doc = " RegisterMCRegInfoFn - Helper template for registering a target register\n info implementation.  This invokes the specified function to do the\n construction.  Usage:\n\n extern \"C\" void LLVMInitializeFooTarget() {\n   extern Target TheFooTarget;\n   RegisterMCRegInfoFn X(TheFooTarget, TheFunction);\n }"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_RegisterMCRegInfoFn {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_llvm_RegisterMCRegInfoFn() {
    assert_eq!(
        ::std::mem::size_of::<llvm_RegisterMCRegInfoFn>(),
        1usize,
        concat!("Size of: ", stringify!(llvm_RegisterMCRegInfoFn))
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_RegisterMCRegInfoFn>(),
        1usize,
        concat!("Alignment of ", stringify!(llvm_RegisterMCRegInfoFn))
    );
}
#[doc = " RegisterMCSubtargetInfo - Helper template for registering a target\n subtarget info implementation.  This invokes the static \"Create\" method\n on the class to actually do the construction.  Usage:\n\n extern \"C\" void LLVMInitializeFooTarget() {\n   extern Target TheFooTarget;\n   RegisterMCSubtargetInfo<FooMCSubtargetInfo> X(TheFooTarget);\n }"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_RegisterMCSubtargetInfo {
    pub _address: u8,
}
#[doc = " RegisterMCSubtargetInfoFn - Helper template for registering a target\n subtarget info implementation.  This invokes the specified function to\n do the construction.  Usage:\n\n extern \"C\" void LLVMInitializeFooTarget() {\n   extern Target TheFooTarget;\n   RegisterMCSubtargetInfoFn X(TheFooTarget, TheFunction);\n }"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_RegisterMCSubtargetInfoFn {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_llvm_RegisterMCSubtargetInfoFn() {
    assert_eq!(
        ::std::mem::size_of::<llvm_RegisterMCSubtargetInfoFn>(),
        1usize,
        concat!("Size of: ", stringify!(llvm_RegisterMCSubtargetInfoFn))
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_RegisterMCSubtargetInfoFn>(),
        1usize,
        concat!("Alignment of ", stringify!(llvm_RegisterMCSubtargetInfoFn))
    );
}
#[doc = " RegisterTargetMachine - Helper template for registering a target machine\n implementation, for use in the target machine initialization\n function. Usage:\n\n extern \"C\" void LLVMInitializeFooTarget() {\n   extern Target TheFooTarget;\n   RegisterTargetMachine<FooTargetMachine> X(TheFooTarget);\n }"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_RegisterTargetMachine {
    pub _address: u8,
}
#[doc = " RegisterMCAsmBackend - Helper template for registering a target specific\n assembler backend. Usage:\n\n extern \"C\" void LLVMInitializeFooMCAsmBackend() {\n   extern Target TheFooTarget;\n   RegisterMCAsmBackend<FooAsmLexer> X(TheFooTarget);\n }"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_RegisterMCAsmBackend {
    pub _address: u8,
}
#[doc = " RegisterMCAsmParser - Helper template for registering a target specific\n assembly parser, for use in the target machine initialization\n function. Usage:\n\n extern \"C\" void LLVMInitializeFooMCAsmParser() {\n   extern Target TheFooTarget;\n   RegisterMCAsmParser<FooAsmParser> X(TheFooTarget);\n }"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_RegisterMCAsmParser {
    pub _address: u8,
}
#[doc = " RegisterAsmPrinter - Helper template for registering a target specific\n assembly printer, for use in the target machine initialization\n function. Usage:\n\n extern \"C\" void LLVMInitializeFooAsmPrinter() {\n   extern Target TheFooTarget;\n   RegisterAsmPrinter<FooAsmPrinter> X(TheFooTarget);\n }"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_RegisterAsmPrinter {
    pub _address: u8,
}
#[doc = " RegisterMCCodeEmitter - Helper template for registering a target specific\n machine code emitter, for use in the target initialization\n function. Usage:\n\n extern \"C\" void LLVMInitializeFooMCCodeEmitter() {\n   extern Target TheFooTarget;\n   RegisterMCCodeEmitter<FooCodeEmitter> X(TheFooTarget);\n }"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_RegisterMCCodeEmitter {
    pub _address: u8,
}
#[doc = " TinyPtrVector - This class is specialized for cases where there are\n normally 0 or 1 element in a vector, but is general enough to go beyond that\n when required.\n\n NOTE: This container doesn't allow you to store a null pointer into it.\n"]
#[repr(C)]
#[derive(Debug)]
pub struct llvm_TinyPtrVector {
    pub Val: llvm_TinyPtrVector_PtrUnion,
}
#[doc = " Forward declaration of SmallVector so that\n calculateSmallVectorDefaultInlinedElements can reference\n `sizeof(SmallVector<T, 0>)`."]
pub type llvm_TinyPtrVector_VecTy = u8;
pub type llvm_TinyPtrVector_value_type = llvm_TinyPtrVector_VecTy;
#[doc = " A discriminated union of two or more pointer types, with the discriminator\n in the low bit of the pointer.\n\n This implementation is extremely efficient in space due to leveraging the\n low bits of the pointer, while exposing a natural and type-safe API.\n\n Common use patterns would be something like this:\n    PointerUnion<int*, float*> P;\n    P = (int*)0;\n    printf(\"%d %d\", P.is<int*>(), P.is<float*>());  // prints \"1 0\"\n    X = P.get<int*>();     // ok.\n    Y = P.get<float*>();   // runtime assertion failure.\n    Z = P.get<double*>();  // compile time failure.\n    P = (float*)0;\n    Y = P.get<float*>();   // ok.\n    X = P.get<int*>();     // runtime assertion failure.\n    PointerUnion<int*, int*> Q; // compile time failure."]
pub type llvm_TinyPtrVector_PtrUnion = llvm_PointerUnion;
pub type llvm_TinyPtrVector_iterator<EltTy> = *mut EltTy;
pub type llvm_TinyPtrVector_const_iterator<EltTy> = *const EltTy;
pub type llvm_TinyPtrVector_reverse_iterator<EltTy> =
    std_reverse_iterator<llvm_TinyPtrVector_iterator<EltTy>>;
pub type llvm_TinyPtrVector_const_reverse_iterator<EltTy> =
    std_reverse_iterator<llvm_TinyPtrVector_const_iterator<EltTy>>;
#[doc = " A special type used by analysis passes to provide an address that\n identifies that particular analysis pass type.\n\n Analysis passes should have a static data member of this type and derive\n from the \\c AnalysisInfoMixin to get a static ID method used to identify\n the analysis in the pass management infrastructure."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_AnalysisKey {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_llvm_AnalysisKey() {
    assert_eq!(
        ::std::mem::size_of::<llvm_AnalysisKey>(),
        8usize,
        concat!("Size of: ", stringify!(llvm_AnalysisKey))
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_AnalysisKey>(),
        8usize,
        concat!("Alignment of ", stringify!(llvm_AnalysisKey))
    );
}
#[doc = " A special type used to provide an address that identifies a set of related\n analyses.  These sets are primarily used below to mark sets of analyses as\n preserved.\n\n For example, a transformation can indicate that it preserves the CFG of a\n function by preserving the appropriate AnalysisSetKey.  An analysis that\n depends only on the CFG can then check if that AnalysisSetKey is preserved;\n if it is, the analysis knows that it itself is preserved."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_AnalysisSetKey {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_llvm_AnalysisSetKey() {
    assert_eq!(
        ::std::mem::size_of::<llvm_AnalysisSetKey>(),
        8usize,
        concat!("Size of: ", stringify!(llvm_AnalysisSetKey))
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_AnalysisSetKey>(),
        8usize,
        concat!("Alignment of ", stringify!(llvm_AnalysisSetKey))
    );
}
#[doc = " This templated class represents \"all analyses that operate over \\<a\n particular IR unit\\>\" (e.g. a Function or a Module) in instances of\n PreservedAnalysis.\n\n This lets a transformation say e.g. \"I preserved all function analyses\".\n\n Note that you must provide an explicit instantiation declaration and\n definition for this template in order to get the correct behavior on\n Windows. Otherwise, the address of SetKey will not be stable."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_AllAnalysesOn {
    pub _address: u8,
}
extern "C" {
    #[link_name = "\u{1}SetKey"]
    pub static mut llvm_SetKey: llvm_AnalysisSetKey;
}
#[test]
fn __bindgen_test_layout_llvm_AllAnalysesOn_open0_llvm_Module_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<llvm_AllAnalysesOn>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_AllAnalysesOn)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_AllAnalysesOn>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_AllAnalysesOn)
        )
    );
}
#[test]
fn __bindgen_test_layout_llvm_AllAnalysesOn_open0_llvm_Function_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<llvm_AllAnalysesOn>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_AllAnalysesOn)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_AllAnalysesOn>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_AllAnalysesOn)
        )
    );
}
#[doc = " Represents analyses that only rely on functions' control flow.\n\n This can be used with \\c PreservedAnalyses to mark the CFG as preserved and\n to query whether it has been preserved.\n\n The CFG of a function is defined as the set of basic blocks and the edges\n between them. Changing the set of basic blocks in a function is enough to\n mutate the CFG. Mutating the condition of a branch or argument of an\n invoked function does not mutate the CFG, but changing the successor labels\n of those instructions does."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_CFGAnalyses {
    pub _address: u8,
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm11CFGAnalyses6SetKeyE"]
    pub static mut llvm_CFGAnalyses_SetKey: llvm_AnalysisSetKey;
}
#[test]
fn bindgen_test_layout_llvm_CFGAnalyses() {
    assert_eq!(
        ::std::mem::size_of::<llvm_CFGAnalyses>(),
        1usize,
        concat!("Size of: ", stringify!(llvm_CFGAnalyses))
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_CFGAnalyses>(),
        1usize,
        concat!("Alignment of ", stringify!(llvm_CFGAnalyses))
    );
}
#[doc = " A set of analyses that are preserved following a run of a transformation\n pass.\n\n Transformation passes build and return these objects to communicate which\n analyses are still valid after the transformation. For most passes this is\n fairly simple: if they don't change anything all analyses are preserved,\n otherwise only a short list of analyses that have been explicitly updated\n are preserved.\n\n This class also lets transformation passes mark abstract *sets* of analyses\n as preserved. A transformation that (say) does not alter the CFG can\n indicate such by marking a particular AnalysisSetKey as preserved, and\n then analyses can query whether that AnalysisSetKey is preserved.\n\n Finally, this class can represent an \"abandoned\" analysis, which is\n not preserved even if it would be covered by some abstract set of analyses.\n\n Given a `PreservedAnalyses` object, an analysis will typically want to\n figure out whether it is preserved. In the example below, MyAnalysisType is\n preserved if it's not abandoned, and (a) it's explicitly marked as\n preserved, (b), the set AllAnalysesOn<MyIRUnit> is preserved, or (c) both\n AnalysisSetA and AnalysisSetB are preserved.\n\n ```\n   auto PAC = PA.getChecker<MyAnalysisType>();\n   if (PAC.preserved() || PAC.preservedSet<AllAnalysesOn<MyIRUnit>>() ||\n       (PAC.preservedSet<AnalysisSetA>() &&\n        PAC.preservedSet<AnalysisSetB>())) {\n     // The analysis has been successfully preserved ...\n   }\n ```"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_PreservedAnalyses {
    #[doc = " The IDs of analyses and analysis sets that are preserved."]
    pub PreservedIDs: [u64; 7usize],
    #[doc = " The IDs of explicitly not-preserved analyses.\n\n If an analysis in this set is covered by a set in `PreservedIDs`, we\n consider it not-preserved. That is, `NotPreservedAnalysisIDs` always\n \"wins\" over analysis sets in `PreservedIDs`.\n\n Also, a given ID should never occur both here and in `PreservedIDs`."]
    pub NotPreservedAnalysisIDs: [u64; 7usize],
}
#[doc = " A checker object that makes it easy to query for whether an analysis or\n some set covering it is preserved."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_PreservedAnalyses_PreservedAnalysisChecker {
    pub PA: *const llvm_PreservedAnalyses,
    pub ID: *mut llvm_AnalysisKey,
    pub IsAbandoned: bool,
}
#[test]
fn bindgen_test_layout_llvm_PreservedAnalyses_PreservedAnalysisChecker() {
    const UNINIT: ::std::mem::MaybeUninit<llvm_PreservedAnalyses_PreservedAnalysisChecker> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<llvm_PreservedAnalyses_PreservedAnalysisChecker>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(llvm_PreservedAnalyses_PreservedAnalysisChecker)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_PreservedAnalyses_PreservedAnalysisChecker>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(llvm_PreservedAnalyses_PreservedAnalysisChecker)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).PA) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_PreservedAnalyses_PreservedAnalysisChecker),
            "::",
            stringify!(PA)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ID) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_PreservedAnalyses_PreservedAnalysisChecker),
            "::",
            stringify!(ID)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).IsAbandoned) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_PreservedAnalyses_PreservedAnalysisChecker),
            "::",
            stringify!(IsAbandoned)
        )
    );
}
extern "C" {
    #[doc = " A special key used to indicate all analyses."]
    #[link_name = "\u{1}_ZN4llvm17PreservedAnalyses14AllAnalysesKeyE"]
    pub static mut llvm_PreservedAnalyses_AllAnalysesKey: llvm_AnalysisSetKey;
}
#[test]
fn bindgen_test_layout_llvm_PreservedAnalyses() {
    const UNINIT: ::std::mem::MaybeUninit<llvm_PreservedAnalyses> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<llvm_PreservedAnalyses>(),
        112usize,
        concat!("Size of: ", stringify!(llvm_PreservedAnalyses))
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_PreservedAnalyses>(),
        8usize,
        concat!("Alignment of ", stringify!(llvm_PreservedAnalyses))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).PreservedIDs) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_PreservedAnalyses),
            "::",
            stringify!(PreservedIDs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).NotPreservedAnalysisIDs) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_PreservedAnalyses),
            "::",
            stringify!(NotPreservedAnalysisIDs)
        )
    );
}
#[doc = " A CRTP mix-in to automatically provide informational APIs needed for\n passes.\n\n This provides some boilerplate for types that are passes."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_PassInfoMixin {
    pub _address: u8,
}
#[doc = " A CRTP mix-in that provides informational APIs needed for analysis passes.\n\n This provides some boilerplate for types that are analysis passes. It\n automatically mixes in \\c PassInfoMixin."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_AnalysisInfoMixin {
    pub _address: u8,
}
#[doc = " Manages a sequence of passes over a particular unit of IR.\n\n A pass manager contains a sequence of passes to run over a particular unit\n of IR (e.g. Functions, Modules). It is itself a valid pass over that unit of\n IR, and when run over some given IR will run each of its contained passes in\n sequence. Pass managers are the primary and most basic building block of a\n pass pipeline.\n\n When you run a pass manager, you provide an \\c AnalysisManager<IRUnitT>\n argument. The pass manager will propagate that analysis manager to each\n pass it runs, and will call the analysis manager's invalidation routine with\n the PreservedAnalyses of each pass it runs."]
#[repr(C)]
pub struct llvm_PassManager {
    pub Passes: std_vector,
}
#[doc = " Template for the abstract base class used to dispatch\n polymorphically over pass objects."]
pub type llvm_PassManager_PassConceptT = llvm_detail_PassConcept;
extern "C" {
    #[link_name = "\u{1}_ZN4llvm28printIRUnitNameForStackTraceINS_6ModuleEEEvRNS_11raw_ostreamERKT_"]
    pub fn llvm_printIRUnitNameForStackTrace(OS: *mut llvm_raw_ostream, IR: *const llvm_Module);
}
#[test]
fn __bindgen_test_layout_llvm_PassManager_open0_llvm_Module_llvm_AnalysisManager_open1_llvm_Module_close1_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<llvm_PassManager>(),
        24usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_PassManager)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_PassManager>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_PassManager)
        )
    );
}
#[doc = " Convenience typedef for a pass manager over modules."]
pub type llvm_ModulePassManager = llvm_PassManager;
extern "C" {
    #[link_name = "\u{1}_ZN4llvm28printIRUnitNameForStackTraceINS_8FunctionEEEvRNS_11raw_ostreamERKT_"]
    pub fn llvm_printIRUnitNameForStackTrace1(OS: *mut llvm_raw_ostream, IR: *const llvm_Function);
}
#[test]
fn __bindgen_test_layout_llvm_PassManager_open0_llvm_Function_llvm_AnalysisManager_open1_llvm_Function_close1_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<llvm_PassManager>(),
        24usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_PassManager)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_PassManager>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_PassManager)
        )
    );
}
#[doc = " Convenience typedef for a pass manager over functions."]
pub type llvm_FunctionPassManager = llvm_PassManager;
#[doc = " A container for analyses that lazily runs them and caches their\n results.\n\n This class can manage analyses for any IR unit where the address of the IR\n unit sufficies as its identity."]
#[repr(C)]
#[derive(Debug)]
pub struct llvm_AnalysisManager {
    #[doc = " Collection of analysis passes, indexed by ID."]
    pub AnalysisPasses: llvm_AnalysisManager_AnalysisPassMapT,
    #[doc = " Map from IR unit to a list of analysis results.\n\n Provides linear time removal of all analysis results for a IR unit and\n the ultimate storage for a particular cached analysis result."]
    pub AnalysisResultLists: llvm_AnalysisManager_AnalysisResultListMapT,
    #[doc = " Map from an analysis ID and IR unit to a particular cached\n analysis result."]
    pub AnalysisResults: llvm_AnalysisManager_AnalysisResultMapT,
}
#[doc = " Abstract concept of an analysis result.\n\n This concept is parameterized over the IR unit that this result pertains\n to."]
pub type llvm_AnalysisManager_ResultConceptT = llvm_detail_AnalysisResultConcept;
#[doc = " Abstract concept of an analysis pass.\n\n This concept is parameterized over the IR unit that it can run over and\n produce an analysis result."]
pub type llvm_AnalysisManager_PassConceptT = llvm_detail_AnalysisPassConcept;
#[doc = " List of analysis pass IDs and associated concept pointers.\n\n Requires iterators to be valid across appending new entries and arbitrary\n erases. Provides the analysis ID to enable finding iterators to a given\n entry in maps below, and provides the storage for the actual result\n concept."]
pub type llvm_AnalysisManager_AnalysisResultListT = std_list;
#[doc = " Map type from IRUnitT pointer to our custom list type."]
pub type llvm_AnalysisManager_AnalysisResultListMapT = llvm_DenseMap<BucketT>;
#[doc = " Map type from a pair of analysis ID and IRUnitT pointer to an\n iterator into a particular result list (which is where the actual analysis\n result is stored)."]
pub type llvm_AnalysisManager_AnalysisResultMapT = llvm_DenseMap<BucketT>;
#[doc = " API to communicate dependencies between analyses during invalidation.\n\n When an analysis result embeds handles to other analysis results, it\n needs to be invalidated both when its own information isn't preserved and\n when any of its embedded analysis results end up invalidated. We pass an\n \\c Invalidator object as an argument to \\c invalidate() in order to let\n the analysis results themselves define the dependency graph on the fly.\n This lets us avoid building an explicit representation of the\n dependencies between analysis results."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_AnalysisManager_Invalidator {
    pub IsResultInvalidated: *mut [u64; 18usize],
    pub Results: *const llvm_AnalysisManager_AnalysisResultMapT,
}
#[doc = " Map type from analysis pass ID to pass concept pointer."]
pub type llvm_AnalysisManager_AnalysisPassMapT = llvm_DenseMap<BucketT>;
#[test]
fn __bindgen_test_layout_llvm_AnalysisManager_open0_llvm_Module_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<llvm_AnalysisManager>(),
        96usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_AnalysisManager)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_AnalysisManager>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_AnalysisManager)
        )
    );
}
#[doc = " Convenience typedef for the Module analysis manager."]
pub type llvm_ModuleAnalysisManager = llvm_AnalysisManager;
#[test]
fn __bindgen_test_layout_llvm_AnalysisManager_open0_llvm_Function_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<llvm_AnalysisManager>(),
        96usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_AnalysisManager)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_AnalysisManager>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_AnalysisManager)
        )
    );
}
#[doc = " Convenience typedef for the Function analysis manager."]
pub type llvm_FunctionAnalysisManager = llvm_AnalysisManager;
#[doc = " An analysis over an \"outer\" IR unit that provides access to an\n analysis manager over an \"inner\" IR unit.  The inner unit must be contained\n in the outer unit.\n\n For example, InnerAnalysisManagerProxy<FunctionAnalysisManager, Module> is\n an analysis over Modules (the \"outer\" unit) that provides access to a\n Function analysis manager.  The FunctionAnalysisManager is the \"inner\"\n manager being proxied, and Functions are the \"inner\" unit.  The inner/outer\n relationship is valid because each Function is contained in one Module.\n\n If you're (transitively) within a pass manager for an IR unit U that\n contains IR unit V, you should never use an analysis manager over V, except\n via one of these proxies.\n\n Note that the proxy's result is a move-only RAII object.  The validity of\n the analyses in the inner analysis manager is tied to its lifetime."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_InnerAnalysisManagerProxy<AnalysisManagerT> {
    pub InnerAM: *mut AnalysisManagerT,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<AnalysisManagerT>>,
}
#[repr(C)]
#[derive(Debug)]
pub struct llvm_InnerAnalysisManagerProxy_Result<AnalysisManagerT> {
    pub InnerAM: *mut AnalysisManagerT,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<AnalysisManagerT>>,
}
extern "C" {
    #[link_name = "\u{1}Key"]
    pub static mut llvm_Key: llvm_AnalysisKey;
}
#[doc = " Provide the \\c FunctionAnalysisManager to \\c Module proxy."]
pub type llvm_FunctionAnalysisManagerModuleProxy =
    llvm_InnerAnalysisManagerProxy<llvm_FunctionAnalysisManager>;
#[test]
fn __bindgen_test_layout_llvm_InnerAnalysisManagerProxy_open0_llvm_AnalysisManager_open1_llvm_Function_close1_llvm_Module_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<llvm_InnerAnalysisManagerProxy<llvm_AnalysisManager>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_InnerAnalysisManagerProxy<llvm_AnalysisManager>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_InnerAnalysisManagerProxy<llvm_AnalysisManager>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_InnerAnalysisManagerProxy<llvm_AnalysisManager>)
        )
    );
}
#[doc = "\n This proxy doesn't manage invalidation in any way -- that is handled by the\n recursive return path of each layer of the pass manager.  A consequence of\n this is the outer analyses may be stale.  We invalidate the outer analyses\n only when we're done running passes over the inner IR units."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_OuterAnalysisManagerProxy<AnalysisManagerT> {
    pub OuterAM: *const AnalysisManagerT,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<AnalysisManagerT>>,
}
#[doc = " Result proxy object for \\c OuterAnalysisManagerProxy."]
#[repr(C)]
#[derive(Debug)]
pub struct llvm_OuterAnalysisManagerProxy_Result<AnalysisManagerT> {
    pub OuterAM: *const AnalysisManagerT,
    #[doc = " A map from an outer analysis ID to the set of this IR-unit's analyses\n which need to be invalidated."]
    pub OuterAnalysisInvalidationMap: [u64; 6usize],
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<AnalysisManagerT>>,
}
#[test]
fn __bindgen_test_layout_llvm_OuterAnalysisManagerProxy_open0_llvm_AnalysisManager_open1_llvm_Module_close1_llvm_Function_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<llvm_OuterAnalysisManagerProxy<llvm_AnalysisManager>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_OuterAnalysisManagerProxy<llvm_AnalysisManager>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_OuterAnalysisManagerProxy<llvm_AnalysisManager>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_OuterAnalysisManagerProxy<llvm_AnalysisManager>)
        )
    );
}
#[doc = " Provide the \\c ModuleAnalysisManager to \\c Function proxy."]
pub type llvm_ModuleAnalysisManagerFunctionProxy =
    llvm_OuterAnalysisManagerProxy<llvm_ModuleAnalysisManager>;
#[doc = " Trivial adaptor that maps from a module to its functions.\n\n Designed to allow composition of a FunctionPass(Manager) and\n a ModulePassManager, by running the FunctionPass(Manager) over every\n function in the module.\n\n Function passes run within this adaptor can rely on having exclusive access\n to the function they are run over. They should not read or modify any other\n functions! Other threads or systems may be manipulating other functions in\n the module, and so their state should never be relied on.\n FIXME: Make the above true for all of LLVM's actual passes, some still\n violate this principle.\n\n Function passes can also read the module containing the function, but they\n should not modify that module outside of the use lists of various globals.\n For example, a function pass is not permitted to add functions to the\n module.\n FIXME: Make the above true for all of LLVM's actual passes, some still\n violate this principle.\n\n Note that although function passes can access module analyses, module\n analyses are not invalidated while the function passes are running, so they\n may be stale.  Function analyses will not be stale."]
#[repr(C)]
#[derive(Debug)]
pub struct llvm_ModuleToFunctionPassAdaptor {
    pub Pass: std_unique_ptr,
    pub EagerlyInvalidate: bool,
}
#[doc = " Template for the abstract base class used to dispatch\n polymorphically over pass objects."]
pub type llvm_ModuleToFunctionPassAdaptor_PassConceptT = llvm_detail_PassConcept;
#[test]
fn bindgen_test_layout_llvm_ModuleToFunctionPassAdaptor() {
    const UNINIT: ::std::mem::MaybeUninit<llvm_ModuleToFunctionPassAdaptor> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<llvm_ModuleToFunctionPassAdaptor>(),
        16usize,
        concat!("Size of: ", stringify!(llvm_ModuleToFunctionPassAdaptor))
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_ModuleToFunctionPassAdaptor>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(llvm_ModuleToFunctionPassAdaptor)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Pass) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_ModuleToFunctionPassAdaptor),
            "::",
            stringify!(Pass)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).EagerlyInvalidate) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_ModuleToFunctionPassAdaptor),
            "::",
            stringify!(EagerlyInvalidate)
        )
    );
}
extern "C" {
    #[doc = " Runs the function pass across every function in the module."]
    #[link_name = "\u{1}_ZN4llvm27ModuleToFunctionPassAdaptor3runERNS_6ModuleERNS_15AnalysisManagerIS1_JEEE"]
    pub fn llvm_ModuleToFunctionPassAdaptor_run(
        this: *mut llvm_ModuleToFunctionPassAdaptor,
        M: *mut llvm_Module,
        AM: *mut llvm_ModuleAnalysisManager,
    ) -> llvm_PreservedAnalyses;
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm27ModuleToFunctionPassAdaptor13printPipelineERNS_11raw_ostreamENS_12function_refIFNS_9StringRefES4_EEE"]
    pub fn llvm_ModuleToFunctionPassAdaptor_printPipeline(
        this: *mut llvm_ModuleToFunctionPassAdaptor,
        OS: *mut llvm_raw_ostream,
        MapClassName2PassName: [u64; 2usize],
    );
}
impl llvm_ModuleToFunctionPassAdaptor {
    #[inline]
    pub unsafe fn run(
        &mut self,
        M: *mut llvm_Module,
        AM: *mut llvm_ModuleAnalysisManager,
    ) -> llvm_PreservedAnalyses {
        llvm_ModuleToFunctionPassAdaptor_run(self, M, AM)
    }
    #[inline]
    pub unsafe fn printPipeline(
        &mut self,
        OS: *mut llvm_raw_ostream,
        MapClassName2PassName: [u64; 2usize],
    ) {
        llvm_ModuleToFunctionPassAdaptor_printPipeline(self, OS, MapClassName2PassName)
    }
}
#[doc = " A utility pass template to force an analysis result to be available.\n\n If there are extra arguments at the pass's run level there may also be\n extra arguments to the analysis manager's \\c getResult routine. We can't\n guess how to effectively map the arguments from one to the other, and so\n this specialization just ignores them.\n\n Specific patterns of run-method extra arguments and analysis manager extra\n arguments will have to be defined as appropriate specializations."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_RequireAnalysisPass {
    pub _address: u8,
}
#[doc = " A no-op pass template which simply forces a specific analysis result\n to be invalidated."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_InvalidateAnalysisPass {
    pub _address: u8,
}
#[doc = " A utility pass that does nothing, but preserves no analyses.\n\n Because this preserves no analyses, any analysis passes queried after this\n pass runs will recompute fresh results."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_InvalidateAllAnalysesPass {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_llvm_InvalidateAllAnalysesPass() {
    assert_eq!(
        ::std::mem::size_of::<llvm_InvalidateAllAnalysesPass>(),
        1usize,
        concat!("Size of: ", stringify!(llvm_InvalidateAllAnalysesPass))
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_InvalidateAllAnalysesPass>(),
        1usize,
        concat!("Alignment of ", stringify!(llvm_InvalidateAllAnalysesPass))
    );
}
pub type llvm_BumpPtrAllocatorImpl_AllocTy<AllocatorT> = llvm_detail_AllocatorHolder<AllocatorT>;
#[doc = " The standard BumpPtrAllocator which just uses the default template\n parameters."]
pub type llvm_BumpPtrAllocator = [u64; 12usize];
#[doc = " A BumpPtrAllocator that allows only elements of a specific type to be\n allocated.\n\n This allows calling the destructor in DestroyAll() and when the allocator is\n destroyed."]
#[repr(C)]
#[derive(Debug)]
pub struct llvm_SpecificBumpPtrAllocator {
    pub Allocator: llvm_BumpPtrAllocator,
}
#[doc = " A CRTP mixin class that adds reference counting to a type.\n\n The lifetime of an object which inherits from RefCountedBase is managed by\n calls to Release() and Retain(), which increment and decrement the object's\n refcount, respectively.  When a Release() call decrements the refcount to 0,\n the object deletes itself."]
#[repr(C)]
#[derive(Debug)]
pub struct llvm_RefCountedBase {
    pub RefCount: ::std::os::raw::c_uint,
}
#[doc = " A thread-safe version of \\c RefCountedBase."]
#[repr(C)]
#[derive(Debug)]
pub struct llvm_ThreadSafeRefCountedBase {
    pub RefCount: std_atomic<::std::os::raw::c_int>,
}
#[doc = " Class you can specialize to provide custom retain/release functionality for\n a type.\n\n Usually specializing this class is not necessary, as IntrusiveRefCntPtr\n works with any type which defines Retain() and Release() functions -- you\n can define those functions yourself if RefCountedBase doesn't work for you.\n\n One case when you might want to specialize this type is if you have\n  - Foo.h defines type Foo and includes Bar.h, and\n  - Bar.h uses IntrusiveRefCntPtr<Foo> in inline functions.\n\n Because Foo.h includes Bar.h, Bar.h can't include Foo.h in order to pull in\n the declaration of Foo.  Without the declaration of Foo, normally Bar.h\n wouldn't be able to use IntrusiveRefCntPtr<Foo>, which wants to call\n T::Retain and T::Release.\n\n To resolve this, Bar.h could include a third header, FooFwd.h, which\n forward-declares Foo and specializes IntrusiveRefCntPtrInfo<Foo>.  Then\n Bar.h could use IntrusiveRefCntPtr<Foo>, although it still couldn't call any\n functions on Foo itself, because Foo would be an incomplete type."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_IntrusiveRefCntPtrInfo {
    pub _address: u8,
}
#[doc = " A smart pointer to a reference-counted object that inherits from\n RefCountedBase or ThreadSafeRefCountedBase.\n\n This class increments its pointee's reference count when it is created, and\n decrements its refcount when it's destroyed (or is changed to point to a\n different object)."]
#[repr(C)]
#[derive(Debug)]
pub struct llvm_IntrusiveRefCntPtr<T> {
    pub Obj: *mut T,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<T>>,
}
pub type llvm_IntrusiveRefCntPtr_element_type<T> = T;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_vfs_FileSystem {
    _unused: [u8; 0],
}
#[doc = " A struct capturing PGO tunables."]
#[repr(C)]
pub struct llvm_PGOOptions {
    pub ProfileFile: std_string,
    pub CSProfileGenFile: std_string,
    pub ProfileRemappingFile: std_string,
    pub MemoryProfile: std_string,
    pub Action: llvm_PGOOptions_PGOAction,
    pub CSAction: llvm_PGOOptions_CSPGOAction,
    pub ColdOptType: llvm_PGOOptions_ColdFuncOpt,
    pub DebugInfoForProfiling: bool,
    pub PseudoProbeForProfiling: bool,
    pub AtomicCounterUpdate: bool,
    pub FS: llvm_IntrusiveRefCntPtr<llvm_vfs_FileSystem>,
}
pub const llvm_PGOOptions_PGOAction_NoAction: llvm_PGOOptions_PGOAction = 0;
pub const llvm_PGOOptions_PGOAction_IRInstr: llvm_PGOOptions_PGOAction = 1;
pub const llvm_PGOOptions_PGOAction_IRUse: llvm_PGOOptions_PGOAction = 2;
pub const llvm_PGOOptions_PGOAction_SampleUse: llvm_PGOOptions_PGOAction = 3;
pub type llvm_PGOOptions_PGOAction = ::std::os::raw::c_uint;
pub const llvm_PGOOptions_CSPGOAction_NoCSAction: llvm_PGOOptions_CSPGOAction = 0;
pub const llvm_PGOOptions_CSPGOAction_CSIRInstr: llvm_PGOOptions_CSPGOAction = 1;
pub const llvm_PGOOptions_CSPGOAction_CSIRUse: llvm_PGOOptions_CSPGOAction = 2;
pub type llvm_PGOOptions_CSPGOAction = ::std::os::raw::c_uint;
pub const llvm_PGOOptions_ColdFuncOpt_Default: llvm_PGOOptions_ColdFuncOpt = 0;
pub const llvm_PGOOptions_ColdFuncOpt_OptSize: llvm_PGOOptions_ColdFuncOpt = 1;
pub const llvm_PGOOptions_ColdFuncOpt_MinSize: llvm_PGOOptions_ColdFuncOpt = 2;
pub const llvm_PGOOptions_ColdFuncOpt_OptNone: llvm_PGOOptions_ColdFuncOpt = 3;
pub type llvm_PGOOptions_ColdFuncOpt = ::std::os::raw::c_int;
#[test]
fn bindgen_test_layout_llvm_PGOOptions() {
    const UNINIT: ::std::mem::MaybeUninit<llvm_PGOOptions> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<llvm_PGOOptions>(),
        152usize,
        concat!("Size of: ", stringify!(llvm_PGOOptions))
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_PGOOptions>(),
        8usize,
        concat!("Alignment of ", stringify!(llvm_PGOOptions))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ProfileFile) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_PGOOptions),
            "::",
            stringify!(ProfileFile)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).CSProfileGenFile) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_PGOOptions),
            "::",
            stringify!(CSProfileGenFile)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ProfileRemappingFile) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_PGOOptions),
            "::",
            stringify!(ProfileRemappingFile)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).MemoryProfile) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_PGOOptions),
            "::",
            stringify!(MemoryProfile)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Action) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_PGOOptions),
            "::",
            stringify!(Action)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).CSAction) as usize - ptr as usize },
        132usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_PGOOptions),
            "::",
            stringify!(CSAction)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ColdOptType) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_PGOOptions),
            "::",
            stringify!(ColdOptType)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).DebugInfoForProfiling) as usize - ptr as usize },
        140usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_PGOOptions),
            "::",
            stringify!(DebugInfoForProfiling)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).PseudoProbeForProfiling) as usize - ptr as usize },
        141usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_PGOOptions),
            "::",
            stringify!(PseudoProbeForProfiling)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).AtomicCounterUpdate) as usize - ptr as usize },
        142usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_PGOOptions),
            "::",
            stringify!(AtomicCounterUpdate)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).FS) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_PGOOptions),
            "::",
            stringify!(FS)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm10PGOOptionsC1ENSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEES6_S6_S6_NS_18IntrusiveRefCntPtrINS_3vfs10FileSystemEEENS0_9PGOActionENS0_11CSPGOActionENS0_11ColdFuncOptEbbb"]
    pub fn llvm_PGOOptions_PGOOptions(
        this: *mut llvm_PGOOptions,
        ProfileFile: std_string,
        CSProfileGenFile: std_string,
        ProfileRemappingFile: std_string,
        MemoryProfile: std_string,
        FS: llvm_IntrusiveRefCntPtr<llvm_vfs_FileSystem>,
        Action: llvm_PGOOptions_PGOAction,
        CSAction: llvm_PGOOptions_CSPGOAction,
        ColdType: llvm_PGOOptions_ColdFuncOpt,
        DebugInfoForProfiling: bool,
        PseudoProbeForProfiling: bool,
        AtomicCounterUpdate: bool,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm10PGOOptionsC1ERKS0_"]
    pub fn llvm_PGOOptions_PGOOptions1(this: *mut llvm_PGOOptions, arg1: *const llvm_PGOOptions);
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm10PGOOptionsD1Ev"]
    pub fn llvm_PGOOptions_PGOOptions_destructor(this: *mut llvm_PGOOptions);
}
impl llvm_PGOOptions {
    #[inline]
    pub unsafe fn new(
        ProfileFile: std_string,
        CSProfileGenFile: std_string,
        ProfileRemappingFile: std_string,
        MemoryProfile: std_string,
        FS: llvm_IntrusiveRefCntPtr<llvm_vfs_FileSystem>,
        Action: llvm_PGOOptions_PGOAction,
        CSAction: llvm_PGOOptions_CSPGOAction,
        ColdType: llvm_PGOOptions_ColdFuncOpt,
        DebugInfoForProfiling: bool,
        PseudoProbeForProfiling: bool,
        AtomicCounterUpdate: bool,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        llvm_PGOOptions_PGOOptions(
            __bindgen_tmp.as_mut_ptr(),
            ProfileFile,
            CSProfileGenFile,
            ProfileRemappingFile,
            MemoryProfile,
            FS,
            Action,
            CSAction,
            ColdType,
            DebugInfoForProfiling,
            PseudoProbeForProfiling,
            AtomicCounterUpdate,
        );
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(arg1: *const llvm_PGOOptions) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        llvm_PGOOptions_PGOOptions1(__bindgen_tmp.as_mut_ptr(), arg1);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn destruct(&mut self) {
        llvm_PGOOptions_PGOOptions_destructor(self)
    }
}
pub const llvm_RunOutliner_TargetDefault: llvm_RunOutliner = 0;
pub const llvm_RunOutliner_AlwaysOutline: llvm_RunOutliner = 1;
pub const llvm_RunOutliner_NeverOutline: llvm_RunOutliner = 2;
pub type llvm_RunOutliner = ::std::os::raw::c_int;
pub const llvm_RegAllocType_Default: llvm_RegAllocType = 0;
pub const llvm_RegAllocType_Basic: llvm_RegAllocType = 1;
pub const llvm_RegAllocType_Fast: llvm_RegAllocType = 2;
pub const llvm_RegAllocType_Greedy: llvm_RegAllocType = 3;
pub const llvm_RegAllocType_PBQP: llvm_RegAllocType = 4;
pub type llvm_RegAllocType = ::std::os::raw::c_int;
#[repr(C)]
pub struct llvm_CGPassBuilderOption {
    pub OptimizeRegAlloc: std_optional,
    pub EnableIPRA: std_optional,
    pub DebugPM: bool,
    pub DisableVerify: bool,
    pub EnableImplicitNullChecks: bool,
    pub EnableBlockPlacementStats: bool,
    pub EnableMachineFunctionSplitter: bool,
    pub MISchedPostRA: bool,
    pub EarlyLiveIntervals: bool,
    pub GCEmptyBlocks: bool,
    pub DisableLSR: bool,
    pub DisableCGP: bool,
    pub PrintLSR: bool,
    pub DisableMergeICmps: bool,
    pub DisablePartialLibcallInlining: bool,
    pub DisableConstantHoisting: bool,
    pub DisableSelectOptimize: bool,
    pub DisableAtExitBasedGlobalDtorLowering: bool,
    pub DisableExpandReductions: bool,
    pub DisableRAFSProfileLoader: bool,
    pub DisableCFIFixup: bool,
    pub PrintAfterISel: bool,
    pub PrintISelInput: bool,
    pub RequiresCodeGenSCCOrder: bool,
    pub EnableMachineOutliner: llvm_RunOutliner,
    pub RegAlloc: llvm_StringRef,
    pub EnableGlobalISelAbort: std_optional,
    pub FSProfileFile: std_string,
    pub FSRemappingFile: std_string,
    pub VerifyMachineCode: std_optional,
    pub EnableFastISelOption: std_optional,
    pub EnableGlobalISelOption: std_optional,
    pub DebugifyAndStripAll: std_optional,
    pub DebugifyCheckAndStripAll: std_optional,
}
#[test]
fn bindgen_test_layout_llvm_CGPassBuilderOption() {
    const UNINIT: ::std::mem::MaybeUninit<llvm_CGPassBuilderOption> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<llvm_CGPassBuilderOption>(),
        136usize,
        concat!("Size of: ", stringify!(llvm_CGPassBuilderOption))
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_CGPassBuilderOption>(),
        8usize,
        concat!("Alignment of ", stringify!(llvm_CGPassBuilderOption))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).OptimizeRegAlloc) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_CGPassBuilderOption),
            "::",
            stringify!(OptimizeRegAlloc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).EnableIPRA) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_CGPassBuilderOption),
            "::",
            stringify!(EnableIPRA)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).DebugPM) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_CGPassBuilderOption),
            "::",
            stringify!(DebugPM)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).DisableVerify) as usize - ptr as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_CGPassBuilderOption),
            "::",
            stringify!(DisableVerify)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).EnableImplicitNullChecks) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_CGPassBuilderOption),
            "::",
            stringify!(EnableImplicitNullChecks)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).EnableBlockPlacementStats) as usize - ptr as usize },
        7usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_CGPassBuilderOption),
            "::",
            stringify!(EnableBlockPlacementStats)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).EnableMachineFunctionSplitter) as usize - ptr as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_CGPassBuilderOption),
            "::",
            stringify!(EnableMachineFunctionSplitter)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).MISchedPostRA) as usize - ptr as usize },
        9usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_CGPassBuilderOption),
            "::",
            stringify!(MISchedPostRA)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).EarlyLiveIntervals) as usize - ptr as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_CGPassBuilderOption),
            "::",
            stringify!(EarlyLiveIntervals)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).GCEmptyBlocks) as usize - ptr as usize },
        11usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_CGPassBuilderOption),
            "::",
            stringify!(GCEmptyBlocks)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).DisableLSR) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_CGPassBuilderOption),
            "::",
            stringify!(DisableLSR)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).DisableCGP) as usize - ptr as usize },
        13usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_CGPassBuilderOption),
            "::",
            stringify!(DisableCGP)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).PrintLSR) as usize - ptr as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_CGPassBuilderOption),
            "::",
            stringify!(PrintLSR)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).DisableMergeICmps) as usize - ptr as usize },
        15usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_CGPassBuilderOption),
            "::",
            stringify!(DisableMergeICmps)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).DisablePartialLibcallInlining) as usize - ptr as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_CGPassBuilderOption),
            "::",
            stringify!(DisablePartialLibcallInlining)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).DisableConstantHoisting) as usize - ptr as usize },
        17usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_CGPassBuilderOption),
            "::",
            stringify!(DisableConstantHoisting)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).DisableSelectOptimize) as usize - ptr as usize },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_CGPassBuilderOption),
            "::",
            stringify!(DisableSelectOptimize)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).DisableAtExitBasedGlobalDtorLowering) as usize
                - ptr as usize
        },
        19usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_CGPassBuilderOption),
            "::",
            stringify!(DisableAtExitBasedGlobalDtorLowering)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).DisableExpandReductions) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_CGPassBuilderOption),
            "::",
            stringify!(DisableExpandReductions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).DisableRAFSProfileLoader) as usize - ptr as usize },
        21usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_CGPassBuilderOption),
            "::",
            stringify!(DisableRAFSProfileLoader)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).DisableCFIFixup) as usize - ptr as usize },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_CGPassBuilderOption),
            "::",
            stringify!(DisableCFIFixup)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).PrintAfterISel) as usize - ptr as usize },
        23usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_CGPassBuilderOption),
            "::",
            stringify!(PrintAfterISel)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).PrintISelInput) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_CGPassBuilderOption),
            "::",
            stringify!(PrintISelInput)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).RequiresCodeGenSCCOrder) as usize - ptr as usize },
        25usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_CGPassBuilderOption),
            "::",
            stringify!(RequiresCodeGenSCCOrder)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).EnableMachineOutliner) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_CGPassBuilderOption),
            "::",
            stringify!(EnableMachineOutliner)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).RegAlloc) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_CGPassBuilderOption),
            "::",
            stringify!(RegAlloc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).EnableGlobalISelAbort) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_CGPassBuilderOption),
            "::",
            stringify!(EnableGlobalISelAbort)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).FSProfileFile) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_CGPassBuilderOption),
            "::",
            stringify!(FSProfileFile)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).FSRemappingFile) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_CGPassBuilderOption),
            "::",
            stringify!(FSRemappingFile)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).VerifyMachineCode) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_CGPassBuilderOption),
            "::",
            stringify!(VerifyMachineCode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).EnableFastISelOption) as usize - ptr as usize },
        122usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_CGPassBuilderOption),
            "::",
            stringify!(EnableFastISelOption)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).EnableGlobalISelOption) as usize - ptr as usize },
        124usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_CGPassBuilderOption),
            "::",
            stringify!(EnableGlobalISelOption)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).DebugifyAndStripAll) as usize - ptr as usize },
        126usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_CGPassBuilderOption),
            "::",
            stringify!(DebugifyAndStripAll)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).DebugifyCheckAndStripAll) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_CGPassBuilderOption),
            "::",
            stringify!(DebugifyCheckAndStripAll)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm22getCGPassBuilderOptionEv"]
    pub fn llvm_getCGPassBuilderOption() -> llvm_CGPassBuilderOption;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_AAManager {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_MachineModuleInfoWrapperPass {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_Mangler {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_PassBuilder {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_PassInstrumentationCallbacks {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_PerFunctionMIParsingState {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_TargetIntrinsicInfo {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_TargetIRAnalysis {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_TargetTransformInfo {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_TargetLoweringObjectFile {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_TargetPassConfig {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_TargetSubtargetInfo {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_MachineFunctionInfo {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_yaml_MachineFunctionInfo {
    _unused: [u8; 0],
}
#[repr(C)]
pub struct llvm_TargetMachine__bindgen_vtable(::std::os::raw::c_void);
#[doc = "\n Primary interface to the complete machine description for the target\n machine.  All target-specific information should be accessible through this\n interface.\n"]
#[repr(C)]
pub struct llvm_TargetMachine {
    pub vtable_: *const llvm_TargetMachine__bindgen_vtable,
    #[doc = " The Target that this machine was created for."]
    pub TheTarget: *const llvm_Target,
    #[doc = " DataLayout for the target: keep ABI type size and alignment.\n\n The DataLayout is created based on the string representation provided\n during construction. It is kept here only to avoid reparsing the string\n but should not really be used during compilation, because it has an\n internal cache that is context specific."]
    pub DL: llvm_DataLayout,
    #[doc = " Triple string, CPU name, and target feature strings the TargetMachine\n instance is created with."]
    pub TargetTriple: llvm_Triple,
    pub TargetCPU: std_string,
    pub TargetFS: std_string,
    pub RM: llvm_Reloc_Model,
    pub CMModel: llvm_CodeModel_Model,
    pub LargeDataThreshold: u64,
    pub OptLevel: llvm_CodeGenOptLevel,
    #[doc = " Contains target specific asm information."]
    pub AsmInfo: std_unique_ptr,
    pub MRI: std_unique_ptr,
    pub MII: std_unique_ptr,
    pub STI: std_unique_ptr,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub PGOOption: std_optional,
    pub Options: llvm_TargetOptions,
}
#[doc = " The integer bit size to use for SjLj based exception handling."]
pub const llvm_TargetMachine_DefaultSjLjDataSize: ::std::os::raw::c_uint = 32;
#[test]
fn bindgen_test_layout_llvm_TargetMachine() {
    const UNINIT: ::std::mem::MaybeUninit<llvm_TargetMachine> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<llvm_TargetMachine>(),
        1232usize,
        concat!("Size of: ", stringify!(llvm_TargetMachine))
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_TargetMachine>(),
        8usize,
        concat!("Alignment of ", stringify!(llvm_TargetMachine))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).TheTarget) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_TargetMachine),
            "::",
            stringify!(TheTarget)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).DL) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_TargetMachine),
            "::",
            stringify!(DL)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).TargetTriple) as usize - ptr as usize },
        528usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_TargetMachine),
            "::",
            stringify!(TargetTriple)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).TargetCPU) as usize - ptr as usize },
        584usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_TargetMachine),
            "::",
            stringify!(TargetCPU)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).TargetFS) as usize - ptr as usize },
        616usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_TargetMachine),
            "::",
            stringify!(TargetFS)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).RM) as usize - ptr as usize },
        648usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_TargetMachine),
            "::",
            stringify!(RM)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).CMModel) as usize - ptr as usize },
        652usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_TargetMachine),
            "::",
            stringify!(CMModel)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LargeDataThreshold) as usize - ptr as usize },
        656usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_TargetMachine),
            "::",
            stringify!(LargeDataThreshold)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).OptLevel) as usize - ptr as usize },
        664usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_TargetMachine),
            "::",
            stringify!(OptLevel)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).AsmInfo) as usize - ptr as usize },
        672usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_TargetMachine),
            "::",
            stringify!(AsmInfo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).MRI) as usize - ptr as usize },
        680usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_TargetMachine),
            "::",
            stringify!(MRI)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).MII) as usize - ptr as usize },
        688usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_TargetMachine),
            "::",
            stringify!(MII)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).STI) as usize - ptr as usize },
        696usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_TargetMachine),
            "::",
            stringify!(STI)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).PGOOption) as usize - ptr as usize },
        712usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_TargetMachine),
            "::",
            stringify!(PGOOption)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Options) as usize - ptr as usize },
        872usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_TargetMachine),
            "::",
            stringify!(Options)
        )
    );
}
extern "C" {
    #[doc = " Reset the target options based on the function's attributes."]
    #[link_name = "\u{1}_ZNK4llvm13TargetMachine18resetTargetOptionsERKNS_8FunctionE"]
    pub fn llvm_TargetMachine_resetTargetOptions(
        this: *const llvm_TargetMachine,
        F: *const llvm_Function,
    );
}
extern "C" {
    #[doc = " Returns the code generation relocation model. The choices are static, PIC,\n and dynamic-no-pic, and target default."]
    #[link_name = "\u{1}_ZNK4llvm13TargetMachine18getRelocationModelEv"]
    pub fn llvm_TargetMachine_getRelocationModel(
        this: *const llvm_TargetMachine,
    ) -> llvm_Reloc_Model;
}
extern "C" {
    #[doc = " Returns the maximum code size possible under the code model."]
    #[link_name = "\u{1}_ZNK4llvm13TargetMachine14getMaxCodeSizeEv"]
    pub fn llvm_TargetMachine_getMaxCodeSize(this: *const llvm_TargetMachine) -> u64;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4llvm13TargetMachine18isLargeGlobalValueEPKNS_11GlobalValueE"]
    pub fn llvm_TargetMachine_isLargeGlobalValue(
        this: *const llvm_TargetMachine,
        GV: *const llvm_GlobalValue,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4llvm13TargetMachine21isPositionIndependentEv"]
    pub fn llvm_TargetMachine_isPositionIndependent(this: *const llvm_TargetMachine) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4llvm13TargetMachine20shouldAssumeDSOLocalEPKNS_11GlobalValueE"]
    pub fn llvm_TargetMachine_shouldAssumeDSOLocal(
        this: *const llvm_TargetMachine,
        GV: *const llvm_GlobalValue,
    ) -> bool;
}
extern "C" {
    #[doc = " Returns true if this target uses emulated TLS."]
    #[link_name = "\u{1}_ZNK4llvm13TargetMachine14useEmulatedTLSEv"]
    pub fn llvm_TargetMachine_useEmulatedTLS(this: *const llvm_TargetMachine) -> bool;
}
extern "C" {
    #[doc = " Returns true if this target uses TLS Descriptors."]
    #[link_name = "\u{1}_ZNK4llvm13TargetMachine10useTLSDESCEv"]
    pub fn llvm_TargetMachine_useTLSDESC(this: *const llvm_TargetMachine) -> bool;
}
extern "C" {
    #[doc = " Returns the TLS model which should be used for the given global variable."]
    #[link_name = "\u{1}_ZNK4llvm13TargetMachine11getTLSModelEPKNS_11GlobalValueE"]
    pub fn llvm_TargetMachine_getTLSModel(
        this: *const llvm_TargetMachine,
        GV: *const llvm_GlobalValue,
    ) -> llvm_TLSModel_Model;
}
extern "C" {
    #[doc = " Get a \\c TargetIRAnalysis appropriate for the target.\n\n This is used to construct the new pass manager's target IR analysis pass,\n set up appropriately for this target machine. Even the old pass manager\n uses this to answer queries about the IR."]
    #[link_name = "\u{1}_ZNK4llvm13TargetMachine19getTargetIRAnalysisEv"]
    pub fn llvm_TargetMachine_getTargetIRAnalysis(
        this: *const llvm_TargetMachine,
    ) -> llvm_TargetIRAnalysis;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4llvm13TargetMachine17getNameWithPrefixERNS_15SmallVectorImplIcEEPKNS_11GlobalValueERNS_7ManglerEb"]
    pub fn llvm_TargetMachine_getNameWithPrefix(
        this: *const llvm_TargetMachine,
        Name: *mut llvm_SmallVectorImpl,
        GV: *const llvm_GlobalValue,
        Mang: *mut llvm_Mangler,
        MayAlwaysUsePrivate: bool,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK4llvm13TargetMachine9getSymbolEPKNS_11GlobalValueE"]
    pub fn llvm_TargetMachine_getSymbol(
        this: *const llvm_TargetMachine,
        GV: *const llvm_GlobalValue,
    ) -> *mut llvm_MCSymbol;
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm13TargetMachine20parseBinutilsVersionENS_9StringRefE"]
    pub fn llvm_TargetMachine_parseBinutilsVersion(
        Version: llvm_StringRef,
    ) -> std_pair<::std::os::raw::c_int, ::std::os::raw::c_int>;
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm13TargetMachineC1ERKNS_6TargetENS_9StringRefERKNS_6TripleES4_S4_RKNS_13TargetOptionsE"]
    pub fn llvm_TargetMachine_TargetMachine(
        this: *mut llvm_TargetMachine,
        T: *const llvm_Target,
        DataLayoutString: llvm_StringRef,
        TargetTriple: *const llvm_Triple,
        CPU: llvm_StringRef,
        FS: llvm_StringRef,
        Options: *const llvm_TargetOptions,
    );
}
impl llvm_TargetMachine {
    #[inline]
    pub fn RequireStructuredCFG(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_RequireStructuredCFG(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn O0WantsFastISel(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_O0WantsFastISel(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        RequireStructuredCFG: ::std::os::raw::c_uint,
        O0WantsFastISel: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let RequireStructuredCFG: u32 = unsafe { ::std::mem::transmute(RequireStructuredCFG) };
            RequireStructuredCFG as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let O0WantsFastISel: u32 = unsafe { ::std::mem::transmute(O0WantsFastISel) };
            O0WantsFastISel as u64
        });
        __bindgen_bitfield_unit
    }
    #[inline]
    pub unsafe fn resetTargetOptions(&self, F: *const llvm_Function) {
        llvm_TargetMachine_resetTargetOptions(self, F)
    }
    #[inline]
    pub unsafe fn getRelocationModel(&self) -> llvm_Reloc_Model {
        llvm_TargetMachine_getRelocationModel(self)
    }
    #[inline]
    pub unsafe fn getMaxCodeSize(&self) -> u64 {
        llvm_TargetMachine_getMaxCodeSize(self)
    }
    #[inline]
    pub unsafe fn isLargeGlobalValue(&self, GV: *const llvm_GlobalValue) -> bool {
        llvm_TargetMachine_isLargeGlobalValue(self, GV)
    }
    #[inline]
    pub unsafe fn isPositionIndependent(&self) -> bool {
        llvm_TargetMachine_isPositionIndependent(self)
    }
    #[inline]
    pub unsafe fn shouldAssumeDSOLocal(&self, GV: *const llvm_GlobalValue) -> bool {
        llvm_TargetMachine_shouldAssumeDSOLocal(self, GV)
    }
    #[inline]
    pub unsafe fn useEmulatedTLS(&self) -> bool {
        llvm_TargetMachine_useEmulatedTLS(self)
    }
    #[inline]
    pub unsafe fn useTLSDESC(&self) -> bool {
        llvm_TargetMachine_useTLSDESC(self)
    }
    #[inline]
    pub unsafe fn getTLSModel(&self, GV: *const llvm_GlobalValue) -> llvm_TLSModel_Model {
        llvm_TargetMachine_getTLSModel(self, GV)
    }
    #[inline]
    pub unsafe fn getTargetIRAnalysis(&self) -> llvm_TargetIRAnalysis {
        llvm_TargetMachine_getTargetIRAnalysis(self)
    }
    #[inline]
    pub unsafe fn getNameWithPrefix(
        &self,
        Name: *mut llvm_SmallVectorImpl,
        GV: *const llvm_GlobalValue,
        Mang: *mut llvm_Mangler,
        MayAlwaysUsePrivate: bool,
    ) {
        llvm_TargetMachine_getNameWithPrefix(self, Name, GV, Mang, MayAlwaysUsePrivate)
    }
    #[inline]
    pub unsafe fn getSymbol(&self, GV: *const llvm_GlobalValue) -> *mut llvm_MCSymbol {
        llvm_TargetMachine_getSymbol(self, GV)
    }
    #[inline]
    pub unsafe fn parseBinutilsVersion(
        Version: llvm_StringRef,
    ) -> std_pair<::std::os::raw::c_int, ::std::os::raw::c_int> {
        llvm_TargetMachine_parseBinutilsVersion(Version)
    }
    #[inline]
    pub unsafe fn new(
        T: *const llvm_Target,
        DataLayoutString: llvm_StringRef,
        TargetTriple: *const llvm_Triple,
        CPU: llvm_StringRef,
        FS: llvm_StringRef,
        Options: *const llvm_TargetOptions,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        llvm_TargetMachine_TargetMachine(
            __bindgen_tmp.as_mut_ptr(),
            T,
            DataLayoutString,
            TargetTriple,
            CPU,
            FS,
            Options,
        );
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm13TargetMachineD1Ev"]
    pub fn llvm_TargetMachine_TargetMachine_destructor(this: *mut llvm_TargetMachine);
}
extern "C" {
    #[doc = " Return a TargetTransformInfo for a given function.\n\n The returned TargetTransformInfo is specialized to the subtarget\n corresponding to \\p F."]
    #[link_name = "\u{1}_ZNK4llvm13TargetMachine22getTargetTransformInfoERKNS_8FunctionE"]
    pub fn llvm_TargetMachine_getTargetTransformInfo(
        this: *mut ::std::os::raw::c_void,
        F: *const llvm_Function,
    ) -> llvm_TargetTransformInfo;
}
#[doc = " This class describes a target machine that is implemented with the LLVM\n target-independent code generator.\n"]
#[repr(C)]
pub struct llvm_LLVMTargetMachine {
    pub _base: llvm_TargetMachine,
}
#[test]
fn bindgen_test_layout_llvm_LLVMTargetMachine() {
    assert_eq!(
        ::std::mem::size_of::<llvm_LLVMTargetMachine>(),
        1232usize,
        concat!("Size of: ", stringify!(llvm_LLVMTargetMachine))
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_LLVMTargetMachine>(),
        8usize,
        concat!("Alignment of ", stringify!(llvm_LLVMTargetMachine))
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm17LLVMTargetMachine11initAsmInfoEv"]
    pub fn llvm_LLVMTargetMachine_initAsmInfo(this: *mut llvm_LLVMTargetMachine);
}
extern "C" {
    #[doc = " Adds an AsmPrinter pass to the pipeline that prints assembly or\n machine code from the MI representation."]
    #[link_name = "\u{1}_ZN4llvm17LLVMTargetMachine13addAsmPrinterERNS_6legacy15PassManagerBaseERNS_17raw_pwrite_streamEPS4_NS_15CodeGenFileTypeERNS_9MCContextE"]
    pub fn llvm_LLVMTargetMachine_addAsmPrinter(
        this: *mut llvm_LLVMTargetMachine,
        PM: *mut llvm_legacy_PassManagerBase,
        Out: *mut llvm_raw_pwrite_stream,
        DwoOut: *mut llvm_raw_pwrite_stream,
        FileType: llvm_CodeGenFileType,
        Context: *mut llvm_MCContext,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm17LLVMTargetMachine16createMCStreamerERNS_17raw_pwrite_streamEPS1_NS_15CodeGenFileTypeERNS_9MCContextE"]
    pub fn llvm_LLVMTargetMachine_createMCStreamer(
        this: *mut llvm_LLVMTargetMachine,
        Out: *mut llvm_raw_pwrite_stream,
        DwoOut: *mut llvm_raw_pwrite_stream,
        FileType: llvm_CodeGenFileType,
        Ctx: *mut llvm_MCContext,
    ) -> llvm_Expected;
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm17LLVMTargetMachineC1ERKNS_6TargetENS_9StringRefERKNS_6TripleES4_S4_RKNS_13TargetOptionsENS_5Reloc5ModelENS_9CodeModel5ModelENS_15CodeGenOptLevelE"]
    pub fn llvm_LLVMTargetMachine_LLVMTargetMachine(
        this: *mut llvm_LLVMTargetMachine,
        T: *const llvm_Target,
        DataLayoutString: llvm_StringRef,
        TT: *const llvm_Triple,
        CPU: llvm_StringRef,
        FS: llvm_StringRef,
        Options: *const llvm_TargetOptions,
        RM: llvm_Reloc_Model,
        CM: llvm_CodeModel_Model,
        OL: llvm_CodeGenOptLevel,
    );
}
impl llvm_LLVMTargetMachine {
    #[inline]
    pub unsafe fn initAsmInfo(&mut self) {
        llvm_LLVMTargetMachine_initAsmInfo(self)
    }
    #[inline]
    pub unsafe fn addAsmPrinter(
        &mut self,
        PM: *mut llvm_legacy_PassManagerBase,
        Out: *mut llvm_raw_pwrite_stream,
        DwoOut: *mut llvm_raw_pwrite_stream,
        FileType: llvm_CodeGenFileType,
        Context: *mut llvm_MCContext,
    ) -> bool {
        llvm_LLVMTargetMachine_addAsmPrinter(self, PM, Out, DwoOut, FileType, Context)
    }
    #[inline]
    pub unsafe fn createMCStreamer(
        &mut self,
        Out: *mut llvm_raw_pwrite_stream,
        DwoOut: *mut llvm_raw_pwrite_stream,
        FileType: llvm_CodeGenFileType,
        Ctx: *mut llvm_MCContext,
    ) -> llvm_Expected {
        llvm_LLVMTargetMachine_createMCStreamer(self, Out, DwoOut, FileType, Ctx)
    }
    #[inline]
    pub unsafe fn new(
        T: *const llvm_Target,
        DataLayoutString: llvm_StringRef,
        TT: *const llvm_Triple,
        CPU: llvm_StringRef,
        FS: llvm_StringRef,
        Options: *const llvm_TargetOptions,
        RM: llvm_Reloc_Model,
        CM: llvm_CodeModel_Model,
        OL: llvm_CodeGenOptLevel,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        llvm_LLVMTargetMachine_LLVMTargetMachine(
            __bindgen_tmp.as_mut_ptr(),
            T,
            DataLayoutString,
            TT,
            CPU,
            FS,
            Options,
            RM,
            CM,
            OL,
        );
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[doc = " Get a TargetTransformInfo implementation for the target.\n\n The TTI returned uses the common code generator to answer queries about\n the IR."]
    #[link_name = "\u{1}_ZNK4llvm17LLVMTargetMachine22getTargetTransformInfoERKNS_8FunctionE"]
    pub fn llvm_LLVMTargetMachine_getTargetTransformInfo(
        this: *mut ::std::os::raw::c_void,
        F: *const llvm_Function,
    ) -> llvm_TargetTransformInfo;
}
extern "C" {
    #[doc = " Create a pass configuration object to be used by addPassToEmitX methods\n for generating a pipeline of CodeGen passes."]
    #[link_name = "\u{1}_ZN4llvm17LLVMTargetMachine16createPassConfigERNS_6legacy15PassManagerBaseE"]
    pub fn llvm_LLVMTargetMachine_createPassConfig(
        this: *mut ::std::os::raw::c_void,
        PM: *mut llvm_legacy_PassManagerBase,
    ) -> *mut llvm_TargetPassConfig;
}
extern "C" {
    #[doc = " Add passes to the specified pass manager to get the specified file\n emitted.  Typically this will involve several steps of code generation.\n \\p MMIWP is an optional parameter that, if set to non-nullptr,\n will be used to set the MachineModuloInfo for this PM."]
    #[link_name = "\u{1}_ZN4llvm17LLVMTargetMachine19addPassesToEmitFileERNS_6legacy15PassManagerBaseERNS_17raw_pwrite_streamEPS4_NS_15CodeGenFileTypeEbPNS_28MachineModuleInfoWrapperPassE"]
    pub fn llvm_LLVMTargetMachine_addPassesToEmitFile(
        this: *mut ::std::os::raw::c_void,
        PM: *mut llvm_legacy_PassManagerBase,
        Out: *mut llvm_raw_pwrite_stream,
        DwoOut: *mut llvm_raw_pwrite_stream,
        FileType: llvm_CodeGenFileType,
        DisableVerify: bool,
        MMIWP: *mut llvm_MachineModuleInfoWrapperPass,
    ) -> bool;
}
extern "C" {
    #[doc = " Add passes to the specified pass manager to get machine code emitted with\n the MCJIT. This method returns true if machine code is not supported. It\n fills the MCContext Ctx pointer which can be used to build custom\n MCStreamer."]
    #[link_name = "\u{1}_ZN4llvm17LLVMTargetMachine17addPassesToEmitMCERNS_6legacy15PassManagerBaseERPNS_9MCContextERNS_17raw_pwrite_streamEb"]
    pub fn llvm_LLVMTargetMachine_addPassesToEmitMC(
        this: *mut ::std::os::raw::c_void,
        PM: *mut llvm_legacy_PassManagerBase,
        Ctx: *mut *mut llvm_MCContext,
        Out: *mut llvm_raw_pwrite_stream,
        DisableVerify: bool,
    ) -> bool;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LLVMOpaqueTargetData {
    _unused: [u8; 0],
}
pub type LLVMTargetDataRef = *mut LLVMOpaqueTargetData;
#[doc = " An opaque reference to a disassembler context."]
pub type LLVMDisasmContextRef = *mut ::std::os::raw::c_void;
#[doc = " The type for the operand information call back function.  This is called to\n get the symbolic information for an operand of an instruction.  Typically\n this is from the relocation information, symbol table, etc.  That block of\n information is saved when the disassembler context is created and passed to\n the call back in the DisInfo parameter.  The instruction containing operand\n is at the PC parameter.  For some instruction sets, there can be more than\n one operand with symbolic information.  To determine the symbolic operand\n information for each operand, the bytes for the specific operand in the\n instruction are specified by the Offset parameter and its byte widith is the\n OpSize parameter.  For instructions sets with fixed widths and one symbolic\n operand per instruction, the Offset parameter will be zero and InstSize\n parameter will be the instruction width.  The information is returned in\n TagBuf and is Triple specific with its specific information defined by the\n value of TagType for that Triple.  If symbolic information is returned the\n function * returns 1, otherwise it returns 0."]
pub type LLVMOpInfoCallback = ::std::option::Option<
    unsafe extern "C" fn(
        DisInfo: *mut ::std::os::raw::c_void,
        PC: u64,
        Offset: u64,
        OpSize: u64,
        InstSize: u64,
        TagType: ::std::os::raw::c_int,
        TagBuf: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " The initial support in LLVM MC for the most general form of a relocatable\n expression is \"AddSymbol - SubtractSymbol + Offset\".  For some Darwin targets\n this full form is encoded in the relocation information so that AddSymbol and\n SubtractSymbol can be link edited independent of each other.  Many other\n platforms only allow a relocatable expression of the form AddSymbol + Offset\n to be encoded.\n\n The LLVMOpInfoCallback() for the TagType value of 1 uses the struct\n LLVMOpInfo1.  The value of the relocatable expression for the operand,\n including any PC adjustment, is passed in to the call back in the Value\n field.  The symbolic information about the operand is returned using all\n the fields of the structure with the Offset of the relocatable expression\n returned in the Value field.  It is possible that some symbols in the\n relocatable expression were assembly temporary symbols, for example\n \"Ldata - LpicBase + constant\", and only the Values of the symbols without\n symbol names are present in the relocation information.  The VariantKind\n type is one of the Target specific #defines below and is used to print\n operands like \"_foo@GOT\", \":lower16:_foo\", etc."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LLVMOpInfoSymbol1 {
    pub Present: u64,
    pub Name: *const ::std::os::raw::c_char,
    pub Value: u64,
}
#[test]
fn bindgen_test_layout_LLVMOpInfoSymbol1() {
    const UNINIT: ::std::mem::MaybeUninit<LLVMOpInfoSymbol1> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<LLVMOpInfoSymbol1>(),
        24usize,
        concat!("Size of: ", stringify!(LLVMOpInfoSymbol1))
    );
    assert_eq!(
        ::std::mem::align_of::<LLVMOpInfoSymbol1>(),
        8usize,
        concat!("Alignment of ", stringify!(LLVMOpInfoSymbol1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Present) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(LLVMOpInfoSymbol1),
            "::",
            stringify!(Present)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Name) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(LLVMOpInfoSymbol1),
            "::",
            stringify!(Name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Value) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(LLVMOpInfoSymbol1),
            "::",
            stringify!(Value)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LLVMOpInfo1 {
    pub AddSymbol: LLVMOpInfoSymbol1,
    pub SubtractSymbol: LLVMOpInfoSymbol1,
    pub Value: u64,
    pub VariantKind: u64,
}
#[test]
fn bindgen_test_layout_LLVMOpInfo1() {
    const UNINIT: ::std::mem::MaybeUninit<LLVMOpInfo1> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<LLVMOpInfo1>(),
        64usize,
        concat!("Size of: ", stringify!(LLVMOpInfo1))
    );
    assert_eq!(
        ::std::mem::align_of::<LLVMOpInfo1>(),
        8usize,
        concat!("Alignment of ", stringify!(LLVMOpInfo1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).AddSymbol) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(LLVMOpInfo1),
            "::",
            stringify!(AddSymbol)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).SubtractSymbol) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(LLVMOpInfo1),
            "::",
            stringify!(SubtractSymbol)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Value) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(LLVMOpInfo1),
            "::",
            stringify!(Value)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).VariantKind) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(LLVMOpInfo1),
            "::",
            stringify!(VariantKind)
        )
    );
}
#[doc = " The type for the symbol lookup function.  This may be called by the\n disassembler for things like adding a comment for a PC plus a constant\n offset load instruction to use a symbol name instead of a load address value.\n It is passed the block information is saved when the disassembler context is\n created and the ReferenceValue to look up as a symbol.  If no symbol is found\n for the ReferenceValue NULL is returned.  The ReferenceType of the\n instruction is passed indirectly as is the PC of the instruction in\n ReferencePC.  If the output reference can be determined its type is returned\n indirectly in ReferenceType along with ReferenceName if any, or that is set\n to NULL."]
pub type LLVMSymbolLookupCallback = ::std::option::Option<
    unsafe extern "C" fn(
        DisInfo: *mut ::std::os::raw::c_void,
        ReferenceValue: u64,
        ReferenceType: *mut u64,
        ReferencePC: u64,
        ReferenceName: *mut *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_1 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_2 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_3 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_4 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_5 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_6 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_7 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_8 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_9 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_10 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_11 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_12 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_13 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_14 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_15 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_16 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_17 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_18 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_19 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_20 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_21 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_22 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_23 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_24 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_25 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_26 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_27 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_28 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_29 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_30 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_31 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_32 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_33 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_34 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_35 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_36 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_37 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_38 {
    pub _address: u8,
}
#[test]
fn __bindgen_test_layout_std_iterator_open0_std_output_iterator_tag_void_void_void_void_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<std_iterator>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_iterator)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_iterator>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_iterator)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_iterator_open0_std_output_iterator_tag_void_void_void_void_close0_instantiation_1(
) {
    assert_eq!(
        ::std::mem::size_of::<std_iterator>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_iterator)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_iterator>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_iterator)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_iterator_open0_std_output_iterator_tag_void_void_void_void_close0_instantiation_2(
) {
    assert_eq!(
        ::std::mem::size_of::<std_iterator>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_iterator)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_iterator>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_iterator)
        )
    );
}
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __uint64_t = ::std::os::raw::c_ulong;
pub type __int_least8_t = __int8_t;
pub type __int8_t = ::std::os::raw::c_schar;
pub type __int_least16_t = __int16_t;
pub type __int16_t = ::std::os::raw::c_short;
pub type __int_least32_t = __int32_t;
pub type __int32_t = ::std::os::raw::c_int;
pub type __int_least64_t = __int64_t;
pub type __int64_t = ::std::os::raw::c_long;
pub type __uint_least8_t = __uint8_t;
pub type __uint_least16_t = __uint16_t;
pub type __uint_least32_t = __uint32_t;
pub type __uint_least64_t = __uint64_t;
pub type __intmax_t = ::std::os::raw::c_long;
pub type __uintmax_t = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_39 {
    pub _address: u8,
}
#[test]
fn __bindgen_test_layout_std_hash_open0_long_double_close0_instantiation_1() {
    assert_eq!(
        ::std::mem::size_of::<std_hash>(),
        1usize,
        concat!("Size of template specialization: ", stringify!(std_hash))
    );
    assert_eq!(
        ::std::mem::align_of::<std_hash>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_hash)
        )
    );
}
#[repr(C)]
pub struct exception__bindgen_vtable(::std::os::raw::c_void);
#[repr(C)]
#[derive(Debug)]
pub struct exception {
    pub vtable_: *const exception__bindgen_vtable,
}
#[test]
fn bindgen_test_layout_exception() {
    assert_eq!(
        ::std::mem::size_of::<exception>(),
        8usize,
        concat!("Size of: ", stringify!(exception))
    );
    assert_eq!(
        ::std::mem::align_of::<exception>(),
        8usize,
        concat!("Alignment of ", stringify!(exception))
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNSt9exceptionD1Ev"]
    pub fn exception_exception_destructor(this: *mut exception);
}
extern "C" {
    #[link_name = "\u{1}_ZNKSt9exception4whatEv"]
    pub fn exception_what(this: *mut ::std::os::raw::c_void) -> *const ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_40 {
    pub _address: u8,
}
#[test]
fn __bindgen_test_layout_std_allocator_open0_void_close0_instantiation_2() {
    assert_eq!(
        ::std::mem::size_of::<std_allocator>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_allocator)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_allocator>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_allocator)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_pair_open0_bool__std_size_t_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_pair<bool, usize>>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify ! (std_pair < bool , usize >)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_pair<bool, usize>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify ! (std_pair < bool , usize >)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_pair_open0_bool__std_size_t_close0_instantiation_1() {
    assert_eq!(
        ::std::mem::size_of::<std_pair<bool, usize>>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify ! (std_pair < bool , usize >)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_pair<bool, usize>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify ! (std_pair < bool , usize >)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_iterator_open0_std_random_access_iterator_tag_bool__long_ptr_bool_ref_bool_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<std_iterator>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_iterator)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_iterator>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_iterator)
        )
    );
}
pub type iterator = std__Bit_iterator;
pub type size_type = usize;
pub type iterator = std__Bit_iterator;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_41 {
    pub _address: u8,
}
#[test]
fn __bindgen_test_layout_std_equal_to_open0_void_close0_instantiation_1() {
    assert_eq!(
        ::std::mem::size_of::<std_equal_to>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_equal_to)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_equal_to>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_equal_to)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_basic_string_open0_char_std_char_traits_open1_char_close1_std_allocator_open1_char_close1_close0_instantiation_1(
) {
    assert_eq!(
        ::std::mem::size_of::<std_basic_string<::std::os::raw::c_char>>(),
        32usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_basic_string<::std::os::raw::c_char>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_basic_string<::std::os::raw::c_char>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_basic_string<::std::os::raw::c_char>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_char_traits_open0_char_close0_instantiation_2() {
    assert_eq!(
        ::std::mem::size_of::<std_char_traits>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_char_traits)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_char_traits>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_char_traits)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_allocator_open0_char_close0_instantiation_1() {
    assert_eq!(
        ::std::mem::size_of::<std_allocator>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_allocator)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_allocator>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_allocator)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_basic_string_open0_wchar_t_std_char_traits_open1_wchar_t_close1_std_allocator_open1_wchar_t_close1_close0_instantiation_1(
) {
    assert_eq!(
        ::std::mem::size_of::<std_basic_string<u32>>(),
        32usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_basic_string<u32>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_basic_string<u32>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_basic_string<u32>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_char_traits_open0_wchar_t_close0_instantiation_2() {
    assert_eq!(
        ::std::mem::size_of::<std_char_traits>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_char_traits)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_char_traits>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_char_traits)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_allocator_open0_wchar_t_close0_instantiation_1() {
    assert_eq!(
        ::std::mem::size_of::<std_allocator>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_allocator)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_allocator>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_allocator)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_basic_string_open0_char16_t_std_char_traits_open1_char16_t_close1_std_allocator_open1_char16_t_close1_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<std_basic_string<u16>>(),
        32usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_basic_string<u16>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_basic_string<u16>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_basic_string<u16>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_char_traits_open0_char16_t_close0_instantiation_2() {
    assert_eq!(
        ::std::mem::size_of::<std_char_traits>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_char_traits)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_char_traits>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_char_traits)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_allocator_open0_char16_t_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_allocator>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_allocator)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_allocator>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_allocator)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_basic_string_open0_char32_t_std_char_traits_open1_char32_t_close1_std_allocator_open1_char32_t_close1_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<std_basic_string<u32>>(),
        32usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_basic_string<u32>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_basic_string<u32>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_basic_string<u32>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_char_traits_open0_char32_t_close0_instantiation_2() {
    assert_eq!(
        ::std::mem::size_of::<std_char_traits>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_char_traits)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_char_traits>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_char_traits)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_allocator_open0_char32_t_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_allocator>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_allocator)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_allocator>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_allocator)
        )
    );
}
pub type __builtin_va_list = [__va_list_tag; 1usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __va_list_tag {
    pub gp_offset: ::std::os::raw::c_uint,
    pub fp_offset: ::std::os::raw::c_uint,
    pub overflow_arg_area: *mut ::std::os::raw::c_void,
    pub reg_save_area: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout___va_list_tag() {
    const UNINIT: ::std::mem::MaybeUninit<__va_list_tag> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__va_list_tag>(),
        24usize,
        concat!("Size of: ", stringify!(__va_list_tag))
    );
    assert_eq!(
        ::std::mem::align_of::<__va_list_tag>(),
        8usize,
        concat!("Alignment of ", stringify!(__va_list_tag))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gp_offset) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(gp_offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fp_offset) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(fp_offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).overflow_arg_area) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(overflow_arg_area)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reg_save_area) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(reg_save_area)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_FILE {
    pub _flags: ::std::os::raw::c_int,
    pub _IO_read_ptr: *mut ::std::os::raw::c_char,
    pub _IO_read_end: *mut ::std::os::raw::c_char,
    pub _IO_read_base: *mut ::std::os::raw::c_char,
    pub _IO_write_base: *mut ::std::os::raw::c_char,
    pub _IO_write_ptr: *mut ::std::os::raw::c_char,
    pub _IO_write_end: *mut ::std::os::raw::c_char,
    pub _IO_buf_base: *mut ::std::os::raw::c_char,
    pub _IO_buf_end: *mut ::std::os::raw::c_char,
    pub _IO_save_base: *mut ::std::os::raw::c_char,
    pub _IO_backup_base: *mut ::std::os::raw::c_char,
    pub _IO_save_end: *mut ::std::os::raw::c_char,
    pub _markers: *mut _IO_marker,
    pub _chain: *mut _IO_FILE,
    pub _fileno: ::std::os::raw::c_int,
    pub _flags2: ::std::os::raw::c_int,
    pub _old_offset: _IO_FILE___off_t,
    pub _cur_column: ::std::os::raw::c_ushort,
    pub _vtable_offset: ::std::os::raw::c_schar,
    pub _shortbuf: [::std::os::raw::c_char; 1usize],
    pub _lock: *mut _IO_lock_t,
    pub _offset: _IO_FILE___off64_t,
    pub _codecvt: *mut _IO_codecvt,
    pub _wide_data: *mut _IO_wide_data,
    pub _freeres_list: *mut _IO_FILE,
    pub _freeres_buf: *mut ::std::os::raw::c_void,
    pub __pad5: usize,
    pub _mode: ::std::os::raw::c_int,
    pub _unused2: [::std::os::raw::c_char; 20usize],
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_marker {
    pub _address: u8,
}
pub type _IO_FILE___off_t = ::std::os::raw::c_long;
pub type _IO_lock_t = ::std::os::raw::c_void;
pub type _IO_FILE___off64_t = ::std::os::raw::c_long;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_codecvt {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_wide_data {
    pub _address: u8,
}
#[test]
fn __bindgen_test_layout_std_char_traits_open0_char_close0_instantiation_3() {
    assert_eq!(
        ::std::mem::size_of::<std_char_traits>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_char_traits)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_char_traits>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_char_traits)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_basic_streambuf_open0_char_std_char_traits_open1_char_close1_close0_instantiation_1(
) {
    assert_eq!(
        ::std::mem::size_of::<std_basic_streambuf<::std::os::raw::c_char>>(),
        64usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_basic_streambuf<::std::os::raw::c_char>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_basic_streambuf<::std::os::raw::c_char>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_basic_streambuf<::std::os::raw::c_char>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_char_traits_open0_char_close0_instantiation_4() {
    assert_eq!(
        ::std::mem::size_of::<std_char_traits>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_char_traits)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_char_traits>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_char_traits)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_char_traits_open0_char_close0_instantiation_5() {
    assert_eq!(
        ::std::mem::size_of::<std_char_traits>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_char_traits)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_char_traits>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_char_traits)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_char_traits_open0_char_close0_instantiation_6() {
    assert_eq!(
        ::std::mem::size_of::<std_char_traits>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_char_traits)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_char_traits>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_char_traits)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_char_traits_open0_char_close0_instantiation_7() {
    assert_eq!(
        ::std::mem::size_of::<std_char_traits>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_char_traits)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_char_traits>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_char_traits)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_char_traits_open0_char_close0_instantiation_8() {
    assert_eq!(
        ::std::mem::size_of::<std_char_traits>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_char_traits)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_char_traits>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_char_traits)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_allocator_open0_char_close0_instantiation_2() {
    assert_eq!(
        ::std::mem::size_of::<std_allocator>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_allocator)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_allocator>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_allocator)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_char_traits_open0_char_close0_instantiation_9() {
    assert_eq!(
        ::std::mem::size_of::<std_char_traits>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_char_traits)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_char_traits>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_char_traits)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_allocator_open0_char_close0_instantiation_3() {
    assert_eq!(
        ::std::mem::size_of::<std_allocator>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_allocator)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_allocator>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_allocator)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_char_traits_open0_char_close0_instantiation_10() {
    assert_eq!(
        ::std::mem::size_of::<std_char_traits>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_char_traits)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_char_traits>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_char_traits)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_allocator_open0_char_close0_instantiation_4() {
    assert_eq!(
        ::std::mem::size_of::<std_allocator>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_allocator)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_allocator>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_allocator)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_char_traits_open0_char_close0_instantiation_11() {
    assert_eq!(
        ::std::mem::size_of::<std_char_traits>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_char_traits)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_char_traits>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_char_traits)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_allocator_open0_char_close0_instantiation_5() {
    assert_eq!(
        ::std::mem::size_of::<std_allocator>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_allocator)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_allocator>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_allocator)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_char_traits_open0_char_close0_instantiation_12() {
    assert_eq!(
        ::std::mem::size_of::<std_char_traits>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_char_traits)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_char_traits>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_char_traits)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_char_traits_open0_char_close0_instantiation_13() {
    assert_eq!(
        ::std::mem::size_of::<std_char_traits>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_char_traits)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_char_traits>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_char_traits)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_char_traits_open0_char_close0_instantiation_14() {
    assert_eq!(
        ::std::mem::size_of::<std_char_traits>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_char_traits)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_char_traits>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_char_traits)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_char_traits_open0_char_close0_instantiation_15() {
    assert_eq!(
        ::std::mem::size_of::<std_char_traits>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_char_traits)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_char_traits>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_char_traits)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_char_traits_open0_wchar_t_close0_instantiation_3() {
    assert_eq!(
        ::std::mem::size_of::<std_char_traits>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_char_traits)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_char_traits>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_char_traits)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_basic_streambuf_open0_wchar_t_std_char_traits_open1_wchar_t_close1_close0_instantiation_1(
) {
    assert_eq!(
        ::std::mem::size_of::<std_basic_streambuf<u32>>(),
        64usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_basic_streambuf<u32>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_basic_streambuf<u32>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_basic_streambuf<u32>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_char_traits_open0_wchar_t_close0_instantiation_4() {
    assert_eq!(
        ::std::mem::size_of::<std_char_traits>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_char_traits)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_char_traits>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_char_traits)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_char_traits_open0_wchar_t_close0_instantiation_5() {
    assert_eq!(
        ::std::mem::size_of::<std_char_traits>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_char_traits)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_char_traits>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_char_traits)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_char_traits_open0_wchar_t_close0_instantiation_6() {
    assert_eq!(
        ::std::mem::size_of::<std_char_traits>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_char_traits)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_char_traits>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_char_traits)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_char_traits_open0_wchar_t_close0_instantiation_7() {
    assert_eq!(
        ::std::mem::size_of::<std_char_traits>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_char_traits)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_char_traits>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_char_traits)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_char_traits_open0_wchar_t_close0_instantiation_8() {
    assert_eq!(
        ::std::mem::size_of::<std_char_traits>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_char_traits)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_char_traits>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_char_traits)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_allocator_open0_wchar_t_close0_instantiation_2() {
    assert_eq!(
        ::std::mem::size_of::<std_allocator>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_allocator)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_allocator>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_allocator)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_char_traits_open0_wchar_t_close0_instantiation_9() {
    assert_eq!(
        ::std::mem::size_of::<std_char_traits>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_char_traits)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_char_traits>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_char_traits)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_allocator_open0_wchar_t_close0_instantiation_3() {
    assert_eq!(
        ::std::mem::size_of::<std_allocator>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_allocator)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_allocator>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_allocator)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_char_traits_open0_wchar_t_close0_instantiation_10() {
    assert_eq!(
        ::std::mem::size_of::<std_char_traits>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_char_traits)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_char_traits>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_char_traits)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_allocator_open0_wchar_t_close0_instantiation_4() {
    assert_eq!(
        ::std::mem::size_of::<std_allocator>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_allocator)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_allocator>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_allocator)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_char_traits_open0_wchar_t_close0_instantiation_11() {
    assert_eq!(
        ::std::mem::size_of::<std_char_traits>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_char_traits)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_char_traits>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_char_traits)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_allocator_open0_wchar_t_close0_instantiation_5() {
    assert_eq!(
        ::std::mem::size_of::<std_allocator>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_allocator)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_allocator>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_allocator)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_char_traits_open0_wchar_t_close0_instantiation_12() {
    assert_eq!(
        ::std::mem::size_of::<std_char_traits>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_char_traits)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_char_traits>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_char_traits)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_char_traits_open0_wchar_t_close0_instantiation_13() {
    assert_eq!(
        ::std::mem::size_of::<std_char_traits>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_char_traits)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_char_traits>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_char_traits)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_char_traits_open0_wchar_t_close0_instantiation_14() {
    assert_eq!(
        ::std::mem::size_of::<std_char_traits>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_char_traits)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_char_traits>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_char_traits)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_char_traits_open0_wchar_t_close0_instantiation_15() {
    assert_eq!(
        ::std::mem::size_of::<std_char_traits>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_char_traits)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_char_traits>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_char_traits)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_iterator_open0_std_output_iterator_tag_void_void_void_void_close0_instantiation_3(
) {
    assert_eq!(
        ::std::mem::size_of::<std_iterator>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_iterator)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_iterator>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_iterator)
        )
    );
}
pub type __locale_t = *mut __locale_struct;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __locale_struct {
    pub __locales: [*mut __locale_data; 13usize],
    pub __ctype_b: *const ::std::os::raw::c_ushort,
    pub __ctype_tolower: *const ::std::os::raw::c_int,
    pub __ctype_toupper: *const ::std::os::raw::c_int,
    pub __names: [*const ::std::os::raw::c_char; 13usize],
}
#[test]
fn bindgen_test_layout___locale_struct() {
    const UNINIT: ::std::mem::MaybeUninit<__locale_struct> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__locale_struct>(),
        232usize,
        concat!("Size of: ", stringify!(__locale_struct))
    );
    assert_eq!(
        ::std::mem::align_of::<__locale_struct>(),
        8usize,
        concat!("Alignment of ", stringify!(__locale_struct))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__locales) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__locales)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__ctype_b) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__ctype_b)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__ctype_tolower) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__ctype_tolower)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__ctype_toupper) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__ctype_toupper)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__names) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__names)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __locale_data {
    pub _address: u8,
}
pub type timex___syscall_slong_t = ::std::os::raw::c_long;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timex_timeval {
    pub tv_sec: timex_timeval___time_t,
    pub tv_usec: timex_timeval___suseconds_t,
}
#[test]
fn bindgen_test_layout_timex_timeval() {
    const UNINIT: ::std::mem::MaybeUninit<timex_timeval> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<timex_timeval>(),
        16usize,
        concat!("Size of: ", stringify!(timex_timeval))
    );
    assert_eq!(
        ::std::mem::align_of::<timex_timeval>(),
        8usize,
        concat!("Alignment of ", stringify!(timex_timeval))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tv_sec) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timex_timeval),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tv_usec) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(timex_timeval),
            "::",
            stringify!(tv_usec)
        )
    );
}
pub type timex_timeval___time_t = ::std::os::raw::c_long;
pub type timex_timeval___suseconds_t = ::std::os::raw::c_long;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct itimerspec_timespec {
    pub tv_sec: timex_timeval___time_t,
    pub tv_nsec: timex___syscall_slong_t,
}
#[test]
fn bindgen_test_layout_itimerspec_timespec() {
    const UNINIT: ::std::mem::MaybeUninit<itimerspec_timespec> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<itimerspec_timespec>(),
        16usize,
        concat!("Size of: ", stringify!(itimerspec_timespec))
    );
    assert_eq!(
        ::std::mem::align_of::<itimerspec_timespec>(),
        8usize,
        concat!("Alignment of ", stringify!(itimerspec_timespec))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tv_sec) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(itimerspec_timespec),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tv_nsec) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(itimerspec_timespec),
            "::",
            stringify!(tv_nsec)
        )
    );
}
pub type pthread_t = ::std::os::raw::c_ulong;
pub type pthread_key_t = ::std::os::raw::c_uint;
pub type pthread_once_t = ::std::os::raw::c_int;
#[test]
fn __bindgen_test_layout_std_basic_string_view_open0_char_std_char_traits_open1_char_close1_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<std_basic_string_view<::std::os::raw::c_char>>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_basic_string_view<::std::os::raw::c_char>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_basic_string_view<::std::os::raw::c_char>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_basic_string_view<::std::os::raw::c_char>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_char_traits_open0_char_close0_instantiation_16() {
    assert_eq!(
        ::std::mem::size_of::<std_char_traits>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_char_traits)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_char_traits>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_char_traits)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_basic_string_view_open0_wchar_t_std_char_traits_open1_wchar_t_close1_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<std_basic_string_view<u32>>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_basic_string_view<u32>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_basic_string_view<u32>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_basic_string_view<u32>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_char_traits_open0_wchar_t_close0_instantiation_16() {
    assert_eq!(
        ::std::mem::size_of::<std_char_traits>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_char_traits)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_char_traits>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_char_traits)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_basic_string_view_open0_char16_t_std_char_traits_open1_char16_t_close1_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<std_basic_string_view<u16>>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_basic_string_view<u16>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_basic_string_view<u16>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_basic_string_view<u16>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_char_traits_open0_char16_t_close0_instantiation_3() {
    assert_eq!(
        ::std::mem::size_of::<std_char_traits>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_char_traits)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_char_traits>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_char_traits)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_basic_string_view_open0_char32_t_std_char_traits_open1_char32_t_close1_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<std_basic_string_view<u32>>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_basic_string_view<u32>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_basic_string_view<u32>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_basic_string_view<u32>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_char_traits_open0_char32_t_close0_instantiation_3() {
    assert_eq!(
        ::std::mem::size_of::<std_char_traits>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_char_traits)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_char_traits>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_char_traits)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_basic_string_view_open0_char_std_char_traits_open1_char_close1_close0_instantiation_1(
) {
    assert_eq!(
        ::std::mem::size_of::<std_basic_string_view<::std::os::raw::c_char>>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_basic_string_view<::std::os::raw::c_char>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_basic_string_view<::std::os::raw::c_char>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_basic_string_view<::std::os::raw::c_char>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_char_traits_open0_char_close0_instantiation_17() {
    assert_eq!(
        ::std::mem::size_of::<std_char_traits>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_char_traits)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_char_traits>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_char_traits)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_hash_open0_std_basic_string_view_open1_char_std_char_traits_open2_char_close2_close1_close0_instantiation_1(
) {
    assert_eq!(
        ::std::mem::size_of::<std_hash>(),
        1usize,
        concat!("Size of template specialization: ", stringify!(std_hash))
    );
    assert_eq!(
        ::std::mem::align_of::<std_hash>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_hash)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_basic_string_view_open0_char_std_char_traits_open1_char_close1_close0_instantiation_2(
) {
    assert_eq!(
        ::std::mem::size_of::<std_basic_string_view<::std::os::raw::c_char>>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_basic_string_view<::std::os::raw::c_char>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_basic_string_view<::std::os::raw::c_char>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_basic_string_view<::std::os::raw::c_char>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_char_traits_open0_char_close0_instantiation_18() {
    assert_eq!(
        ::std::mem::size_of::<std_char_traits>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_char_traits)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_char_traits>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_char_traits)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_basic_string_view_open0_wchar_t_std_char_traits_open1_wchar_t_close1_close0_instantiation_1(
) {
    assert_eq!(
        ::std::mem::size_of::<std_basic_string_view<u32>>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_basic_string_view<u32>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_basic_string_view<u32>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_basic_string_view<u32>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_char_traits_open0_wchar_t_close0_instantiation_17() {
    assert_eq!(
        ::std::mem::size_of::<std_char_traits>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_char_traits)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_char_traits>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_char_traits)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_hash_open0_std_basic_string_view_open1_wchar_t_std_char_traits_open2_wchar_t_close2_close1_close0_instantiation_1(
) {
    assert_eq!(
        ::std::mem::size_of::<std_hash>(),
        1usize,
        concat!("Size of template specialization: ", stringify!(std_hash))
    );
    assert_eq!(
        ::std::mem::align_of::<std_hash>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_hash)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_basic_string_view_open0_wchar_t_std_char_traits_open1_wchar_t_close1_close0_instantiation_2(
) {
    assert_eq!(
        ::std::mem::size_of::<std_basic_string_view<u32>>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_basic_string_view<u32>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_basic_string_view<u32>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_basic_string_view<u32>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_char_traits_open0_wchar_t_close0_instantiation_18() {
    assert_eq!(
        ::std::mem::size_of::<std_char_traits>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_char_traits)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_char_traits>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_char_traits)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_basic_string_view_open0_char16_t_std_char_traits_open1_char16_t_close1_close0_instantiation_1(
) {
    assert_eq!(
        ::std::mem::size_of::<std_basic_string_view<u16>>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_basic_string_view<u16>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_basic_string_view<u16>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_basic_string_view<u16>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_char_traits_open0_char16_t_close0_instantiation_4() {
    assert_eq!(
        ::std::mem::size_of::<std_char_traits>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_char_traits)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_char_traits>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_char_traits)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_hash_open0_std_basic_string_view_open1_char16_t_std_char_traits_open2_char16_t_close2_close1_close0_instantiation_1(
) {
    assert_eq!(
        ::std::mem::size_of::<std_hash>(),
        1usize,
        concat!("Size of template specialization: ", stringify!(std_hash))
    );
    assert_eq!(
        ::std::mem::align_of::<std_hash>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_hash)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_basic_string_view_open0_char16_t_std_char_traits_open1_char16_t_close1_close0_instantiation_2(
) {
    assert_eq!(
        ::std::mem::size_of::<std_basic_string_view<u16>>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_basic_string_view<u16>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_basic_string_view<u16>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_basic_string_view<u16>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_char_traits_open0_char16_t_close0_instantiation_5() {
    assert_eq!(
        ::std::mem::size_of::<std_char_traits>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_char_traits)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_char_traits>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_char_traits)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_basic_string_view_open0_char32_t_std_char_traits_open1_char32_t_close1_close0_instantiation_1(
) {
    assert_eq!(
        ::std::mem::size_of::<std_basic_string_view<u32>>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_basic_string_view<u32>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_basic_string_view<u32>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_basic_string_view<u32>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_char_traits_open0_char32_t_close0_instantiation_4() {
    assert_eq!(
        ::std::mem::size_of::<std_char_traits>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_char_traits)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_char_traits>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_char_traits)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_hash_open0_std_basic_string_view_open1_char32_t_std_char_traits_open2_char32_t_close2_close1_close0_instantiation_1(
) {
    assert_eq!(
        ::std::mem::size_of::<std_hash>(),
        1usize,
        concat!("Size of template specialization: ", stringify!(std_hash))
    );
    assert_eq!(
        ::std::mem::align_of::<std_hash>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_hash)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_basic_string_view_open0_char32_t_std_char_traits_open1_char32_t_close1_close0_instantiation_2(
) {
    assert_eq!(
        ::std::mem::size_of::<std_basic_string_view<u32>>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_basic_string_view<u32>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_basic_string_view<u32>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_basic_string_view<u32>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_char_traits_open0_char32_t_close0_instantiation_5() {
    assert_eq!(
        ::std::mem::size_of::<std_char_traits>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_char_traits)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_char_traits>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_char_traits)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_char_traits_open0_char_close0_instantiation_19() {
    assert_eq!(
        ::std::mem::size_of::<std_char_traits>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_char_traits)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_char_traits>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_char_traits)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_basic_string_open0_char_std_char_traits_open1_char_close1_std_allocator_open1_char_close1_close0_instantiation_2(
) {
    assert_eq!(
        ::std::mem::size_of::<std_basic_string<::std::os::raw::c_char>>(),
        32usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_basic_string<::std::os::raw::c_char>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_basic_string<::std::os::raw::c_char>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_basic_string<::std::os::raw::c_char>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_char_traits_open0_char_close0_instantiation_20() {
    assert_eq!(
        ::std::mem::size_of::<std_char_traits>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_char_traits)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_char_traits>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_char_traits)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_allocator_open0_char_close0_instantiation_6() {
    assert_eq!(
        ::std::mem::size_of::<std_allocator>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_allocator)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_allocator>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_allocator)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_char_traits_open0_char_close0_instantiation_21() {
    assert_eq!(
        ::std::mem::size_of::<std_char_traits>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_char_traits)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_char_traits>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_char_traits)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_char_traits_open0_wchar_t_close0_instantiation_19() {
    assert_eq!(
        ::std::mem::size_of::<std_char_traits>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_char_traits)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_char_traits>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_char_traits)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_basic_string_open0_wchar_t_std_char_traits_open1_wchar_t_close1_std_allocator_open1_wchar_t_close1_close0_instantiation_2(
) {
    assert_eq!(
        ::std::mem::size_of::<std_basic_string<u32>>(),
        32usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_basic_string<u32>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_basic_string<u32>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_basic_string<u32>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_char_traits_open0_wchar_t_close0_instantiation_20() {
    assert_eq!(
        ::std::mem::size_of::<std_char_traits>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_char_traits)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_char_traits>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_char_traits)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_allocator_open0_wchar_t_close0_instantiation_6() {
    assert_eq!(
        ::std::mem::size_of::<std_allocator>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_allocator)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_allocator>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_allocator)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_char_traits_open0_wchar_t_close0_instantiation_21() {
    assert_eq!(
        ::std::mem::size_of::<std_char_traits>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_char_traits)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_char_traits>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_char_traits)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_basic_string_open0_char_std_char_traits_open1_char_close1_std_allocator_open1_char_close1_close0_instantiation_3(
) {
    assert_eq!(
        ::std::mem::size_of::<std_basic_string<::std::os::raw::c_char>>(),
        32usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_basic_string<::std::os::raw::c_char>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_basic_string<::std::os::raw::c_char>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_basic_string<::std::os::raw::c_char>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_char_traits_open0_char_close0_instantiation_22() {
    assert_eq!(
        ::std::mem::size_of::<std_char_traits>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_char_traits)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_char_traits>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_char_traits)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_allocator_open0_char_close0_instantiation_7() {
    assert_eq!(
        ::std::mem::size_of::<std_allocator>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_allocator)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_allocator>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_allocator)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_basic_string_open0_wchar_t_std_char_traits_open1_wchar_t_close1_std_allocator_open1_wchar_t_close1_close0_instantiation_3(
) {
    assert_eq!(
        ::std::mem::size_of::<std_basic_string<u32>>(),
        32usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_basic_string<u32>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_basic_string<u32>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_basic_string<u32>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_char_traits_open0_wchar_t_close0_instantiation_22() {
    assert_eq!(
        ::std::mem::size_of::<std_char_traits>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_char_traits)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_char_traits>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_char_traits)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_allocator_open0_wchar_t_close0_instantiation_7() {
    assert_eq!(
        ::std::mem::size_of::<std_allocator>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_allocator)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_allocator>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_allocator)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_basic_string_open0_char16_t_std_char_traits_open1_char16_t_close1_std_allocator_open1_char16_t_close1_close0_instantiation_1(
) {
    assert_eq!(
        ::std::mem::size_of::<std_basic_string<u16>>(),
        32usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_basic_string<u16>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_basic_string<u16>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_basic_string<u16>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_char_traits_open0_char16_t_close0_instantiation_6() {
    assert_eq!(
        ::std::mem::size_of::<std_char_traits>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_char_traits)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_char_traits>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_char_traits)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_allocator_open0_char16_t_close0_instantiation_1() {
    assert_eq!(
        ::std::mem::size_of::<std_allocator>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_allocator)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_allocator>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_allocator)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_basic_string_open0_char32_t_std_char_traits_open1_char32_t_close1_std_allocator_open1_char32_t_close1_close0_instantiation_1(
) {
    assert_eq!(
        ::std::mem::size_of::<std_basic_string<u32>>(),
        32usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_basic_string<u32>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_basic_string<u32>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_basic_string<u32>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_char_traits_open0_char32_t_close0_instantiation_6() {
    assert_eq!(
        ::std::mem::size_of::<std_char_traits>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_char_traits)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_char_traits>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_char_traits)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_allocator_open0_char32_t_close0_instantiation_1() {
    assert_eq!(
        ::std::mem::size_of::<std_allocator>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_allocator)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_allocator>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_allocator)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_char_traits_open0_char_close0_instantiation_23() {
    assert_eq!(
        ::std::mem::size_of::<std_char_traits>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_char_traits)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_char_traits>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_char_traits)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_allocator_open0_char_close0_instantiation_8() {
    assert_eq!(
        ::std::mem::size_of::<std_allocator>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_allocator)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_allocator>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_allocator)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_char_traits_open0_wchar_t_close0_instantiation_23() {
    assert_eq!(
        ::std::mem::size_of::<std_char_traits>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_char_traits)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_char_traits>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_char_traits)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_allocator_open0_wchar_t_close0_instantiation_8() {
    assert_eq!(
        ::std::mem::size_of::<std_allocator>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_allocator)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_allocator>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_allocator)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_char_traits_open0_char_close0_instantiation_24() {
    assert_eq!(
        ::std::mem::size_of::<std_char_traits>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_char_traits)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_char_traits>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_char_traits)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_char_traits_open0_char16_t_close0_instantiation_7() {
    assert_eq!(
        ::std::mem::size_of::<std_char_traits>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_char_traits)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_char_traits>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_char_traits)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_char_traits_open0_char32_t_close0_instantiation_7() {
    assert_eq!(
        ::std::mem::size_of::<std_char_traits>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_char_traits)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_char_traits>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_char_traits)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_char_traits_open0_wchar_t_close0_instantiation_24() {
    assert_eq!(
        ::std::mem::size_of::<std_char_traits>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_char_traits)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_char_traits>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_char_traits)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNSt9type_infoD1Ev"]
    pub fn std_type_info_type_info_destructor(this: *mut std_type_info);
}
extern "C" {
    #[link_name = "\u{1}_ZNKSt9type_info14__is_pointer_pEv"]
    pub fn std_type_info___is_pointer_p(this: *mut ::std::os::raw::c_void) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZNKSt9type_info15__is_function_pEv"]
    pub fn std_type_info___is_function_p(this: *mut ::std::os::raw::c_void) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZNKSt9type_info10__do_catchEPKS_PPvj"]
    pub fn std_type_info___do_catch(
        this: *mut ::std::os::raw::c_void,
        __thr_type: *mut std_type_info,
        __thr_obj: *mut *mut ::std::os::raw::c_void,
        __outer: ::std::os::raw::c_uint,
    ) -> bool;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __class_type_info {
    _unused: [u8; 0],
}
extern "C" {
    #[link_name = "\u{1}_ZNKSt9type_info11__do_upcastEPKN10__cxxabiv117__class_type_infoEPPv"]
    pub fn std_type_info___do_upcast(
        this: *mut ::std::os::raw::c_void,
        __target: *mut __class_type_info,
        __obj_ptr: *mut *mut ::std::os::raw::c_void,
    ) -> bool;
}
#[test]
fn __bindgen_test_layout_std_basic_string_open0_char_std_char_traits_open1_char_close1_std_allocator_open1_char_close1_close0_instantiation_4(
) {
    assert_eq!(
        ::std::mem::size_of::<std_basic_string<::std::os::raw::c_char>>(),
        32usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_basic_string<::std::os::raw::c_char>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_basic_string<::std::os::raw::c_char>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_basic_string<::std::os::raw::c_char>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_char_traits_open0_char_close0_instantiation_25() {
    assert_eq!(
        ::std::mem::size_of::<std_char_traits>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_char_traits)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_char_traits>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_char_traits)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_allocator_open0_char_close0_instantiation_9() {
    assert_eq!(
        ::std::mem::size_of::<std_allocator>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_allocator)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_allocator>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_allocator)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_basic_streambuf_open0_char_std_char_traits_open1_char_close1_close0_instantiation_2(
) {
    assert_eq!(
        ::std::mem::size_of::<std_basic_streambuf<::std::os::raw::c_char>>(),
        64usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_basic_streambuf<::std::os::raw::c_char>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_basic_streambuf<::std::os::raw::c_char>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_basic_streambuf<::std::os::raw::c_char>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_char_traits_open0_char_close0_instantiation_26() {
    assert_eq!(
        ::std::mem::size_of::<std_char_traits>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_char_traits)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_char_traits>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_char_traits)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_basic_streambuf_open0_char_std_char_traits_open1_char_close1_close0_instantiation_3(
) {
    assert_eq!(
        ::std::mem::size_of::<std_basic_streambuf<::std::os::raw::c_char>>(),
        64usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_basic_streambuf<::std::os::raw::c_char>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_basic_streambuf<::std::os::raw::c_char>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_basic_streambuf<::std::os::raw::c_char>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_char_traits_open0_char_close0_instantiation_27() {
    assert_eq!(
        ::std::mem::size_of::<std_char_traits>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_char_traits)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_char_traits>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_char_traits)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_basic_streambuf_open0_wchar_t_std_char_traits_open1_wchar_t_close1_close0_instantiation_2(
) {
    assert_eq!(
        ::std::mem::size_of::<std_basic_streambuf<u32>>(),
        64usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_basic_streambuf<u32>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_basic_streambuf<u32>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_basic_streambuf<u32>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_char_traits_open0_wchar_t_close0_instantiation_25() {
    assert_eq!(
        ::std::mem::size_of::<std_char_traits>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_char_traits)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_char_traits>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_char_traits)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_basic_streambuf_open0_wchar_t_std_char_traits_open1_wchar_t_close1_close0_instantiation_3(
) {
    assert_eq!(
        ::std::mem::size_of::<std_basic_streambuf<u32>>(),
        64usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_basic_streambuf<u32>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_basic_streambuf<u32>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_basic_streambuf<u32>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_char_traits_open0_wchar_t_close0_instantiation_26() {
    assert_eq!(
        ::std::mem::size_of::<std_char_traits>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_char_traits)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_char_traits>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_char_traits)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_char_traits_open0_char_close0_instantiation_28() {
    assert_eq!(
        ::std::mem::size_of::<std_char_traits>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_char_traits)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_char_traits>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_char_traits)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_char_traits_open0_wchar_t_close0_instantiation_27() {
    assert_eq!(
        ::std::mem::size_of::<std_char_traits>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_char_traits)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_char_traits>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_char_traits)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_iterator_open0_std_output_iterator_tag_void_void_void_void_close0_instantiation_4(
) {
    assert_eq!(
        ::std::mem::size_of::<std_iterator>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_iterator)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_iterator>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_iterator)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_iterator_open0_std_output_iterator_tag_void_void_void_void_close0_instantiation_5(
) {
    assert_eq!(
        ::std::mem::size_of::<std_iterator>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_iterator)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_iterator>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_iterator)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_52 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __atomic_flag_base {
    pub _M_i: std___atomic_flag_data_type,
}
#[test]
fn bindgen_test_layout___atomic_flag_base() {
    const UNINIT: ::std::mem::MaybeUninit<__atomic_flag_base> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__atomic_flag_base>(),
        1usize,
        concat!("Size of: ", stringify!(__atomic_flag_base))
    );
    assert_eq!(
        ::std::mem::align_of::<__atomic_flag_base>(),
        1usize,
        concat!("Alignment of ", stringify!(__atomic_flag_base))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._M_i) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__atomic_flag_base),
            "::",
            stringify!(_M_i)
        )
    );
}
#[test]
fn __bindgen_test_layout_llvm_iterator_facade_base_open0_llvm_detail_index_iterator_std_random_access_iterator_tag_std_size_t_long_ptr_unsigned_long_ref_unsigned_long_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<llvm_iterator_facade_base>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_iterator_facade_base)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_iterator_facade_base>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_iterator_facade_base)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_reverse_iterator_open0_llvm_StringRef_iterator_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_reverse_iterator<llvm_StringRef_iterator>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_reverse_iterator<llvm_StringRef_iterator>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_reverse_iterator<llvm_StringRef_iterator>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_reverse_iterator<llvm_StringRef_iterator>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_reverse_iterator_open0_llvm_StringRef_const_iterator_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<std_reverse_iterator<llvm_StringRef_const_iterator>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_reverse_iterator<llvm_StringRef_const_iterator>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_reverse_iterator<llvm_StringRef_const_iterator>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_reverse_iterator<llvm_StringRef_const_iterator>)
        )
    );
}
#[test]
fn __bindgen_test_layout_llvm_iterator_range_open0_ptr_const_unsigned_char_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<llvm_iterator_range<*const ::std::os::raw::c_uchar>>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_iterator_range<*const ::std::os::raw::c_uchar>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_iterator_range<*const ::std::os::raw::c_uchar>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_iterator_range<*const ::std::os::raw::c_uchar>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_pair_open0_llvm_StringRef_llvm_StringRef_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_pair<llvm_StringRef, llvm_StringRef>>(),
        32usize,
        concat!(
            "Size of template specialization: ",
            stringify ! (std_pair < llvm_StringRef , llvm_StringRef >)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_pair<llvm_StringRef, llvm_StringRef>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify ! (std_pair < llvm_StringRef , llvm_StringRef >)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_pair_open0_llvm_StringRef_llvm_StringRef_close0_instantiation_1() {
    assert_eq!(
        ::std::mem::size_of::<std_pair<llvm_StringRef, llvm_StringRef>>(),
        32usize,
        concat!(
            "Size of template specialization: ",
            stringify ! (std_pair < llvm_StringRef , llvm_StringRef >)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_pair<llvm_StringRef, llvm_StringRef>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify ! (std_pair < llvm_StringRef , llvm_StringRef >)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_pair_open0_llvm_StringRef_llvm_StringRef_close0_instantiation_2() {
    assert_eq!(
        ::std::mem::size_of::<std_pair<llvm_StringRef, llvm_StringRef>>(),
        32usize,
        concat!(
            "Size of template specialization: ",
            stringify ! (std_pair < llvm_StringRef , llvm_StringRef >)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_pair<llvm_StringRef, llvm_StringRef>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify ! (std_pair < llvm_StringRef , llvm_StringRef >)
        )
    );
}
#[test]
fn __bindgen_test_layout_llvm_SmallVectorImpl_open0_llvm_StringRef_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<llvm_SmallVectorImpl>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_SmallVectorImpl)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_SmallVectorImpl>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_SmallVectorImpl)
        )
    );
}
#[test]
fn __bindgen_test_layout_llvm_SmallVectorImpl_open0_llvm_StringRef_close0_instantiation_1() {
    assert_eq!(
        ::std::mem::size_of::<llvm_SmallVectorImpl>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_SmallVectorImpl)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_SmallVectorImpl>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_SmallVectorImpl)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_pair_open0_llvm_StringRef_llvm_StringRef_close0_instantiation_3() {
    assert_eq!(
        ::std::mem::size_of::<std_pair<llvm_StringRef, llvm_StringRef>>(),
        32usize,
        concat!(
            "Size of template specialization: ",
            stringify ! (std_pair < llvm_StringRef , llvm_StringRef >)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_pair<llvm_StringRef, llvm_StringRef>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify ! (std_pair < llvm_StringRef , llvm_StringRef >)
        )
    );
}
#[test]
fn __bindgen_test_layout_llvm_SmallVectorImpl_open0_char_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<llvm_SmallVectorImpl>(),
        24usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_SmallVectorImpl)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_SmallVectorImpl>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_SmallVectorImpl)
        )
    );
}
#[test]
fn __bindgen_test_layout_llvm_SmallVectorImpl_open0_char_close0_instantiation_1() {
    assert_eq!(
        ::std::mem::size_of::<llvm_SmallVectorImpl>(),
        24usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_SmallVectorImpl)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_SmallVectorImpl>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_SmallVectorImpl)
        )
    );
}
#[test]
fn __bindgen_test_layout_llvm_SmallVectorImpl_open0_char_close0_instantiation_2() {
    assert_eq!(
        ::std::mem::size_of::<llvm_SmallVectorImpl>(),
        24usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_SmallVectorImpl)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_SmallVectorImpl>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_SmallVectorImpl)
        )
    );
}
#[test]
fn __bindgen_test_layout_llvm_SmallVectorImpl_open0_char_close0_instantiation_3() {
    assert_eq!(
        ::std::mem::size_of::<llvm_SmallVectorImpl>(),
        24usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_SmallVectorImpl)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_SmallVectorImpl>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_SmallVectorImpl)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_optional_open0_llvm_Align_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_optional>(),
        2usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_optional)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_optional>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_optional)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_optional_open0_llvm_Align_close0_instantiation_1() {
    assert_eq!(
        ::std::mem::size_of::<std_optional>(),
        2usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_optional)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_optional>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_optional)
        )
    );
}
#[test]
fn __bindgen_test_layout_llvm_AlignedCharArrayUnion_open0_std_error_code_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<llvm_AlignedCharArrayUnion>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_AlignedCharArrayUnion)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_AlignedCharArrayUnion>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_AlignedCharArrayUnion)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_optional_open0_llvm_Align_close0_instantiation_2() {
    assert_eq!(
        ::std::mem::size_of::<std_optional>(),
        2usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_optional)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_optional>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_optional)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_unique_ptr_open0_llvm_MemoryBuffer_std_default_delete_open1_llvm_MemoryBuffer_close1_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<std_unique_ptr>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_unique_ptr)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_unique_ptr>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_unique_ptr)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_default_delete_open0_llvm_MemoryBuffer_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_default_delete>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_default_delete)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_default_delete>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_default_delete)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_unique_ptr_open0_llvm_MemoryBuffer_std_default_delete_open1_llvm_MemoryBuffer_close1_close0_instantiation_1(
) {
    assert_eq!(
        ::std::mem::size_of::<std_unique_ptr>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_unique_ptr)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_unique_ptr>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_unique_ptr)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_default_delete_open0_llvm_MemoryBuffer_close0_instantiation_1() {
    assert_eq!(
        ::std::mem::size_of::<std_default_delete>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_default_delete)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_default_delete>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_default_delete)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_optional_open0_llvm_Align_close0_instantiation_3() {
    assert_eq!(
        ::std::mem::size_of::<std_optional>(),
        2usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_optional)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_optional>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_optional)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_unique_ptr_open0_llvm_MemoryBuffer_std_default_delete_open1_llvm_MemoryBuffer_close1_close0_instantiation_2(
) {
    assert_eq!(
        ::std::mem::size_of::<std_unique_ptr>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_unique_ptr)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_unique_ptr>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_unique_ptr)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_default_delete_open0_llvm_MemoryBuffer_close0_instantiation_2() {
    assert_eq!(
        ::std::mem::size_of::<std_default_delete>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_default_delete)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_default_delete>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_default_delete)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_optional_open0_llvm_Align_close0_instantiation_4() {
    assert_eq!(
        ::std::mem::size_of::<std_optional>(),
        2usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_optional)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_optional>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_optional)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_unique_ptr_open0_llvm_MemoryBuffer_std_default_delete_open1_llvm_MemoryBuffer_close1_close0_instantiation_3(
) {
    assert_eq!(
        ::std::mem::size_of::<std_unique_ptr>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_unique_ptr)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_unique_ptr>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_unique_ptr)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_default_delete_open0_llvm_MemoryBuffer_close0_instantiation_3() {
    assert_eq!(
        ::std::mem::size_of::<std_default_delete>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_default_delete)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_default_delete>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_default_delete)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_unique_ptr_open0_llvm_MemoryBuffer_std_default_delete_open1_llvm_MemoryBuffer_close1_close0_instantiation_4(
) {
    assert_eq!(
        ::std::mem::size_of::<std_unique_ptr>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_unique_ptr)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_unique_ptr>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_unique_ptr)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_default_delete_open0_llvm_MemoryBuffer_close0_instantiation_4() {
    assert_eq!(
        ::std::mem::size_of::<std_default_delete>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_default_delete)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_default_delete>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_default_delete)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_unique_ptr_open0_llvm_MemoryBuffer_std_default_delete_open1_llvm_MemoryBuffer_close1_close0_instantiation_5(
) {
    assert_eq!(
        ::std::mem::size_of::<std_unique_ptr>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_unique_ptr)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_unique_ptr>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_unique_ptr)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_default_delete_open0_llvm_MemoryBuffer_close0_instantiation_5() {
    assert_eq!(
        ::std::mem::size_of::<std_default_delete>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_default_delete)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_default_delete>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_default_delete)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_unique_ptr_open0_llvm_MemoryBuffer_std_default_delete_open1_llvm_MemoryBuffer_close1_close0_instantiation_6(
) {
    assert_eq!(
        ::std::mem::size_of::<std_unique_ptr>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_unique_ptr)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_unique_ptr>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_unique_ptr)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_default_delete_open0_llvm_MemoryBuffer_close0_instantiation_6() {
    assert_eq!(
        ::std::mem::size_of::<std_default_delete>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_default_delete)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_default_delete>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_default_delete)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_unique_ptr_open0_llvm_MemoryBuffer_std_default_delete_open1_llvm_MemoryBuffer_close1_close0_instantiation_7(
) {
    assert_eq!(
        ::std::mem::size_of::<std_unique_ptr>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_unique_ptr)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_unique_ptr>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_unique_ptr)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_default_delete_open0_llvm_MemoryBuffer_close0_instantiation_7() {
    assert_eq!(
        ::std::mem::size_of::<std_default_delete>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_default_delete)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_default_delete>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_default_delete)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_optional_open0_llvm_Align_close0_instantiation_5() {
    assert_eq!(
        ::std::mem::size_of::<std_optional>(),
        2usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_optional)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_optional>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_optional)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_unique_ptr_open0_llvm_MemoryBuffer_std_default_delete_open1_llvm_MemoryBuffer_close1_close0_instantiation_8(
) {
    assert_eq!(
        ::std::mem::size_of::<std_unique_ptr>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_unique_ptr)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_unique_ptr>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_unique_ptr)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_default_delete_open0_llvm_MemoryBuffer_close0_instantiation_8() {
    assert_eq!(
        ::std::mem::size_of::<std_default_delete>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_default_delete)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_default_delete>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_default_delete)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_optional_open0_llvm_Align_close0_instantiation_6() {
    assert_eq!(
        ::std::mem::size_of::<std_optional>(),
        2usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_optional)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_optional>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_optional)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_unique_ptr_open0_llvm_MemoryBuffer_std_default_delete_open1_llvm_MemoryBuffer_close1_close0_instantiation_9(
) {
    assert_eq!(
        ::std::mem::size_of::<std_unique_ptr>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_unique_ptr)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_unique_ptr>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_unique_ptr)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_default_delete_open0_llvm_MemoryBuffer_close0_instantiation_9() {
    assert_eq!(
        ::std::mem::size_of::<std_default_delete>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_default_delete)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_default_delete>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_default_delete)
        )
    );
}
#[test]
fn __bindgen_test_layout_llvm_MutableArrayRef_open0_char_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<llvm_MutableArrayRef<::std::os::raw::c_char>>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_MutableArrayRef<::std::os::raw::c_char>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_MutableArrayRef<::std::os::raw::c_char>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_MutableArrayRef<::std::os::raw::c_char>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_optional_open0_llvm_Align_close0_instantiation_7() {
    assert_eq!(
        ::std::mem::size_of::<std_optional>(),
        2usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_optional)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_optional>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_optional)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_optional_open0_llvm_Align_close0_instantiation_8() {
    assert_eq!(
        ::std::mem::size_of::<std_optional>(),
        2usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_optional)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_optional>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_optional)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_optional_open0_llvm_Align_close0_instantiation_9() {
    assert_eq!(
        ::std::mem::size_of::<std_optional>(),
        2usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_optional)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_optional>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_optional)
        )
    );
}
#[test]
fn __bindgen_test_layout_llvm_MutableArrayRef_open0_char_close0_instantiation_1() {
    assert_eq!(
        ::std::mem::size_of::<llvm_MutableArrayRef<::std::os::raw::c_char>>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_MutableArrayRef<::std::os::raw::c_char>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_MutableArrayRef<::std::os::raw::c_char>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_MutableArrayRef<::std::os::raw::c_char>)
        )
    );
}
#[doc = " Used to pass regions of memory through LLVM interfaces.\n\n @see llvm::MemoryBuffer"]
pub type LLVMMemoryBufferRef = *mut LLVMOpaqueMemoryBuffer;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LLVMOpaqueMemoryBuffer {
    _unused: [u8; 0],
}
#[test]
fn __bindgen_test_layout_std_unique_ptr_open0_llvm_MemoryBuffer_std_default_delete_open1_llvm_MemoryBuffer_close1_close0_instantiation_10(
) {
    assert_eq!(
        ::std::mem::size_of::<std_unique_ptr>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_unique_ptr)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_unique_ptr>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_unique_ptr)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_default_delete_open0_llvm_MemoryBuffer_close0_instantiation_10() {
    assert_eq!(
        ::std::mem::size_of::<std_default_delete>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_default_delete)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_default_delete>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_default_delete)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_vector_open0_llvm_SourceMgr_SrcBuffer_std_allocator_open1_llvm_SourceMgr_SrcBuffer_close1_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<std_vector>(),
        24usize,
        concat!("Size of template specialization: ", stringify!(std_vector))
    );
    assert_eq!(
        ::std::mem::align_of::<std_vector>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_vector)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_allocator_open0_llvm_SourceMgr_SrcBuffer_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_allocator>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_allocator)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_allocator>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_allocator)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_vector_open0_std_string_std_allocator_open1_std_basic_string_open2_char_std_char_traits_open3_char_close3_std_allocator_open3_char_close3_close2_close1_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<std_vector>(),
        24usize,
        concat!("Size of template specialization: ", stringify!(std_vector))
    );
    assert_eq!(
        ::std::mem::align_of::<std_vector>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_vector)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_allocator_open0_std_basic_string_open1_char_std_char_traits_open2_char_close2_std_allocator_open2_char_close2_close1_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<std_allocator>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_allocator)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_allocator>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_allocator)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_basic_string_open0_char_std_char_traits_open1_char_close1_std_allocator_open1_char_close1_close0_instantiation_5(
) {
    assert_eq!(
        ::std::mem::size_of::<std_basic_string<::std::os::raw::c_char>>(),
        32usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_basic_string<::std::os::raw::c_char>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_basic_string<::std::os::raw::c_char>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_basic_string<::std::os::raw::c_char>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_char_traits_open0_char_close0_instantiation_29() {
    assert_eq!(
        ::std::mem::size_of::<std_char_traits>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_char_traits)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_char_traits>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_char_traits)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_allocator_open0_char_close0_instantiation_10() {
    assert_eq!(
        ::std::mem::size_of::<std_allocator>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_allocator)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_allocator>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_allocator)
        )
    );
}
#[test]
fn __bindgen_test_layout_llvm_ArrayRef_open0_std_string_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<llvm_ArrayRef<std_string>>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_ArrayRef<std_string>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_ArrayRef<std_string>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_ArrayRef<std_string>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_vector_open0_std_string_std_allocator_open1_std_basic_string_open2_char_std_char_traits_open3_char_close3_std_allocator_open3_char_close3_close2_close1_close0_instantiation_1(
) {
    assert_eq!(
        ::std::mem::size_of::<std_vector>(),
        24usize,
        concat!("Size of template specialization: ", stringify!(std_vector))
    );
    assert_eq!(
        ::std::mem::align_of::<std_vector>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_vector)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_allocator_open0_std_basic_string_open1_char_std_char_traits_open2_char_close2_std_allocator_open2_char_close2_close1_close0_instantiation_1(
) {
    assert_eq!(
        ::std::mem::size_of::<std_allocator>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_allocator)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_allocator>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_allocator)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_basic_string_open0_char_std_char_traits_open1_char_close1_std_allocator_open1_char_close1_close0_instantiation_6(
) {
    assert_eq!(
        ::std::mem::size_of::<std_basic_string<::std::os::raw::c_char>>(),
        32usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_basic_string<::std::os::raw::c_char>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_basic_string<::std::os::raw::c_char>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_basic_string<::std::os::raw::c_char>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_char_traits_open0_char_close0_instantiation_30() {
    assert_eq!(
        ::std::mem::size_of::<std_char_traits>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_char_traits)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_char_traits>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_char_traits)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_allocator_open0_char_close0_instantiation_11() {
    assert_eq!(
        ::std::mem::size_of::<std_allocator>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_allocator)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_allocator>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_allocator)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_unique_ptr_open0_llvm_MemoryBuffer_std_default_delete_open1_llvm_MemoryBuffer_close1_close0_instantiation_11(
) {
    assert_eq!(
        ::std::mem::size_of::<std_unique_ptr>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_unique_ptr)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_unique_ptr>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_unique_ptr)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_default_delete_open0_llvm_MemoryBuffer_close0_instantiation_11() {
    assert_eq!(
        ::std::mem::size_of::<std_default_delete>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_default_delete)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_default_delete>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_default_delete)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_unique_ptr_open0_llvm_MemoryBuffer_std_default_delete_open1_llvm_MemoryBuffer_close1_close0_instantiation_12(
) {
    assert_eq!(
        ::std::mem::size_of::<std_unique_ptr>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_unique_ptr)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_unique_ptr>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_unique_ptr)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_default_delete_open0_llvm_MemoryBuffer_close0_instantiation_12() {
    assert_eq!(
        ::std::mem::size_of::<std_default_delete>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_default_delete)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_default_delete>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_default_delete)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_pair_open0_unsigned_int_unsigned_int_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_pair<::std::os::raw::c_uint, ::std::os::raw::c_uint>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify ! (std_pair < :: std :: os :: raw :: c_uint , :: std :: os :: raw :: c_uint >)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_pair<::std::os::raw::c_uint, ::std::os::raw::c_uint>>(),
        4usize,
        concat!(
            "Alignment of template specialization: ",
            stringify ! (std_pair < :: std :: os :: raw :: c_uint , :: std :: os :: raw :: c_uint >)
        )
    );
}
#[test]
fn __bindgen_test_layout_llvm_ArrayRef_open0_llvm_SMRange_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<llvm_ArrayRef<llvm_SMRange>>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_ArrayRef<llvm_SMRange>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_ArrayRef<llvm_SMRange>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_ArrayRef<llvm_SMRange>)
        )
    );
}
#[test]
fn __bindgen_test_layout_llvm_ArrayRef_open0_llvm_SMFixIt_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<llvm_ArrayRef<llvm_SMFixIt>>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_ArrayRef<llvm_SMFixIt>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_ArrayRef<llvm_SMFixIt>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_ArrayRef<llvm_SMFixIt>)
        )
    );
}
#[test]
fn __bindgen_test_layout_llvm_ArrayRef_open0_llvm_SMRange_close0_instantiation_1() {
    assert_eq!(
        ::std::mem::size_of::<llvm_ArrayRef<llvm_SMRange>>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_ArrayRef<llvm_SMRange>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_ArrayRef<llvm_SMRange>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_ArrayRef<llvm_SMRange>)
        )
    );
}
#[test]
fn __bindgen_test_layout_llvm_ArrayRef_open0_llvm_SMFixIt_close0_instantiation_1() {
    assert_eq!(
        ::std::mem::size_of::<llvm_ArrayRef<llvm_SMFixIt>>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_ArrayRef<llvm_SMFixIt>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_ArrayRef<llvm_SMFixIt>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_ArrayRef<llvm_SMFixIt>)
        )
    );
}
#[test]
fn __bindgen_test_layout_llvm_ArrayRef_open0_llvm_SMRange_close0_instantiation_2() {
    assert_eq!(
        ::std::mem::size_of::<llvm_ArrayRef<llvm_SMRange>>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_ArrayRef<llvm_SMRange>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_ArrayRef<llvm_SMRange>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_ArrayRef<llvm_SMRange>)
        )
    );
}
#[test]
fn __bindgen_test_layout_llvm_ArrayRef_open0_llvm_SMFixIt_close0_instantiation_2() {
    assert_eq!(
        ::std::mem::size_of::<llvm_ArrayRef<llvm_SMFixIt>>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_ArrayRef<llvm_SMFixIt>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_ArrayRef<llvm_SMFixIt>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_ArrayRef<llvm_SMFixIt>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_vector_open0_std_pair_open1_unsigned_int_unsigned_int_close1_std_allocator_open1_std_pair_open2_unsigned_int_unsigned_int_close2_close1_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<std_vector>(),
        24usize,
        concat!("Size of template specialization: ", stringify!(std_vector))
    );
    assert_eq!(
        ::std::mem::align_of::<std_vector>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_vector)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_pair_open0_unsigned_int_unsigned_int_close0_instantiation_1() {
    assert_eq!(
        ::std::mem::size_of::<std_pair<::std::os::raw::c_uint, ::std::os::raw::c_uint>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify ! (std_pair < :: std :: os :: raw :: c_uint , :: std :: os :: raw :: c_uint >)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_pair<::std::os::raw::c_uint, ::std::os::raw::c_uint>>(),
        4usize,
        concat!(
            "Alignment of template specialization: ",
            stringify ! (std_pair < :: std :: os :: raw :: c_uint , :: std :: os :: raw :: c_uint >)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_allocator_open0_std_pair_open1_unsigned_int_unsigned_int_close1_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<std_allocator>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_allocator)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_allocator>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_allocator)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_pair_open0_unsigned_int_unsigned_int_close0_instantiation_2() {
    assert_eq!(
        ::std::mem::size_of::<std_pair<::std::os::raw::c_uint, ::std::os::raw::c_uint>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify ! (std_pair < :: std :: os :: raw :: c_uint , :: std :: os :: raw :: c_uint >)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_pair<::std::os::raw::c_uint, ::std::os::raw::c_uint>>(),
        4usize,
        concat!(
            "Alignment of template specialization: ",
            stringify ! (std_pair < :: std :: os :: raw :: c_uint , :: std :: os :: raw :: c_uint >)
        )
    );
}
#[test]
fn __bindgen_test_layout_llvm_ArrayRef_open0_std_pair_open1_unsigned_int_unsigned_int_close1_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<
            llvm_ArrayRef<std_pair<::std::os::raw::c_uint, ::std::os::raw::c_uint>>,
        >(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_ArrayRef<std_pair<::std::os::raw::c_uint, ::std::os::raw::c_uint>>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<
            llvm_ArrayRef<std_pair<::std::os::raw::c_uint, ::std::os::raw::c_uint>>,
        >(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_ArrayRef<std_pair<::std::os::raw::c_uint, ::std::os::raw::c_uint>>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_pair_open0_unsigned_int_unsigned_int_close0_instantiation_3() {
    assert_eq!(
        ::std::mem::size_of::<std_pair<::std::os::raw::c_uint, ::std::os::raw::c_uint>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify ! (std_pair < :: std :: os :: raw :: c_uint , :: std :: os :: raw :: c_uint >)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_pair<::std::os::raw::c_uint, ::std::os::raw::c_uint>>(),
        4usize,
        concat!(
            "Alignment of template specialization: ",
            stringify ! (std_pair < :: std :: os :: raw :: c_uint , :: std :: os :: raw :: c_uint >)
        )
    );
}
#[test]
fn __bindgen_test_layout_llvm_ArrayRef_open0_llvm_SMFixIt_close0_instantiation_3() {
    assert_eq!(
        ::std::mem::size_of::<llvm_ArrayRef<llvm_SMFixIt>>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_ArrayRef<llvm_SMFixIt>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_ArrayRef<llvm_SMFixIt>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_ArrayRef<llvm_SMFixIt>)
        )
    );
}
#[test]
fn __bindgen_test_layout_llvm_ArrayRef_open0_std_pair_open1_unsigned_int_unsigned_int_close1_close0_instantiation_1(
) {
    assert_eq!(
        ::std::mem::size_of::<
            llvm_ArrayRef<std_pair<::std::os::raw::c_uint, ::std::os::raw::c_uint>>,
        >(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_ArrayRef<std_pair<::std::os::raw::c_uint, ::std::os::raw::c_uint>>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<
            llvm_ArrayRef<std_pair<::std::os::raw::c_uint, ::std::os::raw::c_uint>>,
        >(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_ArrayRef<std_pair<::std::os::raw::c_uint, ::std::os::raw::c_uint>>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_pair_open0_unsigned_int_unsigned_int_close0_instantiation_4() {
    assert_eq!(
        ::std::mem::size_of::<std_pair<::std::os::raw::c_uint, ::std::os::raw::c_uint>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify ! (std_pair < :: std :: os :: raw :: c_uint , :: std :: os :: raw :: c_uint >)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_pair<::std::os::raw::c_uint, ::std::os::raw::c_uint>>(),
        4usize,
        concat!(
            "Alignment of template specialization: ",
            stringify ! (std_pair < :: std :: os :: raw :: c_uint , :: std :: os :: raw :: c_uint >)
        )
    );
}
#[test]
fn __bindgen_test_layout_llvm_ArrayRef_open0_llvm_SMFixIt_close0_instantiation_4() {
    assert_eq!(
        ::std::mem::size_of::<llvm_ArrayRef<llvm_SMFixIt>>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_ArrayRef<llvm_SMFixIt>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_ArrayRef<llvm_SMFixIt>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_ArrayRef<llvm_SMFixIt>)
        )
    );
}
#[test]
fn __bindgen_test_layout_llvm_SmallVectorImpl_open0_llvm_StringRef_close0_instantiation_2() {
    assert_eq!(
        ::std::mem::size_of::<llvm_SmallVectorImpl>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_SmallVectorImpl)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_SmallVectorImpl>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_SmallVectorImpl)
        )
    );
}
#[test]
fn __bindgen_test_layout_llvm_SmallVectorImpl_open0_llvm_StringRef_close0_instantiation_3() {
    assert_eq!(
        ::std::mem::size_of::<llvm_SmallVectorImpl>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_SmallVectorImpl)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_SmallVectorImpl>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_SmallVectorImpl)
        )
    );
}
#[test]
fn __bindgen_test_layout_llvm_SmallVectorImpl_open0_llvm_StringRef_close0_instantiation_4() {
    assert_eq!(
        ::std::mem::size_of::<llvm_SmallVectorImpl>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_SmallVectorImpl)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_SmallVectorImpl>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_SmallVectorImpl)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_optional_open0_uint32_t_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_optional>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_optional)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_optional>(),
        4usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_optional)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_optional_open0_uint64_t_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_optional>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_optional)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_optional>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_optional)
        )
    );
}
#[doc = " The top-level container for all LLVM global data. See the LLVMContext class."]
pub type LLVMContextRef = *mut LLVMOpaqueContext;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LLVMOpaqueContext {
    _unused: [u8; 0],
}
#[test]
fn __bindgen_test_layout_llvm_AllocatorBase_open0_llvm_MallocAllocator_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<llvm_AllocatorBase>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_AllocatorBase)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_AllocatorBase>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_AllocatorBase)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_optional_open0_llvm_CodeGenOptLevel_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_optional>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_optional)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_optional>(),
        4usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_optional)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_optional_open0_llvm_CodeGenOptLevel_close0_instantiation_1() {
    assert_eq!(
        ::std::mem::size_of::<std_optional>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_optional)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_optional>(),
        4usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_optional)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_optional_open0_bool__close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_optional>(),
        2usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_optional)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_optional>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_optional)
        )
    );
}
#[doc = " This reads the \\p Size bytes into a buffer pointed by \\p Ptr.\n\n \\param Ptr The start of the buffer to hold data to be read.\n\n \\param Size The number of bytes to be read.\n\n On success, the number of bytes read is returned, and the file position is\n advanced by this number. On error, -1 is returned, use error() to get the\n error code."]
pub type __ssize_t = ::std::os::raw::c_long;
#[test]
fn __bindgen_test_layout_llvm_SmallVectorImpl_open0_char_close0_instantiation_4() {
    assert_eq!(
        ::std::mem::size_of::<llvm_SmallVectorImpl>(),
        24usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_SmallVectorImpl)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_SmallVectorImpl>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_SmallVectorImpl)
        )
    );
}
#[test]
fn __bindgen_test_layout_llvm_SmallVectorImpl_open0_char_close0_instantiation_5() {
    assert_eq!(
        ::std::mem::size_of::<llvm_SmallVectorImpl>(),
        24usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_SmallVectorImpl)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_SmallVectorImpl>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_SmallVectorImpl)
        )
    );
}
#[test]
fn __bindgen_test_layout_llvm_SmallVectorImpl_open0_char_close0_instantiation_6() {
    assert_eq!(
        ::std::mem::size_of::<llvm_SmallVectorImpl>(),
        24usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_SmallVectorImpl)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_SmallVectorImpl>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_SmallVectorImpl)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_unique_ptr_open0_llvm_raw_ostream_std_default_delete_open1_llvm_raw_ostream_close1_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<std_unique_ptr>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_unique_ptr)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_unique_ptr>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_unique_ptr)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_default_delete_open0_llvm_raw_ostream_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_default_delete>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_default_delete)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_default_delete>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_default_delete)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_unique_ptr_open0_llvm_raw_ostream_std_default_delete_open1_llvm_raw_ostream_close1_close0_instantiation_1(
) {
    assert_eq!(
        ::std::mem::size_of::<std_unique_ptr>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_unique_ptr)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_unique_ptr>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_unique_ptr)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_default_delete_open0_llvm_raw_ostream_close0_instantiation_1() {
    assert_eq!(
        ::std::mem::size_of::<std_default_delete>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_default_delete)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_default_delete>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_default_delete)
        )
    );
}
#[test]
fn __bindgen_test_layout_llvm_MemoryEffectsBase_open0_llvm_IRMemLocation_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<llvm_MemoryEffectsBase>(),
        4usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_MemoryEffectsBase)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_MemoryEffectsBase>(),
        4usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_MemoryEffectsBase)
        )
    );
}
#[test]
fn __bindgen_test_layout_llvm_ArrayRef_open0_llvm_ConstantRange_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<llvm_ArrayRef<llvm_ConstantRange>>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_ArrayRef<llvm_ConstantRange>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_ArrayRef<llvm_ConstantRange>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_ArrayRef<llvm_ConstantRange>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_optional_open0_unsigned_int_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_optional>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_optional)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_optional>(),
        4usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_optional)
        )
    );
}
#[test]
fn __bindgen_test_layout_llvm_ArrayRef_open0_llvm_ConstantRange_close0_instantiation_1() {
    assert_eq!(
        ::std::mem::size_of::<llvm_ArrayRef<llvm_ConstantRange>>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_ArrayRef<llvm_ConstantRange>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_ArrayRef<llvm_ConstantRange>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_ArrayRef<llvm_ConstantRange>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_optional_open0_unsigned_int_close0_instantiation_1() {
    assert_eq!(
        ::std::mem::size_of::<std_optional>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_optional)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_optional>(),
        4usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_optional)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_optional_open0_unsigned_int_close0_instantiation_2() {
    assert_eq!(
        ::std::mem::size_of::<std_optional>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_optional)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_optional>(),
        4usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_optional)
        )
    );
}
#[test]
fn __bindgen_test_layout_llvm_ArrayRef_open0_llvm_ConstantRange_close0_instantiation_2() {
    assert_eq!(
        ::std::mem::size_of::<llvm_ArrayRef<llvm_ConstantRange>>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_ArrayRef<llvm_ConstantRange>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_ArrayRef<llvm_ConstantRange>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_ArrayRef<llvm_ConstantRange>)
        )
    );
}
#[doc = " Used to represent an attributes.\n\n @see llvm::Attribute"]
pub type LLVMAttributeRef = *mut LLVMOpaqueAttributeRef;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LLVMOpaqueAttributeRef {
    pub _address: u8,
}
#[test]
fn __bindgen_test_layout_llvm_ArrayRef_open0_llvm_Attribute_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<llvm_ArrayRef<llvm_Attribute>>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_ArrayRef<llvm_Attribute>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_ArrayRef<llvm_Attribute>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_ArrayRef<llvm_Attribute>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_optional_open0_unsigned_int_close0_instantiation_3() {
    assert_eq!(
        ::std::mem::size_of::<std_optional>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_optional)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_optional>(),
        4usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_optional)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_optional_open0_unsigned_int_close0_instantiation_4() {
    assert_eq!(
        ::std::mem::size_of::<std_optional>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_optional)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_optional>(),
        4usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_optional)
        )
    );
}
#[test]
fn __bindgen_test_layout_llvm_ArrayRef_open0_std_pair_open1_unsigned_int_llvm_Attribute_close1_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<llvm_ArrayRef<std_pair<::std::os::raw::c_uint, llvm_Attribute>>>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_ArrayRef<std_pair<::std::os::raw::c_uint, llvm_Attribute>>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_ArrayRef<std_pair<::std::os::raw::c_uint, llvm_Attribute>>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_ArrayRef<std_pair<::std::os::raw::c_uint, llvm_Attribute>>)
        )
    );
}
#[test]
fn __bindgen_test_layout_llvm_ArrayRef_open0_std_pair_open1_unsigned_int_llvm_AttributeSet_close1_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<llvm_ArrayRef<std_pair<::std::os::raw::c_uint, llvm_AttributeSet>>>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_ArrayRef<std_pair<::std::os::raw::c_uint, llvm_AttributeSet>>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_ArrayRef<std_pair<::std::os::raw::c_uint, llvm_AttributeSet>>>(
        ),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_ArrayRef<std_pair<::std::os::raw::c_uint, llvm_AttributeSet>>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_pair_open0_unsigned_int_llvm_AttributeSet_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_pair<::std::os::raw::c_uint, llvm_AttributeSet>>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify ! (std_pair < :: std :: os :: raw :: c_uint , llvm_AttributeSet >)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_pair<::std::os::raw::c_uint, llvm_AttributeSet>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify ! (std_pair < :: std :: os :: raw :: c_uint , llvm_AttributeSet >)
        )
    );
}
#[test]
fn __bindgen_test_layout_llvm_ArrayRef_open0_llvm_AttributeList_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<llvm_ArrayRef<llvm_AttributeList>>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_ArrayRef<llvm_AttributeList>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_ArrayRef<llvm_AttributeList>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_ArrayRef<llvm_AttributeList>)
        )
    );
}
#[test]
fn __bindgen_test_layout_llvm_ArrayRef_open0_uint64_t_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<llvm_ArrayRef<u64>>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_ArrayRef<u64>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_ArrayRef<u64>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_ArrayRef<u64>)
        )
    );
}
#[test]
fn __bindgen_test_layout_llvm_ArrayRef_open0_unsigned_int_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<llvm_ArrayRef<::std::os::raw::c_uint>>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_ArrayRef<::std::os::raw::c_uint>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_ArrayRef<::std::os::raw::c_uint>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_ArrayRef<::std::os::raw::c_uint>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_optional_open0_unsigned_int_close0_instantiation_5() {
    assert_eq!(
        ::std::mem::size_of::<std_optional>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_optional)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_optional>(),
        4usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_optional)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_optional_open0_uint64_t_close0_instantiation_1() {
    assert_eq!(
        ::std::mem::size_of::<std_optional>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_optional)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_optional>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_optional)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_optional_open0_unsigned_int_close0_instantiation_6() {
    assert_eq!(
        ::std::mem::size_of::<std_optional>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_optional)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_optional>(),
        4usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_optional)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_optional_open0_unsigned_int_close0_instantiation_7() {
    assert_eq!(
        ::std::mem::size_of::<std_optional>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_optional)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_optional>(),
        4usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_optional)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_optional_open0_unsigned_int_close0_instantiation_8() {
    assert_eq!(
        ::std::mem::size_of::<std_optional>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_optional)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_optional>(),
        4usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_optional)
        )
    );
}
#[test]
fn __bindgen_test_layout_llvm_ArrayRef_open0_llvm_ConstantRange_close0_instantiation_3() {
    assert_eq!(
        ::std::mem::size_of::<llvm_ArrayRef<llvm_ConstantRange>>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_ArrayRef<llvm_ConstantRange>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_ArrayRef<llvm_ConstantRange>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_ArrayRef<llvm_ConstantRange>)
        )
    );
}
#[test]
fn __bindgen_test_layout_llvm_ArrayRef_open0_llvm_Attribute_close0_instantiation_1() {
    assert_eq!(
        ::std::mem::size_of::<llvm_ArrayRef<llvm_Attribute>>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_ArrayRef<llvm_Attribute>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_ArrayRef<llvm_Attribute>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_ArrayRef<llvm_Attribute>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_pair_open0_ptr_ptr_const_void_bool__close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_pair<*const *const ::std::os::raw::c_void, bool>>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_pair<*const *const ::std::os::raw::c_void, bool>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_pair<*const *const ::std::os::raw::c_void, bool>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_pair<*const *const ::std::os::raw::c_void, bool>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_pair_open0_ptr_ptr_const_void_bool__close0_instantiation_1() {
    assert_eq!(
        ::std::mem::size_of::<std_pair<*const *const ::std::os::raw::c_void, bool>>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_pair<*const *const ::std::os::raw::c_void, bool>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_pair<*const *const ::std::os::raw::c_void, bool>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_pair<*const *const ::std::os::raw::c_void, bool>)
        )
    );
}
#[test]
fn __bindgen_test_layout_llvm_SmallPtrSetImpl_open0_ptr_GlobalObject_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<llvm_SmallPtrSetImpl>(),
        40usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_SmallPtrSetImpl)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_SmallPtrSetImpl>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_SmallPtrSetImpl)
        )
    );
}
#[doc = " @see llvm::Comdat"]
pub type LLVMComdatRef = *mut LLVMComdat;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LLVMComdat {
    _unused: [u8; 0],
}
#[test]
fn __bindgen_test_layout_llvm_ArrayRef_open0_uint64_t_close0_instantiation_1() {
    assert_eq!(
        ::std::mem::size_of::<llvm_ArrayRef<u64>>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_ArrayRef<u64>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_ArrayRef<u64>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_ArrayRef<u64>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_optional_open0_uint64_t_close0_instantiation_2() {
    assert_eq!(
        ::std::mem::size_of::<std_optional>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_optional)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_optional>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_optional)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_optional_open0_int64_t_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_optional>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_optional)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_optional>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_optional)
        )
    );
}
#[test]
fn __bindgen_test_layout_llvm_SmallVectorImpl_open0_char_close0_instantiation_7() {
    assert_eq!(
        ::std::mem::size_of::<llvm_SmallVectorImpl>(),
        24usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_SmallVectorImpl)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_SmallVectorImpl>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_SmallVectorImpl)
        )
    );
}
#[test]
fn __bindgen_test_layout_llvm_SmallVectorImpl_open0_char_close0_instantiation_8() {
    assert_eq!(
        ::std::mem::size_of::<llvm_SmallVectorImpl>(),
        24usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_SmallVectorImpl)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_SmallVectorImpl>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_SmallVectorImpl)
        )
    );
}
#[test]
fn __bindgen_test_layout_llvm_SmallVectorImpl_open0_char_close0_instantiation_9() {
    assert_eq!(
        ::std::mem::size_of::<llvm_SmallVectorImpl>(),
        24usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_SmallVectorImpl)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_SmallVectorImpl>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_SmallVectorImpl)
        )
    );
}
#[test]
fn __bindgen_test_layout_llvm_ArrayRef_open0_uint64_t_close0_instantiation_2() {
    assert_eq!(
        ::std::mem::size_of::<llvm_ArrayRef<u64>>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_ArrayRef<u64>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_ArrayRef<u64>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_ArrayRef<u64>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_optional_open0_unsigned_int_close0_instantiation_9() {
    assert_eq!(
        ::std::mem::size_of::<std_optional>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_optional)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_optional>(),
        4usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_optional)
        )
    );
}
#[test]
fn __bindgen_test_layout_llvm_details_FixedOrScalableQuantity_open0_llvm_ElementCount_unsigned_int_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<llvm_details_FixedOrScalableQuantity<::std::os::raw::c_uint>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_details_FixedOrScalableQuantity<::std::os::raw::c_uint>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_details_FixedOrScalableQuantity<::std::os::raw::c_uint>>(),
        4usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_details_FixedOrScalableQuantity<::std::os::raw::c_uint>)
        )
    );
}
pub type ScalarTy = ::std::os::raw::c_uint;
#[test]
fn __bindgen_test_layout_llvm_details_FixedOrScalableQuantity_open0_llvm_ElementCount_unsigned_int_close0_instantiation_1(
) {
    assert_eq!(
        ::std::mem::size_of::<llvm_details_FixedOrScalableQuantity<::std::os::raw::c_uint>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_details_FixedOrScalableQuantity<::std::os::raw::c_uint>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_details_FixedOrScalableQuantity<::std::os::raw::c_uint>>(),
        4usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_details_FixedOrScalableQuantity<::std::os::raw::c_uint>)
        )
    );
}
#[test]
fn __bindgen_test_layout_llvm_details_FixedOrScalableQuantity_open0_llvm_TypeSize_uint64_t_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<llvm_details_FixedOrScalableQuantity<u64>>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_details_FixedOrScalableQuantity<u64>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_details_FixedOrScalableQuantity<u64>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_details_FixedOrScalableQuantity<u64>)
        )
    );
}
#[test]
fn __bindgen_test_layout_llvm_details_FixedOrScalableQuantity_open0_llvm_TypeSize_uint64_t_close0_instantiation_1(
) {
    assert_eq!(
        ::std::mem::size_of::<llvm_details_FixedOrScalableQuantity<u64>>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_details_FixedOrScalableQuantity<u64>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_details_FixedOrScalableQuantity<u64>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_details_FixedOrScalableQuantity<u64>)
        )
    );
}
pub type ScalarTy = ::std::os::raw::c_ulong;
#[test]
fn __bindgen_test_layout_llvm_ArrayRef_open0_ptr_Type_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<llvm_ArrayRef<*mut llvm_Type>>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_ArrayRef<*mut llvm_Type>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_ArrayRef<*mut llvm_Type>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_ArrayRef<*mut llvm_Type>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_reverse_iterator_open0_llvm_Type_subtype_iterator_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<std_reverse_iterator<llvm_Type_subtype_iterator>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_reverse_iterator<llvm_Type_subtype_iterator>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_reverse_iterator<llvm_Type_subtype_iterator>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_reverse_iterator<llvm_Type_subtype_iterator>)
        )
    );
}
#[doc = " Each value in the LLVM IR has a type, an LLVMTypeRef.\n\n @see llvm::Type"]
pub type LLVMTypeRef = *mut LLVMOpaqueType;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LLVMOpaqueType {
    _unused: [u8; 0],
}
#[test]
fn __bindgen_test_layout_llvm_ArrayRef_open0_ptr_Type_close0_instantiation_1() {
    assert_eq!(
        ::std::mem::size_of::<llvm_ArrayRef<*mut llvm_Type>>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_ArrayRef<*mut llvm_Type>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_ArrayRef<*mut llvm_Type>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_ArrayRef<*mut llvm_Type>)
        )
    );
}
#[test]
fn __bindgen_test_layout_llvm_ArrayRef_open0_ptr_Type_close0_instantiation_2() {
    assert_eq!(
        ::std::mem::size_of::<llvm_ArrayRef<*mut llvm_Type>>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_ArrayRef<*mut llvm_Type>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_ArrayRef<*mut llvm_Type>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_ArrayRef<*mut llvm_Type>)
        )
    );
}
#[test]
fn __bindgen_test_layout_llvm_ArrayRef_open0_ptr_Type_close0_instantiation_3() {
    assert_eq!(
        ::std::mem::size_of::<llvm_ArrayRef<*mut llvm_Type>>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_ArrayRef<*mut llvm_Type>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_ArrayRef<*mut llvm_Type>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_ArrayRef<*mut llvm_Type>)
        )
    );
}
#[test]
fn __bindgen_test_layout_llvm_ArrayRef_open0_ptr_Type_close0_instantiation_4() {
    assert_eq!(
        ::std::mem::size_of::<llvm_ArrayRef<*mut llvm_Type>>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_ArrayRef<*mut llvm_Type>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_ArrayRef<*mut llvm_Type>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_ArrayRef<*mut llvm_Type>)
        )
    );
}
#[test]
fn __bindgen_test_layout_llvm_ArrayRef_open0_ptr_Type_close0_instantiation_5() {
    assert_eq!(
        ::std::mem::size_of::<llvm_ArrayRef<*mut llvm_Type>>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_ArrayRef<*mut llvm_Type>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_ArrayRef<*mut llvm_Type>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_ArrayRef<*mut llvm_Type>)
        )
    );
}
#[test]
fn __bindgen_test_layout_llvm_ArrayRef_open0_ptr_Type_close0_instantiation_6() {
    assert_eq!(
        ::std::mem::size_of::<llvm_ArrayRef<*mut llvm_Type>>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_ArrayRef<*mut llvm_Type>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_ArrayRef<*mut llvm_Type>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_ArrayRef<*mut llvm_Type>)
        )
    );
}
#[test]
fn __bindgen_test_layout_llvm_ArrayRef_open0_ptr_Type_close0_instantiation_7() {
    assert_eq!(
        ::std::mem::size_of::<llvm_ArrayRef<*mut llvm_Type>>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_ArrayRef<*mut llvm_Type>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_ArrayRef<*mut llvm_Type>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_ArrayRef<*mut llvm_Type>)
        )
    );
}
#[test]
fn __bindgen_test_layout_llvm_ArrayRef_open0_ptr_Type_close0_instantiation_8() {
    assert_eq!(
        ::std::mem::size_of::<llvm_ArrayRef<*mut llvm_Type>>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_ArrayRef<*mut llvm_Type>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_ArrayRef<*mut llvm_Type>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_ArrayRef<*mut llvm_Type>)
        )
    );
}
#[test]
fn __bindgen_test_layout_llvm_ArrayRef_open0_ptr_Type_close0_instantiation_9() {
    assert_eq!(
        ::std::mem::size_of::<llvm_ArrayRef<*mut llvm_Type>>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_ArrayRef<*mut llvm_Type>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_ArrayRef<*mut llvm_Type>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_ArrayRef<*mut llvm_Type>)
        )
    );
}
#[test]
fn __bindgen_test_layout_llvm_ArrayRef_open0_ptr_Type_close0_instantiation_10() {
    assert_eq!(
        ::std::mem::size_of::<llvm_ArrayRef<*mut llvm_Type>>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_ArrayRef<*mut llvm_Type>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_ArrayRef<*mut llvm_Type>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_ArrayRef<*mut llvm_Type>)
        )
    );
}
#[test]
fn __bindgen_test_layout_llvm_ArrayRef_open0_ptr_Type_close0_instantiation_11() {
    assert_eq!(
        ::std::mem::size_of::<llvm_ArrayRef<*mut llvm_Type>>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_ArrayRef<*mut llvm_Type>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_ArrayRef<*mut llvm_Type>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_ArrayRef<*mut llvm_Type>)
        )
    );
}
#[test]
fn __bindgen_test_layout_llvm_ArrayRef_open0_unsigned_int_close0_instantiation_1() {
    assert_eq!(
        ::std::mem::size_of::<llvm_ArrayRef<::std::os::raw::c_uint>>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_ArrayRef<::std::os::raw::c_uint>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_ArrayRef<::std::os::raw::c_uint>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_ArrayRef<::std::os::raw::c_uint>)
        )
    );
}
#[test]
fn __bindgen_test_layout_llvm_ArrayRef_open0_ptr_Type_close0_instantiation_12() {
    assert_eq!(
        ::std::mem::size_of::<llvm_ArrayRef<*mut llvm_Type>>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_ArrayRef<*mut llvm_Type>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_ArrayRef<*mut llvm_Type>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_ArrayRef<*mut llvm_Type>)
        )
    );
}
#[test]
fn __bindgen_test_layout_llvm_ArrayRef_open0_unsigned_int_close0_instantiation_2() {
    assert_eq!(
        ::std::mem::size_of::<llvm_ArrayRef<::std::os::raw::c_uint>>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_ArrayRef<::std::os::raw::c_uint>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_ArrayRef<::std::os::raw::c_uint>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_ArrayRef<::std::os::raw::c_uint>)
        )
    );
}
#[test]
fn __bindgen_test_layout_llvm_ArrayRef_open0_ptr_Type_close0_instantiation_13() {
    assert_eq!(
        ::std::mem::size_of::<llvm_ArrayRef<*mut llvm_Type>>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_ArrayRef<*mut llvm_Type>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_ArrayRef<*mut llvm_Type>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_ArrayRef<*mut llvm_Type>)
        )
    );
}
#[test]
fn __bindgen_test_layout_llvm_ArrayRef_open0_unsigned_int_close0_instantiation_3() {
    assert_eq!(
        ::std::mem::size_of::<llvm_ArrayRef<::std::os::raw::c_uint>>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_ArrayRef<::std::os::raw::c_uint>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_ArrayRef<::std::os::raw::c_uint>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_ArrayRef<::std::os::raw::c_uint>)
        )
    );
}
#[test]
fn __bindgen_test_layout_llvm_ArrayRef_open0_unsigned_int_close0_instantiation_4() {
    assert_eq!(
        ::std::mem::size_of::<llvm_ArrayRef<::std::os::raw::c_uint>>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_ArrayRef<::std::os::raw::c_uint>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_ArrayRef<::std::os::raw::c_uint>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_ArrayRef<::std::os::raw::c_uint>)
        )
    );
}
#[test]
fn __bindgen_test_layout_llvm_TrailingObjects_open0_llvm_StructLayout_llvm_TypeSize_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<llvm_TrailingObjects>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_TrailingObjects)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_TrailingObjects>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_TrailingObjects)
        )
    );
}
#[test]
fn __bindgen_test_layout_llvm_MutableArrayRef_open0_llvm_TypeSize_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<llvm_MutableArrayRef<llvm_TypeSize>>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_MutableArrayRef<llvm_TypeSize>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_MutableArrayRef<llvm_TypeSize>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_MutableArrayRef<llvm_TypeSize>)
        )
    );
}
#[test]
fn __bindgen_test_layout_llvm_ArrayRef_open0_llvm_TypeSize_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<llvm_ArrayRef<llvm_TypeSize>>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_ArrayRef<llvm_TypeSize>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_ArrayRef<llvm_TypeSize>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_ArrayRef<llvm_TypeSize>)
        )
    );
}
#[test]
fn __bindgen_test_layout_llvm_trailing_objects_internal_TrailingObjectsBase_OverloadToken_open0_llvm_TypeSize_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<llvm_trailing_objects_internal_TrailingObjectsBase_OverloadToken>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_trailing_objects_internal_TrailingObjectsBase_OverloadToken)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_trailing_objects_internal_TrailingObjectsBase_OverloadToken>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_trailing_objects_internal_TrailingObjectsBase_OverloadToken)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_53 {
    pub _address: u8,
}
#[doc = " Used to get the users and usees of a Value.\n\n @see llvm::Use"]
pub type LLVMUseRef = *mut LLVMOpaqueUse;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LLVMOpaqueUse {
    _unused: [u8; 0],
}
#[test]
fn __bindgen_test_layout_llvm_Value_use_iterator_impl_open0_llvm_Use_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<llvm_Value_use_iterator_impl<llvm_Use>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_Value_use_iterator_impl<llvm_Use>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_Value_use_iterator_impl<llvm_Use>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_Value_use_iterator_impl<llvm_Use>)
        )
    );
}
#[test]
fn __bindgen_test_layout_llvm_Value_use_iterator_impl_open0_llvm_Use_close0_instantiation_1() {
    assert_eq!(
        ::std::mem::size_of::<llvm_Value_use_iterator_impl<llvm_Use>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_Value_use_iterator_impl<llvm_Use>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_Value_use_iterator_impl<llvm_Use>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_Value_use_iterator_impl<llvm_Use>)
        )
    );
}
#[test]
fn __bindgen_test_layout_llvm_Value_use_iterator_impl_open0_llvm_Use_close0_instantiation_2() {
    assert_eq!(
        ::std::mem::size_of::<llvm_Value_use_iterator_impl<llvm_Use>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_Value_use_iterator_impl<llvm_Use>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_Value_use_iterator_impl<llvm_Use>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_Value_use_iterator_impl<llvm_Use>)
        )
    );
}
#[test]
fn __bindgen_test_layout_llvm_iterator_range_open0_llvm_Value_use_iterator_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<llvm_iterator_range<llvm_Value_use_iterator>>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_iterator_range<llvm_Value_use_iterator>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_iterator_range<llvm_Value_use_iterator>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_iterator_range<llvm_Value_use_iterator>)
        )
    );
}
#[test]
fn __bindgen_test_layout_llvm_iterator_range_open0_llvm_Value_const_use_iterator_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<llvm_iterator_range<llvm_Value_const_use_iterator>>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_iterator_range<llvm_Value_const_use_iterator>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_iterator_range<llvm_Value_const_use_iterator>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_iterator_range<llvm_Value_const_use_iterator>)
        )
    );
}
#[test]
fn __bindgen_test_layout_llvm_iterator_range_open0_llvm_Value_use_iterator_close0_instantiation_1()
{
    assert_eq!(
        ::std::mem::size_of::<llvm_iterator_range<llvm_Value_use_iterator>>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_iterator_range<llvm_Value_use_iterator>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_iterator_range<llvm_Value_use_iterator>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_iterator_range<llvm_Value_use_iterator>)
        )
    );
}
#[test]
fn __bindgen_test_layout_llvm_iterator_range_open0_llvm_Value_const_use_iterator_close0_instantiation_1(
) {
    assert_eq!(
        ::std::mem::size_of::<llvm_iterator_range<llvm_Value_const_use_iterator>>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_iterator_range<llvm_Value_const_use_iterator>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_iterator_range<llvm_Value_const_use_iterator>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_iterator_range<llvm_Value_const_use_iterator>)
        )
    );
}
#[test]
fn __bindgen_test_layout_llvm_Value_user_iterator_impl_open0_llvm_User_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<llvm_Value_user_iterator_impl>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_Value_user_iterator_impl)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_Value_user_iterator_impl>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_Value_user_iterator_impl)
        )
    );
}
#[test]
fn __bindgen_test_layout_llvm_Value_user_iterator_impl_open0_llvm_User_close0_instantiation_1() {
    assert_eq!(
        ::std::mem::size_of::<llvm_Value_user_iterator_impl>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_Value_user_iterator_impl)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_Value_user_iterator_impl>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_Value_user_iterator_impl)
        )
    );
}
#[test]
fn __bindgen_test_layout_llvm_iterator_range_open0_llvm_Value_user_iterator_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<llvm_iterator_range<llvm_Value_user_iterator>>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_iterator_range<llvm_Value_user_iterator>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_iterator_range<llvm_Value_user_iterator>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_iterator_range<llvm_Value_user_iterator>)
        )
    );
}
#[test]
fn __bindgen_test_layout_llvm_iterator_range_open0_llvm_Value_const_user_iterator_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<llvm_iterator_range<llvm_Value_const_user_iterator>>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_iterator_range<llvm_Value_const_user_iterator>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_iterator_range<llvm_Value_const_user_iterator>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_iterator_range<llvm_Value_const_user_iterator>)
        )
    );
}
#[test]
fn __bindgen_test_layout_llvm_iterator_range_open0_llvm_Value_user_iterator_close0_instantiation_1()
{
    assert_eq!(
        ::std::mem::size_of::<llvm_iterator_range<llvm_Value_user_iterator>>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_iterator_range<llvm_Value_user_iterator>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_iterator_range<llvm_Value_user_iterator>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_iterator_range<llvm_Value_user_iterator>)
        )
    );
}
#[test]
fn __bindgen_test_layout_llvm_iterator_range_open0_llvm_Value_const_user_iterator_close0_instantiation_1(
) {
    assert_eq!(
        ::std::mem::size_of::<llvm_iterator_range<llvm_Value_const_user_iterator>>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_iterator_range<llvm_Value_const_user_iterator>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_iterator_range<llvm_Value_const_user_iterator>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_iterator_range<llvm_Value_const_user_iterator>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_optional_open0_int64_t_close0_instantiation_1() {
    assert_eq!(
        ::std::mem::size_of::<std_optional>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_optional)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_optional>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_optional)
        )
    );
}
#[doc = " Represents an individual value in LLVM IR.\n\n This models llvm::Value."]
pub type LLVMValueRef = *mut LLVMOpaqueValue;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LLVMOpaqueValue {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_54 {
    pub _address: u8,
}
#[test]
fn __bindgen_test_layout_llvm_iterator_range_open0_llvm_User_op_iterator_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<llvm_iterator_range<llvm_User_op_iterator>>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_iterator_range<llvm_User_op_iterator>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_iterator_range<llvm_User_op_iterator>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_iterator_range<llvm_User_op_iterator>)
        )
    );
}
#[test]
fn __bindgen_test_layout_llvm_iterator_range_open0_llvm_User_const_op_iterator_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<llvm_iterator_range<llvm_User_const_op_iterator>>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_iterator_range<llvm_User_const_op_iterator>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_iterator_range<llvm_User_const_op_iterator>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_iterator_range<llvm_User_const_op_iterator>)
        )
    );
}
#[test]
fn __bindgen_test_layout_llvm_iterator_adaptor_base_open0_llvm_User_value_op_iterator_llvm_User_op_iterator_std_random_access_iterator_tag_ptr_Value_ptrdiff_t_ptr_Value_ptr_Value_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<llvm_iterator_adaptor_base<llvm_User_op_iterator>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_iterator_adaptor_base<llvm_User_op_iterator>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_iterator_adaptor_base<llvm_User_op_iterator>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_iterator_adaptor_base<llvm_User_op_iterator>)
        )
    );
}
#[test]
fn __bindgen_test_layout_llvm_iterator_range_open0_llvm_User_value_op_iterator_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<llvm_iterator_range<llvm_User_value_op_iterator>>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_iterator_range<llvm_User_value_op_iterator>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_iterator_range<llvm_User_value_op_iterator>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_iterator_range<llvm_User_value_op_iterator>)
        )
    );
}
#[test]
fn __bindgen_test_layout_llvm_iterator_adaptor_base_open0_llvm_User_const_value_op_iterator_llvm_User_const_op_iterator_std_random_access_iterator_tag_ptr_const_Value_ptrdiff_t_ptr_const_Value_ptr_const_Value_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<llvm_iterator_adaptor_base<llvm_User_const_op_iterator>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_iterator_adaptor_base<llvm_User_const_op_iterator>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_iterator_adaptor_base<llvm_User_const_op_iterator>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_iterator_adaptor_base<llvm_User_const_op_iterator>)
        )
    );
}
#[test]
fn __bindgen_test_layout_llvm_iterator_range_open0_llvm_User_const_value_op_iterator_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<llvm_iterator_range<llvm_User_const_value_op_iterator>>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_iterator_range<llvm_User_const_value_op_iterator>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_iterator_range<llvm_User_const_value_op_iterator>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_iterator_range<llvm_User_const_value_op_iterator>)
        )
    );
}
#[doc = " Represents an LLVM Metadata.\n\n This models llvm::Metadata."]
pub type LLVMMetadataRef = *mut LLVMOpaqueMetadata;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LLVMOpaqueMetadata {
    _unused: [u8; 0],
}
#[test]
fn __bindgen_test_layout_llvm_ArrayRef_open0_ptr_Metadata_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<llvm_ArrayRef<*mut llvm_Metadata>>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_ArrayRef<*mut llvm_Metadata>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_ArrayRef<*mut llvm_Metadata>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_ArrayRef<*mut llvm_Metadata>)
        )
    );
}
#[test]
fn __bindgen_test_layout_llvm_PointerUnion_open0_ptr_MetadataAsValue_ptr_Metadata_ptr_DebugValueUser_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<llvm_PointerUnion>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_PointerUnion)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_PointerUnion>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_PointerUnion)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_pair_open0_llvm_ReplaceableMetadataImpl_OwnerTy_uint64_t_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<std_pair<llvm_ReplaceableMetadataImpl_OwnerTy, u64>>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify ! (std_pair < llvm_ReplaceableMetadataImpl_OwnerTy , u64 >)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_pair<llvm_ReplaceableMetadataImpl_OwnerTy, u64>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify ! (std_pair < llvm_ReplaceableMetadataImpl_OwnerTy , u64 >)
        )
    );
}
#[test]
fn __bindgen_test_layout_llvm_detail_DenseMapPair_open0_ptr_void_std_pair_open1_llvm_PointerUnion_open2_ptr_MetadataAsValue_ptr_Metadata_ptr_DebugValueUser_close2_unsigned_long_close1_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<
            llvm_detail_DenseMapPair<
                *mut ::std::os::raw::c_void,
                std_pair<llvm_PointerUnion, ::std::os::raw::c_ulong>,
            >,
        >(),
        24usize,
        concat!(
            "Size of template specialization: ",
            stringify!(
                llvm_detail_DenseMapPair<
                    *mut ::std::os::raw::c_void,
                    std_pair<llvm_PointerUnion, ::std::os::raw::c_ulong>,
                >
            )
        )
    );
    assert_eq!(
        ::std::mem::align_of::<
            llvm_detail_DenseMapPair<
                *mut ::std::os::raw::c_void,
                std_pair<llvm_PointerUnion, ::std::os::raw::c_ulong>,
            >,
        >(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(
                llvm_detail_DenseMapPair<
                    *mut ::std::os::raw::c_void,
                    std_pair<llvm_PointerUnion, ::std::os::raw::c_ulong>,
                >
            )
        )
    );
}
#[test]
fn __bindgen_test_layout_std_pair_open0_llvm_PointerUnion_open1_ptr_MetadataAsValue_ptr_Metadata_ptr_DebugValueUser_close1_unsigned_long_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<std_pair<llvm_PointerUnion, ::std::os::raw::c_ulong>>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify ! (std_pair < llvm_PointerUnion , :: std :: os :: raw :: c_ulong >)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_pair<llvm_PointerUnion, ::std::os::raw::c_ulong>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify ! (std_pair < llvm_PointerUnion , :: std :: os :: raw :: c_ulong >)
        )
    );
}
#[test]
fn __bindgen_test_layout_llvm_PointerUnion_open0_ptr_MetadataAsValue_ptr_Metadata_ptr_DebugValueUser_close0_instantiation_1(
) {
    assert_eq!(
        ::std::mem::size_of::<llvm_PointerUnion>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_PointerUnion)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_PointerUnion>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_PointerUnion)
        )
    );
}
#[test]
fn __bindgen_test_layout_llvm_PointerUnion_open0_ptr_LLVMContext_ptr_ReplaceableMetadataImpl_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<llvm_PointerUnion>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_PointerUnion)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_PointerUnion>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_PointerUnion)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_unique_ptr_open0_llvm_ReplaceableMetadataImpl_std_default_delete_open1_llvm_ReplaceableMetadataImpl_close1_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<std_unique_ptr>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_unique_ptr)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_unique_ptr>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_unique_ptr)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_default_delete_open0_llvm_ReplaceableMetadataImpl_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<std_default_delete>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_default_delete)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_default_delete>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_default_delete)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_unique_ptr_open0_llvm_ReplaceableMetadataImpl_std_default_delete_open1_llvm_ReplaceableMetadataImpl_close1_close0_instantiation_1(
) {
    assert_eq!(
        ::std::mem::size_of::<std_unique_ptr>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_unique_ptr)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_unique_ptr>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_unique_ptr)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_default_delete_open0_llvm_ReplaceableMetadataImpl_close0_instantiation_1(
) {
    assert_eq!(
        ::std::mem::size_of::<std_default_delete>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_default_delete)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_default_delete>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_default_delete)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_unique_ptr_open0_llvm_ReplaceableMetadataImpl_std_default_delete_open1_llvm_ReplaceableMetadataImpl_close1_close0_instantiation_2(
) {
    assert_eq!(
        ::std::mem::size_of::<std_unique_ptr>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_unique_ptr)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_unique_ptr>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_unique_ptr)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_default_delete_open0_llvm_ReplaceableMetadataImpl_close0_instantiation_2(
) {
    assert_eq!(
        ::std::mem::size_of::<std_default_delete>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_default_delete)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_default_delete>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_default_delete)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_unique_ptr_open0_llvm_MDTuple_llvm_TempMDNodeDeleter_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<std_unique_ptr>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_unique_ptr)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_unique_ptr>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_unique_ptr)
        )
    );
}
#[test]
fn __bindgen_test_layout_llvm_MutableArrayRef_open0_llvm_MDOperand_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<llvm_MutableArrayRef<llvm_MDOperand>>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_MutableArrayRef<llvm_MDOperand>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_MutableArrayRef<llvm_MDOperand>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_MutableArrayRef<llvm_MDOperand>)
        )
    );
}
#[test]
fn __bindgen_test_layout_llvm_ArrayRef_open0_llvm_MDOperand_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<llvm_ArrayRef<llvm_MDOperand>>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_ArrayRef<llvm_MDOperand>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_ArrayRef<llvm_MDOperand>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_ArrayRef<llvm_MDOperand>)
        )
    );
}
#[test]
fn __bindgen_test_layout_llvm_ArrayRef_open0_ptr_Metadata_close0_instantiation_1() {
    assert_eq!(
        ::std::mem::size_of::<llvm_ArrayRef<*mut llvm_Metadata>>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_ArrayRef<*mut llvm_Metadata>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_ArrayRef<*mut llvm_Metadata>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_ArrayRef<*mut llvm_Metadata>)
        )
    );
}
#[test]
fn __bindgen_test_layout_llvm_ArrayRef_open0_ptr_Metadata_close0_instantiation_2() {
    assert_eq!(
        ::std::mem::size_of::<llvm_ArrayRef<*mut llvm_Metadata>>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_ArrayRef<*mut llvm_Metadata>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_ArrayRef<*mut llvm_Metadata>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_ArrayRef<*mut llvm_Metadata>)
        )
    );
}
#[test]
fn __bindgen_test_layout_llvm_iterator_range_open0_ptr_MDOperand_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<llvm_iterator_range<*mut llvm_MDOperand>>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_iterator_range<*mut llvm_MDOperand>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_iterator_range<*mut llvm_MDOperand>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_iterator_range<*mut llvm_MDOperand>)
        )
    );
}
#[test]
fn __bindgen_test_layout_llvm_ArrayRef_open0_ptr_Metadata_close0_instantiation_3() {
    assert_eq!(
        ::std::mem::size_of::<llvm_ArrayRef<*mut llvm_Metadata>>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_ArrayRef<*mut llvm_Metadata>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_ArrayRef<*mut llvm_Metadata>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_ArrayRef<*mut llvm_Metadata>)
        )
    );
}
#[test]
fn __bindgen_test_layout_llvm_ArrayRef_open0_ptr_Metadata_close0_instantiation_4() {
    assert_eq!(
        ::std::mem::size_of::<llvm_ArrayRef<*mut llvm_Metadata>>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_ArrayRef<*mut llvm_Metadata>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_ArrayRef<*mut llvm_Metadata>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_ArrayRef<*mut llvm_Metadata>)
        )
    );
}
#[test]
fn __bindgen_test_layout_llvm_ArrayRef_open0_ptr_Metadata_close0_instantiation_5() {
    assert_eq!(
        ::std::mem::size_of::<llvm_ArrayRef<*mut llvm_Metadata>>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_ArrayRef<*mut llvm_Metadata>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_ArrayRef<*mut llvm_Metadata>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_ArrayRef<*mut llvm_Metadata>)
        )
    );
}
#[test]
fn __bindgen_test_layout_llvm_ArrayRef_open0_ptr_Metadata_close0_instantiation_6() {
    assert_eq!(
        ::std::mem::size_of::<llvm_ArrayRef<*mut llvm_Metadata>>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_ArrayRef<*mut llvm_Metadata>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_ArrayRef<*mut llvm_Metadata>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_ArrayRef<*mut llvm_Metadata>)
        )
    );
}
#[test]
fn __bindgen_test_layout_llvm_ArrayRef_open0_llvm_MDOperand_close0_instantiation_1() {
    assert_eq!(
        ::std::mem::size_of::<llvm_ArrayRef<llvm_MDOperand>>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_ArrayRef<llvm_MDOperand>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_ArrayRef<llvm_MDOperand>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_ArrayRef<llvm_MDOperand>)
        )
    );
}
#[test]
fn __bindgen_test_layout_llvm_ArrayRef_open0_ptr_Metadata_close0_instantiation_7() {
    assert_eq!(
        ::std::mem::size_of::<llvm_ArrayRef<*mut llvm_Metadata>>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_ArrayRef<*mut llvm_Metadata>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_ArrayRef<*mut llvm_Metadata>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_ArrayRef<*mut llvm_Metadata>)
        )
    );
}
#[test]
fn __bindgen_test_layout_llvm_ArrayRef_open0_ptr_Metadata_close0_instantiation_8() {
    assert_eq!(
        ::std::mem::size_of::<llvm_ArrayRef<*mut llvm_Metadata>>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_ArrayRef<*mut llvm_Metadata>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_ArrayRef<*mut llvm_Metadata>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_ArrayRef<*mut llvm_Metadata>)
        )
    );
}
#[test]
fn __bindgen_test_layout_llvm_ArrayRef_open0_ptr_Metadata_close0_instantiation_9() {
    assert_eq!(
        ::std::mem::size_of::<llvm_ArrayRef<*mut llvm_Metadata>>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_ArrayRef<*mut llvm_Metadata>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_ArrayRef<*mut llvm_Metadata>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_ArrayRef<*mut llvm_Metadata>)
        )
    );
}
#[test]
fn __bindgen_test_layout_llvm_ArrayRef_open0_ptr_Metadata_close0_instantiation_10() {
    assert_eq!(
        ::std::mem::size_of::<llvm_ArrayRef<*mut llvm_Metadata>>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_ArrayRef<*mut llvm_Metadata>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_ArrayRef<*mut llvm_Metadata>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_ArrayRef<*mut llvm_Metadata>)
        )
    );
}
#[test]
fn __bindgen_test_layout_llvm_ArrayRef_open0_ptr_Metadata_close0_instantiation_11() {
    assert_eq!(
        ::std::mem::size_of::<llvm_ArrayRef<*mut llvm_Metadata>>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_ArrayRef<*mut llvm_Metadata>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_ArrayRef<*mut llvm_Metadata>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_ArrayRef<*mut llvm_Metadata>)
        )
    );
}
#[test]
fn __bindgen_test_layout_llvm_ArrayRef_open0_ptr_Metadata_close0_instantiation_12() {
    assert_eq!(
        ::std::mem::size_of::<llvm_ArrayRef<*mut llvm_Metadata>>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_ArrayRef<*mut llvm_Metadata>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_ArrayRef<*mut llvm_Metadata>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_ArrayRef<*mut llvm_Metadata>)
        )
    );
}
#[test]
fn __bindgen_test_layout_llvm_ArrayRef_open0_ptr_Metadata_close0_instantiation_13() {
    assert_eq!(
        ::std::mem::size_of::<llvm_ArrayRef<*mut llvm_Metadata>>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_ArrayRef<*mut llvm_Metadata>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_ArrayRef<*mut llvm_Metadata>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_ArrayRef<*mut llvm_Metadata>)
        )
    );
}
#[test]
fn __bindgen_test_layout_llvm_ArrayRef_open0_ptr_Metadata_close0_instantiation_14() {
    assert_eq!(
        ::std::mem::size_of::<llvm_ArrayRef<*mut llvm_Metadata>>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_ArrayRef<*mut llvm_Metadata>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_ArrayRef<*mut llvm_Metadata>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_ArrayRef<*mut llvm_Metadata>)
        )
    );
}
#[test]
fn __bindgen_test_layout_llvm_ArrayRef_open0_ptr_Metadata_close0_instantiation_15() {
    assert_eq!(
        ::std::mem::size_of::<llvm_ArrayRef<*mut llvm_Metadata>>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_ArrayRef<*mut llvm_Metadata>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_ArrayRef<*mut llvm_Metadata>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_ArrayRef<*mut llvm_Metadata>)
        )
    );
}
#[test]
fn __bindgen_test_layout_llvm_ArrayRef_open0_ptr_Metadata_close0_instantiation_16() {
    assert_eq!(
        ::std::mem::size_of::<llvm_ArrayRef<*mut llvm_Metadata>>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_ArrayRef<*mut llvm_Metadata>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_ArrayRef<*mut llvm_Metadata>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_ArrayRef<*mut llvm_Metadata>)
        )
    );
}
#[test]
fn __bindgen_test_layout_llvm_ilist_node_open0_llvm_NamedMDNode_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<llvm_ilist_node>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_ilist_node)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_ilist_node>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_ilist_node)
        )
    );
}
#[test]
fn __bindgen_test_layout_llvm_NamedMDNode_op_iterator_impl_open0_ptr_MDNode_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<llvm_NamedMDNode_op_iterator_impl>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_NamedMDNode_op_iterator_impl)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_NamedMDNode_op_iterator_impl>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_NamedMDNode_op_iterator_impl)
        )
    );
}
#[test]
fn __bindgen_test_layout_llvm_NamedMDNode_op_iterator_impl_open0_ptr_const_MDNode_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<llvm_NamedMDNode_op_iterator_impl>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_NamedMDNode_op_iterator_impl)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_NamedMDNode_op_iterator_impl>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_NamedMDNode_op_iterator_impl)
        )
    );
}
#[test]
fn __bindgen_test_layout_llvm_iterator_range_open0_llvm_NamedMDNode_op_iterator_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<llvm_iterator_range<llvm_NamedMDNode_op_iterator>>(),
        32usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_iterator_range<llvm_NamedMDNode_op_iterator>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_iterator_range<llvm_NamedMDNode_op_iterator>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_iterator_range<llvm_NamedMDNode_op_iterator>)
        )
    );
}
#[test]
fn __bindgen_test_layout_llvm_iterator_range_open0_llvm_NamedMDNode_const_op_iterator_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<llvm_iterator_range<llvm_NamedMDNode_const_op_iterator>>(),
        32usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_iterator_range<llvm_NamedMDNode_const_op_iterator>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_iterator_range<llvm_NamedMDNode_const_op_iterator>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_iterator_range<llvm_NamedMDNode_const_op_iterator>)
        )
    );
}
#[doc = " Represents an LLVM Named Metadata Node.\n\n This models llvm::NamedMDNode."]
pub type LLVMNamedMDNodeRef = *mut LLVMOpaqueNamedMDNode;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LLVMOpaqueNamedMDNode {
    _unused: [u8; 0],
}
#[test]
fn __bindgen_test_layout_llvm_TypedTrackingMDRef_open0_llvm_MDNode_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<llvm_TypedTrackingMDRef>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_TypedTrackingMDRef)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_TypedTrackingMDRef>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_TypedTrackingMDRef)
        )
    );
}
#[test]
fn __bindgen_test_layout_llvm_iterator_range_open0_llvm_ilist_select_iterator_type_open1__bindgen_ty_id_100454_close1_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<[u64; 2usize]>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!([u64; 2usize])
        )
    );
    assert_eq!(
        ::std::mem::align_of::<[u64; 2usize]>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!([u64; 2usize])
        )
    );
}
#[test]
fn __bindgen_test_layout_llvm_SymbolTableList_open0_llvm_Instruction_llvm_ilist_iterator_bits_open1_close1_llvm_ilist_parent_open1_llvm_BasicBlock_close1_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<llvm_SymbolTableList>(),
        24usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_SymbolTableList)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_SymbolTableList>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_SymbolTableList)
        )
    );
}
#[test]
fn __bindgen_test_layout_llvm_ilist_node_with_parent_open0_llvm_Instruction_llvm_BasicBlock_llvm_ilist_iterator_bits_open1_close1_llvm_ilist_parent_open1_llvm_BasicBlock_close1_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<llvm_ilist_node_with_parent>(),
        24usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_ilist_node_with_parent)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_ilist_node_with_parent>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_ilist_node_with_parent)
        )
    );
}
#[test]
fn __bindgen_test_layout_llvm_SymbolTableList_open0_llvm_Instruction_llvm_ilist_iterator_bits_open1_close1_llvm_ilist_parent_open1_llvm_BasicBlock_close1_close0_instantiation_1(
) {
    assert_eq!(
        ::std::mem::size_of::<llvm_SymbolTableList>(),
        24usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_SymbolTableList)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_SymbolTableList>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_SymbolTableList)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_optional_open0_llvm_ilist_select_iterator_type_open1__bindgen_ty_id_100506_close1_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<std_optional>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_optional)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_optional>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_optional)
        )
    );
}
#[test]
fn __bindgen_test_layout_llvm_iterator_range_open0_llvm_ilist_select_iterator_type_open1__bindgen_ty_id_100516_close1_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<[u64; 2usize]>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!([u64; 2usize])
        )
    );
    assert_eq!(
        ::std::mem::align_of::<[u64; 2usize]>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!([u64; 2usize])
        )
    );
}
#[test]
fn __bindgen_test_layout_llvm_iterator_range_open0_llvm_ilist_select_iterator_type_open1__bindgen_ty_id_100526_close1_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<[u64; 2usize]>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!([u64; 2usize])
        )
    );
    assert_eq!(
        ::std::mem::align_of::<[u64; 2usize]>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!([u64; 2usize])
        )
    );
}
#[test]
fn __bindgen_test_layout_std_optional_open0_llvm_ilist_select_iterator_type_open1__bindgen_ty_id_100536_close1_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<std_optional>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_optional)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_optional>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_optional)
        )
    );
}
#[test]
fn __bindgen_test_layout_llvm_ArrayRef_open0_unsigned_int_close0_instantiation_5() {
    assert_eq!(
        ::std::mem::size_of::<llvm_ArrayRef<::std::os::raw::c_uint>>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_ArrayRef<::std::os::raw::c_uint>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_ArrayRef<::std::os::raw::c_uint>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_ArrayRef<::std::os::raw::c_uint>)
        )
    );
}
#[test]
fn __bindgen_test_layout_llvm_ArrayRef_open0_unsigned_int_close0_instantiation_6() {
    assert_eq!(
        ::std::mem::size_of::<llvm_ArrayRef<::std::os::raw::c_uint>>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_ArrayRef<::std::os::raw::c_uint>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_ArrayRef<::std::os::raw::c_uint>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_ArrayRef<::std::os::raw::c_uint>)
        )
    );
}
#[test]
fn __bindgen_test_layout_llvm_ArrayRef_open0_unsigned_int_close0_instantiation_7() {
    assert_eq!(
        ::std::mem::size_of::<llvm_ArrayRef<::std::os::raw::c_uint>>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_ArrayRef<::std::os::raw::c_uint>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_ArrayRef<::std::os::raw::c_uint>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_ArrayRef<::std::os::raw::c_uint>)
        )
    );
}
#[test]
fn __bindgen_test_layout_llvm_ilist_node_open0_llvm_DbgRecord_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<llvm_ilist_node>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_ilist_node)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_ilist_node>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_ilist_node)
        )
    );
}
#[test]
fn __bindgen_test_layout_llvm_DbgRecordParamRef_open0_llvm_DILabel_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<llvm_DbgRecordParamRef>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_DbgRecordParamRef)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_DbgRecordParamRef>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_DbgRecordParamRef)
        )
    );
}
#[test]
fn __bindgen_test_layout_llvm_DbgRecordParamRef_open0_llvm_DILocalVariable_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<llvm_DbgRecordParamRef>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_DbgRecordParamRef)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_DbgRecordParamRef>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_DbgRecordParamRef)
        )
    );
}
#[test]
fn __bindgen_test_layout_llvm_DbgRecordParamRef_open0_llvm_DIExpression_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<llvm_DbgRecordParamRef>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_DbgRecordParamRef)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_DbgRecordParamRef>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_DbgRecordParamRef)
        )
    );
}
#[test]
fn __bindgen_test_layout_llvm_DbgRecordParamRef_open0_llvm_DIExpression_close0_instantiation_1() {
    assert_eq!(
        ::std::mem::size_of::<llvm_DbgRecordParamRef>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_DbgRecordParamRef)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_DbgRecordParamRef>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_DbgRecordParamRef)
        )
    );
}
#[test]
fn __bindgen_test_layout_llvm_iterator_facade_base_open0_llvm_DbgVariableRecord_location_op_iterator_std_bidirectional_iterator_tag_ptr_Value_long_ptr_ptr_Value_ref_ptr_Value_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<llvm_iterator_facade_base>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_iterator_facade_base)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_iterator_facade_base>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_iterator_facade_base)
        )
    );
}
#[test]
fn __bindgen_test_layout_llvm_PointerUnion_open0_ptr_ValueAsMetadata_ptr_ptr_ValueAsMetadata_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<llvm_PointerUnion>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_PointerUnion)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_PointerUnion>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_PointerUnion)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_optional_open0_llvm_DbgVariableFragmentInfo_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_optional>(),
        24usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_optional)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_optional>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_optional)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_optional_open0_uint64_t_close0_instantiation_3() {
    assert_eq!(
        ::std::mem::size_of::<std_optional>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_optional)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_optional>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_optional)
        )
    );
}
#[test]
fn __bindgen_test_layout_llvm_iterator_range_open0_llvm_ilist_select_iterator_type_open1__bindgen_ty_id_101112_close1_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<[u64; 2usize]>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!([u64; 2usize])
        )
    );
    assert_eq!(
        ::std::mem::align_of::<[u64; 2usize]>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!([u64; 2usize])
        )
    );
}
#[test]
fn __bindgen_test_layout_llvm_iterator_range_open0__bindgen_ty_id_101121_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<llvm_iterator_range<[u64; 4usize]>>(),
        64usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_iterator_range<[u64; 4usize]>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_iterator_range<[u64; 4usize]>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_iterator_range<[u64; 4usize]>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_reference_wrapper_open0_llvm_DbgVariableRecord_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_reference_wrapper<llvm_DbgVariableRecord>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_reference_wrapper<llvm_DbgVariableRecord>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_reference_wrapper<llvm_DbgVariableRecord>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_reference_wrapper<llvm_DbgVariableRecord>)
        )
    );
}
#[test]
fn __bindgen_test_layout_llvm_simple_ilist_open0_llvm_DbgRecord_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<llvm_simple_ilist>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_simple_ilist)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_simple_ilist>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_simple_ilist)
        )
    );
}
#[test]
fn __bindgen_test_layout_llvm_iterator_range_open0_llvm_ilist_select_iterator_type_open1__bindgen_ty_id_101157_close1_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<[u64; 2usize]>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!([u64; 2usize])
        )
    );
    assert_eq!(
        ::std::mem::align_of::<[u64; 2usize]>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!([u64; 2usize])
        )
    );
}
#[test]
fn __bindgen_test_layout_llvm_iterator_range_open0_llvm_DbgRecord_self_iterator_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<llvm_iterator_range<llvm_DbgRecord_self_iterator>>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_iterator_range<llvm_DbgRecord_self_iterator>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_iterator_range<llvm_DbgRecord_self_iterator>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_iterator_range<llvm_DbgRecord_self_iterator>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_optional_open0_llvm_ilist_select_iterator_type_open1__bindgen_ty_id_101196_close1_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<std_optional>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_optional)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_optional>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_optional)
        )
    );
}
#[test]
fn __bindgen_test_layout_llvm_iterator_range_open0_llvm_ilist_select_iterator_type_open1__bindgen_ty_id_101206_close1_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<[u64; 2usize]>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!([u64; 2usize])
        )
    );
    assert_eq!(
        ::std::mem::align_of::<[u64; 2usize]>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!([u64; 2usize])
        )
    );
}
#[test]
fn __bindgen_test_layout_llvm_iterator_range_open0_llvm_ilist_select_iterator_type_open1__bindgen_ty_id_101218_close1_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<[u64; 2usize]>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!([u64; 2usize])
        )
    );
    assert_eq!(
        ::std::mem::align_of::<[u64; 2usize]>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!([u64; 2usize])
        )
    );
}
#[test]
fn __bindgen_test_layout_llvm_iterator_range_open0_llvm_ilist_select_iterator_type_open1__bindgen_ty_id_101230_close1_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<[u64; 2usize]>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!([u64; 2usize])
        )
    );
    assert_eq!(
        ::std::mem::align_of::<[u64; 2usize]>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!([u64; 2usize])
        )
    );
}
#[doc = " @see llvm::DbgRecord"]
pub type LLVMDbgRecordRef = *mut LLVMOpaqueDbgRecord;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LLVMOpaqueDbgRecord {
    _unused: [u8; 0],
}
#[test]
fn __bindgen_test_layout_llvm_ilist_node_with_parent_open0_llvm_BasicBlock_llvm_Function_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<llvm_ilist_node_with_parent>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_ilist_node_with_parent)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_ilist_node_with_parent>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_ilist_node_with_parent)
        )
    );
}
#[test]
fn __bindgen_test_layout_llvm_SymbolTableList_open0_llvm_Instruction_llvm_ilist_iterator_bits_open1_close1_llvm_ilist_parent_open1_llvm_BasicBlock_close1_close0_instantiation_2(
) {
    assert_eq!(
        ::std::mem::size_of::<llvm_SymbolTableList>(),
        24usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_SymbolTableList)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_SymbolTableList>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_SymbolTableList)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_optional_open0_llvm_DbgRecord_self_iterator_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_optional>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_optional)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_optional>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_optional)
        )
    );
}
#[doc = " Return the size of the basic block ignoring debug instructions"]
pub type difference_type = ::std::os::raw::c_long;
#[test]
fn __bindgen_test_layout_llvm_BasicBlock_phi_iterator_impl_open0_llvm_PHINode_llvm_ilist_iterator_w_bits_open1_llvm_ilist_detail_node_options_open2_llvm_Instruction_void_llvm_BasicBlock_close2_close1_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<llvm_BasicBlock_phi_iterator_impl<llvm_PHINode>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_BasicBlock_phi_iterator_impl<llvm_PHINode>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_BasicBlock_phi_iterator_impl<llvm_PHINode>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_BasicBlock_phi_iterator_impl<llvm_PHINode>)
        )
    );
}
#[test]
fn __bindgen_test_layout_llvm_BasicBlock_phi_iterator_impl_open0_llvm_PHINode_llvm_BasicBlock_const_iterator_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<llvm_BasicBlock_phi_iterator_impl<llvm_PHINode>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_BasicBlock_phi_iterator_impl<llvm_PHINode>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_BasicBlock_phi_iterator_impl<llvm_PHINode>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_BasicBlock_phi_iterator_impl<llvm_PHINode>)
        )
    );
}
#[test]
fn __bindgen_test_layout_llvm_iterator_range_open0_llvm_BasicBlock_const_phi_iterator_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<llvm_iterator_range<llvm_BasicBlock_const_phi_iterator>>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_iterator_range<llvm_BasicBlock_const_phi_iterator>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_iterator_range<llvm_BasicBlock_const_phi_iterator>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_iterator_range<llvm_BasicBlock_const_phi_iterator>)
        )
    );
}
#[test]
fn __bindgen_test_layout_llvm_iterator_range_open0_llvm_BasicBlock_phi_iterator_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<llvm_iterator_range<llvm_BasicBlock_phi_iterator>>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_iterator_range<llvm_BasicBlock_phi_iterator>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_iterator_range<llvm_BasicBlock_phi_iterator>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_iterator_range<llvm_BasicBlock_phi_iterator>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_optional_open0_uint64_t_close0_instantiation_4() {
    assert_eq!(
        ::std::mem::size_of::<std_optional>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_optional)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_optional>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_optional)
        )
    );
}
#[doc = " Represents a basic block of instructions in LLVM IR.\n\n This models llvm::BasicBlock."]
pub type LLVMBasicBlockRef = *mut LLVMOpaqueBasicBlock;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LLVMOpaqueBasicBlock {
    _unused: [u8; 0],
}
#[test]
fn __bindgen_test_layout_llvm_ilist_node_open0_llvm_Function_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<llvm_ilist_node>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_ilist_node)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_ilist_node>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_ilist_node)
        )
    );
}
#[test]
fn __bindgen_test_layout_llvm_SymbolTableList_open0_llvm_BasicBlock_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<llvm_SymbolTableList>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_SymbolTableList)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_SymbolTableList>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_SymbolTableList)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_unique_ptr_open0_llvm_ValueSymbolTable_std_default_delete_open1_llvm_ValueSymbolTable_close1_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<std_unique_ptr>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_unique_ptr)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_unique_ptr>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_unique_ptr)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_default_delete_open0_llvm_ValueSymbolTable_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_default_delete>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_default_delete)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_default_delete>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_default_delete)
        )
    );
}
#[test]
fn __bindgen_test_layout_llvm_DenseMapInfo_open0_unsigned_long_void_close0_instantiation_1() {
    assert_eq!(
        ::std::mem::size_of::<llvm_DenseMapInfo>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_DenseMapInfo)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_DenseMapInfo>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_DenseMapInfo)
        )
    );
}
#[test]
fn __bindgen_test_layout_llvm_DenseMapInfo_open0_unsigned_long_void_close0_instantiation_2() {
    assert_eq!(
        ::std::mem::size_of::<llvm_DenseMapInfo>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_DenseMapInfo)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_DenseMapInfo>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_DenseMapInfo)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_optional_open0_llvm_Function_ProfileCount_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_optional>(),
        24usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_optional)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_optional>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_optional)
        )
    );
}
#[test]
fn __bindgen_test_layout_llvm_DenseMapInfo_open0_unsigned_long_void_close0_instantiation_3() {
    assert_eq!(
        ::std::mem::size_of::<llvm_DenseMapInfo>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_DenseMapInfo)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_DenseMapInfo>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_DenseMapInfo)
        )
    );
}
#[test]
fn __bindgen_test_layout_llvm_iterator_range_open0_llvm_Function_arg_iterator_close0_instantiation()
{
    assert_eq!(
        ::std::mem::size_of::<llvm_iterator_range<llvm_Function_arg_iterator>>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_iterator_range<llvm_Function_arg_iterator>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_iterator_range<llvm_Function_arg_iterator>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_iterator_range<llvm_Function_arg_iterator>)
        )
    );
}
#[test]
fn __bindgen_test_layout_llvm_iterator_range_open0_llvm_Function_const_arg_iterator_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<llvm_iterator_range<llvm_Function_const_arg_iterator>>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_iterator_range<llvm_Function_const_arg_iterator>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_iterator_range<llvm_Function_const_arg_iterator>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_iterator_range<llvm_Function_const_arg_iterator>)
        )
    );
}
#[test]
fn __bindgen_test_layout_llvm_ilist_node_open0_llvm_GlobalAlias_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<llvm_ilist_node>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_ilist_node)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_ilist_node>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_ilist_node)
        )
    );
}
#[test]
fn __bindgen_test_layout_llvm_ilist_node_open0_llvm_GlobalIFunc_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<llvm_ilist_node>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_ilist_node)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_ilist_node>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_ilist_node)
        )
    );
}
#[test]
fn __bindgen_test_layout_llvm_ilist_node_open0_llvm_GlobalVariable_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<llvm_ilist_node>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_ilist_node)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_ilist_node>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_ilist_node)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_optional_open0_unsigned_int_close0_instantiation_10() {
    assert_eq!(
        ::std::mem::size_of::<std_optional>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_optional)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_optional>(),
        4usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_optional)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_optional_open0_llvm_CodeModel_Model_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_optional>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_optional)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_optional>(),
        4usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_optional)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_vector_open0_llvm_ProfileSummaryEntry_std_allocator_open1_llvm_ProfileSummaryEntry_close1_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<std_vector>(),
        24usize,
        concat!("Size of template specialization: ", stringify!(std_vector))
    );
    assert_eq!(
        ::std::mem::align_of::<std_vector>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_vector)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_allocator_open0_llvm_ProfileSummaryEntry_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_allocator>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_allocator)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_allocator>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_allocator)
        )
    );
}
#[test]
fn __bindgen_test_layout_llvm_SymbolTableList_open0_llvm_GlobalVariable_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<llvm_SymbolTableList>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_SymbolTableList)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_SymbolTableList>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_SymbolTableList)
        )
    );
}
#[test]
fn __bindgen_test_layout_llvm_SymbolTableList_open0_llvm_Function_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<llvm_SymbolTableList>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_SymbolTableList)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_SymbolTableList>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_SymbolTableList)
        )
    );
}
#[test]
fn __bindgen_test_layout_llvm_SymbolTableList_open0_llvm_GlobalAlias_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<llvm_SymbolTableList>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_SymbolTableList)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_SymbolTableList>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_SymbolTableList)
        )
    );
}
#[test]
fn __bindgen_test_layout_llvm_SymbolTableList_open0_llvm_GlobalIFunc_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<llvm_SymbolTableList>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_SymbolTableList)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_SymbolTableList>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_SymbolTableList)
        )
    );
}
#[test]
fn __bindgen_test_layout_llvm_iplist_open0_llvm_NamedMDNode_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<llvm_iplist>(),
        16usize,
        concat!("Size of template specialization: ", stringify!(llvm_iplist))
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_iplist>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_iplist)
        )
    );
}
#[test]
fn __bindgen_test_layout_llvm_StringMap_open0_llvm_Comdat_llvm_MallocAllocator_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<llvm_StringMap<llvm_MallocAllocator>>(),
        24usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_StringMap<llvm_MallocAllocator>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_StringMap<llvm_MallocAllocator>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_StringMap<llvm_MallocAllocator>)
        )
    );
}
#[test]
fn __bindgen_test_layout_llvm_StringMap_open0_ptr_NamedMDNode_llvm_MallocAllocator_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<llvm_StringMap<llvm_MallocAllocator>>(),
        24usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_StringMap<llvm_MallocAllocator>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_StringMap<llvm_MallocAllocator>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_StringMap<llvm_MallocAllocator>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_unique_ptr_open0_llvm_ValueSymbolTable_std_default_delete_open1_llvm_ValueSymbolTable_close1_close0_instantiation_1(
) {
    assert_eq!(
        ::std::mem::size_of::<std_unique_ptr>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_unique_ptr)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_unique_ptr>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_unique_ptr)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_default_delete_open0_llvm_ValueSymbolTable_close0_instantiation_1() {
    assert_eq!(
        ::std::mem::size_of::<std_default_delete>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_default_delete)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_default_delete>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_default_delete)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_unique_ptr_open0_llvm_MemoryBuffer_std_default_delete_open1_llvm_MemoryBuffer_close1_close0_instantiation_13(
) {
    assert_eq!(
        ::std::mem::size_of::<std_unique_ptr>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_unique_ptr)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_unique_ptr>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_unique_ptr)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_default_delete_open0_llvm_MemoryBuffer_close0_instantiation_13() {
    assert_eq!(
        ::std::mem::size_of::<std_default_delete>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_default_delete)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_default_delete>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_default_delete)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_unique_ptr_open0_llvm_GVMaterializer_std_default_delete_open1_llvm_GVMaterializer_close1_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<std_unique_ptr>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_unique_ptr)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_unique_ptr>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_unique_ptr)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_default_delete_open0_llvm_GVMaterializer_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_default_delete>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_default_delete)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_default_delete>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_default_delete)
        )
    );
}
#[test]
fn __bindgen_test_layout_llvm_StringMap_open0_unsigned_int_llvm_MallocAllocator_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<llvm_StringMap<llvm_MallocAllocator>>(),
        24usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_StringMap<llvm_MallocAllocator>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_StringMap<llvm_MallocAllocator>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_StringMap<llvm_MallocAllocator>)
        )
    );
}
#[test]
fn __bindgen_test_layout_llvm_DenseMap_open0_std_pair_open1_llvm_Intrinsic_ID_ptr_const_FunctionType_close1_unsigned_int_llvm_DenseMapInfo_open1_std_pair_open2_unsigned_int_ptr_const_llvm__FunctionType_close2_void_close1_llvm_detail_DenseMapPair_open1_std_pair_open2_unsigned_int_ptr_const_llvm__FunctionType_close2_unsigned_int_close1_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<
            llvm_DenseMap<
                llvm_detail_DenseMapPair<
                    std_pair<::std::os::raw::c_uint, *const llvm_FunctionType>,
                    ::std::os::raw::c_uint,
                >,
            >,
        >(),
        32usize,
        concat!(
            "Size of template specialization: ",
            stringify!(
                llvm_DenseMap<
                    llvm_detail_DenseMapPair<
                        std_pair<::std::os::raw::c_uint, *const llvm_FunctionType>,
                        ::std::os::raw::c_uint,
                    >,
                >
            )
        )
    );
    assert_eq!(
        ::std::mem::align_of::<
            llvm_DenseMap<
                llvm_detail_DenseMapPair<
                    std_pair<::std::os::raw::c_uint, *const llvm_FunctionType>,
                    ::std::os::raw::c_uint,
                >,
            >,
        >(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(
                llvm_DenseMap<
                    llvm_detail_DenseMapPair<
                        std_pair<::std::os::raw::c_uint, *const llvm_FunctionType>,
                        ::std::os::raw::c_uint,
                    >,
                >
            )
        )
    );
}
#[test]
fn __bindgen_test_layout_llvm_SmallVectorImpl_open0_llvm_StringRef_close0_instantiation_5() {
    assert_eq!(
        ::std::mem::size_of::<llvm_SmallVectorImpl>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_SmallVectorImpl)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_SmallVectorImpl>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_SmallVectorImpl)
        )
    );
}
#[test]
fn __bindgen_test_layout_llvm_SmallVectorImpl_open0_llvm_StringRef_close0_instantiation_6() {
    assert_eq!(
        ::std::mem::size_of::<llvm_SmallVectorImpl>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_SmallVectorImpl)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_SmallVectorImpl>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_SmallVectorImpl)
        )
    );
}
#[test]
fn __bindgen_test_layout_llvm_iterator_range_open0_llvm_Module_global_iterator_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<llvm_iterator_range<llvm_Module_global_iterator>>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_iterator_range<llvm_Module_global_iterator>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_iterator_range<llvm_Module_global_iterator>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_iterator_range<llvm_Module_global_iterator>)
        )
    );
}
#[test]
fn __bindgen_test_layout_llvm_iterator_range_open0_llvm_Module_const_global_iterator_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<llvm_iterator_range<llvm_Module_const_global_iterator>>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_iterator_range<llvm_Module_const_global_iterator>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_iterator_range<llvm_Module_const_global_iterator>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_iterator_range<llvm_Module_const_global_iterator>)
        )
    );
}
#[test]
fn __bindgen_test_layout_llvm_iterator_range_open0_llvm_Module_iterator_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<llvm_iterator_range<llvm_Module_iterator>>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_iterator_range<llvm_Module_iterator>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_iterator_range<llvm_Module_iterator>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_iterator_range<llvm_Module_iterator>)
        )
    );
}
#[test]
fn __bindgen_test_layout_llvm_iterator_range_open0_llvm_Module_const_iterator_close0_instantiation()
{
    assert_eq!(
        ::std::mem::size_of::<llvm_iterator_range<llvm_Module_const_iterator>>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_iterator_range<llvm_Module_const_iterator>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_iterator_range<llvm_Module_const_iterator>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_iterator_range<llvm_Module_const_iterator>)
        )
    );
}
#[test]
fn __bindgen_test_layout_llvm_iterator_range_open0_llvm_Module_alias_iterator_close0_instantiation()
{
    assert_eq!(
        ::std::mem::size_of::<llvm_iterator_range<llvm_Module_alias_iterator>>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_iterator_range<llvm_Module_alias_iterator>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_iterator_range<llvm_Module_alias_iterator>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_iterator_range<llvm_Module_alias_iterator>)
        )
    );
}
#[test]
fn __bindgen_test_layout_llvm_iterator_range_open0_llvm_Module_const_alias_iterator_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<llvm_iterator_range<llvm_Module_const_alias_iterator>>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_iterator_range<llvm_Module_const_alias_iterator>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_iterator_range<llvm_Module_const_alias_iterator>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_iterator_range<llvm_Module_const_alias_iterator>)
        )
    );
}
#[test]
fn __bindgen_test_layout_llvm_iterator_range_open0_llvm_Module_ifunc_iterator_close0_instantiation()
{
    assert_eq!(
        ::std::mem::size_of::<llvm_iterator_range<llvm_Module_ifunc_iterator>>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_iterator_range<llvm_Module_ifunc_iterator>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_iterator_range<llvm_Module_ifunc_iterator>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_iterator_range<llvm_Module_ifunc_iterator>)
        )
    );
}
#[test]
fn __bindgen_test_layout_llvm_iterator_range_open0_llvm_Module_const_ifunc_iterator_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<llvm_iterator_range<llvm_Module_const_ifunc_iterator>>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_iterator_range<llvm_Module_const_ifunc_iterator>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_iterator_range<llvm_Module_const_ifunc_iterator>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_iterator_range<llvm_Module_const_ifunc_iterator>)
        )
    );
}
#[test]
fn __bindgen_test_layout_llvm_iterator_range_open0_llvm_Module_named_metadata_iterator_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<llvm_iterator_range<llvm_Module_named_metadata_iterator>>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_iterator_range<llvm_Module_named_metadata_iterator>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_iterator_range<llvm_Module_named_metadata_iterator>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_iterator_range<llvm_Module_named_metadata_iterator>)
        )
    );
}
#[test]
fn __bindgen_test_layout_llvm_iterator_range_open0_llvm_Module_const_named_metadata_iterator_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<llvm_iterator_range<llvm_Module_const_named_metadata_iterator>>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_iterator_range<llvm_Module_const_named_metadata_iterator>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_iterator_range<llvm_Module_const_named_metadata_iterator>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_iterator_range<llvm_Module_const_named_metadata_iterator>)
        )
    );
}
#[test]
fn __bindgen_test_layout_llvm_iterator_range_open0_llvm_Module_debug_compile_units_iterator_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<llvm_iterator_range<llvm_Module_debug_compile_units_iterator>>(),
        32usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_iterator_range<llvm_Module_debug_compile_units_iterator>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_iterator_range<llvm_Module_debug_compile_units_iterator>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_iterator_range<llvm_Module_debug_compile_units_iterator>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_optional_open0_llvm_CodeModel_Model_close0_instantiation_1() {
    assert_eq!(
        ::std::mem::size_of::<std_optional>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_optional)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_optional>(),
        4usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_optional)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_optional_open0_uint64_t_close0_instantiation_5() {
    assert_eq!(
        ::std::mem::size_of::<std_optional>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_optional)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_optional>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_optional)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_unique_ptr_open0_llvm_MemoryBuffer_std_default_delete_open1_llvm_MemoryBuffer_close1_close0_instantiation_14(
) {
    assert_eq!(
        ::std::mem::size_of::<std_unique_ptr>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_unique_ptr)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_unique_ptr>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_unique_ptr)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_default_delete_open0_llvm_MemoryBuffer_close0_instantiation_14() {
    assert_eq!(
        ::std::mem::size_of::<std_default_delete>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_default_delete)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_default_delete>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_default_delete)
        )
    );
}
#[doc = " The top-level container for all other LLVM Intermediate Representation (IR)\n objects.\n\n @see llvm::Module"]
pub type LLVMModuleRef = *mut LLVMOpaqueModule;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LLVMOpaqueModule {
    _unused: [u8; 0],
}
#[doc = " Interface used to provide a module to JIT or interpreter.\n This is now just a synonym for llvm::Module, but we have to keep using the\n different type to keep binary compatibility."]
pub type LLVMModuleProviderRef = *mut LLVMOpaqueModuleProvider;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LLVMOpaqueModuleProvider {
    _unused: [u8; 0],
}
#[test]
fn __bindgen_test_layout_llvm_ArrayRef_open0_uint8_t_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<llvm_ArrayRef<u8>>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_ArrayRef<u8>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_ArrayRef<u8>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_ArrayRef<u8>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_optional_open0_uint64_t_close0_instantiation_6() {
    assert_eq!(
        ::std::mem::size_of::<std_optional>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_optional)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_optional>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_optional)
        )
    );
}
#[test]
fn __bindgen_test_layout_llvm_ArrayRef_open0_uint8_t_close0_instantiation_1() {
    assert_eq!(
        ::std::mem::size_of::<llvm_ArrayRef<u8>>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_ArrayRef<u8>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_ArrayRef<u8>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_ArrayRef<u8>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_optional_open0_uint64_t_close0_instantiation_7() {
    assert_eq!(
        ::std::mem::size_of::<std_optional>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_optional)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_optional>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_optional)
        )
    );
}
#[test]
fn __bindgen_test_layout_llvm_ArrayRef_open0_uint8_t_close0_instantiation_2() {
    assert_eq!(
        ::std::mem::size_of::<llvm_ArrayRef<u8>>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_ArrayRef<u8>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_ArrayRef<u8>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_ArrayRef<u8>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_optional_open0_uint64_t_close0_instantiation_8() {
    assert_eq!(
        ::std::mem::size_of::<std_optional>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_optional)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_optional>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_optional)
        )
    );
}
#[test]
fn __bindgen_test_layout_llvm_ArrayRef_open0_uint8_t_close0_instantiation_3() {
    assert_eq!(
        ::std::mem::size_of::<llvm_ArrayRef<u8>>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_ArrayRef<u8>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_ArrayRef<u8>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_ArrayRef<u8>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_optional_open0_uint64_t_close0_instantiation_9() {
    assert_eq!(
        ::std::mem::size_of::<std_optional>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_optional)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_optional>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_optional)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_unique_ptr_open0_llvm_ErrorInfoBase_std_default_delete_open1_llvm_ErrorInfoBase_close1_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<std_unique_ptr>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_unique_ptr)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_unique_ptr>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_unique_ptr)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_default_delete_open0_llvm_ErrorInfoBase_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_default_delete>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_default_delete)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_default_delete>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_default_delete)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_unique_ptr_open0_llvm_ErrorInfoBase_std_default_delete_open1_llvm_ErrorInfoBase_close1_close0_instantiation_1(
) {
    assert_eq!(
        ::std::mem::size_of::<std_unique_ptr>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_unique_ptr)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_unique_ptr>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_unique_ptr)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_default_delete_open0_llvm_ErrorInfoBase_close0_instantiation_1() {
    assert_eq!(
        ::std::mem::size_of::<std_default_delete>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_default_delete)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_default_delete>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_default_delete)
        )
    );
}
#[test]
fn __bindgen_test_layout_llvm_ErrorInfo_open0_llvm_ErrorList_llvm_ErrorInfoBase_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<llvm_ErrorInfo<llvm_ErrorInfoBase>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_ErrorInfo<llvm_ErrorInfoBase>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_ErrorInfo<llvm_ErrorInfoBase>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_ErrorInfo<llvm_ErrorInfoBase>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_unique_ptr_open0_llvm_ErrorInfoBase_std_default_delete_open1_llvm_ErrorInfoBase_close1_close0_instantiation_2(
) {
    assert_eq!(
        ::std::mem::size_of::<std_unique_ptr>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_unique_ptr)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_unique_ptr>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_unique_ptr)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_default_delete_open0_llvm_ErrorInfoBase_close0_instantiation_2() {
    assert_eq!(
        ::std::mem::size_of::<std_default_delete>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_default_delete)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_default_delete>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_default_delete)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_unique_ptr_open0_llvm_ErrorInfoBase_std_default_delete_open1_llvm_ErrorInfoBase_close1_close0_instantiation_3(
) {
    assert_eq!(
        ::std::mem::size_of::<std_unique_ptr>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_unique_ptr)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_unique_ptr>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_unique_ptr)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_default_delete_open0_llvm_ErrorInfoBase_close0_instantiation_3() {
    assert_eq!(
        ::std::mem::size_of::<std_default_delete>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_default_delete)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_default_delete>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_default_delete)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_vector_open0_std_unique_ptr_open1_llvm_ErrorInfoBase_std_default_delete_open2_llvm_ErrorInfoBase_close2_close1_std_allocator_open1_std_unique_ptr_open2_llvm_ErrorInfoBase_std_default_delete_open3_llvm_ErrorInfoBase_close3_close2_close1_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<std_vector>(),
        24usize,
        concat!("Size of template specialization: ", stringify!(std_vector))
    );
    assert_eq!(
        ::std::mem::align_of::<std_vector>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_vector)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_unique_ptr_open0_llvm_ErrorInfoBase_std_default_delete_open1_llvm_ErrorInfoBase_close1_close0_instantiation_4(
) {
    assert_eq!(
        ::std::mem::size_of::<std_unique_ptr>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_unique_ptr)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_unique_ptr>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_unique_ptr)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_default_delete_open0_llvm_ErrorInfoBase_close0_instantiation_4() {
    assert_eq!(
        ::std::mem::size_of::<std_default_delete>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_default_delete)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_default_delete>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_default_delete)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_allocator_open0_std_unique_ptr_open1_llvm_ErrorInfoBase_std_default_delete_open2_llvm_ErrorInfoBase_close2_close1_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<std_allocator>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_allocator)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_allocator>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_allocator)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_unique_ptr_open0_llvm_ErrorInfoBase_std_default_delete_open1_llvm_ErrorInfoBase_close1_close0_instantiation_5(
) {
    assert_eq!(
        ::std::mem::size_of::<std_unique_ptr>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_unique_ptr)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_unique_ptr>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_unique_ptr)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_default_delete_open0_llvm_ErrorInfoBase_close0_instantiation_5() {
    assert_eq!(
        ::std::mem::size_of::<std_default_delete>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_default_delete)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_default_delete>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_default_delete)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_unique_ptr_open0_llvm_ErrorInfoBase_std_default_delete_open1_llvm_ErrorInfoBase_close1_close0_instantiation_6(
) {
    assert_eq!(
        ::std::mem::size_of::<std_unique_ptr>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_unique_ptr)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_unique_ptr>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_unique_ptr)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_default_delete_open0_llvm_ErrorInfoBase_close0_instantiation_6() {
    assert_eq!(
        ::std::mem::size_of::<std_default_delete>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_default_delete)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_default_delete>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_default_delete)
        )
    );
}
#[test]
fn __bindgen_test_layout_llvm_AlignedCharArrayUnion_open0_llvm_Expected_error_type_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<llvm_AlignedCharArrayUnion>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_AlignedCharArrayUnion)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_AlignedCharArrayUnion>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_AlignedCharArrayUnion)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_unique_ptr_open0_llvm_ErrorInfoBase_std_default_delete_open1_llvm_ErrorInfoBase_close1_close0_instantiation_7(
) {
    assert_eq!(
        ::std::mem::size_of::<std_unique_ptr>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_unique_ptr)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_unique_ptr>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_unique_ptr)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_default_delete_open0_llvm_ErrorInfoBase_close0_instantiation_7() {
    assert_eq!(
        ::std::mem::size_of::<std_default_delete>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_default_delete)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_default_delete>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_default_delete)
        )
    );
}
#[test]
fn __bindgen_test_layout_llvm_ErrorInfo_open0_llvm_ECError_llvm_ErrorInfoBase_close0_instantiation()
{
    assert_eq!(
        ::std::mem::size_of::<llvm_ErrorInfo<llvm_ErrorInfoBase>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_ErrorInfo<llvm_ErrorInfoBase>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_ErrorInfo<llvm_ErrorInfoBase>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_ErrorInfo<llvm_ErrorInfoBase>)
        )
    );
}
#[test]
fn __bindgen_test_layout_llvm_ErrorInfo_open0_llvm_StringError_llvm_ErrorInfoBase_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<llvm_ErrorInfo<llvm_ErrorInfoBase>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_ErrorInfo<llvm_ErrorInfoBase>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_ErrorInfo<llvm_ErrorInfoBase>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_ErrorInfo<llvm_ErrorInfoBase>)
        )
    );
}
#[test]
fn __bindgen_test_layout_llvm_ErrorInfo_open0_llvm_FileError_llvm_ErrorInfoBase_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<llvm_ErrorInfo<llvm_ErrorInfoBase>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_ErrorInfo<llvm_ErrorInfoBase>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_ErrorInfo<llvm_ErrorInfoBase>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_ErrorInfo<llvm_ErrorInfoBase>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_optional_open0_size_t_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_optional>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_optional)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_optional>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_optional)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_unique_ptr_open0_llvm_ErrorInfoBase_std_default_delete_open1_llvm_ErrorInfoBase_close1_close0_instantiation_8(
) {
    assert_eq!(
        ::std::mem::size_of::<std_unique_ptr>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_unique_ptr)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_unique_ptr>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_unique_ptr)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_default_delete_open0_llvm_ErrorInfoBase_close0_instantiation_8() {
    assert_eq!(
        ::std::mem::size_of::<std_default_delete>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_default_delete)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_default_delete>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_default_delete)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_optional_open0_size_t_close0_instantiation_1() {
    assert_eq!(
        ::std::mem::size_of::<std_optional>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_optional)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_optional>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_optional)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_optional_open0_size_t_close0_instantiation_2() {
    assert_eq!(
        ::std::mem::size_of::<std_optional>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_optional)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_optional>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_optional)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_unique_ptr_open0_llvm_ErrorInfoBase_std_default_delete_open1_llvm_ErrorInfoBase_close1_close0_instantiation_9(
) {
    assert_eq!(
        ::std::mem::size_of::<std_unique_ptr>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_unique_ptr)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_unique_ptr>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_unique_ptr)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_default_delete_open0_llvm_ErrorInfoBase_close0_instantiation_9() {
    assert_eq!(
        ::std::mem::size_of::<std_default_delete>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_default_delete)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_default_delete>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_default_delete)
        )
    );
}
#[doc = " Conversion from Error to LLVMErrorRef for C error bindings."]
pub type LLVMErrorRef = *mut LLVMOpaqueError;
#[doc = " Conversion from Error to LLVMErrorRef for C error bindings."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LLVMOpaqueError {
    pub _address: u8,
}
#[test]
fn __bindgen_test_layout_std_optional_open0_llvm_DataLayoutCallbackFuncTy_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_optional>(),
        40usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_optional)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_optional>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_optional)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_optional_open0_llvm_ValueTypeCallbackTy_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_optional>(),
        40usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_optional)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_optional>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_optional)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_optional_open0_llvm_MDTypeCallbackTy_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_optional>(),
        40usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_optional)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_optional>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_optional)
        )
    );
}
#[test]
fn __bindgen_test_layout_llvm_ArrayRef_open0_uint8_t_close0_instantiation_4() {
    assert_eq!(
        ::std::mem::size_of::<llvm_ArrayRef<u8>>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_ArrayRef<u8>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_ArrayRef<u8>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_ArrayRef<u8>)
        )
    );
}
#[test]
fn __bindgen_test_layout_llvm_ArrayRef_open0_uint8_t_close0_instantiation_5() {
    assert_eq!(
        ::std::mem::size_of::<llvm_ArrayRef<u8>>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_ArrayRef<u8>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_ArrayRef<u8>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_ArrayRef<u8>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_vector_open0_llvm_BitcodeModule_std_allocator_open1_llvm_BitcodeModule_close1_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<std_vector>(),
        24usize,
        concat!("Size of template specialization: ", stringify!(std_vector))
    );
    assert_eq!(
        ::std::mem::align_of::<std_vector>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_vector)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_allocator_open0_llvm_BitcodeModule_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_allocator>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_allocator)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_allocator>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_allocator)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_vector_open0_llvm_BitcodeModule_std_allocator_open1_llvm_BitcodeModule_close1_close0_instantiation_1(
) {
    assert_eq!(
        ::std::mem::size_of::<std_vector>(),
        24usize,
        concat!("Size of template specialization: ", stringify!(std_vector))
    );
    assert_eq!(
        ::std::mem::align_of::<std_vector>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_vector)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_allocator_open0_llvm_BitcodeModule_close0_instantiation_1() {
    assert_eq!(
        ::std::mem::size_of::<std_allocator>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_allocator)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_allocator>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_allocator)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_unique_ptr_open0_llvm_MemoryBuffer_std_default_delete_open1_llvm_MemoryBuffer_close1_close0_instantiation_15(
) {
    assert_eq!(
        ::std::mem::size_of::<std_unique_ptr>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_unique_ptr)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_unique_ptr>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_unique_ptr)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_default_delete_open0_llvm_MemoryBuffer_close0_instantiation_15() {
    assert_eq!(
        ::std::mem::size_of::<std_default_delete>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_default_delete)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_default_delete>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_default_delete)
        )
    );
}
#[test]
fn __bindgen_test_layout_llvm_ArrayRef_open0_uint64_t_close0_instantiation_3() {
    assert_eq!(
        ::std::mem::size_of::<llvm_ArrayRef<u64>>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_ArrayRef<u64>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_ArrayRef<u64>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_ArrayRef<u64>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_unique_ptr_open0_llvm_MemoryBuffer_std_default_delete_open1_llvm_MemoryBuffer_close1_close0_instantiation_16(
) {
    assert_eq!(
        ::std::mem::size_of::<std_unique_ptr>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_unique_ptr)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_unique_ptr>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_unique_ptr)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_default_delete_open0_llvm_MemoryBuffer_close0_instantiation_16() {
    assert_eq!(
        ::std::mem::size_of::<std_default_delete>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_default_delete)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_default_delete>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_default_delete)
        )
    );
}
#[test]
fn __bindgen_test_layout_llvm_ArrayRef_open0_uint8_t_close0_instantiation_6() {
    assert_eq!(
        ::std::mem::size_of::<llvm_ArrayRef<u8>>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_ArrayRef<u8>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_ArrayRef<u8>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_ArrayRef<u8>)
        )
    );
}
#[test]
fn __bindgen_test_layout_llvm_SmallVectorImpl_open0_uint8_t_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<llvm_SmallVectorImpl>(),
        24usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_SmallVectorImpl)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_SmallVectorImpl>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_SmallVectorImpl)
        )
    );
}
#[test]
fn __bindgen_test_layout_llvm_ArrayRef_open0_uint8_t_close0_instantiation_7() {
    assert_eq!(
        ::std::mem::size_of::<llvm_ArrayRef<u8>>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_ArrayRef<u8>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_ArrayRef<u8>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_ArrayRef<u8>)
        )
    );
}
#[test]
fn __bindgen_test_layout_llvm_ArrayRef_open0_uint8_t_close0_instantiation_8() {
    assert_eq!(
        ::std::mem::size_of::<llvm_ArrayRef<u8>>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_ArrayRef<u8>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_ArrayRef<u8>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_ArrayRef<u8>)
        )
    );
}
#[test]
fn __bindgen_test_layout_llvm_SmallVectorImpl_open0_uint8_t_close0_instantiation_1() {
    assert_eq!(
        ::std::mem::size_of::<llvm_SmallVectorImpl>(),
        24usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_SmallVectorImpl)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_SmallVectorImpl>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_SmallVectorImpl)
        )
    );
}
#[test]
fn __bindgen_test_layout_llvm_ArrayRef_open0_uint8_t_close0_instantiation_9() {
    assert_eq!(
        ::std::mem::size_of::<llvm_ArrayRef<u8>>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_ArrayRef<u8>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_ArrayRef<u8>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_ArrayRef<u8>)
        )
    );
}
#[test]
fn __bindgen_test_layout_llvm_SmallVectorImpl_open0_uint8_t_close0_instantiation_2() {
    assert_eq!(
        ::std::mem::size_of::<llvm_SmallVectorImpl>(),
        24usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_SmallVectorImpl)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_SmallVectorImpl>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_SmallVectorImpl)
        )
    );
}
#[test]
fn __bindgen_test_layout_llvm_ArrayRef_open0_uint8_t_close0_instantiation_10() {
    assert_eq!(
        ::std::mem::size_of::<llvm_ArrayRef<u8>>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_ArrayRef<u8>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_ArrayRef<u8>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_ArrayRef<u8>)
        )
    );
}
#[test]
fn __bindgen_test_layout_llvm_ArrayRef_open0_uint8_t_close0_instantiation_11() {
    assert_eq!(
        ::std::mem::size_of::<llvm_ArrayRef<u8>>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_ArrayRef<u8>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_ArrayRef<u8>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_ArrayRef<u8>)
        )
    );
}
#[test]
fn __bindgen_test_layout_llvm_SmallVectorImpl_open0_uint8_t_close0_instantiation_3() {
    assert_eq!(
        ::std::mem::size_of::<llvm_SmallVectorImpl>(),
        24usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_SmallVectorImpl)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_SmallVectorImpl>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_SmallVectorImpl)
        )
    );
}
#[test]
fn __bindgen_test_layout_llvm_ArrayRef_open0_uint8_t_close0_instantiation_12() {
    assert_eq!(
        ::std::mem::size_of::<llvm_ArrayRef<u8>>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_ArrayRef<u8>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_ArrayRef<u8>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_ArrayRef<u8>)
        )
    );
}
#[test]
fn __bindgen_test_layout_llvm_SmallVectorImpl_open0_uint8_t_close0_instantiation_4() {
    assert_eq!(
        ::std::mem::size_of::<llvm_SmallVectorImpl>(),
        24usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_SmallVectorImpl)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_SmallVectorImpl>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_SmallVectorImpl)
        )
    );
}
#[test]
fn __bindgen_test_layout_llvm_ArrayRef_open0_uint8_t_close0_instantiation_13() {
    assert_eq!(
        ::std::mem::size_of::<llvm_ArrayRef<u8>>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_ArrayRef<u8>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_ArrayRef<u8>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_ArrayRef<u8>)
        )
    );
}
#[test]
fn __bindgen_test_layout_llvm_ArrayRef_open0_uint8_t_close0_instantiation_14() {
    assert_eq!(
        ::std::mem::size_of::<llvm_ArrayRef<u8>>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_ArrayRef<u8>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_ArrayRef<u8>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_ArrayRef<u8>)
        )
    );
}
#[test]
fn __bindgen_test_layout_llvm_SmallVectorImpl_open0_uint8_t_close0_instantiation_5() {
    assert_eq!(
        ::std::mem::size_of::<llvm_SmallVectorImpl>(),
        24usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_SmallVectorImpl)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_SmallVectorImpl>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_SmallVectorImpl)
        )
    );
}
#[test]
fn __bindgen_test_layout_llvm_ArrayRef_open0_uint8_t_close0_instantiation_15() {
    assert_eq!(
        ::std::mem::size_of::<llvm_ArrayRef<u8>>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_ArrayRef<u8>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_ArrayRef<u8>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_ArrayRef<u8>)
        )
    );
}
#[test]
fn __bindgen_test_layout_llvm_SmallVectorImpl_open0_uint8_t_close0_instantiation_6() {
    assert_eq!(
        ::std::mem::size_of::<llvm_SmallVectorImpl>(),
        24usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_SmallVectorImpl)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_SmallVectorImpl>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_SmallVectorImpl)
        )
    );
}
#[test]
fn __bindgen_test_layout_llvm_ArrayRef_open0_std_string_close0_instantiation_1() {
    assert_eq!(
        ::std::mem::size_of::<llvm_ArrayRef<std_string>>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_ArrayRef<std_string>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_ArrayRef<std_string>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_ArrayRef<std_string>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_vector_open0_std_string_std_allocator_open1_std_basic_string_open2_char_std_char_traits_open3_char_close3_std_allocator_open3_char_close3_close2_close1_close0_instantiation_2(
) {
    assert_eq!(
        ::std::mem::size_of::<std_vector>(),
        24usize,
        concat!("Size of template specialization: ", stringify!(std_vector))
    );
    assert_eq!(
        ::std::mem::align_of::<std_vector>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_vector)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_allocator_open0_std_basic_string_open1_char_std_char_traits_open2_char_close2_std_allocator_open2_char_close2_close1_close0_instantiation_2(
) {
    assert_eq!(
        ::std::mem::size_of::<std_allocator>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_allocator)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_allocator>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_allocator)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_basic_string_open0_char_std_char_traits_open1_char_close1_std_allocator_open1_char_close1_close0_instantiation_7(
) {
    assert_eq!(
        ::std::mem::size_of::<std_basic_string<::std::os::raw::c_char>>(),
        32usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_basic_string<::std::os::raw::c_char>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_basic_string<::std::os::raw::c_char>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_basic_string<::std::os::raw::c_char>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_char_traits_open0_char_close0_instantiation_31() {
    assert_eq!(
        ::std::mem::size_of::<std_char_traits>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_char_traits)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_char_traits>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_char_traits)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_allocator_open0_char_close0_instantiation_12() {
    assert_eq!(
        ::std::mem::size_of::<std_allocator>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_allocator)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_allocator>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_allocator)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_pair_open0_int_int_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_pair<::std::os::raw::c_int, ::std::os::raw::c_int>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify ! (std_pair < :: std :: os :: raw :: c_int , :: std :: os :: raw :: c_int >)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_pair<::std::os::raw::c_int, ::std::os::raw::c_int>>(),
        4usize,
        concat!(
            "Alignment of template specialization: ",
            stringify ! (std_pair < :: std :: os :: raw :: c_int , :: std :: os :: raw :: c_int >)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_shared_ptr_open0_llvm_MemoryBuffer_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_shared_ptr>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_shared_ptr)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_shared_ptr>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_shared_ptr)
        )
    );
}
#[doc = " @see llvm::PassManagerBase"]
pub type LLVMPassManagerRef = *mut LLVMOpaquePassManager;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LLVMOpaquePassManager {
    _unused: [u8; 0],
}
#[test]
fn __bindgen_test_layout_std_initializer_list_open0_llvm_StringRef_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_initializer_list<llvm_StringRef>>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_initializer_list<llvm_StringRef>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_initializer_list<llvm_StringRef>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_initializer_list<llvm_StringRef>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_initializer_list_open0_llvm_StringRef_close0_instantiation_1() {
    assert_eq!(
        ::std::mem::size_of::<std_initializer_list<llvm_StringRef>>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_initializer_list<llvm_StringRef>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_initializer_list<llvm_StringRef>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_initializer_list<llvm_StringRef>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_optional_open0_size_t_close0_instantiation_3() {
    assert_eq!(
        ::std::mem::size_of::<std_optional>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_optional)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_optional>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_optional)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_optional_open0_size_t_close0_instantiation_4() {
    assert_eq!(
        ::std::mem::size_of::<std_optional>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_optional)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_optional>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_optional)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_optional_open0_size_t_close0_instantiation_5() {
    assert_eq!(
        ::std::mem::size_of::<std_optional>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_optional)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_optional>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_optional)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_optional_open0_llvm_HexPrintStyle_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_optional>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_optional)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_optional>(),
        4usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_optional)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_55 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_56 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_57 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_58 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_59 {
    pub _address: u8,
}
#[test]
fn __bindgen_test_layout_std_chrono_duration_open0_long_std_nano_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_chrono_duration<::std::os::raw::c_long>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_chrono_duration<::std::os::raw::c_long>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_chrono_duration<::std::os::raw::c_long>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_chrono_duration<::std::os::raw::c_long>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_chrono_duration_open0_long_std_micro_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_chrono_duration<::std::os::raw::c_long>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_chrono_duration<::std::os::raw::c_long>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_chrono_duration<::std::os::raw::c_long>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_chrono_duration<::std::os::raw::c_long>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_chrono_duration_open0_long_std_milli_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_chrono_duration<::std::os::raw::c_long>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_chrono_duration<::std::os::raw::c_long>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_chrono_duration<::std::os::raw::c_long>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_chrono_duration<::std::os::raw::c_long>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_chrono_duration_open0_long_std_ratio_open1_close1_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<std_chrono_duration<::std::os::raw::c_long>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_chrono_duration<::std::os::raw::c_long>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_chrono_duration<::std::os::raw::c_long>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_chrono_duration<::std::os::raw::c_long>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_chrono_duration_open0_long_std_ratio_open1_close1_close0_instantiation_1(
) {
    assert_eq!(
        ::std::mem::size_of::<std_chrono_duration<::std::os::raw::c_long>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_chrono_duration<::std::os::raw::c_long>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_chrono_duration<::std::os::raw::c_long>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_chrono_duration<::std::os::raw::c_long>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_chrono_duration_open0_long_std_ratio_open1_close1_close0_instantiation_2(
) {
    assert_eq!(
        ::std::mem::size_of::<std_chrono_duration<::std::os::raw::c_long>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_chrono_duration<::std::os::raw::c_long>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_chrono_duration<::std::os::raw::c_long>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_chrono_duration<::std::os::raw::c_long>)
        )
    );
}
pub type rep = ::std::os::raw::c_long;
#[test]
fn __bindgen_test_layout_std_chrono_time_point_open0_std_chrono__V2_system_clock_std_chrono__V2_system_clock_duration_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<std_chrono_time_point<std_chrono__V2_system_clock_duration>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_chrono_time_point<std_chrono__V2_system_clock_duration>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_chrono_time_point<std_chrono__V2_system_clock_duration>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_chrono_time_point<std_chrono__V2_system_clock_duration>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_chrono_time_point_open0_std_filesystem___file_clock_std_chrono_duration_open1_long_std_ratio_open2_close2_close1_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<std_chrono_time_point<std_chrono_duration<::std::os::raw::c_long>>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_chrono_time_point<std_chrono_duration<::std::os::raw::c_long>>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_chrono_time_point<std_chrono_duration<::std::os::raw::c_long>>>(
        ),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_chrono_time_point<std_chrono_duration<::std::os::raw::c_long>>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_chrono_duration_open0_long_std_ratio_open1_close1_close0_instantiation_3(
) {
    assert_eq!(
        ::std::mem::size_of::<std_chrono_duration<::std::os::raw::c_long>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_chrono_duration<::std::os::raw::c_long>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_chrono_duration<::std::os::raw::c_long>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_chrono_duration<::std::os::raw::c_long>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_chrono_time_point_open0_std_chrono_seconds_std_chrono_duration_open1_long_std_ratio_open2_close2_close1_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<std_chrono_time_point<std_chrono_duration<::std::os::raw::c_long>>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_chrono_time_point<std_chrono_duration<::std::os::raw::c_long>>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_chrono_time_point<std_chrono_duration<::std::os::raw::c_long>>>(
        ),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_chrono_time_point<std_chrono_duration<::std::os::raw::c_long>>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_chrono_duration_open0_long_std_ratio_open1_close1_close0_instantiation_4(
) {
    assert_eq!(
        ::std::mem::size_of::<std_chrono_duration<::std::os::raw::c_long>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_chrono_duration<::std::os::raw::c_long>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_chrono_duration<::std::os::raw::c_long>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_chrono_duration<::std::os::raw::c_long>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_chrono_time_point_open0_std_chrono__V2_system_clock_std_chrono_duration_open1_long_std_ratio_open2_close2_close1_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<std_chrono_time_point<std_chrono_duration<::std::os::raw::c_long>>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_chrono_time_point<std_chrono_duration<::std::os::raw::c_long>>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_chrono_time_point<std_chrono_duration<::std::os::raw::c_long>>>(
        ),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_chrono_time_point<std_chrono_duration<::std::os::raw::c_long>>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_chrono_duration_open0_long_std_ratio_open1_close1_close0_instantiation_5(
) {
    assert_eq!(
        ::std::mem::size_of::<std_chrono_duration<::std::os::raw::c_long>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_chrono_duration<::std::os::raw::c_long>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_chrono_duration<::std::os::raw::c_long>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_chrono_duration<::std::os::raw::c_long>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_chrono_time_point_open0_llvm_sys_UtcClock_std_chrono_duration_open1_long_std_ratio_open2_close2_close1_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<std_chrono_time_point<std_chrono_duration<::std::os::raw::c_long>>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_chrono_time_point<std_chrono_duration<::std::os::raw::c_long>>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_chrono_time_point<std_chrono_duration<::std::os::raw::c_long>>>(
        ),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_chrono_time_point<std_chrono_duration<::std::os::raw::c_long>>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_chrono_duration_open0_long_std_ratio_open1_close1_close0_instantiation_6(
) {
    assert_eq!(
        ::std::mem::size_of::<std_chrono_duration<::std::os::raw::c_long>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_chrono_duration<::std::os::raw::c_long>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_chrono_duration<::std::os::raw::c_long>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_chrono_duration<::std::os::raw::c_long>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_chrono_time_point_open0_std_chrono_seconds_std_chrono_duration_open1_long_std_ratio_open2_close2_close1_close0_instantiation_1(
) {
    assert_eq!(
        ::std::mem::size_of::<std_chrono_time_point<std_chrono_duration<::std::os::raw::c_long>>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_chrono_time_point<std_chrono_duration<::std::os::raw::c_long>>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_chrono_time_point<std_chrono_duration<::std::os::raw::c_long>>>(
        ),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_chrono_time_point<std_chrono_duration<::std::os::raw::c_long>>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_chrono_duration_open0_long_std_ratio_open1_close1_close0_instantiation_7(
) {
    assert_eq!(
        ::std::mem::size_of::<std_chrono_duration<::std::os::raw::c_long>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_chrono_duration<::std::os::raw::c_long>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_chrono_duration<::std::os::raw::c_long>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_chrono_duration<::std::os::raw::c_long>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_chrono_time_point_open0_std_chrono__V2_system_clock_std_chrono_duration_open1_long_std_ratio_open2_close2_close1_close0_instantiation_1(
) {
    assert_eq!(
        ::std::mem::size_of::<std_chrono_time_point<std_chrono_duration<::std::os::raw::c_long>>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_chrono_time_point<std_chrono_duration<::std::os::raw::c_long>>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_chrono_time_point<std_chrono_duration<::std::os::raw::c_long>>>(
        ),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_chrono_time_point<std_chrono_duration<::std::os::raw::c_long>>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_chrono_duration_open0_long_std_ratio_open1_close1_close0_instantiation_8(
) {
    assert_eq!(
        ::std::mem::size_of::<std_chrono_duration<::std::os::raw::c_long>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_chrono_duration<::std::os::raw::c_long>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_chrono_duration<::std::os::raw::c_long>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_chrono_duration<::std::os::raw::c_long>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_chrono_time_point_open0_std_chrono__V2_system_clock_std_chrono_duration_open1_long_std_ratio_open2_close2_close1_close0_instantiation_2(
) {
    assert_eq!(
        ::std::mem::size_of::<std_chrono_time_point<std_chrono_duration<::std::os::raw::c_long>>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_chrono_time_point<std_chrono_duration<::std::os::raw::c_long>>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_chrono_time_point<std_chrono_duration<::std::os::raw::c_long>>>(
        ),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_chrono_time_point<std_chrono_duration<::std::os::raw::c_long>>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_chrono_duration_open0_long_std_ratio_open1_close1_close0_instantiation_9(
) {
    assert_eq!(
        ::std::mem::size_of::<std_chrono_duration<::std::os::raw::c_long>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_chrono_duration<::std::os::raw::c_long>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_chrono_duration<::std::os::raw::c_long>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_chrono_duration<::std::os::raw::c_long>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_chrono_time_point_open0_llvm_sys_UtcClock_std_chrono_duration_open1_long_std_ratio_open2_close2_close1_close0_instantiation_1(
) {
    assert_eq!(
        ::std::mem::size_of::<std_chrono_time_point<std_chrono_duration<::std::os::raw::c_long>>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_chrono_time_point<std_chrono_duration<::std::os::raw::c_long>>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_chrono_time_point<std_chrono_duration<::std::os::raw::c_long>>>(
        ),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_chrono_time_point<std_chrono_duration<::std::os::raw::c_long>>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_chrono_duration_open0_long_std_ratio_open1_close1_close0_instantiation_10(
) {
    assert_eq!(
        ::std::mem::size_of::<std_chrono_duration<::std::os::raw::c_long>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_chrono_duration<::std::os::raw::c_long>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_chrono_duration<::std::os::raw::c_long>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_chrono_duration<::std::os::raw::c_long>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_pair_open0_uint64_t_uint64_t_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_pair<u64, u64>>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify ! (std_pair < u64 , u64 >)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_pair<u64, u64>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify ! (std_pair < u64 , u64 >)
        )
    );
}
#[test]
fn __bindgen_test_layout_llvm_ArrayRef_open0_uint8_t_close0_instantiation_16() {
    assert_eq!(
        ::std::mem::size_of::<llvm_ArrayRef<u8>>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_ArrayRef<u8>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_ArrayRef<u8>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_ArrayRef<u8>)
        )
    );
}
#[test]
fn __bindgen_test_layout_llvm_SmallVectorImpl_open0_char_close0_instantiation_10() {
    assert_eq!(
        ::std::mem::size_of::<llvm_SmallVectorImpl>(),
        24usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_SmallVectorImpl)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_SmallVectorImpl>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_SmallVectorImpl)
        )
    );
}
#[test]
fn __bindgen_test_layout_llvm_ArrayRef_open0_uint8_t_close0_instantiation_17() {
    assert_eq!(
        ::std::mem::size_of::<llvm_ArrayRef<u8>>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_ArrayRef<u8>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_ArrayRef<u8>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_ArrayRef<u8>)
        )
    );
}
#[test]
fn __bindgen_test_layout_llvm_ArrayRef_open0_uint8_t_close0_instantiation_18() {
    assert_eq!(
        ::std::mem::size_of::<llvm_ArrayRef<u8>>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_ArrayRef<u8>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_ArrayRef<u8>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_ArrayRef<u8>)
        )
    );
}
pub type llvm_sys_fs_basic_file_status_time_t = timex_timeval___time_t;
pub type llvm_sys_fs_basic_file_status_uid_t = __uid_t;
pub type __uid_t = ::std::os::raw::c_uint;
pub type llvm_sys_fs_basic_file_status_gid_t = __gid_t;
pub type __gid_t = ::std::os::raw::c_uint;
pub type llvm_sys_fs_basic_file_status_off_t = _IO_FILE___off_t;
#[test]
fn __bindgen_test_layout_std_chrono_time_point_open0_std_chrono__V2_system_clock_std_chrono_duration_open1_long_std_ratio_open2_close2_close1_close0_instantiation_3(
) {
    assert_eq!(
        ::std::mem::size_of::<std_chrono_time_point<std_chrono_duration<::std::os::raw::c_long>>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_chrono_time_point<std_chrono_duration<::std::os::raw::c_long>>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_chrono_time_point<std_chrono_duration<::std::os::raw::c_long>>>(
        ),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_chrono_time_point<std_chrono_duration<::std::os::raw::c_long>>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_chrono_duration_open0_long_std_ratio_open1_close1_close0_instantiation_11(
) {
    assert_eq!(
        ::std::mem::size_of::<std_chrono_duration<::std::os::raw::c_long>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_chrono_duration<::std::os::raw::c_long>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_chrono_duration<::std::os::raw::c_long>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_chrono_duration<::std::os::raw::c_long>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_chrono_time_point_open0_std_chrono__V2_system_clock_std_chrono_duration_open1_long_std_ratio_open2_close2_close1_close0_instantiation_4(
) {
    assert_eq!(
        ::std::mem::size_of::<std_chrono_time_point<std_chrono_duration<::std::os::raw::c_long>>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_chrono_time_point<std_chrono_duration<::std::os::raw::c_long>>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_chrono_time_point<std_chrono_duration<::std::os::raw::c_long>>>(
        ),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_chrono_time_point<std_chrono_duration<::std::os::raw::c_long>>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_chrono_duration_open0_long_std_ratio_open1_close1_close0_instantiation_12(
) {
    assert_eq!(
        ::std::mem::size_of::<std_chrono_duration<::std::os::raw::c_long>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_chrono_duration<::std::os::raw::c_long>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_chrono_duration<::std::os::raw::c_long>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_chrono_duration<::std::os::raw::c_long>)
        )
    );
}
pub type llvm_sys_fs_file_status_dev_t = __dev_t;
pub type __dev_t = ::std::os::raw::c_ulong;
pub type llvm_sys_fs_file_status_nlink_t = __nlink_t;
pub type __nlink_t = ::std::os::raw::c_ulong;
pub type llvm_sys_fs_file_status_ino_t = __ino_t;
pub type __ino_t = ::std::os::raw::c_ulong;
#[test]
fn __bindgen_test_layout_llvm_SmallVectorImpl_open0_char_close0_instantiation_11() {
    assert_eq!(
        ::std::mem::size_of::<llvm_SmallVectorImpl>(),
        24usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_SmallVectorImpl)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_SmallVectorImpl>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_SmallVectorImpl)
        )
    );
}
#[test]
fn __bindgen_test_layout_llvm_SmallVectorImpl_open0_char_close0_instantiation_12() {
    assert_eq!(
        ::std::mem::size_of::<llvm_SmallVectorImpl>(),
        24usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_SmallVectorImpl)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_SmallVectorImpl>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_SmallVectorImpl)
        )
    );
}
#[test]
fn __bindgen_test_layout_llvm_SmallVectorImpl_open0_char_close0_instantiation_13() {
    assert_eq!(
        ::std::mem::size_of::<llvm_SmallVectorImpl>(),
        24usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_SmallVectorImpl)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_SmallVectorImpl>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_SmallVectorImpl)
        )
    );
}
#[test]
fn __bindgen_test_layout_llvm_SmallVectorImpl_open0_char_close0_instantiation_14() {
    assert_eq!(
        ::std::mem::size_of::<llvm_SmallVectorImpl>(),
        24usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_SmallVectorImpl)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_SmallVectorImpl>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_SmallVectorImpl)
        )
    );
}
#[test]
fn __bindgen_test_layout_llvm_SmallVectorImpl_open0_char_close0_instantiation_15() {
    assert_eq!(
        ::std::mem::size_of::<llvm_SmallVectorImpl>(),
        24usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_SmallVectorImpl)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_SmallVectorImpl>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_SmallVectorImpl)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_chrono_time_point_open0_std_chrono__V2_system_clock_std_chrono_duration_open1_long_std_ratio_open2_close2_close1_close0_instantiation_5(
) {
    assert_eq!(
        ::std::mem::size_of::<std_chrono_time_point<std_chrono_duration<::std::os::raw::c_long>>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_chrono_time_point<std_chrono_duration<::std::os::raw::c_long>>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_chrono_time_point<std_chrono_duration<::std::os::raw::c_long>>>(
        ),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_chrono_time_point<std_chrono_duration<::std::os::raw::c_long>>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_chrono_duration_open0_long_std_ratio_open1_close1_close0_instantiation_13(
) {
    assert_eq!(
        ::std::mem::size_of::<std_chrono_duration<::std::os::raw::c_long>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_chrono_duration<::std::os::raw::c_long>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_chrono_duration<::std::os::raw::c_long>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_chrono_duration<::std::os::raw::c_long>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_chrono_time_point_open0_std_chrono__V2_system_clock_std_chrono_duration_open1_long_std_ratio_open2_close2_close1_close0_instantiation_6(
) {
    assert_eq!(
        ::std::mem::size_of::<std_chrono_time_point<std_chrono_duration<::std::os::raw::c_long>>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_chrono_time_point<std_chrono_duration<::std::os::raw::c_long>>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_chrono_time_point<std_chrono_duration<::std::os::raw::c_long>>>(
        ),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_chrono_time_point<std_chrono_duration<::std::os::raw::c_long>>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_chrono_duration_open0_long_std_ratio_open1_close1_close0_instantiation_14(
) {
    assert_eq!(
        ::std::mem::size_of::<std_chrono_duration<::std::os::raw::c_long>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_chrono_duration<::std::os::raw::c_long>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_chrono_duration<::std::os::raw::c_long>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_chrono_duration<::std::os::raw::c_long>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_chrono_time_point_open0_std_chrono__V2_system_clock_std_chrono_duration_open1_long_std_ratio_open2_close2_close1_close0_instantiation_7(
) {
    assert_eq!(
        ::std::mem::size_of::<std_chrono_time_point<std_chrono_duration<::std::os::raw::c_long>>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_chrono_time_point<std_chrono_duration<::std::os::raw::c_long>>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_chrono_time_point<std_chrono_duration<::std::os::raw::c_long>>>(
        ),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_chrono_time_point<std_chrono_duration<::std::os::raw::c_long>>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_chrono_duration_open0_long_std_ratio_open1_close1_close0_instantiation_15(
) {
    assert_eq!(
        ::std::mem::size_of::<std_chrono_duration<::std::os::raw::c_long>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_chrono_duration<::std::os::raw::c_long>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_chrono_duration<::std::os::raw::c_long>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_chrono_duration<::std::os::raw::c_long>)
        )
    );
}
#[test]
fn __bindgen_test_layout_llvm_SmallVectorImpl_open0_char_close0_instantiation_16() {
    assert_eq!(
        ::std::mem::size_of::<llvm_SmallVectorImpl>(),
        24usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_SmallVectorImpl)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_SmallVectorImpl>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_SmallVectorImpl)
        )
    );
}
#[test]
fn __bindgen_test_layout_llvm_SmallVectorImpl_open0_char_close0_instantiation_17() {
    assert_eq!(
        ::std::mem::size_of::<llvm_SmallVectorImpl>(),
        24usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_SmallVectorImpl)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_SmallVectorImpl>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_SmallVectorImpl)
        )
    );
}
#[test]
fn __bindgen_test_layout_llvm_SmallVectorImpl_open0_char_close0_instantiation_18() {
    assert_eq!(
        ::std::mem::size_of::<llvm_SmallVectorImpl>(),
        24usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_SmallVectorImpl)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_SmallVectorImpl>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_SmallVectorImpl)
        )
    );
}
#[test]
fn __bindgen_test_layout_llvm_SmallVectorImpl_open0_char_close0_instantiation_19() {
    assert_eq!(
        ::std::mem::size_of::<llvm_SmallVectorImpl>(),
        24usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_SmallVectorImpl)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_SmallVectorImpl>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_SmallVectorImpl)
        )
    );
}
#[test]
fn __bindgen_test_layout_llvm_SmallVectorImpl_open0_char_close0_instantiation_20() {
    assert_eq!(
        ::std::mem::size_of::<llvm_SmallVectorImpl>(),
        24usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_SmallVectorImpl)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_SmallVectorImpl>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_SmallVectorImpl)
        )
    );
}
#[test]
fn __bindgen_test_layout_llvm_SmallVectorImpl_open0_char_close0_instantiation_21() {
    assert_eq!(
        ::std::mem::size_of::<llvm_SmallVectorImpl>(),
        24usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_SmallVectorImpl)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_SmallVectorImpl>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_SmallVectorImpl)
        )
    );
}
#[test]
fn __bindgen_test_layout_llvm_SmallVectorImpl_open0_char_close0_instantiation_22() {
    assert_eq!(
        ::std::mem::size_of::<llvm_SmallVectorImpl>(),
        24usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_SmallVectorImpl)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_SmallVectorImpl>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_SmallVectorImpl)
        )
    );
}
#[test]
fn __bindgen_test_layout_llvm_SmallVectorImpl_open0_char_close0_instantiation_23() {
    assert_eq!(
        ::std::mem::size_of::<llvm_SmallVectorImpl>(),
        24usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_SmallVectorImpl)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_SmallVectorImpl>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_SmallVectorImpl)
        )
    );
}
#[test]
fn __bindgen_test_layout_llvm_Expected_open0_llvm_sys_fs_file_t_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<llvm_Expected>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_Expected)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_Expected>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_Expected)
        )
    );
}
#[test]
fn __bindgen_test_layout_llvm_MutableArrayRef_open0_char_close0_instantiation_2() {
    assert_eq!(
        ::std::mem::size_of::<llvm_MutableArrayRef<::std::os::raw::c_char>>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_MutableArrayRef<::std::os::raw::c_char>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_MutableArrayRef<::std::os::raw::c_char>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_MutableArrayRef<::std::os::raw::c_char>)
        )
    );
}
#[test]
fn __bindgen_test_layout_llvm_SmallVectorImpl_open0_char_close0_instantiation_24() {
    assert_eq!(
        ::std::mem::size_of::<llvm_SmallVectorImpl>(),
        24usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_SmallVectorImpl)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_SmallVectorImpl>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_SmallVectorImpl)
        )
    );
}
#[test]
fn __bindgen_test_layout_llvm_MutableArrayRef_open0_char_close0_instantiation_3() {
    assert_eq!(
        ::std::mem::size_of::<llvm_MutableArrayRef<::std::os::raw::c_char>>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_MutableArrayRef<::std::os::raw::c_char>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_MutableArrayRef<::std::os::raw::c_char>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_MutableArrayRef<::std::os::raw::c_char>)
        )
    );
}
#[test]
fn __bindgen_test_layout_llvm_Expected_open0_llvm_sys_fs_file_t_close0_instantiation_1() {
    assert_eq!(
        ::std::mem::size_of::<llvm_Expected>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_Expected)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_Expected>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_Expected)
        )
    );
}
#[test]
fn __bindgen_test_layout_llvm_Expected_open0_llvm_sys_fs_file_t_close0_instantiation_2() {
    assert_eq!(
        ::std::mem::size_of::<llvm_Expected>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_Expected)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_Expected>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_Expected)
        )
    );
}
#[test]
fn __bindgen_test_layout_llvm_SmallVectorImpl_open0_char_close0_instantiation_25() {
    assert_eq!(
        ::std::mem::size_of::<llvm_SmallVectorImpl>(),
        24usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_SmallVectorImpl)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_SmallVectorImpl>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_SmallVectorImpl)
        )
    );
}
#[test]
fn __bindgen_test_layout_llvm_SmallVectorImpl_open0_char_close0_instantiation_26() {
    assert_eq!(
        ::std::mem::size_of::<llvm_SmallVectorImpl>(),
        24usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_SmallVectorImpl)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_SmallVectorImpl>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_SmallVectorImpl)
        )
    );
}
#[test]
fn __bindgen_test_layout_llvm_Expected_open0_llvm_sys_fs_file_t_close0_instantiation_3() {
    assert_eq!(
        ::std::mem::size_of::<llvm_Expected>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_Expected)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_Expected>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_Expected)
        )
    );
}
#[test]
fn __bindgen_test_layout_llvm_ErrorOr_open0_llvm_sys_fs_basic_file_status_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<llvm_ErrorOr>(),
        56usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_ErrorOr)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_ErrorOr>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_ErrorOr)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_shared_ptr_open0_llvm_sys_fs_detail_DirIterState_close0_instantiation()
{
    assert_eq!(
        ::std::mem::size_of::<std_shared_ptr>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_shared_ptr)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_shared_ptr>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_shared_ptr)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_vector_open0_llvm_sys_fs_directory_iterator_std_allocator_open1_llvm_sys_fs_directory_iterator_close1_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<std_vector>(),
        24usize,
        concat!("Size of template specialization: ", stringify!(std_vector))
    );
    assert_eq!(
        ::std::mem::align_of::<std_vector>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_vector)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_allocator_open0_llvm_sys_fs_directory_iterator_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_allocator>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_allocator)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_allocator>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_allocator)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_shared_ptr_open0_llvm_sys_fs_detail_RecDirIterState_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<std_shared_ptr>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_shared_ptr)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_shared_ptr>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_shared_ptr)
        )
    );
}
pub type iterator = iterator;
pub type iterator = *mut llvm_MCOperand;
pub type const_iterator = const_iterator;
pub type const_iterator = *const llvm_MCOperand;
pub type const_iterator = const_iterator;
pub type const_iterator = *const llvm_MCFixup;
pub type iterator = iterator;
pub type iterator = *mut llvm_MCFixup;
#[test]
fn __bindgen_test_layout_llvm_SmallVectorImpl_open0_char_close0_instantiation_27() {
    assert_eq!(
        ::std::mem::size_of::<llvm_SmallVectorImpl>(),
        24usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_SmallVectorImpl)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_SmallVectorImpl>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_SmallVectorImpl)
        )
    );
}
#[test]
fn __bindgen_test_layout_llvm_SmallVectorImpl_open0_char_close0_instantiation_28() {
    assert_eq!(
        ::std::mem::size_of::<llvm_SmallVectorImpl>(),
        24usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_SmallVectorImpl)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_SmallVectorImpl>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_SmallVectorImpl)
        )
    );
}
#[test]
fn __bindgen_test_layout_llvm_SmallVectorImpl_open0_llvm_MCFixup_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<llvm_SmallVectorImpl>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_SmallVectorImpl)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_SmallVectorImpl>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_SmallVectorImpl)
        )
    );
}
#[test]
fn __bindgen_test_layout_llvm_SmallVectorImpl_open0_llvm_MCFixup_close0_instantiation_1() {
    assert_eq!(
        ::std::mem::size_of::<llvm_SmallVectorImpl>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_SmallVectorImpl)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_SmallVectorImpl>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_SmallVectorImpl)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_pair_open0_ptr_const_MCSymbol_ptr_const_MCSymbol_close0_instantiation()
{
    assert_eq!(
        ::std::mem::size_of::<std_pair<*const llvm_MCSymbol, *const llvm_MCSymbol>>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_pair<*const llvm_MCSymbol, *const llvm_MCSymbol>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_pair<*const llvm_MCSymbol, *const llvm_MCSymbol>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_pair<*const llvm_MCSymbol, *const llvm_MCSymbol>)
        )
    );
}
#[test]
fn __bindgen_test_layout_llvm_ArrayRef_open0_std_pair_open1_ptr_const_MCSymbol_ptr_const_MCSymbol_close1_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<llvm_ArrayRef<std_pair<*const llvm_MCSymbol, *const llvm_MCSymbol>>>(
        ),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_ArrayRef<std_pair<*const llvm_MCSymbol, *const llvm_MCSymbol>>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_ArrayRef<std_pair<*const llvm_MCSymbol, *const llvm_MCSymbol>>>(
        ),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_ArrayRef<std_pair<*const llvm_MCSymbol, *const llvm_MCSymbol>>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_pair_open0_ptr_const_MCSymbol_ptr_const_MCSymbol_close0_instantiation_1(
) {
    assert_eq!(
        ::std::mem::size_of::<std_pair<*const llvm_MCSymbol, *const llvm_MCSymbol>>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_pair<*const llvm_MCSymbol, *const llvm_MCSymbol>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_pair<*const llvm_MCSymbol, *const llvm_MCSymbol>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_pair<*const llvm_MCSymbol, *const llvm_MCSymbol>)
        )
    );
}
#[test]
fn __bindgen_test_layout_llvm_ArrayRef_open0_std_pair_open1_ptr_const_MCSymbol_ptr_const_MCSymbol_close1_close0_instantiation_1(
) {
    assert_eq!(
        ::std::mem::size_of::<llvm_ArrayRef<std_pair<*const llvm_MCSymbol, *const llvm_MCSymbol>>>(
        ),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_ArrayRef<std_pair<*const llvm_MCSymbol, *const llvm_MCSymbol>>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_ArrayRef<std_pair<*const llvm_MCSymbol, *const llvm_MCSymbol>>>(
        ),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_ArrayRef<std_pair<*const llvm_MCSymbol, *const llvm_MCSymbol>>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_pair_open0_ptr_const_MCSymbol_ptr_const_MCSymbol_close0_instantiation_2(
) {
    assert_eq!(
        ::std::mem::size_of::<std_pair<*const llvm_MCSymbol, *const llvm_MCSymbol>>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_pair<*const llvm_MCSymbol, *const llvm_MCSymbol>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_pair<*const llvm_MCSymbol, *const llvm_MCSymbol>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_pair<*const llvm_MCSymbol, *const llvm_MCSymbol>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_pair_open0_unsigned_int_llvm_MCSection_FragList_close0_instantiation()
{
    assert_eq!(
        ::std::mem::size_of::<std_pair<::std::os::raw::c_uint, llvm_MCSection_FragList>>(),
        24usize,
        concat!(
            "Size of template specialization: ",
            stringify ! (std_pair < :: std :: os :: raw :: c_uint , llvm_MCSection_FragList >)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_pair<::std::os::raw::c_uint, llvm_MCSection_FragList>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify ! (std_pair < :: std :: os :: raw :: c_uint , llvm_MCSection_FragList >)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_optional_open0_unsigned_int_close0_instantiation_11() {
    assert_eq!(
        ::std::mem::size_of::<std_optional>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_optional)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_optional>(),
        4usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_optional)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_optional_open0_unsigned_int_close0_instantiation_12() {
    assert_eq!(
        ::std::mem::size_of::<std_optional>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_optional)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_optional>(),
        4usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_optional)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_optional_open0_unsigned_int_close0_instantiation_13() {
    assert_eq!(
        ::std::mem::size_of::<std_optional>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_optional)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_optional>(),
        4usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_optional)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_pair_open0_unsigned_int_unsigned_int_close0_instantiation_5() {
    assert_eq!(
        ::std::mem::size_of::<std_pair<::std::os::raw::c_uint, ::std::os::raw::c_uint>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify ! (std_pair < :: std :: os :: raw :: c_uint , :: std :: os :: raw :: c_uint >)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_pair<::std::os::raw::c_uint, ::std::os::raw::c_uint>>(),
        4usize,
        concat!(
            "Alignment of template specialization: ",
            stringify ! (std_pair < :: std :: os :: raw :: c_uint , :: std :: os :: raw :: c_uint >)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_optional_open0_llvm_Reloc_Model_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_optional>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_optional)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_optional>(),
        4usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_optional)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_optional_open0_llvm_CodeModel_Model_close0_instantiation_2() {
    assert_eq!(
        ::std::mem::size_of::<std_optional>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_optional)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_optional>(),
        4usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_optional)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_optional_open0_llvm_Reloc_Model_close0_instantiation_1() {
    assert_eq!(
        ::std::mem::size_of::<std_optional>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_optional)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_optional>(),
        4usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_optional)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_optional_open0_llvm_CodeModel_Model_close0_instantiation_3() {
    assert_eq!(
        ::std::mem::size_of::<std_optional>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_optional)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_optional>(),
        4usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_optional)
        )
    );
}
#[test]
fn __bindgen_test_layout_llvm_AnalysisManager_open0_llvm_Module_close0_instantiation_1() {
    assert_eq!(
        ::std::mem::size_of::<llvm_AnalysisManager>(),
        96usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_AnalysisManager)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_AnalysisManager>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_AnalysisManager)
        )
    );
}
#[test]
fn __bindgen_test_layout_llvm_PassManager_open0_llvm_Module_llvm_AnalysisManager_open1_llvm_Module_close1_close0_instantiation_1(
) {
    assert_eq!(
        ::std::mem::size_of::<llvm_PassManager>(),
        24usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_PassManager)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_PassManager>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_PassManager)
        )
    );
}
#[test]
fn __bindgen_test_layout_llvm_AnalysisManager_open0_llvm_Module_close0_instantiation_2() {
    assert_eq!(
        ::std::mem::size_of::<llvm_AnalysisManager>(),
        96usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_AnalysisManager)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_AnalysisManager>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_AnalysisManager)
        )
    );
}
#[test]
fn __bindgen_test_layout_llvm_AnalysisManager_open0_llvm_Function_close0_instantiation_1() {
    assert_eq!(
        ::std::mem::size_of::<llvm_AnalysisManager>(),
        96usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_AnalysisManager)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_AnalysisManager>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_AnalysisManager)
        )
    );
}
#[test]
fn __bindgen_test_layout_llvm_PassManager_open0_llvm_Function_llvm_AnalysisManager_open1_llvm_Function_close1_close0_instantiation_1(
) {
    assert_eq!(
        ::std::mem::size_of::<llvm_PassManager>(),
        24usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_PassManager)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_PassManager>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_PassManager)
        )
    );
}
#[test]
fn __bindgen_test_layout_llvm_AnalysisManager_open0_llvm_Function_close0_instantiation_2() {
    assert_eq!(
        ::std::mem::size_of::<llvm_AnalysisManager>(),
        96usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_AnalysisManager)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_AnalysisManager>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_AnalysisManager)
        )
    );
}
#[test]
fn __bindgen_test_layout_llvm_detail_DenseMapPair_open0_ptr_AnalysisKey_bool__close0_instantiation()
{
    assert_eq!(
        ::std::mem::size_of::<llvm_detail_DenseMapPair<*mut llvm_AnalysisKey, bool>>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_detail_DenseMapPair<*mut llvm_AnalysisKey, bool>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_detail_DenseMapPair<*mut llvm_AnalysisKey, bool>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_detail_DenseMapPair<*mut llvm_AnalysisKey, bool>)
        )
    );
}
#[test]
fn __bindgen_test_layout_llvm_detail_DenseMapPair_open0_ptr_AnalysisKey_bool__close0_instantiation_1(
) {
    assert_eq!(
        ::std::mem::size_of::<llvm_detail_DenseMapPair<*mut llvm_AnalysisKey, bool>>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_detail_DenseMapPair<*mut llvm_AnalysisKey, bool>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_detail_DenseMapPair<*mut llvm_AnalysisKey, bool>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_detail_DenseMapPair<*mut llvm_AnalysisKey, bool>)
        )
    );
}
#[test]
fn __bindgen_test_layout_llvm_AnalysisManager_open0_llvm_Module_close0_instantiation_3() {
    assert_eq!(
        ::std::mem::size_of::<llvm_AnalysisManager>(),
        96usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_AnalysisManager)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_AnalysisManager>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_AnalysisManager)
        )
    );
}
#[test]
fn __bindgen_test_layout_llvm_AnalysisManager_open0_llvm_Function_close0_instantiation_3() {
    assert_eq!(
        ::std::mem::size_of::<llvm_AnalysisManager>(),
        96usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_AnalysisManager)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_AnalysisManager>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_AnalysisManager)
        )
    );
}
#[test]
fn __bindgen_test_layout_llvm_InnerAnalysisManagerProxy_open0_llvm_FunctionAnalysisManager_llvm_Module_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<llvm_InnerAnalysisManagerProxy<llvm_FunctionAnalysisManager>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_InnerAnalysisManagerProxy<llvm_FunctionAnalysisManager>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_InnerAnalysisManagerProxy<llvm_FunctionAnalysisManager>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_InnerAnalysisManagerProxy<llvm_FunctionAnalysisManager>)
        )
    );
}
#[doc = " API to communicate dependencies between analyses during invalidation.\n\n When an analysis result embeds handles to other analysis results, it\n needs to be invalidated both when its own information isn't preserved and\n when any of its embedded analysis results end up invalidated. We pass an\n \\c Invalidator object as an argument to \\c invalidate() in order to let\n the analysis results themselves define the dependency graph on the fly.\n This lets us avoid building an explicit representation of the\n dependencies between analysis results."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Invalidator {
    pub IsResultInvalidated: *mut [u64; 18usize],
    pub Results: *const llvm_DenseMap<
        llvm_detail_DenseMapPair<
            std_pair<*mut llvm_AnalysisKey, *mut llvm_Module>,
            std__List_iterator,
        >,
    >,
    _unused: [u8; 0],
}
#[test]
fn __bindgen_test_layout_llvm_detail_DenseMapPair_open0_ptr_AnalysisKey_bool__close0_instantiation_2(
) {
    assert_eq!(
        ::std::mem::size_of::<llvm_detail_DenseMapPair<*mut llvm_AnalysisKey, bool>>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_detail_DenseMapPair<*mut llvm_AnalysisKey, bool>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_detail_DenseMapPair<*mut llvm_AnalysisKey, bool>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_detail_DenseMapPair<*mut llvm_AnalysisKey, bool>)
        )
    );
}
#[test]
fn __bindgen_test_layout_llvm_DenseMap_open0_std_pair_open1_ptr_AnalysisKey_ptr_Module_close1_std__List_iterator_open1__bindgen_ty_id_106592_close1_llvm_DenseMapInfo_open1_std_pair_open2_ptr_AnalysisKey_ptr_Module_close2_void_close1_llvm_detail_DenseMapPair_open1_std_pair_open2_ptr_AnalysisKey_ptr_Module_close2_std__List_iterator_open2_std_pair_open3_ptr_AnalysisKey_std_unique_ptr_open4_llvm_detail_AnalysisResultConcept_open5_llvm_Module_Invalidator_close5_std_default_delete_open5_llvm_detail_AnalysisResultConcept_open6_llvm_Module_Invalidator_close6_close5_close4_close3_close2_close1_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<
            llvm_DenseMap<
                llvm_detail_DenseMapPair<
                    std_pair<*mut llvm_AnalysisKey, *mut llvm_Module>,
                    std__List_iterator,
                >,
            >,
        >(),
        32usize,
        concat!(
            "Size of template specialization: ",
            stringify!(
                llvm_DenseMap<
                    llvm_detail_DenseMapPair<
                        std_pair<*mut llvm_AnalysisKey, *mut llvm_Module>,
                        std__List_iterator,
                    >,
                >
            )
        )
    );
    assert_eq!(
        ::std::mem::align_of::<
            llvm_DenseMap<
                llvm_detail_DenseMapPair<
                    std_pair<*mut llvm_AnalysisKey, *mut llvm_Module>,
                    std__List_iterator,
                >,
            >,
        >(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(
                llvm_DenseMap<
                    llvm_detail_DenseMapPair<
                        std_pair<*mut llvm_AnalysisKey, *mut llvm_Module>,
                        std__List_iterator,
                    >,
                >
            )
        )
    );
}
#[test]
fn __bindgen_test_layout_llvm_detail_DenseMapPair_open0_ptr_AnalysisKey_bool__close0_instantiation_3(
) {
    assert_eq!(
        ::std::mem::size_of::<llvm_detail_DenseMapPair<*mut llvm_AnalysisKey, bool>>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_detail_DenseMapPair<*mut llvm_AnalysisKey, bool>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_detail_DenseMapPair<*mut llvm_AnalysisKey, bool>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_detail_DenseMapPair<*mut llvm_AnalysisKey, bool>)
        )
    );
}
#[test]
fn __bindgen_test_layout_llvm_DenseMap_open0_std_pair_open1_ptr_AnalysisKey_ptr_Module_close1_std__List_iterator_open1__bindgen_ty_id_106677_close1_llvm_DenseMapInfo_open1_std_pair_open2_ptr_AnalysisKey_ptr_Module_close2_void_close1_llvm_detail_DenseMapPair_open1_std_pair_open2_ptr_AnalysisKey_ptr_Module_close2_std__List_iterator_open2_std_pair_open3_ptr_AnalysisKey_std_unique_ptr_open4_llvm_detail_AnalysisResultConcept_open5_llvm_Module_Invalidator_close5_std_default_delete_open5_llvm_detail_AnalysisResultConcept_open6_llvm_Module_Invalidator_close6_close5_close4_close3_close2_close1_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<
            llvm_DenseMap<
                llvm_detail_DenseMapPair<
                    std_pair<*mut llvm_AnalysisKey, *mut llvm_Module>,
                    std__List_iterator,
                >,
            >,
        >(),
        32usize,
        concat!(
            "Size of template specialization: ",
            stringify!(
                llvm_DenseMap<
                    llvm_detail_DenseMapPair<
                        std_pair<*mut llvm_AnalysisKey, *mut llvm_Module>,
                        std__List_iterator,
                    >,
                >
            )
        )
    );
    assert_eq!(
        ::std::mem::align_of::<
            llvm_DenseMap<
                llvm_detail_DenseMapPair<
                    std_pair<*mut llvm_AnalysisKey, *mut llvm_Module>,
                    std__List_iterator,
                >,
            >,
        >(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(
                llvm_DenseMap<
                    llvm_detail_DenseMapPair<
                        std_pair<*mut llvm_AnalysisKey, *mut llvm_Module>,
                        std__List_iterator,
                    >,
                >
            )
        )
    );
}
#[test]
fn __bindgen_test_layout_llvm_AnalysisManager_open0_llvm_Function_close0_instantiation_4() {
    assert_eq!(
        ::std::mem::size_of::<llvm_AnalysisManager>(),
        96usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_AnalysisManager)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_AnalysisManager>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_AnalysisManager)
        )
    );
}
#[test]
fn __bindgen_test_layout_llvm_TinyPtrVector_open0_ptr_AnalysisKey_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<llvm_TinyPtrVector>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_TinyPtrVector)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_TinyPtrVector>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_TinyPtrVector)
        )
    );
}
#[test]
fn __bindgen_test_layout_llvm_detail_DenseMapPair_open0_ptr_AnalysisKey_llvm_TinyPtrVector_open1_ptr_AnalysisKey_close1_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<llvm_detail_DenseMapPair<*mut llvm_AnalysisKey, llvm_TinyPtrVector>>(
        ),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_detail_DenseMapPair<*mut llvm_AnalysisKey, llvm_TinyPtrVector>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_detail_DenseMapPair<*mut llvm_AnalysisKey, llvm_TinyPtrVector>>(
        ),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_detail_DenseMapPair<*mut llvm_AnalysisKey, llvm_TinyPtrVector>)
        )
    );
}
#[test]
fn __bindgen_test_layout_llvm_TinyPtrVector_open0_ptr_AnalysisKey_close0_instantiation_1() {
    assert_eq!(
        ::std::mem::size_of::<llvm_TinyPtrVector>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_TinyPtrVector)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_TinyPtrVector>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_TinyPtrVector)
        )
    );
}
#[test]
fn __bindgen_test_layout_llvm_TinyPtrVector_open0_ptr_AnalysisKey_close0_instantiation_2() {
    assert_eq!(
        ::std::mem::size_of::<llvm_TinyPtrVector>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_TinyPtrVector)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_TinyPtrVector>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_TinyPtrVector)
        )
    );
}
#[test]
fn __bindgen_test_layout_llvm_detail_DenseMapPair_open0_ptr_AnalysisKey_llvm_TinyPtrVector_open1_ptr_AnalysisKey_close1_close0_instantiation_1(
) {
    assert_eq!(
        ::std::mem::size_of::<llvm_detail_DenseMapPair<*mut llvm_AnalysisKey, llvm_TinyPtrVector>>(
        ),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_detail_DenseMapPair<*mut llvm_AnalysisKey, llvm_TinyPtrVector>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_detail_DenseMapPair<*mut llvm_AnalysisKey, llvm_TinyPtrVector>>(
        ),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_detail_DenseMapPair<*mut llvm_AnalysisKey, llvm_TinyPtrVector>)
        )
    );
}
#[test]
fn __bindgen_test_layout_llvm_TinyPtrVector_open0_ptr_AnalysisKey_close0_instantiation_3() {
    assert_eq!(
        ::std::mem::size_of::<llvm_TinyPtrVector>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_TinyPtrVector)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_TinyPtrVector>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_TinyPtrVector)
        )
    );
}
#[test]
fn __bindgen_test_layout_llvm_AnalysisManager_open0_llvm_Module_close0_instantiation_4() {
    assert_eq!(
        ::std::mem::size_of::<llvm_AnalysisManager>(),
        96usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_AnalysisManager)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_AnalysisManager>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_AnalysisManager)
        )
    );
}
#[test]
fn __bindgen_test_layout_llvm_OuterAnalysisManagerProxy_open0_llvm_ModuleAnalysisManager_llvm_Function_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<llvm_OuterAnalysisManagerProxy<llvm_ModuleAnalysisManager>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_OuterAnalysisManagerProxy<llvm_ModuleAnalysisManager>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_OuterAnalysisManagerProxy<llvm_ModuleAnalysisManager>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_OuterAnalysisManagerProxy<llvm_ModuleAnalysisManager>)
        )
    );
}
#[test]
fn __bindgen_test_layout_llvm_PassInfoMixin_open0_llvm_ModuleToFunctionPassAdaptor_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<llvm_PassInfoMixin>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_PassInfoMixin)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_PassInfoMixin>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_PassInfoMixin)
        )
    );
}
#[test]
fn __bindgen_test_layout_llvm_detail_PassConcept_open0_llvm_Function_llvm_FunctionAnalysisManager_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<llvm_detail_PassConcept>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_detail_PassConcept)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_detail_PassConcept>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_detail_PassConcept)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_unique_ptr_open0_llvm_ModuleToFunctionPassAdaptor_PassConceptT_std_default_delete_open1_llvm_detail_PassConcept_open2_llvm_Function_llvm_AnalysisManager_open3_llvm_Function_close3_close2_close1_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<std_unique_ptr>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_unique_ptr)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_unique_ptr>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_unique_ptr)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_default_delete_open0_llvm_detail_PassConcept_open1_llvm_Function_llvm_AnalysisManager_open2_llvm_Function_close2_close1_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<std_default_delete>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_default_delete)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_default_delete>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_default_delete)
        )
    );
}
#[test]
fn __bindgen_test_layout_llvm_detail_PassConcept_open0_llvm_Function_llvm_AnalysisManager_open1_llvm_Function_close1_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<llvm_detail_PassConcept>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_detail_PassConcept)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_detail_PassConcept>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_detail_PassConcept)
        )
    );
}
#[test]
fn __bindgen_test_layout_llvm_AnalysisManager_open0_llvm_Function_close0_instantiation_5() {
    assert_eq!(
        ::std::mem::size_of::<llvm_AnalysisManager>(),
        96usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_AnalysisManager)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_AnalysisManager>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_AnalysisManager)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_unique_ptr_open0_llvm_ModuleToFunctionPassAdaptor_PassConceptT_std_default_delete_open1_llvm_detail_PassConcept_open2_llvm_Function_llvm_AnalysisManager_open3_llvm_Function_close3_close2_close1_close0_instantiation_1(
) {
    assert_eq!(
        ::std::mem::size_of::<std_unique_ptr>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_unique_ptr)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_unique_ptr>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_unique_ptr)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_default_delete_open0_llvm_detail_PassConcept_open1_llvm_Function_llvm_AnalysisManager_open2_llvm_Function_close2_close1_close0_instantiation_1(
) {
    assert_eq!(
        ::std::mem::size_of::<std_default_delete>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_default_delete)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_default_delete>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_default_delete)
        )
    );
}
#[test]
fn __bindgen_test_layout_llvm_detail_PassConcept_open0_llvm_Function_llvm_AnalysisManager_open1_llvm_Function_close1_close0_instantiation_1(
) {
    assert_eq!(
        ::std::mem::size_of::<llvm_detail_PassConcept>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_detail_PassConcept)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_detail_PassConcept>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_detail_PassConcept)
        )
    );
}
#[test]
fn __bindgen_test_layout_llvm_AnalysisManager_open0_llvm_Function_close0_instantiation_6() {
    assert_eq!(
        ::std::mem::size_of::<llvm_AnalysisManager>(),
        96usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_AnalysisManager)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_AnalysisManager>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_AnalysisManager)
        )
    );
}
#[test]
fn __bindgen_test_layout_llvm_PassInfoMixin_open0_llvm_InvalidateAllAnalysesPass_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<llvm_PassInfoMixin>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_PassInfoMixin)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_PassInfoMixin>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_PassInfoMixin)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_pair_open0_ptr_void_size_t_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_pair<*mut ::std::os::raw::c_void, usize>>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_pair<*mut ::std::os::raw::c_void, usize>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_pair<*mut ::std::os::raw::c_void, usize>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_pair<*mut ::std::os::raw::c_void, usize>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_atomic_open0_bool__close0_instantiation_1() {
    assert_eq!(
        ::std::mem::size_of::<std_atomic<bool>>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_atomic<bool>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_atomic<bool>>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_atomic<bool>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_atomic_open0_char_close0_instantiation_1() {
    assert_eq!(
        ::std::mem::size_of::<std_atomic<::std::os::raw::c_char>>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_atomic<::std::os::raw::c_char>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_atomic<::std::os::raw::c_char>>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_atomic<::std::os::raw::c_char>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_atomic_open0_signed_char_close0_instantiation_1() {
    assert_eq!(
        ::std::mem::size_of::<std_atomic<::std::os::raw::c_schar>>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_atomic<::std::os::raw::c_schar>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_atomic<::std::os::raw::c_schar>>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_atomic<::std::os::raw::c_schar>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_atomic_open0_unsigned_char_close0_instantiation_1() {
    assert_eq!(
        ::std::mem::size_of::<std_atomic<::std::os::raw::c_uchar>>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_atomic<::std::os::raw::c_uchar>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_atomic<::std::os::raw::c_uchar>>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_atomic<::std::os::raw::c_uchar>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_atomic_open0_short_close0_instantiation_1() {
    assert_eq!(
        ::std::mem::size_of::<std_atomic<::std::os::raw::c_short>>(),
        2usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_atomic<::std::os::raw::c_short>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_atomic<::std::os::raw::c_short>>(),
        2usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_atomic<::std::os::raw::c_short>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_atomic_open0_unsigned_short_close0_instantiation_1() {
    assert_eq!(
        ::std::mem::size_of::<std_atomic<::std::os::raw::c_ushort>>(),
        2usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_atomic<::std::os::raw::c_ushort>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_atomic<::std::os::raw::c_ushort>>(),
        2usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_atomic<::std::os::raw::c_ushort>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_atomic_open0_int_close0_instantiation_1() {
    assert_eq!(
        ::std::mem::size_of::<std_atomic<::std::os::raw::c_int>>(),
        4usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_atomic<::std::os::raw::c_int>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_atomic<::std::os::raw::c_int>>(),
        4usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_atomic<::std::os::raw::c_int>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_atomic_open0_unsigned_int_close0_instantiation_1() {
    assert_eq!(
        ::std::mem::size_of::<std_atomic<::std::os::raw::c_uint>>(),
        4usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_atomic<::std::os::raw::c_uint>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_atomic<::std::os::raw::c_uint>>(),
        4usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_atomic<::std::os::raw::c_uint>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_atomic_open0_long_close0_instantiation_1() {
    assert_eq!(
        ::std::mem::size_of::<std_atomic<::std::os::raw::c_long>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_atomic<::std::os::raw::c_long>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_atomic<::std::os::raw::c_long>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_atomic<::std::os::raw::c_long>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_atomic_open0_unsigned_long_close0_instantiation_1() {
    assert_eq!(
        ::std::mem::size_of::<std_atomic<::std::os::raw::c_ulong>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_atomic<::std::os::raw::c_ulong>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_atomic<::std::os::raw::c_ulong>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_atomic<::std::os::raw::c_ulong>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_atomic_open0_long_long_close0_instantiation_1() {
    assert_eq!(
        ::std::mem::size_of::<std_atomic<::std::os::raw::c_longlong>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_atomic<::std::os::raw::c_longlong>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_atomic<::std::os::raw::c_longlong>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_atomic<::std::os::raw::c_longlong>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_atomic_open0_unsigned_long_long_close0_instantiation_1() {
    assert_eq!(
        ::std::mem::size_of::<std_atomic<::std::os::raw::c_ulonglong>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_atomic<::std::os::raw::c_ulonglong>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_atomic<::std::os::raw::c_ulonglong>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_atomic<::std::os::raw::c_ulonglong>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_atomic_open0_wchar_t_close0_instantiation_1() {
    assert_eq!(
        ::std::mem::size_of::<std_atomic<u32>>(),
        4usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_atomic<u32>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_atomic<u32>>(),
        4usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_atomic<u32>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_atomic_open0_char16_t_close0_instantiation_1() {
    assert_eq!(
        ::std::mem::size_of::<std_atomic<u16>>(),
        2usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_atomic<u16>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_atomic<u16>>(),
        2usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_atomic<u16>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_atomic_open0_char32_t_close0_instantiation_1() {
    assert_eq!(
        ::std::mem::size_of::<std_atomic<u32>>(),
        4usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_atomic<u32>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_atomic<u32>>(),
        4usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_atomic<u32>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_atomic_open0_signed_char_close0_instantiation_2() {
    assert_eq!(
        ::std::mem::size_of::<std_atomic<::std::os::raw::c_schar>>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_atomic<::std::os::raw::c_schar>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_atomic<::std::os::raw::c_schar>>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_atomic<::std::os::raw::c_schar>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_atomic_open0_unsigned_char_close0_instantiation_2() {
    assert_eq!(
        ::std::mem::size_of::<std_atomic<::std::os::raw::c_uchar>>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_atomic<::std::os::raw::c_uchar>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_atomic<::std::os::raw::c_uchar>>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_atomic<::std::os::raw::c_uchar>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_atomic_open0_short_close0_instantiation_2() {
    assert_eq!(
        ::std::mem::size_of::<std_atomic<::std::os::raw::c_short>>(),
        2usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_atomic<::std::os::raw::c_short>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_atomic<::std::os::raw::c_short>>(),
        2usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_atomic<::std::os::raw::c_short>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_atomic_open0_unsigned_short_close0_instantiation_2() {
    assert_eq!(
        ::std::mem::size_of::<std_atomic<::std::os::raw::c_ushort>>(),
        2usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_atomic<::std::os::raw::c_ushort>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_atomic<::std::os::raw::c_ushort>>(),
        2usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_atomic<::std::os::raw::c_ushort>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_atomic_open0_int_close0_instantiation_2() {
    assert_eq!(
        ::std::mem::size_of::<std_atomic<::std::os::raw::c_int>>(),
        4usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_atomic<::std::os::raw::c_int>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_atomic<::std::os::raw::c_int>>(),
        4usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_atomic<::std::os::raw::c_int>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_atomic_open0_unsigned_int_close0_instantiation_2() {
    assert_eq!(
        ::std::mem::size_of::<std_atomic<::std::os::raw::c_uint>>(),
        4usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_atomic<::std::os::raw::c_uint>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_atomic<::std::os::raw::c_uint>>(),
        4usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_atomic<::std::os::raw::c_uint>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_atomic_open0_long_close0_instantiation_2() {
    assert_eq!(
        ::std::mem::size_of::<std_atomic<::std::os::raw::c_long>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_atomic<::std::os::raw::c_long>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_atomic<::std::os::raw::c_long>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_atomic<::std::os::raw::c_long>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_atomic_open0_unsigned_long_close0_instantiation_2() {
    assert_eq!(
        ::std::mem::size_of::<std_atomic<::std::os::raw::c_ulong>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_atomic<::std::os::raw::c_ulong>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_atomic<::std::os::raw::c_ulong>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_atomic<::std::os::raw::c_ulong>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_atomic_open0_signed_char_close0_instantiation_3() {
    assert_eq!(
        ::std::mem::size_of::<std_atomic<::std::os::raw::c_schar>>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_atomic<::std::os::raw::c_schar>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_atomic<::std::os::raw::c_schar>>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_atomic<::std::os::raw::c_schar>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_atomic_open0_unsigned_char_close0_instantiation_3() {
    assert_eq!(
        ::std::mem::size_of::<std_atomic<::std::os::raw::c_uchar>>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_atomic<::std::os::raw::c_uchar>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_atomic<::std::os::raw::c_uchar>>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_atomic<::std::os::raw::c_uchar>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_atomic_open0_short_close0_instantiation_3() {
    assert_eq!(
        ::std::mem::size_of::<std_atomic<::std::os::raw::c_short>>(),
        2usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_atomic<::std::os::raw::c_short>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_atomic<::std::os::raw::c_short>>(),
        2usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_atomic<::std::os::raw::c_short>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_atomic_open0_unsigned_short_close0_instantiation_3() {
    assert_eq!(
        ::std::mem::size_of::<std_atomic<::std::os::raw::c_ushort>>(),
        2usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_atomic<::std::os::raw::c_ushort>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_atomic<::std::os::raw::c_ushort>>(),
        2usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_atomic<::std::os::raw::c_ushort>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_atomic_open0_int_close0_instantiation_3() {
    assert_eq!(
        ::std::mem::size_of::<std_atomic<::std::os::raw::c_int>>(),
        4usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_atomic<::std::os::raw::c_int>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_atomic<::std::os::raw::c_int>>(),
        4usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_atomic<::std::os::raw::c_int>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_atomic_open0_unsigned_int_close0_instantiation_3() {
    assert_eq!(
        ::std::mem::size_of::<std_atomic<::std::os::raw::c_uint>>(),
        4usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_atomic<::std::os::raw::c_uint>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_atomic<::std::os::raw::c_uint>>(),
        4usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_atomic<::std::os::raw::c_uint>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_atomic_open0_long_close0_instantiation_3() {
    assert_eq!(
        ::std::mem::size_of::<std_atomic<::std::os::raw::c_long>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_atomic<::std::os::raw::c_long>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_atomic<::std::os::raw::c_long>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_atomic<::std::os::raw::c_long>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_atomic_open0_unsigned_long_close0_instantiation_3() {
    assert_eq!(
        ::std::mem::size_of::<std_atomic<::std::os::raw::c_ulong>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_atomic<::std::os::raw::c_ulong>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_atomic<::std::os::raw::c_ulong>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_atomic<::std::os::raw::c_ulong>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_atomic_open0_signed_char_close0_instantiation_4() {
    assert_eq!(
        ::std::mem::size_of::<std_atomic<::std::os::raw::c_schar>>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_atomic<::std::os::raw::c_schar>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_atomic<::std::os::raw::c_schar>>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_atomic<::std::os::raw::c_schar>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_atomic_open0_unsigned_char_close0_instantiation_4() {
    assert_eq!(
        ::std::mem::size_of::<std_atomic<::std::os::raw::c_uchar>>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_atomic<::std::os::raw::c_uchar>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_atomic<::std::os::raw::c_uchar>>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_atomic<::std::os::raw::c_uchar>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_atomic_open0_long_close0_instantiation_4() {
    assert_eq!(
        ::std::mem::size_of::<std_atomic<::std::os::raw::c_long>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_atomic<::std::os::raw::c_long>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_atomic<::std::os::raw::c_long>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_atomic<::std::os::raw::c_long>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_atomic_open0_unsigned_long_close0_instantiation_4() {
    assert_eq!(
        ::std::mem::size_of::<std_atomic<::std::os::raw::c_ulong>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_atomic<::std::os::raw::c_ulong>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_atomic<::std::os::raw::c_ulong>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_atomic<::std::os::raw::c_ulong>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_atomic_open0_long_close0_instantiation_5() {
    assert_eq!(
        ::std::mem::size_of::<std_atomic<::std::os::raw::c_long>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_atomic<::std::os::raw::c_long>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_atomic<::std::os::raw::c_long>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_atomic<::std::os::raw::c_long>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_atomic_open0_unsigned_long_close0_instantiation_5() {
    assert_eq!(
        ::std::mem::size_of::<std_atomic<::std::os::raw::c_ulong>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_atomic<::std::os::raw::c_ulong>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_atomic<::std::os::raw::c_ulong>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_atomic<::std::os::raw::c_ulong>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_atomic_open0_long_close0_instantiation_6() {
    assert_eq!(
        ::std::mem::size_of::<std_atomic<::std::os::raw::c_long>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_atomic<::std::os::raw::c_long>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_atomic<::std::os::raw::c_long>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_atomic<::std::os::raw::c_long>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_atomic_open0_unsigned_long_close0_instantiation_6() {
    assert_eq!(
        ::std::mem::size_of::<std_atomic<::std::os::raw::c_ulong>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_atomic<::std::os::raw::c_ulong>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_atomic<::std::os::raw::c_ulong>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_atomic<::std::os::raw::c_ulong>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_atomic_open0_long_close0_instantiation_7() {
    assert_eq!(
        ::std::mem::size_of::<std_atomic<::std::os::raw::c_long>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_atomic<::std::os::raw::c_long>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_atomic<::std::os::raw::c_long>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_atomic<::std::os::raw::c_long>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_atomic_open0_unsigned_long_close0_instantiation_7() {
    assert_eq!(
        ::std::mem::size_of::<std_atomic<::std::os::raw::c_ulong>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_atomic<::std::os::raw::c_ulong>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_atomic<::std::os::raw::c_ulong>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_atomic<::std::os::raw::c_ulong>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_atomic_open0_std_size_t_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_atomic<usize>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_atomic<usize>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_atomic<usize>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_atomic<usize>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_atomic_open0_std_ptrdiff_t_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_atomic<isize>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_atomic<isize>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_atomic<isize>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_atomic<isize>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_atomic_open0_long_close0_instantiation_8() {
    assert_eq!(
        ::std::mem::size_of::<std_atomic<::std::os::raw::c_long>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_atomic<::std::os::raw::c_long>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_atomic<::std::os::raw::c_long>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_atomic<::std::os::raw::c_long>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_atomic_open0_unsigned_long_close0_instantiation_8() {
    assert_eq!(
        ::std::mem::size_of::<std_atomic<::std::os::raw::c_ulong>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_atomic<::std::os::raw::c_ulong>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_atomic<::std::os::raw::c_ulong>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_atomic<::std::os::raw::c_ulong>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_atomic_open0_int_close0_instantiation_4() {
    assert_eq!(
        ::std::mem::size_of::<std_atomic<::std::os::raw::c_int>>(),
        4usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_atomic<::std::os::raw::c_int>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_atomic<::std::os::raw::c_int>>(),
        4usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_atomic<::std::os::raw::c_int>)
        )
    );
}
#[test]
fn __bindgen_test_layout_llvm_IntrusiveRefCntPtr_open0_llvm_vfs_FileSystem_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<llvm_IntrusiveRefCntPtr<llvm_vfs_FileSystem>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_IntrusiveRefCntPtr<llvm_vfs_FileSystem>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_IntrusiveRefCntPtr<llvm_vfs_FileSystem>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_IntrusiveRefCntPtr<llvm_vfs_FileSystem>)
        )
    );
}
#[test]
fn __bindgen_test_layout_llvm_IntrusiveRefCntPtr_open0_llvm_vfs_FileSystem_close0_instantiation_1()
{
    assert_eq!(
        ::std::mem::size_of::<llvm_IntrusiveRefCntPtr<llvm_vfs_FileSystem>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_IntrusiveRefCntPtr<llvm_vfs_FileSystem>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_IntrusiveRefCntPtr<llvm_vfs_FileSystem>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_IntrusiveRefCntPtr<llvm_vfs_FileSystem>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_optional_open0_bool__close0_instantiation_1() {
    assert_eq!(
        ::std::mem::size_of::<std_optional>(),
        2usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_optional)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_optional>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_optional)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_optional_open0_bool__close0_instantiation_2() {
    assert_eq!(
        ::std::mem::size_of::<std_optional>(),
        2usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_optional)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_optional>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_optional)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_optional_open0_llvm_GlobalISelAbortMode_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_optional>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_optional)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_optional>(),
        4usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_optional)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_optional_open0_bool__close0_instantiation_3() {
    assert_eq!(
        ::std::mem::size_of::<std_optional>(),
        2usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_optional)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_optional>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_optional)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_optional_open0_bool__close0_instantiation_4() {
    assert_eq!(
        ::std::mem::size_of::<std_optional>(),
        2usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_optional)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_optional>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_optional)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_optional_open0_bool__close0_instantiation_5() {
    assert_eq!(
        ::std::mem::size_of::<std_optional>(),
        2usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_optional)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_optional>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_optional)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_optional_open0_bool__close0_instantiation_6() {
    assert_eq!(
        ::std::mem::size_of::<std_optional>(),
        2usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_optional)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_optional>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_optional)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_optional_open0_bool__close0_instantiation_7() {
    assert_eq!(
        ::std::mem::size_of::<std_optional>(),
        2usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_optional)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_optional>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_optional)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_unique_ptr_open0_llvm_MCAsmInfo_std_default_delete_open1_llvm_MCAsmInfo_close1_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<std_unique_ptr>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_unique_ptr)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_unique_ptr>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_unique_ptr)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_default_delete_open0_llvm_MCAsmInfo_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_default_delete>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_default_delete)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_default_delete>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_default_delete)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_unique_ptr_open0_llvm_MCRegisterInfo_std_default_delete_open1_llvm_MCRegisterInfo_close1_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<std_unique_ptr>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_unique_ptr)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_unique_ptr>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_unique_ptr)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_default_delete_open0_llvm_MCRegisterInfo_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_default_delete>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_default_delete)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_default_delete>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_default_delete)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_unique_ptr_open0_llvm_MCInstrInfo_std_default_delete_open1_llvm_MCInstrInfo_close1_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<std_unique_ptr>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_unique_ptr)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_unique_ptr>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_unique_ptr)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_default_delete_open0_llvm_MCInstrInfo_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_default_delete>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_default_delete)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_default_delete>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_default_delete)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_unique_ptr_open0_llvm_MCSubtargetInfo_std_default_delete_open1_llvm_MCSubtargetInfo_close1_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<std_unique_ptr>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_unique_ptr)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_unique_ptr>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_unique_ptr)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_default_delete_open0_llvm_MCSubtargetInfo_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_default_delete>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_default_delete)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_default_delete>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_default_delete)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_optional_open0_llvm_PGOOptions_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_optional>(),
        160usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_optional)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_optional>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_optional)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_optional_open0_llvm_PGOOptions_close0_instantiation_1() {
    assert_eq!(
        ::std::mem::size_of::<std_optional>(),
        160usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_optional)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_optional>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_optional)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_optional_open0_llvm_PGOOptions_close0_instantiation_2() {
    assert_eq!(
        ::std::mem::size_of::<std_optional>(),
        160usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_optional)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_optional>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_optional)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_pair_open0_ptr_const_Value_unsigned_int_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_pair<*const llvm_Value, ::std::os::raw::c_uint>>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_pair<*const llvm_Value, ::std::os::raw::c_uint>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_pair<*const llvm_Value, ::std::os::raw::c_uint>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_pair<*const llvm_Value, ::std::os::raw::c_uint>)
        )
    );
}
#[test]
fn __bindgen_test_layout_llvm_SmallVectorImpl_open0_char_close0_instantiation_29() {
    assert_eq!(
        ::std::mem::size_of::<llvm_SmallVectorImpl>(),
        24usize,
        concat!(
            "Size of template specialization: ",
            stringify!(llvm_SmallVectorImpl)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_SmallVectorImpl>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(llvm_SmallVectorImpl)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_pair_open0_int_int_close0_instantiation_1() {
    assert_eq!(
        ::std::mem::size_of::<std_pair<::std::os::raw::c_int, ::std::os::raw::c_int>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify ! (std_pair < :: std :: os :: raw :: c_int , :: std :: os :: raw :: c_int >)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_pair<::std::os::raw::c_int, ::std::os::raw::c_int>>(),
        4usize,
        concat!(
            "Alignment of template specialization: ",
            stringify ! (std_pair < :: std :: os :: raw :: c_int , :: std :: os :: raw :: c_int >)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_optional_open0_llvm_CodeModel_Model_close0_instantiation_4() {
    assert_eq!(
        ::std::mem::size_of::<std_optional>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_optional)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_optional>(),
        4usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_optional)
        )
    );
}
